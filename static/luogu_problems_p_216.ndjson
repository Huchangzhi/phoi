{"pid": "P5369", "type": "P", "difficulty": 6, "samples": [["2\n-1 2", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2018", "状压 DP"], "title": "[PKUSC2018] 最大前缀和", "background": "", "description": "小 C 是一个算法竞赛爱好者，有一天小 C 遇到了一个非常难的问题：求一个序列的最大子段和。\n\n但是小 C 并不会做这个题，于是小 C 决定把序列随机打乱，然后取序列的最大前缀和作为答案。\n\n小 C 是一个非常有自知之明的人，他知道自己的算法完全不对，所以并不关心正确率，他只关心求出的解的期望值，现在请你帮他解决这个问题，由于答案可能非常复杂，所以你只需要输出答案乘上 $n!$ 后对 $998244353$ 取模的值，显然这是个整数。\n\n注：最大前缀和的定义：$\\forall i \\in [1,n]$，$\\sum_{j=1}^{i}a_j$的最大值。\n", "inputFormat": "第一行一个正整数 $n$，表示序列长度。\n\n第二行 $n$ 个数，表示原序列 $a[1..n]$，第 $i$ 个数表示 $a[i]$ 。\n", "outputFormat": "输出一个**非负整数**，表示答案。\n", "hint": "对于$10\\%$的数据，有$1\\leq n\\leq 9$。\n\n对于$40\\%$的数据，有$1\\leq n\\leq 15$。\n\n另有$10\\%$的数据，满足$a$中最多只有一个负数。\n\n另有$10\\%$的数据，满足$|a[i]|\\leq 2$。\n\n对于$100\\%$的数据，满足$1\\leq n\\leq 20$，$\\sum_{i=1}^{n}|a[i]|\\leq 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[PKUSC2018] Maximum Prefix Sum", "background": "", "description": "Xiao C is an algorithm contest enthusiast. One day, Xiao C ran into a very difficult problem: finding the maximum subarray sum of a sequence.\n\nHowever, Xiao C cannot solve this problem, so Xiao C decides to randomly shuffle the sequence and then take the maximum prefix sum of the shuffled sequence as the answer.\n\nXiao C knows very well that this algorithm is completely wrong, so he does not care about its correctness. He only cares about the expected value of the computed result. Please help him solve this problem. Since the answer may be very complicated, you only need to output the value of the answer multiplied by $n!$ and then taken modulo $998244353$. Obviously, this is an integer.\n\nNote: The definition of maximum prefix sum: $\\forall i \\in [1,n]$, the maximum value of $\\sum_{j=1}^{i}a_j$.", "inputFormat": "The first line contains a positive integer $n$, which denotes the length of the sequence.\n\nThe second line contains $n$ numbers, representing the original sequence $a[1..n]$. The $i$-th number is $a[i]$.", "outputFormat": "Output a **non-negative integer**, which denotes the answer.", "hint": "For $10\\%$ of the testdata, $1\\leq n\\leq 9$.\n\nFor $40\\%$ of the testdata, $1\\leq n\\leq 15$.\n\nFor another $10\\%$ of the testdata, in $a$ there is at most one negative number.\n\nFor another $10\\%$ of the testdata, $|a[i]|\\leq 2$.\n\nFor $100\\%$ of the testdata, $1\\leq n\\leq 20$, $\\sum_{i=1}^{n}|a[i]|\\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[PKUSC2018] 最大前缀和", "background": "", "description": "小 C 是一个算法竞赛爱好者，有一天小 C 遇到了一个非常难的问题：求一个序列的最大子段和。\n\n但是小 C 并不会做这个题，于是小 C 决定把序列随机打乱，然后取序列的最大前缀和作为答案。\n\n小 C 是一个非常有自知之明的人，他知道自己的算法完全不对，所以并不关心正确率，他只关心求出的解的期望值，现在请你帮他解决这个问题，由于答案可能非常复杂，所以你只需要输出答案乘上 $n!$ 后对 $998244353$ 取模的值，显然这是个整数。\n\n注：最大前缀和的定义：$\\forall i \\in [1,n]$，$\\sum_{j=1}^{i}a_j$的最大值。\n", "inputFormat": "第一行一个正整数 $n$，表示序列长度。\n\n第二行 $n$ 个数，表示原序列 $a[1..n]$，第 $i$ 个数表示 $a[i]$ 。\n", "outputFormat": "输出一个**非负整数**，表示答案。\n", "hint": "对于$10\\%$的数据，有$1\\leq n\\leq 9$。\n\n对于$40\\%$的数据，有$1\\leq n\\leq 15$。\n\n另有$10\\%$的数据，满足$a$中最多只有一个负数。\n\n另有$10\\%$的数据，满足$|a[i]|\\leq 2$。\n\n对于$100\\%$的数据，满足$1\\leq n\\leq 20$，$\\sum_{i=1}^{n}|a[i]|\\leq 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P5370", "type": "P", "difficulty": 6, "samples": [["556789TJJQKKAA22w\n456789TJJQKKAA22w\n456789TJQKKKAAA22", "193483\n0\n613897"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018"], "title": "[PKUSC2018] 主斗地", "background": "", "description": "如果你参加过 NOIP 2015 和 PKUWC 2018，那么你一定对一道叫做斗地主的题印象深刻。为了致敬经典，我们又出了一道有关打牌的题。在本题中，牌型和斗地主**类似但不完全相同**，我们称本题中的扑克游戏为主斗地。\n\n主斗地是一种使用黑桃、红心、梅花、方片的A到K加上大小王的共54张牌来进行的扑克牌游戏，其中大小王各一张，其他数码牌各四张。在斗地主中，牌的大小关系根据牌的数码表示如下：$3<4<5<6<7<8<9<10(T)<J<Q<K<A<2< $小王 $(w)$ $<$ 大王 $(W)$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 $n$ 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。为了简化题目，本题不考虑花色的影响，即**所有的相同的数码的牌都是被视为一样的**。\n\n在这道题中，允许的出牌牌型有（**这一部分与传统的斗地主有所出入，请注意**）：\n\n|   名称    |           解释           |      举例       |     注     |\n| :-----: | :--------------------: | :-----------: | :-------: |\n|   单牌    |         单独的一张牌         |       6       | 单张的王也是单牌  |\n|   对子    |        相同数码的两张牌        |      66       |  大小王不是对子  |\n|   三张牌   |        相同数码的三张牌        |      666      |           |\n|   三带一   |     相同数码的三张牌带上一张单牌     |     666w      |           |\n|   三带二   |  相同数码的三张牌带上一个另外数码的对子   |     66699     |           |\n|   顺子    |    大小连续的 $5$ 张及以上单牌    |    3456789    | 不能含有大小王和2 |\n|   连对    |   大小连续的 $3$ 对及以上的对子    |   33445566    | 不能含有大小王和2 |\n|   三顺    |     大小连续的两组及以上的三张牌     |   333444555   | 不能含有大小王和2 |\n|   四带二   |     四张相同数码的牌带上两张单牌     | 444456 444455 | 注意不能带两个对子 |\n| 飞机（单翅膀） | 三顺带上相同数量的**数码两两不同的**单牌 | 33344455569J  |           |\n| 飞机（双翅膀） | 三顺带上相同数量的**数码两两不同的**对子 |  3334446699   |           |\n\n**注意**：\n\n1. 在牌型中没有连炸这种牌型，但是形如 444455556666 的牌仍然是能出的，它将被视为 444555666 带 456 的飞机（单翅膀）牌型。\n2. 大王和小王数码不同，即飞机带大小王是合法的，例如 333444wW\n3. 容易验证，上述牌型的规则是合法的，即对于任意合法的牌，它都有唯一的牌型。\n4. 在牌型中，没有炸弹。**炸弹将被视为三带一，且没有炸弹的效果**，即它不能压任何牌型。\n5. 在牌型中，没有火箭。这意味着 wW 不再是一个合法的牌型。\n\n两手牌是属于相同牌型的当且仅当他们的名称相同且包含牌的数量相同。相同牌型的牌之间存在着大小关系：\n\n1. 三带一三带二的大小取决于那三张相同牌的数码\n2. 飞机的大小取决于三顺的大小\n3. 四带二的大小取决于四张相同牌的大小\n4. 其他牌型的大小取决于牌中的最大的一张牌\n\n下面是对主斗地的游戏过程的描述：\n\n1. 在主斗地中，有两个玩家，他们是同一个阵营的，两个玩家要一同达成游戏目标。为了方便，我们假设第一个玩家是九条可怜，第二个玩家是××网友。\n2. 游戏只会使用一副完整的扑克牌。在游戏开始的时候，**会先把所有的 $3$ 扔掉**。之后双方各从这一副牌中随机抽取 $17$ 张，余下的 $16$张被丢弃。你可以认为是随机洗牌后，九条可怜取前 $17$ 张，××网友后 $17$ 张，剩下的 $16$ 张被掉了。\n3. 游戏分成若干轮，每一轮分为两步：\n   1. 第一步，九条可怜从当前手牌中选择一个任意牌型任意大小的牌 $C$ 并打出。\n   2. 第二步，××网友从当前手牌中选择一个和 $C$ 牌型相同且大小 **严格更大** 的牌 $C'$ 打出。如果不存在这样的牌则游戏失败。\n4. 在某一轮结束后，如果九条可怜和××网友中有至少一个人没有手牌，则游戏结束。如果两个人都没有手牌，则游戏胜利，否则游戏失败。\n\n下面是一个例子：\n\n假设九条可怜的牌是 44445556789TJQKwW，××网友的牌是 666789TJQKAAAA222。那么一个可以获胜的方案是：\n\n1. 第一轮九条可怜出 4444wW，××网友出 AAAA22。\n2. 第二轮九条可怜出 6789TJQ，××网友出 789TJQK。\n3. 第三轮九条可怜出 555K，××网友出 6662。\n\n这个游戏很考验两个玩家之间的默契。但是因为九条可怜和××网友无法相互理解，于是他们打算以明牌的方式进行游戏，即双方都知道对方的牌。因为两个人都会按照最优策略行动，所以在牌下发的时候，游戏的胜负就已经确定了。\n\n现在给出××网友的牌，你需要计算九条可怜有多少种不同的可能的手牌可以获得胜利。\n\n注意：××网友和九条可怜的牌都来自于同一副扑克，且分牌的时候没有 $3$。", "inputFormat": "每组数据输入一行，一个长度为 $17$ 的字符串表示××网友的牌。我们用 456789TJQKA2wW 来表示每一种牌。\n", "outputFormat": "对每组数据，输出一个整数表示答案，满足条件的九条可怜的牌数。答案可能很大，请对 $998244353$ 取模输出。\n\n**注意**，在这题中我们不考虑花色，如果两种手牌的数码组成完全相同，但是花色不同，他们也是会被视为同一种的。\n", "hint": "\n因为种种原因，本题采用捆绑测试，一共有 $3$ 个 subtask:\n\n| 子问题编号 |  分值  |       约定       |\n| :---: | :--: | :------------: |\n|   1   | $30$ | 每一种牌最多出现 $2$ 次 |\n|   2   | $30$ | 每一种牌最多出现 $3$ 次 |\n|   3   | $40$ | 每一种牌最多出现 $4$ 次 |\n\n时间限制：2s \n\n空间限制：512M", "locale": "zh-CN", "translations": {"en": {"title": "[PKUSC2018] Zhu Dou Di", "background": "", "description": "If you have taken part in NOIP 2015 and PKUWC 2018, you must have a deep impression of a problem called Dou Dizhu. To pay tribute to the classic, we made another card-related problem. In this problem, the hand types are **similar to but not exactly the same as** Dou Dizhu. We call the poker game in this problem Zhu Dou Di.\n\nZhu Dou Di is a poker game played with a total of 54 cards: A to K of spades, hearts, clubs, and diamonds, plus the small joker and the big joker, one each. All other ranks have four copies. In Dou Dizhu, the order of ranks is as follows: $3<4<5<6<7<8<9<10(T)<J<Q<K<A<2<$ small joker $(w)$ $<$ big joker $(W)$, and suits do not affect the card order. In each game, a hand consists of $n$ cards. Each time, a player may play cards according to the allowed hand types. The first player to play all their cards wins the game. To simplify the problem, we ignore suits, i.e., **all cards of the same rank are considered identical**.\n\nIn this problem, the allowed hand types are ( **this part differs from the traditional Dou Dizhu, please be careful** ):\n\n| Name | Explanation | Example | Note |\n| :-----: | :--------------------: | :-----------: | :-------: |\n| Single | A single card | 6 | A single joker is also a single |\n| Pair | Two cards of the same rank | 66 | The two jokers do not form a pair |\n| Triple | Three cards of the same rank | 666 | |\n| Triple + Single | A triple plus one single card | 666w | |\n| Triple + Pair | A triple plus one pair of a different rank | 66699 | |\n| Straight | $5$ or more consecutive single cards | 3456789 | Cannot contain jokers or 2 |\n| Consecutive Pairs | $3$ or more consecutive pairs | 33445566 | Cannot contain jokers or 2 |\n| Consecutive Triples | Two or more consecutive triples | 333444555 | Cannot contain jokers or 2 |\n| Four + Two | Four cards of the same rank plus two single cards | 444456 444455 | Note that you cannot bring two pairs |\n| Plane (single wings) | Consecutive triples plus the same number of single cards whose ranks are **pairwise different** | 33344455569J | |\n| Plane (double wings) | Consecutive triples plus the same number of pairs whose ranks are **pairwise different** | 3334446699 | |\n\n**Notes**:\n\n1. There is no “consecutive bombs” hand type, but a hand like 444455556666 is still playable; it will be treated as a Plane (single wings) hand type, namely 444555666 with wings 456.\n2. The big joker and the small joker are different ranks, so it is legal for the plane’s wings to include both jokers, e.g., 333444wW.\n3. It is easy to verify that the above hand type rules are valid: for any legal hand, it has a unique hand type.\n4. There are no bombs. **A bomb will be treated as Triple + Single, and it has no bomb effect**, i.e., it cannot beat any hand type.\n5. There is no rocket. This means wW is no longer a legal hand type.\n\nTwo hands belong to the same hand type if and only if they have the same name and contain the same number of cards. Between hands of the same hand type, there is an order:\n\n1. For Triple + Single and Triple + Pair, the order depends on the rank of the triple.\n2. For planes, the order depends on the order of the consecutive triples.\n3. For Four + Two, the order depends on the rank of the four-of-a-kind.\n4. For other hand types, the order depends on the largest card in the hand.\n\nBelow is the game process of Zhu Dou Di:\n\n1. In Zhu Dou Di, there are two players, and they are on the same team. The two players must achieve the game goal together. For convenience, assume the first player is Jiutiao Kelian, and the second player is an “×× netizen”.\n2. The game uses only one complete deck of cards. At the start of the game, **all $3$’s are thrown away first**. Then each side randomly draws $17$ cards from the deck, and the remaining $16$ cards are discarded. You may think of it as: after shuffling, Jiutiao Kelian takes the first $17$ cards, the “×× netizen” takes the next $17$ cards, and the remaining $16$ cards are thrown away.\n3. The game consists of several rounds, and each round has two steps:\n   1. Step 1: Jiutiao Kelian chooses any legal hand $C$ of any hand type and any size from their current hand and plays it.\n   2. Step 2: The “×× netizen” chooses a hand $C'$ from their current hand that has the same hand type as $C$ and is **strictly larger** in order, and plays it. If no such hand exists, the game fails.\n4. After a round ends, if at least one of Jiutiao Kelian and the “×× netizen” has no cards left, the game ends. If both players have no cards left, the game is a win; otherwise it is a failure.\n\nHere is an example:\n\nSuppose Jiutiao Kelian’s cards are 44445556789TJQKwW, and the “×× netizen” has 666789TJQKAAAA222. One winning strategy is:\n\n1. Round 1: Jiutiao Kelian plays 4444wW, and the “×× netizen” plays AAAA22.\n2. Round 2: Jiutiao Kelian plays 6789TJQ, and the “×× netizen” plays 789TJQK.\n3. Round 3: Jiutiao Kelian plays 555K, and the “×× netizen” plays 6662.\n\nThis game strongly tests the coordination between the two players. However, since Jiutiao Kelian and the “×× netizen” cannot understand each other, they decide to play with open hands, i.e., both sides know the other’s cards. Since both players will act according to the optimal strategy, the outcome of the game is already determined at the moment the cards are dealt.\n\nNow you are given the “×× netizen”’s hand. You need to compute how many different possible hands Jiutiao Kelian can have that allow them to win.\n\nNote: the “×× netizen”’s cards and Jiutiao Kelian’s cards come from the same deck, and there are no $3$’s when dealing.", "inputFormat": "For each test case, input one line: a string of length $17$ representing the “×× netizen”’s hand. We use 456789TJQKA2wW to represent each rank of card.", "outputFormat": "For each test case, output an integer representing the answer: the number of Jiutiao Kelian’s hands that satisfy the condition. The answer may be very large, so output it modulo $998244353$.\n\n**Note**: in this problem we ignore suits. If two hands have exactly the same multiset of ranks but different suits, they are still considered the same.", "hint": "For various reasons, this problem uses bundled testdata. There are $3$ subtasks in total:\n\n| Subtask ID | Score | Constraint |\n| :---: | :--: | :------------: |\n| 1 | $30$ | Each rank appears at most $2$ times |\n| 2 | $30$ | Each rank appears at most $3$ times |\n| 3 | $40$ | Each rank appears at most $4$ times |\n\nTime limit: 2s.\n\nMemory limit: 512M.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[PKUSC2018] 主斗地", "background": "", "description": "如果你参加过 NOIP 2015 和 PKUWC 2018，那么你一定对一道叫做斗地主的题印象深刻。为了致敬经典，我们又出了一道有关打牌的题。在本题中，牌型和斗地主**类似但不完全相同**，我们称本题中的扑克游戏为主斗地。\n\n主斗地是一种使用黑桃、红心、梅花、方片的A到K加上大小王的共54张牌来进行的扑克牌游戏，其中大小王各一张，其他数码牌各四张。在斗地主中，牌的大小关系根据牌的数码表示如下：$3<4<5<6<7<8<9<10(T)<J<Q<K<A<2< $小王 $(w)$ $<$ 大王 $(W)$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 $n$ 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。为了简化题目，本题不考虑花色的影响，即**所有的相同的数码的牌都是被视为一样的**。\n\n在这道题中，允许的出牌牌型有（**这一部分与传统的斗地主有所出入，请注意**）：\n\n|   名称    |           解释           |      举例       |     注     |\n| :-----: | :--------------------: | :-----------: | :-------: |\n|   单牌    |         单独的一张牌         |       6       | 单张的王也是单牌  |\n|   对子    |        相同数码的两张牌        |      66       |  大小王不是对子  |\n|   三张牌   |        相同数码的三张牌        |      666      |           |\n|   三带一   |     相同数码的三张牌带上一张单牌     |     666w      |           |\n|   三带二   |  相同数码的三张牌带上一个另外数码的对子   |     66699     |           |\n|   顺子    |    大小连续的 $5$ 张及以上单牌    |    3456789    | 不能含有大小王和2 |\n|   连对    |   大小连续的 $3$ 对及以上的对子    |   33445566    | 不能含有大小王和2 |\n|   三顺    |     大小连续的两组及以上的三张牌     |   333444555   | 不能含有大小王和2 |\n|   四带二   |     四张相同数码的牌带上两张单牌     | 444456 444455 | 注意不能带两个对子 |\n| 飞机（单翅膀） | 三顺带上相同数量的**数码两两不同的**单牌 | 33344455569J  |           |\n| 飞机（双翅膀） | 三顺带上相同数量的**数码两两不同的**对子 |  3334446699   |           |\n\n**注意**：\n\n1. 在牌型中没有连炸这种牌型，但是形如 444455556666 的牌仍然是能出的，它将被视为 444555666 带 456 的飞机（单翅膀）牌型。\n2. 大王和小王数码不同，即飞机带大小王是合法的，例如 333444wW\n3. 容易验证，上述牌型的规则是合法的，即对于任意合法的牌，它都有唯一的牌型。\n4. 在牌型中，没有炸弹。**炸弹将被视为三带一，且没有炸弹的效果**，即它不能压任何牌型。\n5. 在牌型中，没有火箭。这意味着 wW 不再是一个合法的牌型。\n\n两手牌是属于相同牌型的当且仅当他们的名称相同且包含牌的数量相同。相同牌型的牌之间存在着大小关系：\n\n1. 三带一三带二的大小取决于那三张相同牌的数码\n2. 飞机的大小取决于三顺的大小\n3. 四带二的大小取决于四张相同牌的大小\n4. 其他牌型的大小取决于牌中的最大的一张牌\n\n下面是对主斗地的游戏过程的描述：\n\n1. 在主斗地中，有两个玩家，他们是同一个阵营的，两个玩家要一同达成游戏目标。为了方便，我们假设第一个玩家是九条可怜，第二个玩家是××网友。\n2. 游戏只会使用一副完整的扑克牌。在游戏开始的时候，**会先把所有的 $3$ 扔掉**。之后双方各从这一副牌中随机抽取 $17$ 张，余下的 $16$张被丢弃。你可以认为是随机洗牌后，九条可怜取前 $17$ 张，××网友后 $17$ 张，剩下的 $16$ 张被掉了。\n3. 游戏分成若干轮，每一轮分为两步：\n   1. 第一步，九条可怜从当前手牌中选择一个任意牌型任意大小的牌 $C$ 并打出。\n   2. 第二步，××网友从当前手牌中选择一个和 $C$ 牌型相同且大小 **严格更大** 的牌 $C'$ 打出。如果不存在这样的牌则游戏失败。\n4. 在某一轮结束后，如果九条可怜和××网友中有至少一个人没有手牌，则游戏结束。如果两个人都没有手牌，则游戏胜利，否则游戏失败。\n\n下面是一个例子：\n\n假设九条可怜的牌是 44445556789TJQKwW，××网友的牌是 666789TJQKAAAA222。那么一个可以获胜的方案是：\n\n1. 第一轮九条可怜出 4444wW，××网友出 AAAA22。\n2. 第二轮九条可怜出 6789TJQ，××网友出 789TJQK。\n3. 第三轮九条可怜出 555K，××网友出 6662。\n\n这个游戏很考验两个玩家之间的默契。但是因为九条可怜和××网友无法相互理解，于是他们打算以明牌的方式进行游戏，即双方都知道对方的牌。因为两个人都会按照最优策略行动，所以在牌下发的时候，游戏的胜负就已经确定了。\n\n现在给出××网友的牌，你需要计算九条可怜有多少种不同的可能的手牌可以获得胜利。\n\n注意：××网友和九条可怜的牌都来自于同一副扑克，且分牌的时候没有 $3$。", "inputFormat": "每组数据输入一行，一个长度为 $17$ 的字符串表示××网友的牌。我们用 456789TJQKA2wW 来表示每一种牌。\n", "outputFormat": "对每组数据，输出一个整数表示答案，满足条件的九条可怜的牌数。答案可能很大，请对 $998244353$ 取模输出。\n\n**注意**，在这题中我们不考虑花色，如果两种手牌的数码组成完全相同，但是花色不同，他们也是会被视为同一种的。\n", "hint": "\n因为种种原因，本题采用捆绑测试，一共有 $3$ 个 subtask:\n\n| 子问题编号 |  分值  |       约定       |\n| :---: | :--: | :------------: |\n|   1   | $30$ | 每一种牌最多出现 $2$ 次 |\n|   2   | $30$ | 每一种牌最多出现 $3$ 次 |\n|   3   | $40$ | 每一种牌最多出现 $4$ 次 |\n\n时间限制：2s \n\n空间限制：512M", "locale": "zh-CN"}}}
{"pid": "P5371", "type": "P", "difficulty": 6, "samples": [["3 3\n0", "10"], ["9 4\n9\n1 3\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n9 3", "3521"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2019", "各省省选", "陕西"], "title": "[SNOI2019] 纸牌", "background": null, "description": "有一副纸牌。牌一共有 $n$ 种，分别标有 $1,2,...,n$ ，每种有 $C$ 张。故这副牌总共有 $nC$ 张。\n\n三张连号的牌 $(i,i+1,i+2)$ 或三张相同的牌 $(i,i,i)$ 可以组成一**叠**。如果一组牌可以分成若干（包括零）**叠**，就称其为一组**王牌**。\n\n你从牌堆中摸了一些初始牌。现在你想挑出一些牌组成一组王牌，请问有多少种可能组成的王牌呢？答案对 $998244353$ 取模。**也就是说，需要在初始牌的基础上再选一些牌（也可以不再选）。**\n\n两组牌相同当且仅当它们含有的每一种牌数量都相同。", "inputFormat": "第 $1$ 行两个整数 $n,C$ 表示牌的种类数和每种的张数；\n\n第 $2$ 行一个整数 $X$ 表示初始牌的种类数；\n\n接下来 $X$ 行每行两个整数 $k_i,a_i$ ，表示初始牌中有 $a_i$ 张 $k_i$ 号牌。每行的 $k_i$ 依次递增。", "outputFormat": "输出 $1$ 行 $1$ 个自然数表示答案，对 $998244353$ 取模。", "hint": "### 样例解释1\n\n所有方案如下：\n\n1. $\\{\\}$ （不选任何牌）\n2. $\\{1,1,1\\}$\n3. $\\{2,2,2\\}$\n4. $\\{3,3,3\\}$\n5. $\\{1,2,3\\}$\n6. $\\{1,1,1,2,2,2\\}$\n7. $\\{1,1,1,3,3,3\\}$\n8. $\\{2,2,2,3,3,3\\}$\n9. $\\{1,1,2,2,3,3\\}$\n10. $\\{1,1,1,2,2,2,3,3,3\\}$\n\n### 数据范围\n\n对于所有数据， $1\\leq n\\leq 10^{18},0\\leq a_i\\leq C\\leq 1000,0\\leq X\\leq 1000$ 。注意 $a_i$ 和 $C$ 可能为 $0$ 。\n\n- 对于 $20\\%$ 的数据， $n=9,C=4$ 。\n- 对于另外 $15\\%$ 的数据， $n\\leq 10^5,C=2$ 。\n- 对于另外 $15\\%$ 的数据， $X\\leq 5,C\\leq 10$ 。\n- 对于另外 $10\\%$ 的数据， $X=0$ 。\n- 对于另外 $20\\%$ 的数据， $n\\leq 10^5$ 。\n- 对于余下 $20\\%$ 的数据，无特殊限制。", "locale": "zh-CN", "translations": {"en": {"title": "[SNOI2019] Cards", "background": "", "description": "There is a deck of cards. There are $n$ types of cards, labeled $1,2,\\ldots,n$, and each type has $C$ cards. Therefore, the deck contains a total of $nC$ cards.\n\nThree consecutive cards $(i,i+1,i+2)$ or three identical cards $(i,i,i)$ can form a **set**. If a multiset of cards can be divided into several (possibly zero) **sets**, then it is called a **winning hand**.\n\nYou have drawn some initial cards from the deck. Now you want to pick some cards to form a winning hand. How many different winning hands can you form? Output the answer modulo $998244353$. **That is, based on the initial cards, you may select some additional cards (or select none).**\n\nTwo groups of cards are considered the same if and only if, for every card type, the quantities of that type in the two groups are the same.", "inputFormat": "The first line contains two integers $n,C$, representing the number of card types and the number of cards of each type.\n\nThe second line contains one integer $X$, representing the number of types present in the initial cards.\n\nThe next $X$ lines each contain two integers $k_i,a_i$, meaning that there are $a_i$ cards of type $k_i$ in the initial cards. The values $k_i$ are given in strictly increasing order.", "outputFormat": "Output one line with one non-negative integer, the answer modulo $998244353$.", "hint": "### Sample Explanation 1\n\nAll valid choices are as follows:\n\n1. $\\{\\}$ (choose no cards)\n2. $\\{1,1,1\\}$\n3. $\\{2,2,2\\}$\n4. $\\{3,3,3\\}$\n5. $\\{1,2,3\\}$\n6. $\\{1,1,1,2,2,2\\}$\n7. $\\{1,1,1,3,3,3\\}$\n8. $\\{2,2,2,3,3,3\\}$\n9. $\\{1,1,2,2,3,3\\}$\n10. $\\{1,1,1,2,2,2,3,3,3\\}$\n\n### Constraints\n\nFor all testdata, $1\\leq n\\leq 10^{18}$, $0\\leq a_i\\leq C\\leq 1000$, and $0\\leq X\\leq 1000$. Note that $a_i$ and $C$ may be $0$.\n\n- For $20\\%$ of the data, $n=9$ and $C=4$.\n- For another $15\\%$ of the data, $n\\leq 10^5$ and $C=2$.\n- For another $15\\%$ of the data, $X\\leq 5$ and $C\\leq 10$.\n- For another $10\\%$ of the data, $X=0$.\n- For another $20\\%$ of the data, $n\\leq 10^5$.\n- For the remaining $20\\%$ of the data, there are no special restrictions.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SNOI2019] 纸牌", "background": null, "description": "有一副纸牌。牌一共有 $n$ 种，分别标有 $1,2,...,n$ ，每种有 $C$ 张。故这副牌总共有 $nC$ 张。\n\n三张连号的牌 $(i,i+1,i+2)$ 或三张相同的牌 $(i,i,i)$ 可以组成一**叠**。如果一组牌可以分成若干（包括零）**叠**，就称其为一组**王牌**。\n\n你从牌堆中摸了一些初始牌。现在你想挑出一些牌组成一组王牌，请问有多少种可能组成的王牌呢？答案对 $998244353$ 取模。**也就是说，需要在初始牌的基础上再选一些牌（也可以不再选）。**\n\n两组牌相同当且仅当它们含有的每一种牌数量都相同。", "inputFormat": "第 $1$ 行两个整数 $n,C$ 表示牌的种类数和每种的张数；\n\n第 $2$ 行一个整数 $X$ 表示初始牌的种类数；\n\n接下来 $X$ 行每行两个整数 $k_i,a_i$ ，表示初始牌中有 $a_i$ 张 $k_i$ 号牌。每行的 $k_i$ 依次递增。", "outputFormat": "输出 $1$ 行 $1$ 个自然数表示答案，对 $998244353$ 取模。", "hint": "### 样例解释1\n\n所有方案如下：\n\n1. $\\{\\}$ （不选任何牌）\n2. $\\{1,1,1\\}$\n3. $\\{2,2,2\\}$\n4. $\\{3,3,3\\}$\n5. $\\{1,2,3\\}$\n6. $\\{1,1,1,2,2,2\\}$\n7. $\\{1,1,1,3,3,3\\}$\n8. $\\{2,2,2,3,3,3\\}$\n9. $\\{1,1,2,2,3,3\\}$\n10. $\\{1,1,1,2,2,2,3,3,3\\}$\n\n### 数据范围\n\n对于所有数据， $1\\leq n\\leq 10^{18},0\\leq a_i\\leq C\\leq 1000,0\\leq X\\leq 1000$ 。注意 $a_i$ 和 $C$ 可能为 $0$ 。\n\n- 对于 $20\\%$ 的数据， $n=9,C=4$ 。\n- 对于另外 $15\\%$ 的数据， $n\\leq 10^5,C=2$ 。\n- 对于另外 $15\\%$ 的数据， $X\\leq 5,C\\leq 10$ 。\n- 对于另外 $10\\%$ 的数据， $X=0$ 。\n- 对于另外 $20\\%$ 的数据， $n\\leq 10^5$ 。\n- 对于余下 $20\\%$ 的数据，无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P5372", "type": "P", "difficulty": 6, "samples": [["3 3\nnnn\nuuu\no<>\n<>n\n<>u\n<>o", "URLR"], ["5 5\nn<><>\nun<>n\nnuonu\nu<>un\n<><>u\n<><>o\n<><>n\n<><>u\n<><>n\n<><>u", "RLLRLRR"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "各省省选", "Special Judge", "陕西"], "title": "[SNOI2019] 积木", "background": "", "description": "有一块 $n$ 行 $m$ 列的网格板， $n,m$ 都是奇数。网格上平铺着一些 $1\\times 2$ 的积木。积木可以旋转，不能重叠。这些积木共有 $\\frac{nm-1}{2}$ 块，也就是说，网格板上只有一格的空位。\n\n你可以做两种操作：\n\n1. 将一块与空白格相邻（指有公共边）的积木旋转 $90^\\circ$ 到空白格中；\n2. 将一块与空白格积木相邻的积木平移至空白格中。\n\n如图所示（被移动的积木颜色较浅）：\n\n![](https://cdn.luogu.com.cn/upload/pic/58669.png)\n\n请你用以上两种操作将给定的网格板变换为指定的状态。", "inputFormat": "第一行两个正奇数 $n,m$ ，分别表示网格的行数和列数。\n\n接下来 $n$ 行，每行 $m$ 个字符，描述网格板的初始状态：\n\n- `<`表示这个格子是一块积木的左半部分；\n- `>`表示这个格子是一块积木的右半部分；\n- `n`表示这个格子是一块积木的上半部分；\n- `u`表示这个格子是一块积木的下半部分；\n- `o`表示这个格子是空的。\n\n接下来另外 $n$ 行，每行 $m$ 个字符，描述你需要将网格板变成的目标状态，格式同上。\n\n", "outputFormat": "你需要输出一个字符串，按顺序表示你的操作：\n\n- `L`表示你移动了空白格左侧的积木；\n- `R`表示你移动了空白格右侧的积木；\n- `U`表示你移动了空白格上方的积木；\n- `D`表示你移动了空白格下方的积木。\n\n当然，没有操作的话输出空串就好了。\n\n", "hint": "#### 数据范围与说明\n\n你输出的操作序列长度不能超过 $8\\times 10^6$ 。\n\n对于所有数据， $1\\leq n,m\\leq 2000$ 。\n\n- 对于 $10\\%$ 的数据， $n,m\\leq 3$ ；\n- 对于另外 $10\\%$ 的数据， $n,m\\leq 5$ ；\n- 对于另外 $20\\%$ 的数据， $m=3$ ；\n- 对于另外 $20\\%$ 的数据， $n,m\\leq 50$ ；\n- 对于另外 $20\\%$ 的数据， $n,m\\leq 200$ ；\n- 对于余下 $20\\%$ 的数据，无特殊限制。\n\n#### SPJ 说明\n\n参考 https://www.luogu.org/discuss/show/114298 ，感谢 @M_sea 的贡献。", "locale": "zh-CN", "translations": {"en": {"title": "[SNOI2019] Bricks", "background": "", "description": "There is a grid board with $n$ rows and $m$ columns, where both $n$ and $m$ are odd. Some $1\\times 2$ bricks are tiled on the grid. Bricks can be rotated and cannot overlap. There are $\\frac{nm-1}{2}$ bricks in total, which means there is exactly one empty cell on the board.\n\nYou can perform two kinds of operations:\n\n1. Rotate a brick that is adjacent to the empty cell (sharing a common edge) by $90^\\circ$ into the empty cell.\n2. Translate a brick that is adjacent to the empty cell into the empty cell.\n\nAs shown in the figure (the moved brick is in a lighter color):\n\n![](https://cdn.luogu.com.cn/upload/pic/58669.png)\n\nPlease use the two operations above to transform the given grid board into the specified target state.", "inputFormat": "The first line contains two positive odd integers $n,m$, representing the number of rows and columns of the grid.\n\nThen follow $n$ lines, each containing $m$ characters, describing the initial state of the grid board:\n\n- `<` means this cell is the left half of a brick.\n- `>` means this cell is the right half of a brick.\n- `n` means this cell is the upper half of a brick.\n- `u` means this cell is the lower half of a brick.\n- `o` means this cell is empty.\n\nThen follow another $n$ lines, each containing $m$ characters, describing the target state you need to transform the board into, in the same format as above.", "outputFormat": "You need to output a string that represents your operations in order:\n\n- `L` means you moved the brick on the left side of the empty cell.\n- `R` means you moved the brick on the right side of the empty cell.\n- `U` means you moved the brick above the empty cell.\n- `D` means you moved the brick below the empty cell.\n\nOf course, if there are no operations, output an empty string.", "hint": "#### Constraints and Notes\n\nThe length of your output operation sequence must not exceed $8\\times 10^6$.\n\nFor all testdata, $1\\leq n,m\\leq 2000$.\n\n- For $10\\%$ of the testdata, $n,m\\leq 3$.\n- For another $10\\%$ of the testdata, $n,m\\leq 5$.\n- For another $20\\%$ of the testdata, $m=3$.\n- For another $20\\%$ of the testdata, $n,m\\leq 50$.\n- For another $20\\%$ of the testdata, $n,m\\leq 200$.\n- For the remaining $20\\%$ of the testdata, there are no special restrictions.\n\n#### SPJ Notes\n\nSee https://www.luogu.org/discuss/show/114298. Thanks to @M_sea for the contribution.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SNOI2019] 积木", "background": "", "description": "有一块 $n$ 行 $m$ 列的网格板， $n,m$ 都是奇数。网格上平铺着一些 $1\\times 2$ 的积木。积木可以旋转，不能重叠。这些积木共有 $\\frac{nm-1}{2}$ 块，也就是说，网格板上只有一格的空位。\n\n你可以做两种操作：\n\n1. 将一块与空白格相邻（指有公共边）的积木旋转 $90^\\circ$ 到空白格中；\n2. 将一块与空白格积木相邻的积木平移至空白格中。\n\n如图所示（被移动的积木颜色较浅）：\n\n![](https://cdn.luogu.com.cn/upload/pic/58669.png)\n\n请你用以上两种操作将给定的网格板变换为指定的状态。", "inputFormat": "第一行两个正奇数 $n,m$ ，分别表示网格的行数和列数。\n\n接下来 $n$ 行，每行 $m$ 个字符，描述网格板的初始状态：\n\n- `<`表示这个格子是一块积木的左半部分；\n- `>`表示这个格子是一块积木的右半部分；\n- `n`表示这个格子是一块积木的上半部分；\n- `u`表示这个格子是一块积木的下半部分；\n- `o`表示这个格子是空的。\n\n接下来另外 $n$ 行，每行 $m$ 个字符，描述你需要将网格板变成的目标状态，格式同上。\n\n", "outputFormat": "你需要输出一个字符串，按顺序表示你的操作：\n\n- `L`表示你移动了空白格左侧的积木；\n- `R`表示你移动了空白格右侧的积木；\n- `U`表示你移动了空白格上方的积木；\n- `D`表示你移动了空白格下方的积木。\n\n当然，没有操作的话输出空串就好了。\n\n", "hint": "#### 数据范围与说明\n\n你输出的操作序列长度不能超过 $8\\times 10^6$ 。\n\n对于所有数据， $1\\leq n,m\\leq 2000$ 。\n\n- 对于 $10\\%$ 的数据， $n,m\\leq 3$ ；\n- 对于另外 $10\\%$ 的数据， $n,m\\leq 5$ ；\n- 对于另外 $20\\%$ 的数据， $m=3$ ；\n- 对于另外 $20\\%$ 的数据， $n,m\\leq 50$ ；\n- 对于另外 $20\\%$ 的数据， $n,m\\leq 200$ ；\n- 对于余下 $20\\%$ 的数据，无特殊限制。\n\n#### SPJ 说明\n\n参考 https://www.luogu.org/discuss/show/114298 ，感谢 @M_sea 的贡献。", "locale": "zh-CN"}}}
{"pid": "P5373", "type": "P", "difficulty": 7, "samples": [["5 1\n1 9 2 6 0 8\n1 7\n", "26 497 4900 29498 96040 134456 \n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】多项式复合函数", "background": "有一天，NaCly_Fish看见 $\\mathsf r \\color{red} \\mathsf{qy}$ 在群里说：“终于把多项式复合写完啦！qwq”  \n她便好奇地去问 $\\mathsf r \\color{red} \\mathsf{qy}$：“这个东西怎么写啊？”   \n\n$\\mathsf r \\color{red} \\mathsf{qy}$ 只丢给了她一份嘤文的 pdf，然而她根本看不懂。  \n于是她求助于你，希望你能帮她解决这个难题。", "description": "给定一个 $n$ 次多项式 $F(x)$，和一个 $m$ 次多项式 $G(x)$，你需要求一个 $n$ 次多项式 $H(x)$ ，满足条件：  \n$$H(x) \\equiv F(G(x))\\space (\\text{mod }x^{n+1})$$   \n换种说法，你要求的多项式应满足：  \n$$H(x) \\equiv \\sum\\limits_{i=0}^n [x^i]F(x)\\times G(x)^i \\space (\\text{mod }x^{n+1})$$\n将结果的各项系数对 $998244353$ 取模。", "inputFormat": "第一行两个正整数 $n,m$ ，分别表示 $F(x)$ 和 $G(x)$ 的次数   \n第二行 $n+1$ 个非负整数 $f_i$，表示 $F(x)$ 的 $i$ 次项系数   \n第三行 $m+1$ 个非负整数 $g_i$，表示 $G(x)$ 的 $i$ 次项系数   ", "outputFormat": "输出一行 $n+1$ 个非负整数，从低到高表示 $H(x)$ 的系数", "hint": "**数据范围：**  \n$1\\le m \\le n \\le 20000$    \n$f_i,g_i \\in [0,998244353)\\cap \\mathbb Z$", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Polynomial Composition Function.", "background": "One day, NaCly_Fish saw $\\mathsf r \\color{red} \\mathsf{qy}$ say in the group chat: “I finally finished writing polynomial composition! qwq”.  \nSo she curiously asked $\\mathsf r \\color{red} \\mathsf{qy}$: “How do you write this thing?”.  \n\n$\\mathsf r \\color{red} \\mathsf{qy}$ only threw her a PDF in “Yingwen” (pinyin), but she could not understand it at all.  \nSo she asked you for help, hoping you can help her solve this difficult problem.", "description": "Given an $n$-degree polynomial $F(x)$ and an $m$-degree polynomial $G(x)$, you need to find an $n$-degree polynomial $H(x)$ that satisfies:  \n$$H(x) \\equiv F(G(x))\\space (\\text{mod }x^{n+1})$$  \nIn other words, the polynomial you need should satisfy:  \n$$H(x) \\equiv \\sum\\limits_{i=0}^n [x^i]F(x)\\times G(x)^i \\space (\\text{mod }x^{n+1})$$  \nTake all coefficients of the result modulo $998244353$.", "inputFormat": "The first line contains two positive integers $n,m$, representing the degrees of $F(x)$ and $G(x)$.  \nThe second line contains $n+1$ non-negative integers $f_i$, representing the coefficient of the $x^i$ term of $F(x)$.  \nThe third line contains $m+1$ non-negative integers $g_i$, representing the coefficient of the $x^i$ term of $G(x)$.", "outputFormat": "Output one line with $n+1$ non-negative integers, from low degree to high degree, representing the coefficients of $H(x)$.", "hint": "**Constraints:**  \n$1\\le m \\le n \\le 20000$  \n$f_i,g_i \\in [0,998244353)\\cap \\mathbb Z$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】多项式复合函数", "background": "有一天，NaCly_Fish看见 $\\mathsf r \\color{red} \\mathsf{qy}$ 在群里说：“终于把多项式复合写完啦！qwq”  \n她便好奇地去问 $\\mathsf r \\color{red} \\mathsf{qy}$：“这个东西怎么写啊？”   \n\n$\\mathsf r \\color{red} \\mathsf{qy}$ 只丢给了她一份嘤文的 pdf，然而她根本看不懂。  \n于是她求助于你，希望你能帮她解决这个难题。", "description": "给定一个 $n$ 次多项式 $F(x)$，和一个 $m$ 次多项式 $G(x)$，你需要求一个 $n$ 次多项式 $H(x)$ ，满足条件：  \n$$H(x) \\equiv F(G(x))\\space (\\text{mod }x^{n+1})$$   \n换种说法，你要求的多项式应满足：  \n$$H(x) \\equiv \\sum\\limits_{i=0}^n [x^i]F(x)\\times G(x)^i \\space (\\text{mod }x^{n+1})$$\n将结果的各项系数对 $998244353$ 取模。", "inputFormat": "第一行两个正整数 $n,m$ ，分别表示 $F(x)$ 和 $G(x)$ 的次数   \n第二行 $n+1$ 个非负整数 $f_i$，表示 $F(x)$ 的 $i$ 次项系数   \n第三行 $m+1$ 个非负整数 $g_i$，表示 $G(x)$ 的 $i$ 次项系数   ", "outputFormat": "输出一行 $n+1$ 个非负整数，从低到高表示 $H(x)$ 的系数", "hint": "**数据范围：**  \n$1\\le m \\le n \\le 20000$    \n$f_i,g_i \\in [0,998244353)\\cap \\mathbb Z$", "locale": "zh-CN"}}}
{"pid": "P5374", "type": "P", "difficulty": 7, "samples": [["7\n1 1 2 3 5 2\n5\n5 1 5 0\n2 0 5 0\n2 2 4 5\n7 2 2 4\n3 2 5 4", "2\n3\n69\n57\n70"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2019", "O2优化", "THUPC"], "title": "[THUPC 2019] 不用找的树", "background": "", "description": "给出一棵 $n$ 个节点的树，结点标号从 $1$ 到 $n$ 。\n\n定义树上两点 $a,b$ 的距离 $d(a,b)$ 是最小的非负整数 $k$ ，满足存在结点序列 $v_0,v_1,...,v_k$ ，满足 $v_0=a,v_k=b$ ，且对于 $0\\leq i\\leq k-1$ 有 $v_i$ 和 $v_{i+1}$ 之间在树上有一条边相连。\n\n有 $m$ 个询问，每个询问包含参数 $p_0,d_0,p_1,d_1$ ，求：\n\n$$\\sum\\limits_{d(p_0,a)\\leq d_0}\\sum\\limits_{d(p_1,b)\\leq d_1}d(a,b)$$\n\n", "inputFormat": "第一行一个整数 $n$ ，表示树的节点数目。\n\n接下来一行 $n-1$ 个整数 $f_2,f_3,...,f_n$ ，依次表示 $i$ 和 $f_i$ （ $1\\leq f_i\\leq i-1$ ）之间有一条边。\n\n接下来一行一个整数 $m$ ，表示询问数目。\n\n接下来 $m$ 行依次描述所有询问：每行四个证书 $p_0,d_0,p_1,d_1$ （ $1\\leq p_0,p_1\\leq n,0\\leq d_0,d_1\\leq n-1$ ）描述一组询问。\n\n保证 $1\\leq n\\leq 10^5,1\\leq m\\leq 10^5$ 。\n\n", "outputFormat": "共 $m$ 行，依次回答各组询问：每行输出一行一个整数表示这组询问的答案。", "hint": "##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN", "translations": {"en": {"title": "[THUPC 2019] A Tree You Do Not Need to Search", "background": "", "description": "You are given a tree with $n$ nodes, numbered from $1$ to $n$.\n\nDefine the distance $d(a,b)$ between two nodes $a,b$ on the tree as the smallest non-negative integer $k$ such that there exists a node sequence $v_0,v_1,...,v_k$ with $v_0=a$, $v_k=b$, and for every $0\\leq i\\leq k-1$, there is an edge directly connecting $v_i$ and $v_{i+1}$ in the tree.\n\nThere are $m$ queries. Each query contains parameters $p_0,d_0,p_1,d_1$. Compute:\n\n$$\\sum\\limits_{d(p_0,a)\\leq d_0}\\sum\\limits_{d(p_1,b)\\leq d_1}d(a,b)$$", "inputFormat": "The first line contains an integer $n$, the number of nodes in the tree.\n\nThe next line contains $n-1$ integers $f_2,f_3,...,f_n$, indicating that there is an edge between $i$ and $f_i$ ($1\\leq f_i\\leq i-1$).\n\nThe next line contains an integer $m$, the number of queries.\n\nThe next $m$ lines describe the queries. Each line contains four integers $p_0,d_0,p_1,d_1$ ($1\\leq p_0,p_1\\leq n,0\\leq d_0,d_1\\leq n-1$), describing one query.\n\nConstraints: $1\\leq n\\leq 10^5,1\\leq m\\leq 10^5$.", "outputFormat": "Output $m$ lines. For each query, output one integer on its own line, which is the answer to that query.", "hint": "##### Copyright Information\n\nFrom THUPC (THU Programming Contest, Tsinghua University Programming Contest) 2019.\n\nResources such as editorials can be found at <https://github.com/wangyurzee7/THUPC2019>.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUPC 2019] 不用找的树", "background": "", "description": "给出一棵 $n$ 个节点的树，结点标号从 $1$ 到 $n$ 。\n\n定义树上两点 $a,b$ 的距离 $d(a,b)$ 是最小的非负整数 $k$ ，满足存在结点序列 $v_0,v_1,...,v_k$ ，满足 $v_0=a,v_k=b$ ，且对于 $0\\leq i\\leq k-1$ 有 $v_i$ 和 $v_{i+1}$ 之间在树上有一条边相连。\n\n有 $m$ 个询问，每个询问包含参数 $p_0,d_0,p_1,d_1$ ，求：\n\n$$\\sum\\limits_{d(p_0,a)\\leq d_0}\\sum\\limits_{d(p_1,b)\\leq d_1}d(a,b)$$\n\n", "inputFormat": "第一行一个整数 $n$ ，表示树的节点数目。\n\n接下来一行 $n-1$ 个整数 $f_2,f_3,...,f_n$ ，依次表示 $i$ 和 $f_i$ （ $1\\leq f_i\\leq i-1$ ）之间有一条边。\n\n接下来一行一个整数 $m$ ，表示询问数目。\n\n接下来 $m$ 行依次描述所有询问：每行四个证书 $p_0,d_0,p_1,d_1$ （ $1\\leq p_0,p_1\\leq n,0\\leq d_0,d_1\\leq n-1$ ）描述一组询问。\n\n保证 $1\\leq n\\leq 10^5,1\\leq m\\leq 10^5$ 。\n\n", "outputFormat": "共 $m$ 行，依次回答各组询问：每行输出一行一个整数表示这组询问的答案。", "hint": "##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN"}}}
{"pid": "P5375", "type": "P", "difficulty": 3, "samples": [["6\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3", "Yes\nNo\nNo\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "THUPC"], "title": "[THUPC 2019] 组合数据结构问题", "background": "", "description": "> 众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。\n\n小葱同学在学习了组合数的计算之后，开始了研究数据结构的道路。通过十五分钟的刻苦学习，小葱同学初步掌握了队列、栈和堆这三种数据结构。小葱同学发现这三种数据结构都支持两种操作：\n\n1. 将某个数插入该数据结构。\n2. 从该数据结构中按照数据结构的原理取出一个数。\n\n小葱同学为了检验自己对这三种数据结构的理解，设计了一个类似的黑箱模型。该模型也支持两种操作，向黑箱中输入一个数或者从黑箱中输出一个数。现在小葱对该黑箱做了若干次操作，并给出每次输入和输出的数，问这个黑箱实现的是否可能是队列、栈、大根堆或者小根堆。\n\n虽然小葱同学对这四种数据结构了如指掌，但他还是决定告诉你它们的分别是什么：\n\n- 如果黑箱是**队列**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**最早被放入的**数将被输出并移出黑箱。\n- 如果黑箱是**栈**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**最晚被放入的**数将被输出并移出黑箱。\n- 如果黑箱是**大根堆**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**值最大的**数将被输出并移出黑箱。特别地，如值最大的数有多个，则仅将其中一个移出黑箱。\n- 如果黑箱是**小根堆**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**值最小的**数将被输出并移出黑箱。特别地，如值最小的数有多个，则仅将其中一个移出黑箱。\n\n", "inputFormat": "第一行一个整数 $N$  代表操作的个数。\n\n接下来 $N$ 行每行两个整数 $\\mathrm{opt},v$ 。如果 $\\mathrm{opt}=1$ ，代表这次操作小葱同学向黑箱中插入 $v$ 了这个数；如果 $\\mathrm{opt=2}$ ，代表小葱这次操作从黑箱中取出了 $v$ 这个数。\n\n保证 $0\\leq N\\leq 10^5$ ，$-2^{31}\\leq v<2^{31}$ ，$\\mathrm{opt}\\in\\{1,2\\}$  。\n\n注意输入的数据仅保证在格式和范围上完全正确，不保证任何其他条件。", "outputFormat": "共四行，每行可能是 `Yes` 或者 `No`，分别依次代表该黑箱是否可能是队列、栈、大根堆或者小根堆。", "hint": "##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN", "translations": {"en": {"title": "[THUPC 2019] Combined Data Structure Problem", "background": "", "description": "> As everyone knows, student Xiaocong is good at calculations, especially at calculating binomial coefficients, but this problem has little to do with binomial coefficients.\n\nAfter learning how to compute binomial coefficients, Xiaocong started studying data structures. After fifteen minutes of hard study, Xiaocong initially mastered three data structures: queue, stack, and heap. Xiaocong found that these three data structures all support two operations:\n\n1. Insert a number into the data structure.\n2. Remove a number from the data structure according to its rules.\n\nTo test his understanding of these three data structures, Xiaocong designed a similar black-box model. This model also supports two operations: input a number into the black box, or output a number from the black box. Now Xiaocong has performed several operations on this black box and provided the number inserted and the number output each time. You are asked whether this black box could possibly be a queue, a stack, a max-heap, or a min-heap.\n\nAlthough Xiaocong knows these four data structures very well, he still decided to tell you how they differ:\n\n- If the black box is a **queue**: the black box is initially empty. On input, the number is placed into the black box. On output, the number that was **inserted earliest** among the current elements in the black box is output and removed.\n- If the black box is a **stack**: the black box is initially empty. On input, the number is placed into the black box. On output, the number that was **inserted latest** among the current elements in the black box is output and removed.\n- If the black box is a **max-heap**: the black box is initially empty. On input, the number is placed into the black box. On output, the **largest value** among the current elements in the black box is output and removed. In particular, if there are multiple largest values, only one of them is removed.\n- If the black box is a **min-heap**: the black box is initially empty. On input, the number is placed into the black box. On output, the **smallest value** among the current elements in the black box is output and removed. In particular, if there are multiple smallest values, only one of them is removed.", "inputFormat": "The first line contains an integer $N$, which represents the number of operations.\n\nThe next $N$ lines each contain two integers $\\mathrm{opt}, v$. If $\\mathrm{opt}=1$, it means that in this operation Xiaocong inserted the number $v$ into the black box. If $\\mathrm{opt}=2$, it means that in this operation Xiaocong removed the number $v$ from the black box.\n\nIt is guaranteed that $0\\leq N\\leq 10^5$, $-2^{31}\\leq v<2^{31}$, and $\\mathrm{opt}\\in\\{1,2\\}$.\n\nNote that the input data is only guaranteed to be completely correct in format and within the ranges, and no other conditions are guaranteed.", "outputFormat": "There are four lines in total. Each line is either `Yes` or `No`, indicating whether the black box could possibly be a queue, a stack, a max-heap, or a min-heap, respectively, in this order.", "hint": "##### Copyright Information\n\nFrom THUPC (THU Programming Contest, Tsinghua University Programming Contest) 2019.\n\nSolutions and other resources can be found at <https://github.com/wangyurzee7/THUPC2019>.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUPC 2019] 组合数据结构问题", "background": "", "description": "> 众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。\n\n小葱同学在学习了组合数的计算之后，开始了研究数据结构的道路。通过十五分钟的刻苦学习，小葱同学初步掌握了队列、栈和堆这三种数据结构。小葱同学发现这三种数据结构都支持两种操作：\n\n1. 将某个数插入该数据结构。\n2. 从该数据结构中按照数据结构的原理取出一个数。\n\n小葱同学为了检验自己对这三种数据结构的理解，设计了一个类似的黑箱模型。该模型也支持两种操作，向黑箱中输入一个数或者从黑箱中输出一个数。现在小葱对该黑箱做了若干次操作，并给出每次输入和输出的数，问这个黑箱实现的是否可能是队列、栈、大根堆或者小根堆。\n\n虽然小葱同学对这四种数据结构了如指掌，但他还是决定告诉你它们的分别是什么：\n\n- 如果黑箱是**队列**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**最早被放入的**数将被输出并移出黑箱。\n- 如果黑箱是**栈**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**最晚被放入的**数将被输出并移出黑箱。\n- 如果黑箱是**大根堆**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**值最大的**数将被输出并移出黑箱。特别地，如值最大的数有多个，则仅将其中一个移出黑箱。\n- 如果黑箱是**小根堆**：黑箱初始为空，输入时数将被放入黑箱，输出时当前黑箱内**值最小的**数将被输出并移出黑箱。特别地，如值最小的数有多个，则仅将其中一个移出黑箱。\n\n", "inputFormat": "第一行一个整数 $N$  代表操作的个数。\n\n接下来 $N$ 行每行两个整数 $\\mathrm{opt},v$ 。如果 $\\mathrm{opt}=1$ ，代表这次操作小葱同学向黑箱中插入 $v$ 了这个数；如果 $\\mathrm{opt=2}$ ，代表小葱这次操作从黑箱中取出了 $v$ 这个数。\n\n保证 $0\\leq N\\leq 10^5$ ，$-2^{31}\\leq v<2^{31}$ ，$\\mathrm{opt}\\in\\{1,2\\}$  。\n\n注意输入的数据仅保证在格式和范围上完全正确，不保证任何其他条件。", "outputFormat": "共四行，每行可能是 `Yes` 或者 `No`，分别依次代表该黑箱是否可能是队列、栈、大根堆或者小根堆。", "hint": "##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN"}}}
{"pid": "P5376", "type": "P", "difficulty": 6, "samples": [["3 3 1\n2 2", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "组合数学", "排列组合", "容斥原理", "Lucas 定理", "THUPC"], "title": "[THUPC 2019] 过河卒二", "background": "", "description": "> 首先我们回忆一下经典难题过河卒问题：\n>\n> 棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向上、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点，因此称之为「马拦过河卒」。\n>\n> 棋盘用坐标表示，$A$ 点 $(1,1)$ 、$B$ 点 $(N,M)$ ，同样马的位置坐标是需要给出的。\n>\n> 现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。\n>\n> **请注意，上述背景内容与本题无关！**\n\nKiana 喜欢玩象棋，尤其是喜欢用象棋玩过河卒的游戏。在传统的过河卒问题中，Kiana 需要控制一个卒从起点走到终点，在路中避开一个对方的马的攻击，然后假装不会算并询问你从起点到终点的路径总数。\n\n在今天的过河卒二游戏中，Kiana 还是控制一个卒在一个 $N\\times M$ 的棋盘上移动，初始时卒位于左下方坐标为 $(1,1)$ 位置，但为了增加难度，Kiana 对游戏规则做出了一些修改。传统的过河卒每步只能向上或向右移动 $1$ 格，Kiana 规定自己的过河卒二还可以在一步中向右上方移动 $1$ 格，即如果当前卒位于坐标 $(x,y)$ 处，则下一步可以走到 $(x+1,y)$ 、$(x,y+1)$ 或 $(x+1,y+1)$ 中的任意一格里面去，同时 Kiana 认为，如果两种移动方案在某一步时卒移动的方向（右、上或右上）不同，则两种方案就是不同的，例如从 $(1,1)$ 先走到 $(1,2)$ 再走到 $(2,2)$ 、从 $(1,1)$ 先走到 $(2,1)$ 再走到 $(2,2)$ 和从 $(1,1)$ 直接走到 $(2,2)$ 是三种不同的移动方案。\n\n其次，过河卒二的终点不再是一个特定的位置，Kiana 规定卒可以从棋盘的上方或右方走出棋盘，此时就视为游戏成功。注意在走出棋盘时仍然有方向选择的不同，例如若过河卒位于 $(1,M)$ 处，则下一步它可以向右或者向右上用两种方式走出棋盘，若过河卒位于 $(N,M)$ 处，则下一步它可以向上、向右或者向右上用三种方式走出棋盘，以不同的方式走出棋盘仍然被算作是不同的移动方案。\n\n此外，对方马的攻击范围不再是有规律的几个位置，而是 Kiana 规定好的 $K$ 个特定坐标，并要求过河卒在移动的过程中不能走到这 $K$ 个坐标的任何一个上，在除这些坐标以外的位置上过河卒都可以按规则自由移动。\n\n现在 Kiana 想知道，过河卒二有多少种不同的移动方案可以走出棋盘，这个答案可能非常大，她只想知道方案数对 $59393$ 取模后的结果。由于她不会算，所以希望由你来告诉她。\n\n", "inputFormat": "第一行包含三个整数 $N$ 、$M$ 和 $K$ ，分别表示棋盘的坐标范围与对方马的攻击格子数（即 Kiana 规定的不能经过的坐标数）。\n\n接下来 $K$ 行，第 $i$ 行包含两个正整数 $X_i$ 和 $Y_i$ ，表示对方马的第 $i$ 个攻击坐标为 $(X_i,Y_i)$ 。\n\n对于所有数据，保证 $1\\leq N\\leq 10^9,1\\leq M\\leq 10^5,0\\leq K\\leq 20,1\\leq X_i\\leq N,1\\leq Y_i\\leq M$，$(1,1)$ 一定不会被对方马攻击，且被攻击的格子中不存在两个坐标相同的格子。", "outputFormat": "输出一行一个整数，表示过河卒走出棋盘的方案数对 $59393$ 取模后的结果。\n\n", "hint": "### 样例解释\n\n用 $\\uparrow$ 表示过河卒向上移动了一格，用 $\\rightarrow$ 表示过河卒向右移动了一格，用 $\\nearrow$ 表示过河卒向右上移动了一格，由此可以简化样例解释的表述。\n\n$24$ 种移动方案如下：\n\n$(\\uparrow\\uparrow\\uparrow)$、$(\\uparrow\\uparrow\\nearrow)$、$(\\uparrow\\uparrow\\rightarrow\\uparrow)$、$(\\uparrow\\uparrow\\rightarrow\\nearrow)$、\n\n$(\\uparrow\\uparrow\\rightarrow\\rightarrow\\uparrow)$、$(\\uparrow\\uparrow\\rightarrow\\rightarrow\\nearrow)$、$(\\uparrow\\uparrow\\rightarrow\\rightarrow\\rightarrow)$、$(\\uparrow\\nearrow\\uparrow)$、\n\n$(\\uparrow\\nearrow\\nearrow)$、$(\\uparrow\\nearrow\\rightarrow\\uparrow)$、$(\\uparrow\\nearrow\\rightarrow\\nearrow)$、$(\\uparrow\\nearrow\\rightarrow\\rightarrow)$、\n\n$(\\rightarrow\\rightarrow\\rightarrow)$、$(\\rightarrow\\rightarrow\\nearrow)$、$(\\rightarrow\\rightarrow\\uparrow\\rightarrow)$、$(\\rightarrow\\rightarrow\\uparrow\\nearrow)$、\n\n$(\\rightarrow\\rightarrow\\uparrow\\uparrow\\rightarrow)$、$(\\rightarrow\\rightarrow\\uparrow\\uparrow\\nearrow)$、$(\\rightarrow\\rightarrow\\uparrow\\uparrow\\uparrow)$、$(\\rightarrow\\nearrow\\rightarrow)$、\n\n$(\\rightarrow\\nearrow\\nearrow)$、$(\\rightarrow\\nearrow\\uparrow\\rightarrow)$、$(\\rightarrow\\nearrow\\uparrow\\nearrow)$、$(\\rightarrow\\nearrow\\uparrow\\uparrow)$。\n\n### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN", "translations": {"en": {"title": "[THUPC 2019] River-Crossing Pawn II", "background": "", "description": "> First, let us recall the classic difficult problem, River-Crossing Pawn:\n>\n> On a chessboard, there is a river-crossing pawn at point $A$ that needs to move to the target point $B$. The pawn moves by the following rules: it can move up, or move right. Meanwhile, there is an opponent knight at point $C$. The knight’s position and all positions it can reach by one knight move are called the opponent knight’s controlled points, hence the name “the knight blocks the river-crossing pawn”.\n>\n> The chessboard is represented by coordinates: $A$ is $(1,1)$, $B$ is $(N,M)$, and the knight’s coordinate is also given.\n>\n> Now you are asked to compute the number of paths for the pawn to get from $A$ to $B$, assuming the knight stays fixed and does not move after each pawn move.\n>\n> **Note that the background above is unrelated to this problem!**\n\nKiana likes playing Chinese chess, and she especially likes using Chinese chess pieces to play the river-crossing pawn game. In the traditional river-crossing pawn problem, Kiana needs to control a pawn to move from the start to the end, avoiding the attacks of an opponent knight on the way, and then pretends she cannot calculate it and asks you for the total number of paths from the start to the end.\n\nIn today’s River-Crossing Pawn II game, Kiana still controls a pawn moving on an $N\\times M$ board. Initially, the pawn is at the bottom-left position with coordinate $(1,1)$. To make the game harder, Kiana changes some rules. In the traditional version, the pawn can only move up or right by $1$ cell each step. Kiana allows her River-Crossing Pawn II to also move up-right by $1$ cell in one step. That is, if the pawn is currently at $(x,y)$, then the next step can go to any of $(x+1,y)$, $(x,y+1)$, or $(x+1,y+1)$. Kiana also considers that if two movement plans differ in the moving direction (right, up, or up-right) at any step, then they are different plans. For example, from $(1,1)$ to $(1,2)$ then to $(2,2)$, from $(1,1)$ to $(2,1)$ then to $(2,2)$, and from $(1,1)$ directly to $(2,2)$ are three different movement plans.\n\nSecond, the goal of River-Crossing Pawn II is no longer a specific position. Kiana defines that the pawn may leave the board from the top side or the right side, and then the game is considered successful. Note that when leaving the board, there are still different direction choices. For example, if the pawn is at $(1,M)$, then in the next step it can leave the board in two ways: right or up-right. If the pawn is at $(N,M)$, then in the next step it can leave the board in three ways: up, right, or up-right. Leaving the board in different ways is still counted as different movement plans.\n\nIn addition, the opponent knight’s attack range is no longer a few regular positions. Instead, Kiana specifies $K$ particular coordinates, and the pawn is not allowed to step on any of these $K$ coordinates during its movement. On all other positions, the pawn may move freely according to the rules.\n\nNow Kiana wants to know how many different movement plans allow the pawn to leave the board. The answer can be very large; she only wants the result modulo $59393$. Since she cannot compute it, she asks you to tell her.", "inputFormat": "The first line contains three integers $N$, $M$, and $K$, representing the coordinate ranges of the board and the number of squares attacked by the opponent knight (i.e., the number of coordinates that Kiana specifies as forbidden).\n\nThe next $K$ lines each contain two positive integers $X_i$ and $Y_i$, meaning the $i$-th attacked coordinate is $(X_i,Y_i)$.\n\nFor all data, it is guaranteed that $1\\leq N\\leq 10^9$, $1\\leq M\\leq 10^5$, $0\\leq K\\leq 20$, $1\\leq X_i\\leq N$, $1\\leq Y_i\\leq M$. The cell $(1,1)$ is definitely not attacked by the opponent knight, and among the attacked cells there are no two cells with the same coordinate.", "outputFormat": "Output one line with one integer, the number of movement plans for the pawn to leave the board modulo $59393$.", "hint": "### Sample Explanation\n\nUse $\\uparrow$ to represent that the pawn moves up by one cell, use $\\rightarrow$ to represent that the pawn moves right by one cell, and use $\\nearrow$ to represent that the pawn moves up-right by one cell. This can simplify the description of the sample explanation.\n\nThe $24$ movement plans are:\n\n$(\\uparrow\\uparrow\\uparrow)$、$(\\uparrow\\uparrow\\nearrow)$、$(\\uparrow\\uparrow\\rightarrow\\uparrow)$、$(\\uparrow\\uparrow\\rightarrow\\nearrow)$、\n\n$(\\uparrow\\uparrow\\rightarrow\\rightarrow\\uparrow)$、$(\\uparrow\\uparrow\\rightarrow\\rightarrow\\nearrow)$、$(\\uparrow\\uparrow\\rightarrow\\rightarrow\\rightarrow)$、$(\\uparrow\\nearrow\\uparrow)$、\n\n$(\\uparrow\\nearrow\\nearrow)$、$(\\uparrow\\nearrow\\rightarrow\\uparrow)$、$(\\uparrow\\nearrow\\rightarrow\\nearrow)$、$(\\uparrow\\nearrow\\rightarrow\\rightarrow)$、\n\n$(\\rightarrow\\rightarrow\\rightarrow)$、$(\\rightarrow\\rightarrow\\nearrow)$、$(\\rightarrow\\rightarrow\\uparrow\\rightarrow)$、$(\\rightarrow\\rightarrow\\uparrow\\nearrow)$、\n\n$(\\rightarrow\\rightarrow\\uparrow\\uparrow\\rightarrow)$、$(\\rightarrow\\rightarrow\\uparrow\\uparrow\\nearrow)$、$(\\rightarrow\\rightarrow\\uparrow\\uparrow\\uparrow)$、$(\\rightarrow\\nearrow\\rightarrow)$、\n\n$(\\rightarrow\\nearrow\\nearrow)$、$(\\rightarrow\\nearrow\\uparrow\\rightarrow)$、$(\\rightarrow\\nearrow\\uparrow\\nearrow)$、$(\\rightarrow\\nearrow\\uparrow\\uparrow)$。\n\n### Copyright Information\n\nFrom THUPC (THU Programming Contest, Tsinghua University Programming Contest) 2019.\n\nResources such as editorial solutions can be found at <https://github.com/wangyurzee7/THUPC2019>.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUPC 2019] 过河卒二", "background": "", "description": "> 首先我们回忆一下经典难题过河卒问题：\n>\n> 棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向上、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点，因此称之为「马拦过河卒」。\n>\n> 棋盘用坐标表示，$A$ 点 $(1,1)$ 、$B$ 点 $(N,M)$ ，同样马的位置坐标是需要给出的。\n>\n> 现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。\n>\n> **请注意，上述背景内容与本题无关！**\n\nKiana 喜欢玩象棋，尤其是喜欢用象棋玩过河卒的游戏。在传统的过河卒问题中，Kiana 需要控制一个卒从起点走到终点，在路中避开一个对方的马的攻击，然后假装不会算并询问你从起点到终点的路径总数。\n\n在今天的过河卒二游戏中，Kiana 还是控制一个卒在一个 $N\\times M$ 的棋盘上移动，初始时卒位于左下方坐标为 $(1,1)$ 位置，但为了增加难度，Kiana 对游戏规则做出了一些修改。传统的过河卒每步只能向上或向右移动 $1$ 格，Kiana 规定自己的过河卒二还可以在一步中向右上方移动 $1$ 格，即如果当前卒位于坐标 $(x,y)$ 处，则下一步可以走到 $(x+1,y)$ 、$(x,y+1)$ 或 $(x+1,y+1)$ 中的任意一格里面去，同时 Kiana 认为，如果两种移动方案在某一步时卒移动的方向（右、上或右上）不同，则两种方案就是不同的，例如从 $(1,1)$ 先走到 $(1,2)$ 再走到 $(2,2)$ 、从 $(1,1)$ 先走到 $(2,1)$ 再走到 $(2,2)$ 和从 $(1,1)$ 直接走到 $(2,2)$ 是三种不同的移动方案。\n\n其次，过河卒二的终点不再是一个特定的位置，Kiana 规定卒可以从棋盘的上方或右方走出棋盘，此时就视为游戏成功。注意在走出棋盘时仍然有方向选择的不同，例如若过河卒位于 $(1,M)$ 处，则下一步它可以向右或者向右上用两种方式走出棋盘，若过河卒位于 $(N,M)$ 处，则下一步它可以向上、向右或者向右上用三种方式走出棋盘，以不同的方式走出棋盘仍然被算作是不同的移动方案。\n\n此外，对方马的攻击范围不再是有规律的几个位置，而是 Kiana 规定好的 $K$ 个特定坐标，并要求过河卒在移动的过程中不能走到这 $K$ 个坐标的任何一个上，在除这些坐标以外的位置上过河卒都可以按规则自由移动。\n\n现在 Kiana 想知道，过河卒二有多少种不同的移动方案可以走出棋盘，这个答案可能非常大，她只想知道方案数对 $59393$ 取模后的结果。由于她不会算，所以希望由你来告诉她。\n\n", "inputFormat": "第一行包含三个整数 $N$ 、$M$ 和 $K$ ，分别表示棋盘的坐标范围与对方马的攻击格子数（即 Kiana 规定的不能经过的坐标数）。\n\n接下来 $K$ 行，第 $i$ 行包含两个正整数 $X_i$ 和 $Y_i$ ，表示对方马的第 $i$ 个攻击坐标为 $(X_i,Y_i)$ 。\n\n对于所有数据，保证 $1\\leq N\\leq 10^9,1\\leq M\\leq 10^5,0\\leq K\\leq 20,1\\leq X_i\\leq N,1\\leq Y_i\\leq M$，$(1,1)$ 一定不会被对方马攻击，且被攻击的格子中不存在两个坐标相同的格子。", "outputFormat": "输出一行一个整数，表示过河卒走出棋盘的方案数对 $59393$ 取模后的结果。\n\n", "hint": "### 样例解释\n\n用 $\\uparrow$ 表示过河卒向上移动了一格，用 $\\rightarrow$ 表示过河卒向右移动了一格，用 $\\nearrow$ 表示过河卒向右上移动了一格，由此可以简化样例解释的表述。\n\n$24$ 种移动方案如下：\n\n$(\\uparrow\\uparrow\\uparrow)$、$(\\uparrow\\uparrow\\nearrow)$、$(\\uparrow\\uparrow\\rightarrow\\uparrow)$、$(\\uparrow\\uparrow\\rightarrow\\nearrow)$、\n\n$(\\uparrow\\uparrow\\rightarrow\\rightarrow\\uparrow)$、$(\\uparrow\\uparrow\\rightarrow\\rightarrow\\nearrow)$、$(\\uparrow\\uparrow\\rightarrow\\rightarrow\\rightarrow)$、$(\\uparrow\\nearrow\\uparrow)$、\n\n$(\\uparrow\\nearrow\\nearrow)$、$(\\uparrow\\nearrow\\rightarrow\\uparrow)$、$(\\uparrow\\nearrow\\rightarrow\\nearrow)$、$(\\uparrow\\nearrow\\rightarrow\\rightarrow)$、\n\n$(\\rightarrow\\rightarrow\\rightarrow)$、$(\\rightarrow\\rightarrow\\nearrow)$、$(\\rightarrow\\rightarrow\\uparrow\\rightarrow)$、$(\\rightarrow\\rightarrow\\uparrow\\nearrow)$、\n\n$(\\rightarrow\\rightarrow\\uparrow\\uparrow\\rightarrow)$、$(\\rightarrow\\rightarrow\\uparrow\\uparrow\\nearrow)$、$(\\rightarrow\\rightarrow\\uparrow\\uparrow\\uparrow)$、$(\\rightarrow\\nearrow\\rightarrow)$、\n\n$(\\rightarrow\\nearrow\\nearrow)$、$(\\rightarrow\\nearrow\\uparrow\\rightarrow)$、$(\\rightarrow\\nearrow\\uparrow\\nearrow)$、$(\\rightarrow\\nearrow\\uparrow\\uparrow)$。\n\n### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN"}}}
{"pid": "P5377", "type": "P", "difficulty": 5, "samples": [["2\n3\n4", "2\n4\n8"]], "limits": {"time": [1000], "memory": [512000]}, "tags": ["2019", "平面图欧拉公式", "组合数学", "排列组合", "THUPC"], "title": "[THUPC 2019] 鸽鸽的分割", "background": "", "description": "牛牛有一块蛋糕，他想把蛋糕分给小朋友们。蛋糕一开始是圆形的，牛牛会在圆周上选择 $n$ 个不重合的点，将这几个点两两用线段连接。这些线段将会把蛋糕分成若干块。\n\n现在，牛牛想知道，蛋糕**最多**会被分成多少块，请你告诉他答案。", "inputFormat": "输入包含至多 $20$ 行，每行一个整数 $n$，含义见「题目描述」。保证 $0\\le n \\le 64$。", "outputFormat": "依次回答牛牛的每个问题，对于每个问题，输出一行，包含一个整数表示答案。", "hint": "### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/pic/58696.png)\n\n##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN", "translations": {"en": {"title": "[THUPC 2019] Gege's Partitioning.", "background": "", "description": "Niuniu has a cake, and he wants to share it with children. The cake is initially a circle. Niuniu will choose $n$ distinct points on the circumference and connect every pair of these points with a line segment. These segments will divide the cake into several pieces.\n\nNow, Niuniu wants to know the **maximum** number of pieces the cake can be divided into. Please output the answer.", "inputFormat": "The input contains up to $20$ lines. Each line contains an integer $n$, as described in the “Description”. It is guaranteed that $0 \\le n \\le 64$.", "outputFormat": "Answer each query in order. For each query, output one line containing an integer representing the answer.", "hint": "### Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/pic/58696.png)\n\n##### Copyright Information\n\nFrom THUPC (THU Programming Contest, Tsinghua University Programming Contest) 2019.\n\nResources such as solutions can be found at <https://github.com/wangyurzee7/THUPC2019>.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUPC 2019] 鸽鸽的分割", "background": "", "description": "牛牛有一块蛋糕，他想把蛋糕分给小朋友们。蛋糕一开始是圆形的，牛牛会在圆周上选择 $n$ 个不重合的点，将这几个点两两用线段连接。这些线段将会把蛋糕分成若干块。\n\n现在，牛牛想知道，蛋糕**最多**会被分成多少块，请你告诉他答案。", "inputFormat": "输入包含至多 $20$ 行，每行一个整数 $n$，含义见「题目描述」。保证 $0\\le n \\le 64$。", "outputFormat": "依次回答牛牛的每个问题，对于每个问题，输出一行，包含一个整数表示答案。", "hint": "### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/pic/58696.png)\n\n##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN"}}}
{"pid": "P5378", "type": "P", "difficulty": 7, "samples": [["1\n8\n0 0 0\n0 0 1\n0 1 0\n0 1 1\n1 0 0\n1 0 1\n1 1 0\n1 1 1\n8\n2 0 0\n2 0 1\n2 1 0\n2 1 1\n3 0 0\n3 0 1\n3 1 0\n3 1 1\n-1 0 0", "1.0000000000"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2019", "THUPC"], "title": "[THUPC 2019] 能量波", "background": "", "description": "> 有两个超级英雄在宇宙中战斗。英雄 A 为了击败对手英雄 B，使出了他的绝招，发出了一记能量光波。\n>\n> 英雄 B 有一些体力值，如果英雄 A 的能量光波对英雄 B 的伤害足够大，英雄 B 就会被击倒。否则英雄 A 就会因为耗尽能量而被英雄 B 抓住破绽，从而反而被英雄 B 击倒。所以英雄 A 迫切想知道自己的能量光波到底能够对英雄 B 造成多少伤害。\n\n为了简化问题，英雄 B 可以被描述为空间中的多个凸多面体拼成的物体。这些凸多面体可能有重合的部分，重合部分作为英雄 B 的身体只会被计算一次。\n\n英雄 A 发出的能量光波也可以被描述为空间中的另外一个凸多面体，这个光波在空间中每秒均匀移动一个向量 $\\vec{v} = (v_x,v_y,v_z)$。能量光波可以穿过任何物体，并且在穿越的过程中对对方造成伤害。\n\n在时刻 $t$, 假设英雄 A 的能量光波和英雄 B 的身体的交的体积为 $f(t) = V$，那么在这一瞬间，能量光波造成的瞬时伤害速率就恰好是 $V$。而所有时刻的总计伤害就可以被表示为\n\n$$\\int_{0}^{\\infty} f(t) \\mathrm{d}t$$\n\n英雄 A 想要知道自己的能量光波对英雄 B 的身体造成了多大的总计伤害。", "inputFormat": "第 $1$ 行一个正整数 $m_B$，表示英雄 B 的身体有多少个凸多面体组成。\n\n接下来有 $m_B$ 个输入块，每块表示英雄 B 的身体的一个组成部分。\n\n每个输入块开头第一行为一个正整数 $n$，表示这个凸多面体的顶点的个数，\n\n接下来 $n$ 行每行一个三元组，其中第 $i$ 个 $(x_i,y_i,z_i)$ 表示第 $i$ 个点的坐标。\n\n接下来一行一个正整数 $n_A$，表示英雄 A 的能量光波的对应凸多面体的顶点数，\n\n接下来 $n_A$ 行每行一个三元组，其中第 $i$ 个 $(x_i,y_i,z_i)$ 表示第 $i$ 个点的坐标。\n\n再接下来一行一个三元组 $(v_x,v_y,v_z)$，表示英雄 A 的能量光波的移动速度。\n\n我们保证 $1 \\le m_B \\le 4,4\\le n,n_A\\le 8$ ，所有输入的点的坐标都是 $[-100,100]$ 内的整数。并且所有速度向量的分量都是 $[-10,10]$ 内的实数。所有凸多面体都是不退化的 （意思是这个凸多面体的体积非 $0$）。\n\n输入中可能会出现四点共面或者三点共线的情况。\n\n我们保证在第 $0$ 秒能量光波和英雄 B 是不相交的。并且在第 $10^4$ 秒之后交集的体积一直是 $0$。", "outputFormat": "一行输出一个实数，表示总计伤害的值。\n\n输出与标准答案的绝对误差或相对误差小于 $10^{-6}$ 就会被算作正确。", "hint": "##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN", "translations": {"en": {"title": "[THUPC 2019] Energy Wave", "background": "", "description": "> Two superheroes are fighting in the universe. To defeat his opponent Hero B, Hero A uses his ultimate move and fires an energy wave.\n>\n> Hero B has some stamina. If the damage from Hero A’s energy wave is large enough, Hero B will be knocked down. Otherwise, Hero A will be caught off guard by Hero B after exhausting his energy, and Hero A will be knocked down instead. So Hero A urgently wants to know how much damage his energy wave can deal to Hero B.\n\nTo simplify the problem, Hero B can be described as an object made up of multiple convex polyhedra in space. These convex polyhedra may overlap. The overlapping part, as part of Hero B’s body, is counted only once.\n\nThe energy wave fired by Hero A can also be described as another convex polyhedron in space. This wave moves uniformly by a vector $\\vec{v} = (v_x,v_y,v_z)$ per second. The energy wave can pass through any object, and deals damage while passing through it.\n\nAt time $t$, suppose the intersection volume of Hero A’s energy wave and Hero B’s body is $f(t) = V$. Then at that instant, the instantaneous damage rate caused by the energy wave is exactly $V$. The total damage over all time can be written as\n\n$$\\int_{0}^{\\infty} f(t) \\mathrm{d}t$$\n\nHero A wants to know the total damage his energy wave deals to Hero B’s body.", "inputFormat": "The first line contains a positive integer $m_B$, indicating how many convex polyhedra make up Hero B’s body.\n\nThen there are $m_B$ input blocks, each describing one component of Hero B’s body.\n\nThe first line of each block contains a positive integer $n$, indicating the number of vertices of this convex polyhedron.\n\nThe next $n$ lines each contain a triple. The $i$-th triple $(x_i,y_i,z_i)$ gives the coordinates of the $i$-th point.\n\nThen one line contains a positive integer $n_A$, indicating the number of vertices of the convex polyhedron corresponding to Hero A’s energy wave.\n\nThe next $n_A$ lines each contain a triple. The $i$-th triple $(x_i,y_i,z_i)$ gives the coordinates of the $i$-th point.\n\nThen one line contains a triple $(v_x,v_y,v_z)$, indicating the moving velocity of Hero A’s energy wave.\n\nIt is guaranteed that $1 \\le m_B \\le 4$, $4 \\le n,n_A \\le 8$. All input point coordinates are integers in $[-100,100]$. Each component of the velocity vector is a real number in $[-10,10]$. All convex polyhedra are non-degenerate (meaning the volume of the polyhedron is not $0$).\n\nIn the input, it may happen that four points are coplanar or three points are collinear.\n\nIt is guaranteed that at time $0$, the energy wave and Hero B do not intersect. Also, after $10^4$ seconds, the intersection volume is always $0$.", "outputFormat": "Output one real number in one line, representing the value of the total damage.\n\nYour answer will be considered correct if its absolute error or relative error is less than $10^{-6}$.", "hint": "##### Copyright Information\n\nFrom THUPC (THU Programming Contest, Tsinghua University Programming Contest) 2019.\n\nSolutions and other resources can be found at <https://github.com/wangyurzee7/THUPC2019>.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUPC 2019] 能量波", "background": "", "description": "> 有两个超级英雄在宇宙中战斗。英雄 A 为了击败对手英雄 B，使出了他的绝招，发出了一记能量光波。\n>\n> 英雄 B 有一些体力值，如果英雄 A 的能量光波对英雄 B 的伤害足够大，英雄 B 就会被击倒。否则英雄 A 就会因为耗尽能量而被英雄 B 抓住破绽，从而反而被英雄 B 击倒。所以英雄 A 迫切想知道自己的能量光波到底能够对英雄 B 造成多少伤害。\n\n为了简化问题，英雄 B 可以被描述为空间中的多个凸多面体拼成的物体。这些凸多面体可能有重合的部分，重合部分作为英雄 B 的身体只会被计算一次。\n\n英雄 A 发出的能量光波也可以被描述为空间中的另外一个凸多面体，这个光波在空间中每秒均匀移动一个向量 $\\vec{v} = (v_x,v_y,v_z)$。能量光波可以穿过任何物体，并且在穿越的过程中对对方造成伤害。\n\n在时刻 $t$, 假设英雄 A 的能量光波和英雄 B 的身体的交的体积为 $f(t) = V$，那么在这一瞬间，能量光波造成的瞬时伤害速率就恰好是 $V$。而所有时刻的总计伤害就可以被表示为\n\n$$\\int_{0}^{\\infty} f(t) \\mathrm{d}t$$\n\n英雄 A 想要知道自己的能量光波对英雄 B 的身体造成了多大的总计伤害。", "inputFormat": "第 $1$ 行一个正整数 $m_B$，表示英雄 B 的身体有多少个凸多面体组成。\n\n接下来有 $m_B$ 个输入块，每块表示英雄 B 的身体的一个组成部分。\n\n每个输入块开头第一行为一个正整数 $n$，表示这个凸多面体的顶点的个数，\n\n接下来 $n$ 行每行一个三元组，其中第 $i$ 个 $(x_i,y_i,z_i)$ 表示第 $i$ 个点的坐标。\n\n接下来一行一个正整数 $n_A$，表示英雄 A 的能量光波的对应凸多面体的顶点数，\n\n接下来 $n_A$ 行每行一个三元组，其中第 $i$ 个 $(x_i,y_i,z_i)$ 表示第 $i$ 个点的坐标。\n\n再接下来一行一个三元组 $(v_x,v_y,v_z)$，表示英雄 A 的能量光波的移动速度。\n\n我们保证 $1 \\le m_B \\le 4,4\\le n,n_A\\le 8$ ，所有输入的点的坐标都是 $[-100,100]$ 内的整数。并且所有速度向量的分量都是 $[-10,10]$ 内的实数。所有凸多面体都是不退化的 （意思是这个凸多面体的体积非 $0$）。\n\n输入中可能会出现四点共面或者三点共线的情况。\n\n我们保证在第 $0$ 秒能量光波和英雄 B 是不相交的。并且在第 $10^4$ 秒之后交集的体积一直是 $0$。", "outputFormat": "一行输出一个实数，表示总计伤害的值。\n\n输出与标准答案的绝对误差或相对误差小于 $10^{-6}$ 就会被算作正确。", "hint": "##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN"}}}
{"pid": "P5379", "type": "P", "difficulty": 7, "samples": [["4 2\n0 1 0 1", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "THUPC"], "title": "[THUPC 2019] 令人难以忘记的题目名称", "background": "", "description": "现在有一个长度为 $N$ 的整数序列 $S$（下标从 $0$ 开始），Alice 和 Bob 在这个序列上博弈。\n\n游戏按轮进行，每一轮中：\n\n* Alice 给出一个长度为 $N$ 的正整数序列 $T$\n* Bob 看到 Alice 给出的 $T$，然后选择 $[0, N-1]$ 里的一个整数 $x$\n* 之后我们把 $S$ 转化为 $S'$，规则如下：\n\n$${S'}_{i} = S_{i} + T_{(i+x)\\bmod N}$$\n\n* 以 $S'$ 作为新的 $S$，结束这一轮。\n\n如果某一轮结束后，$S$ 中每个数都是一个给定质数 $P$ 的倍数，那么 Alice 胜利。\n\n给定 $N$ 和初始序列 $S$，请问：Alice 是否能在有限步必胜，如果答案为是，最快可以在几轮内保证胜利。", "inputFormat": "第一行两个非负整数 $N,P$，保证 $P$ 是一个质数。\n\n接下来一行 $N$ 个空格隔开的整数，描述初始序列 $S$（$0\\le S_i \\le 10^9$）。\n\n保证 $N\\le 3\\times 10^5$，$P\\le 200$。", "outputFormat": "输出一个整数，如果 Alice 不能在有限步必胜，输出 $-1$，否则输出一个整数 $x$ 表示 Alice 最快能在几轮内胜利。", "hint": "### 样例解释\n\n一种可能的游戏情形是：\n\n* 第一轮 $T=[1, 0, 1, 0]$，$x=0$，转化后的  $S'=[1,1,1,1]$。\n* 第二轮 $T=[1,1,1,1]$，无论 $x$ 取什么，转化后的 $S'=[2,2,2,2]$。\n\n可以证明 $2$ 轮是最优的。\n\n##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN", "translations": {"en": {"title": "[THUPC 2019] An Unforgettable Problem Title", "background": "", "description": "Now there is an integer sequence $S$ of length $N$ (indexed from $0$). Alice and Bob play a game on this sequence.\n\nThe game proceeds in rounds. In each round:\n\n* Alice provides a positive integer sequence $T$ of length $N$.\n* Bob sees the $T$ given by Alice, then chooses an integer $x$ in $[0, N-1]$.\n* Then we transform $S$ into $S'$ by the following rule:\n\n$${S'}_{i} = S_{i} + T_{(i+x)\\bmod N}$$\n\n* Take $S'$ as the new $S$, and this round ends.\n\nIf after some round ends, every number in $S$ is a multiple of a given prime $P$, then Alice wins.\n\nGiven $N$ and the initial sequence $S$, determine whether Alice can guarantee a win in finitely many steps. If yes, what is the minimum number of rounds in which she can guarantee a win.", "inputFormat": "The first line contains two non-negative integers $N, P$, and $P$ is guaranteed to be a prime.\n\nThe next line contains $N$ integers separated by spaces, describing the initial sequence $S$ ($0\\le S_i \\le 10^9$).\n\nIt is guaranteed that $N\\le 3\\times 10^5$ and $P\\le 200$.", "outputFormat": "Output one integer. If Alice cannot guarantee a win in finitely many steps, output $-1$. Otherwise, output an integer $x$ indicating the minimum number of rounds in which Alice can win.", "hint": "### Sample Explanation\n\nOne possible game process is:\n\n* Round 1: $T=[1, 0, 1, 0]$, $x=0$, and the transformed sequence is $S'=[1,1,1,1]$.\n* Round 2: $T=[1,1,1,1]$. No matter what $x$ is, the transformed sequence is $S'=[2,2,2,2]$.\n\nIt can be proved that $2$ rounds is optimal.\n\n##### Copyright Information\n\nFrom THUPC (THU Programming Contest, Tsinghua University Programming Contest) 2019.\n\nResources such as solutions can be found at <https://github.com/wangyurzee7/THUPC2019>.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUPC 2019] 令人难以忘记的题目名称", "background": "", "description": "现在有一个长度为 $N$ 的整数序列 $S$（下标从 $0$ 开始），Alice 和 Bob 在这个序列上博弈。\n\n游戏按轮进行，每一轮中：\n\n* Alice 给出一个长度为 $N$ 的正整数序列 $T$\n* Bob 看到 Alice 给出的 $T$，然后选择 $[0, N-1]$ 里的一个整数 $x$\n* 之后我们把 $S$ 转化为 $S'$，规则如下：\n\n$${S'}_{i} = S_{i} + T_{(i+x)\\bmod N}$$\n\n* 以 $S'$ 作为新的 $S$，结束这一轮。\n\n如果某一轮结束后，$S$ 中每个数都是一个给定质数 $P$ 的倍数，那么 Alice 胜利。\n\n给定 $N$ 和初始序列 $S$，请问：Alice 是否能在有限步必胜，如果答案为是，最快可以在几轮内保证胜利。", "inputFormat": "第一行两个非负整数 $N,P$，保证 $P$ 是一个质数。\n\n接下来一行 $N$ 个空格隔开的整数，描述初始序列 $S$（$0\\le S_i \\le 10^9$）。\n\n保证 $N\\le 3\\times 10^5$，$P\\le 200$。", "outputFormat": "输出一个整数，如果 Alice 不能在有限步必胜，输出 $-1$，否则输出一个整数 $x$ 表示 Alice 最快能在几轮内胜利。", "hint": "### 样例解释\n\n一种可能的游戏情形是：\n\n* 第一轮 $T=[1, 0, 1, 0]$，$x=0$，转化后的  $S'=[1,1,1,1]$。\n* 第二轮 $T=[1,1,1,1]$，无论 $x$ 取什么，转化后的 $S'=[2,2,2,2]$。\n\n可以证明 $2$ 轮是最优的。\n\n##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN"}}}
{"pid": "P5380", "type": "P", "difficulty": 6, "samples": [["18\n0 0 7 0\n9 0 8 0\n0 1 1 3\n0 2 2 0\n0 3 1 2\n0 4 0 3\n9 4 8 4\n3 2 2 3\n7 0 4 2\n7 0 5 3\n9 2 7 4\n2 0 4 3\n9 1 8 3\n4 3 6 6\n7 4 9 2\n8 4 9 4\n6 6 9 4\n9 8 8 8", "Invalid command\nInvalid command\nInvalid command\nInvalid command\nred guard;NA;no;no\nInvalid command\nblue captain;NA;no;no\nred soldier;NA;no;no\nInvalid command\nInvalid command\nblue elephant;NA;no;no\nred duck;NA;no;no\nblue horse;NA;no;no\nred duck;blue soldier;no;no\nInvalid command\nblue captain;NA;yes;no\nred duck;blue captain;no;yes\nInvalid command"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000]}, "tags": ["模拟", "2019", "THUPC"], "title": "[THUPC 2019] 鸭棋", "background": "", "description": "#### 题目背景\n\n鸭棋是一种风靡鸭子界的棋类游戏。事实上，它与中国象棋有一些相似之处，但规则不尽相同。在这里，我们将为你介绍鸭棋的规则。\n\n**同时，我们下发了一个模拟鸭棋规则的玩具，你可以结合这个玩具理解题目**（也可以在 AK 后与你的队友进行对弈）。详情请见「玩具使用说明」。\n\n鸭棋在一个 $10\\times 9$（$10$ 行 $9$ 列）的网格棋盘上进行，网格上的每个格点都可以有棋子停留。对弈双方一方执红（`red`）棋、另一方执蓝（`blue`）棋，双方轮流执行操作，轮到一位玩家操作时，他必须选择一枚自己的棋子，并按照规则进行一步移动。\n\n鸭棋发明者鸭子德规定一局鸭棋由红方执先手，并设计了初始棋盘布局如下：\n\n![initial_board.png](https://cdn.luogu.com.cn/upload/pic/58700.png)\n\n##### 棋子类型与走子规则\n\n棋子分为 $7$ 类，下面介绍了它们的名字以及它们的移动规则。介绍移动规则时，我们默认棋子所处位置为 $\\left( x,y\\right)$（表示第 $x$ 行的第 $y$ 列，下同），并列出它可以到达的位置：\n\n* **王**（`captain`)：可达的位置共 $4$ 个，包括 $\\left(x\\pm 1,y\\right)$ 及 $\\left(x,y\\pm 1\\right)$。\n* **士**（`guard`）：可达的位置共 $4$ 个，包括 $\\left(x\\pm 1,y\\pm 1\\right)$ 及 $\\left(x\\pm 1,y\\mp 1\\right)$。\n* **象**（`elephant`）：可达的位置至多 $4$ 个，对于任意 $s_x,s_y\\in \\left\\{ 1,-1\\right\\}$，分别有：\n    * 如果位置 $\\left(x+s_x\\times 1 ,y+ s_y\\times 1\\right)$ 上**无任意一方**的棋子停留，则 $\\left( x+s_x \\times 2,y+s_y \\times 2\\right)$ 为一个可达的位置。\n* **马**（`horse`）：可达的位置至多 $8$ 个，对于任意 $s_x,s_y\\in \\left\\{ 1,-1\\right\\}$，分别有：\n    * 如果位置 $\\left(x+s_x\\times 1 ,y\\right)$ 上**无任意一方**的棋子停留，则 $\\left( x+s_x \\times 2,y+s_y \\times 1\\right)$ 为一个可达的位置。\n    * 如果位置 $\\left(x ,y+ s_y \\times 1 \\right)$ 上**无任意一方**的棋子停留，则 $\\left( x+s_x \\times 1,y+s_y \\times 2\\right)$ 为一个可达的位置。\n* **车**（`car`）：可在**不跨越其他棋子**的前提下，到达同行或同列的所有其他位置。\n* **鸭**（`duck`）：可达的位置至多 $8$ 个，对于任意 $s_x,s_y\\in \\left\\{ 1,-1\\right\\}$，分别有：\n    * 如果位置 $\\left(x+s_x\\times 2 ,y+s_y \\times 1\\right),\\left(x+s_x\\times 1 ,y\\right)$ 上均**无任意一方**的棋子停留，则 $\\left( x+s_x \\times 3,y+s_y \\times 2\\right)$ 为一个可达的位置。\n    * 如果位置 $\\left(x+s_x \\times 1 ,y+ s_y \\times 2 \\right),\\left(x ,y+ s_y \\times 1 \\right)$ 上均**无任意一方**的棋子停留，则 $\\left( x+s_x \\times 2,y+s_y \\times 3\\right)$ 为一个可达的位置。\n* **兵**（`soldier`）：可达的位置共 $8$ 个，包括 $\\left(x\\pm 1,y\\right)$ 及 $\\left(x,y\\pm 1\\right)$ 及 $\\left(x\\pm 1,y\\pm 1\\right)$ 及 $\\left(x\\pm 1,y\\mp 1\\right)$。\n\n**除上面描述的规则之外，棋子移动还有如下额外规则：**\n\n* 不能将棋子移动到棋盘外的某个位置。\n* 玩家不能将棋子移动到**已经停留了己方棋子**的位置。\n* 如果玩家将棋子移动到了一个**已经停留了对方棋子**的位置，那么原本停留在该位置上的这个**对方棋子**将被移出游戏。\n\n##### 胜利条件与将军局面\n\n玩家在这个游戏中的目标是将对方的**王**移出游戏。一旦一方的**王**被移出游戏，则另一方立即宣告胜利。\n\n对于一个棋盘的状态，如果存在一方有一步合法的操作能够将另一方的**王**移出游戏，则我们说当前局面是一个**将军**的局面。需要友情提示的是，根据定义，将军局面的形成包括（但不限于）如下这些可能：\n\n1. 一方将一枚棋子移动到可以攻击对方**王**的位置\n\n2. 在己方**王**受到威胁时不采取措施躲避\n\n3. 主动将**王**移动至会受到攻击的位置\n\n**除此之外，需要特别说明的是，游戏结束后，由于双方不可再操作，因此不可能出现将军局面，即便此时另一方王处于被「攻击」的位置。**\n\n#### 题目描述\n\n今年的 IDCC（International Duck Chess Competition，国际鸭棋大赛）正在如火如荼地进行着。你观摩了一场精彩绝伦的比赛，但你对对弈过程的记忆已经模糊不清了，只有系统留下的他们的**操作序列**，序列中的每个**操作**为当前操作者试图移动某个位置的棋子至另一个位置。你希望用这个序列，来复现出整局棋局的对弈过程。即，对于每步操作，你需要**首先判其是否合法**，若合法，则**进一步求出**：\n\n1. 这步操作移动了哪个棋子。\n2. 这步操作后，是否存在棋子被移出游戏，如有则还需求出被移出游戏的棋子。\n3. 这步操作后，是否形成将军局面。\n4. 这步操作后，游戏是否结束。\n\n可能包含的不合法情况如下：\n\n* 此步移动的初始位置无己方棋子停留。\n* 此步移动的初始位置有己方棋子停留，但移动不符合规则。\n* 游戏已经结束。\n\n序列中的不合法操作是需要被忽略的。比如，如果轮到红方移动，此时序列中的当前操作恰好是不合法的，则这个操作将被忽略，序列中的下一步操作将成为红方这步的操作（如仍不合法则继续忽略，直至出现合法的操作）。", "inputFormat": "第一行一个非负整数 $Q$，表示操作序列的长度。接下来依次描述每个操作。\n\n接下来 $Q$ 行，每行 $4$ 个整数 $x_s, y_s, x_t, y_t$（$0\\leq x_s,x_t < 10$，$0\\leq y_s,y_t < 9$），描述一个欲将 $\\left(x_s,y_s\\right)$ 处棋子移动到 $\\left(x_t,y_t\\right)$ 的操作。在这里，我们规定左下角（即红方**车**摆放的位置，图见「题目背景」）为 $\\left(0,0\\right)$。\n\n保证 $Q\\leq 1000$。", "outputFormat": "输出 $Q$ 行，对于每个操作依次输出复现结果。每行输出一个操作的结果：\n\n* 如果该操作为不合法操作，则请输出 `Invalid command`。\n* 如果为合法操作，则依次回答「题目描述」中的问题 $1\\sim 4$：\n    * 被移动的棋子用 `[颜色] [类型]`（注意中间包含空格）来描述，请使用它们的英文名称（见「题目背景」）。如，红象为 `red elephant`，蓝王为 `blue captain`。\n    * 被移出游戏的棋子的描述方式与上面类似。特别地，**如果无棋子被移出游戏，则该问题的答案为 `NA`**。\n    * 用 `yes`、`no` 分别表示形成、不形成将军局面。\n    * 用 `yes`、`no` 分别表示游戏结束、游戏不结束。\n    * 用 `;`（分号）将所有问题的答案隔开。\n    * 比如，四个问题的答案分别为：被移动的棋子是蓝车，无棋子被移出游戏，形成将军局面，游戏未结束。则该行应输出 `blue car;NA;yes;no`。", "hint": "##### 玩具使用说明\n\n你可以在玩具所在目录下执行如下命令来运行玩具（链接: <https://pan.baidu.com/s/12MJGgZB9zKcE3qgRbRozGw> 提取码: 4d5c）：\n\n```\n./duckchess\n```\n\n特别地，在**初次运行前**，你需要执行如下命令为它添加运行权限：\n\n\n```\nchmod +x duckchess\n```\n\n##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN", "translations": {"en": {"title": "[THUPC 2019] Duck Chess.", "background": "", "description": "#### Background\n\nDuck Chess is a board game that is popular among ducks. In fact, it is somewhat similar to Chinese Chess, but the rules are not exactly the same. Here, we will introduce the rules of Duck Chess.\n\n**At the same time, we provide a toy that simulates the rules of Duck Chess. You can use this toy to better understand the problem** (you may also play with your teammates after getting AK). For details, see “Toy Instructions”.\n\nDuck Chess is played on a $10\\times 9$ grid board ($10$ rows and $9$ columns). Each grid point can hold a piece. One player uses the red (`red`) pieces, and the other uses the blue (`blue`) pieces. The two players take turns to make moves. When it is a player’s turn, they must choose one of their own pieces and make exactly one move according to the rules.\n\nThe inventor Duck De规定 (De Guiding, “规定”) specified that red moves first, and designed the initial board layout as follows:\n\n![initial_board.png](https://cdn.luogu.com.cn/upload/pic/58700.png)\n\n##### Piece Types and Moving Rules\n\nThere are $7$ types of pieces. Below are their names and moving rules. When describing moving rules, we assume the piece is at position $\\left(x,y\\right)$ (meaning row $x$, column $y$, same below), and list the positions it can reach:\n\n* **Captain** (`captain`): It can reach $4$ positions, including $\\left(x\\pm 1,y\\right)$ and $\\left(x,y\\pm 1\\right)$.\n* **Guard** (`guard`): It can reach $4$ positions, including $\\left(x\\pm 1,y\\pm 1\\right)$ and $\\left(x\\pm 1,y\\mp 1\\right)$.\n* **Elephant** (`elephant`): It can reach at most $4$ positions. For any $s_x,s_y\\in \\left\\{ 1,-1\\right\\}$:\n    * If there is **no piece of either side** on $\\left(x+s_x\\times 1 ,y+ s_y\\times 1\\right)$, then $\\left( x+s_x \\times 2,y+s_y \\times 2\\right)$ is a reachable position.\n* **Horse** (`horse`): It can reach at most $8$ positions. For any $s_x,s_y\\in \\left\\{ 1,-1\\right\\}$:\n    * If there is **no piece of either side** on $\\left(x+s_x\\times 1 ,y\\right)$, then $\\left( x+s_x \\times 2,y+s_y \\times 1\\right)$ is a reachable position.\n    * If there is **no piece of either side** on $\\left(x ,y+ s_y \\times 1 \\right)$, then $\\left( x+s_x \\times 1,y+s_y \\times 2\\right)$ is a reachable position.\n* **Car** (`car`): Without **jumping over other pieces**, it can reach all other positions in the same row or the same column.\n* **Duck** (`duck`): It can reach at most $8$ positions. For any $s_x,s_y\\in \\left\\{ 1,-1\\right\\}$:\n    * If both $\\left(x+s_x\\times 2 ,y+s_y \\times 1\\right)$ and $\\left(x+s_x\\times 1 ,y\\right)$ have **no piece of either side**, then $\\left( x+s_x \\times 3,y+s_y \\times 2\\right)$ is a reachable position.\n    * If both $\\left(x+s_x \\times 1 ,y+ s_y \\times 2 \\right)$ and $\\left(x ,y+ s_y \\times 1 \\right)$ have **no piece of either side**, then $\\left( x+s_x \\times 2,y+s_y \\times 3\\right)$ is a reachable position.\n* **Soldier** (`soldier`): It can reach $8$ positions, including $\\left(x\\pm 1,y\\right)$ and $\\left(x,y\\pm 1\\right)$ and $\\left(x\\pm 1,y\\pm 1\\right)$ and $\\left(x\\pm 1,y\\mp 1\\right)$.\n\n**In addition to the rules described above, piece movement also follows these extra rules:**\n\n* You cannot move a piece to a position outside the board.\n* A player cannot move a piece to a position that is **already occupied by one of their own pieces**.\n* If a player moves a piece to a position **occupied by an opponent’s piece**, then that **opponent’s piece** is removed from the game.\n\n##### Winning Condition and “Check” Positions\n\nThe goal of the game is to remove the opponent’s **captain** from the game. Once a side’s **captain** is removed, the other side wins immediately.\n\nFor a board state, if one side has a legal move that can remove the other side’s **captain** from the game in one step, then we say the current position is a **check** position. As a friendly reminder, by definition, forming a check position includes (but is not limited to) the following possibilities:\n\n1. Moving a piece to a position where it can attack the opponent’s **captain**.\n\n2. Not taking any action to avoid threats when one’s own **captain** is under threat.\n\n3. Actively moving the **captain** to a position that will be attacked.\n\n**In addition, note that after the game ends, since neither side can make any further moves, it is impossible for a check position to exist, even if at that time the other side’s captain is in an “attacked” position.**\n\n#### Problem Description\n\nThis year’s IDCC (International Duck Chess Competition) is in full swing. You watched an amazing match, but your memory of the game process has become blurry. Only the system’s **operation sequence** is left. Each **operation** in the sequence is the current player’s attempt to move a piece from one position to another. You want to use this sequence to reproduce the entire game process. That is, for each operation, you need to **first determine whether it is legal**. If it is legal, then you need to **further determine**:\n\n1. Which piece is moved by this operation.\n2. After this operation, whether any piece is removed from the game. If so, also determine which piece is removed.\n3. After this operation, whether a check position is formed.\n4. After this operation, whether the game ends.\n\nPossible illegal situations include:\n\n* There is no piece of the current player at the starting position of this move.\n* There is a piece of the current player at the starting position, but the move does not follow the rules.\n* The game has already ended.\n\nIllegal operations in the sequence should be ignored. For example, if it is red’s turn to move and the current operation in the sequence is illegal, then this operation is ignored, and the next operation in the sequence becomes red’s operation for this turn (if it is still illegal, keep ignoring, until a legal operation appears).", "inputFormat": "The first line contains a non-negative integer $Q$, indicating the length of the operation sequence. Next, each operation is described in order.\n\nIn the next $Q$ lines, each line contains $4$ integers $x_s, y_s, x_t, y_t$ ($0\\leq x_s,x_t < 10$, $0\\leq y_s,y_t < 9$), describing an operation that attempts to move the piece at $\\left(x_s,y_s\\right)$ to $\\left(x_t,y_t\\right)$. Here, we define the bottom-left corner (i.e., the position where red’s **car** is placed, see the figure in “Background”) as $\\left(0,0\\right)$.\n\nIt is guaranteed that $Q\\leq 1000$.", "outputFormat": "Output $Q$ lines. For each operation, output the reproduction result in order. Each line outputs the result of one operation:\n\n* If the operation is illegal, output `Invalid command`.\n* If it is legal, answer questions $1\\sim 4$ in “Problem Description” in order:\n    * Describe the moved piece as `[color] [type]` (note there is a space), using their English names (see “Background”). For example, a red elephant is `red elephant`, and a blue captain is `blue captain`.\n    * The piece removed from the game is described in the same way as above. In particular, **if no piece is removed, the answer to this question is `NA`**.\n    * Use `yes` and `no` to indicate whether a check position is formed.\n    * Use `yes` and `no` to indicate whether the game ends.\n    * Use `;` (semicolon) to separate the answers to all questions.\n    * For example, if the four answers are: the moved piece is a blue car, no piece is removed, a check position is formed, and the game does not end, then the line should be `blue car;NA;yes;no`.", "hint": "##### Toy Instructions\n\nYou can run the toy by executing the following command in the directory where the toy is located (link: <https://pan.baidu.com/s/12MJGgZB9zKcE3qgRbRozGw> extract code: 4d5c):\n\n```\n./duckchess\n```\n\nIn particular, **before the first run**, you need to execute the following command to add execute permission:\n\n```\nchmod +x duckchess\n```\n\n##### Copyright Information\n\nFrom THUPC (THU Programming Contest) 2019.\n\nResources such as editorials can be found at <https://github.com/wangyurzee7/THUPC2019>.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUPC 2019] 鸭棋", "background": "", "description": "#### 题目背景\n\n鸭棋是一种风靡鸭子界的棋类游戏。事实上，它与中国象棋有一些相似之处，但规则不尽相同。在这里，我们将为你介绍鸭棋的规则。\n\n**同时，我们下发了一个模拟鸭棋规则的玩具，你可以结合这个玩具理解题目**（也可以在 AK 后与你的队友进行对弈）。详情请见「玩具使用说明」。\n\n鸭棋在一个 $10\\times 9$（$10$ 行 $9$ 列）的网格棋盘上进行，网格上的每个格点都可以有棋子停留。对弈双方一方执红（`red`）棋、另一方执蓝（`blue`）棋，双方轮流执行操作，轮到一位玩家操作时，他必须选择一枚自己的棋子，并按照规则进行一步移动。\n\n鸭棋发明者鸭子德规定一局鸭棋由红方执先手，并设计了初始棋盘布局如下：\n\n![initial_board.png](https://cdn.luogu.com.cn/upload/pic/58700.png)\n\n##### 棋子类型与走子规则\n\n棋子分为 $7$ 类，下面介绍了它们的名字以及它们的移动规则。介绍移动规则时，我们默认棋子所处位置为 $\\left( x,y\\right)$（表示第 $x$ 行的第 $y$ 列，下同），并列出它可以到达的位置：\n\n* **王**（`captain`)：可达的位置共 $4$ 个，包括 $\\left(x\\pm 1,y\\right)$ 及 $\\left(x,y\\pm 1\\right)$。\n* **士**（`guard`）：可达的位置共 $4$ 个，包括 $\\left(x\\pm 1,y\\pm 1\\right)$ 及 $\\left(x\\pm 1,y\\mp 1\\right)$。\n* **象**（`elephant`）：可达的位置至多 $4$ 个，对于任意 $s_x,s_y\\in \\left\\{ 1,-1\\right\\}$，分别有：\n    * 如果位置 $\\left(x+s_x\\times 1 ,y+ s_y\\times 1\\right)$ 上**无任意一方**的棋子停留，则 $\\left( x+s_x \\times 2,y+s_y \\times 2\\right)$ 为一个可达的位置。\n* **马**（`horse`）：可达的位置至多 $8$ 个，对于任意 $s_x,s_y\\in \\left\\{ 1,-1\\right\\}$，分别有：\n    * 如果位置 $\\left(x+s_x\\times 1 ,y\\right)$ 上**无任意一方**的棋子停留，则 $\\left( x+s_x \\times 2,y+s_y \\times 1\\right)$ 为一个可达的位置。\n    * 如果位置 $\\left(x ,y+ s_y \\times 1 \\right)$ 上**无任意一方**的棋子停留，则 $\\left( x+s_x \\times 1,y+s_y \\times 2\\right)$ 为一个可达的位置。\n* **车**（`car`）：可在**不跨越其他棋子**的前提下，到达同行或同列的所有其他位置。\n* **鸭**（`duck`）：可达的位置至多 $8$ 个，对于任意 $s_x,s_y\\in \\left\\{ 1,-1\\right\\}$，分别有：\n    * 如果位置 $\\left(x+s_x\\times 2 ,y+s_y \\times 1\\right),\\left(x+s_x\\times 1 ,y\\right)$ 上均**无任意一方**的棋子停留，则 $\\left( x+s_x \\times 3,y+s_y \\times 2\\right)$ 为一个可达的位置。\n    * 如果位置 $\\left(x+s_x \\times 1 ,y+ s_y \\times 2 \\right),\\left(x ,y+ s_y \\times 1 \\right)$ 上均**无任意一方**的棋子停留，则 $\\left( x+s_x \\times 2,y+s_y \\times 3\\right)$ 为一个可达的位置。\n* **兵**（`soldier`）：可达的位置共 $8$ 个，包括 $\\left(x\\pm 1,y\\right)$ 及 $\\left(x,y\\pm 1\\right)$ 及 $\\left(x\\pm 1,y\\pm 1\\right)$ 及 $\\left(x\\pm 1,y\\mp 1\\right)$。\n\n**除上面描述的规则之外，棋子移动还有如下额外规则：**\n\n* 不能将棋子移动到棋盘外的某个位置。\n* 玩家不能将棋子移动到**已经停留了己方棋子**的位置。\n* 如果玩家将棋子移动到了一个**已经停留了对方棋子**的位置，那么原本停留在该位置上的这个**对方棋子**将被移出游戏。\n\n##### 胜利条件与将军局面\n\n玩家在这个游戏中的目标是将对方的**王**移出游戏。一旦一方的**王**被移出游戏，则另一方立即宣告胜利。\n\n对于一个棋盘的状态，如果存在一方有一步合法的操作能够将另一方的**王**移出游戏，则我们说当前局面是一个**将军**的局面。需要友情提示的是，根据定义，将军局面的形成包括（但不限于）如下这些可能：\n\n1. 一方将一枚棋子移动到可以攻击对方**王**的位置\n\n2. 在己方**王**受到威胁时不采取措施躲避\n\n3. 主动将**王**移动至会受到攻击的位置\n\n**除此之外，需要特别说明的是，游戏结束后，由于双方不可再操作，因此不可能出现将军局面，即便此时另一方王处于被「攻击」的位置。**\n\n#### 题目描述\n\n今年的 IDCC（International Duck Chess Competition，国际鸭棋大赛）正在如火如荼地进行着。你观摩了一场精彩绝伦的比赛，但你对对弈过程的记忆已经模糊不清了，只有系统留下的他们的**操作序列**，序列中的每个**操作**为当前操作者试图移动某个位置的棋子至另一个位置。你希望用这个序列，来复现出整局棋局的对弈过程。即，对于每步操作，你需要**首先判其是否合法**，若合法，则**进一步求出**：\n\n1. 这步操作移动了哪个棋子。\n2. 这步操作后，是否存在棋子被移出游戏，如有则还需求出被移出游戏的棋子。\n3. 这步操作后，是否形成将军局面。\n4. 这步操作后，游戏是否结束。\n\n可能包含的不合法情况如下：\n\n* 此步移动的初始位置无己方棋子停留。\n* 此步移动的初始位置有己方棋子停留，但移动不符合规则。\n* 游戏已经结束。\n\n序列中的不合法操作是需要被忽略的。比如，如果轮到红方移动，此时序列中的当前操作恰好是不合法的，则这个操作将被忽略，序列中的下一步操作将成为红方这步的操作（如仍不合法则继续忽略，直至出现合法的操作）。", "inputFormat": "第一行一个非负整数 $Q$，表示操作序列的长度。接下来依次描述每个操作。\n\n接下来 $Q$ 行，每行 $4$ 个整数 $x_s, y_s, x_t, y_t$（$0\\leq x_s,x_t < 10$，$0\\leq y_s,y_t < 9$），描述一个欲将 $\\left(x_s,y_s\\right)$ 处棋子移动到 $\\left(x_t,y_t\\right)$ 的操作。在这里，我们规定左下角（即红方**车**摆放的位置，图见「题目背景」）为 $\\left(0,0\\right)$。\n\n保证 $Q\\leq 1000$。", "outputFormat": "输出 $Q$ 行，对于每个操作依次输出复现结果。每行输出一个操作的结果：\n\n* 如果该操作为不合法操作，则请输出 `Invalid command`。\n* 如果为合法操作，则依次回答「题目描述」中的问题 $1\\sim 4$：\n    * 被移动的棋子用 `[颜色] [类型]`（注意中间包含空格）来描述，请使用它们的英文名称（见「题目背景」）。如，红象为 `red elephant`，蓝王为 `blue captain`。\n    * 被移出游戏的棋子的描述方式与上面类似。特别地，**如果无棋子被移出游戏，则该问题的答案为 `NA`**。\n    * 用 `yes`、`no` 分别表示形成、不形成将军局面。\n    * 用 `yes`、`no` 分别表示游戏结束、游戏不结束。\n    * 用 `;`（分号）将所有问题的答案隔开。\n    * 比如，四个问题的答案分别为：被移动的棋子是蓝车，无棋子被移出游戏，形成将军局面，游戏未结束。则该行应输出 `blue car;NA;yes;no`。", "hint": "##### 玩具使用说明\n\n你可以在玩具所在目录下执行如下命令来运行玩具（链接: <https://pan.baidu.com/s/12MJGgZB9zKcE3qgRbRozGw> 提取码: 4d5c）：\n\n```\n./duckchess\n```\n\n特别地，在**初次运行前**，你需要执行如下命令为它添加运行权限：\n\n\n```\nchmod +x duckchess\n```\n\n##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN"}}}
{"pid": "P5381", "type": "P", "difficulty": 6, "samples": [["2\n1 1\n1 2", "0.00000\n1.00000"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "平衡树", "Special Judge", "THUPC"], "title": "[THUPC 2019] 不等式", "background": "", "description": "> 时光回到 2017 年 6 月 7 日。午后，阳光正好。\n>\n> 现在的你，在考场中笔耕不辍。在刷刷声中，你填写着交给从前和未来的自己的答卷。\n> \n> 像无数次训练过的那样，你直接跳到了这张数学试卷的最后一道大题，二选一的题目直接选择了后者。快速地掠过了题目描述，紧缩的眉头渐渐放松。\n> \n> 「稳了。」\n>\n> 你一刻也不敢停留，又向你的梦想靠近了一小步。\n\n已知两个 $n$ 维实向量 $\\vec{a}=(a_1,a_2,\\dots,a_n),\\vec{b}=(b_1,b_2,\\dots,b_n)$，定义 $n$ 个定义域为 $\\mathbb{R}$ 函数 $f_1,f_2,\\dots,f_n$：\n\n$$f_k(x)=\\sum_{i=1}^{k} \\lvert a_ix+b_i\\rvert \\quad (k=1,2,\\dots,n)$$\n\n现在，对于每个 $k=1,2,\\dots,n$，试求 $f_k$ 在 $\\mathbb{R}$ 上的最小值。可以证明最小值一定存在。", "inputFormat": "第一行一个整数 $n$，表示向量的长度及函数的个数。\n\n接下来两行，每行 $n$ 个整数，分别描述向量 $\\vec{a},\\vec{b}$ 的各个分量，以空格隔开。\n\n对于所有的输入数据，都满足 $1\\le n\\le 5\\times 10^5,\\lvert a_i\\rvert ,\\lvert b_i\\rvert <10^5$。", "outputFormat": "输出 $n$ 行，第 $i$（$i=1,2,\\dots,n$） 行为一个实数，表示 $f_i$ 在 $\\mathbb{R}$ 上的最小值。\n\n输出与标准答案的绝对误差或相对误差小于 $10^{-6}$ 就会被算作正确。", "hint": "### 样例解释\n\n$f_1(x)=\\lvert x+1\\rvert$，显然在 $x=-1$ 处取到最小值 $0$；\n\n$f_2(x)=\\lvert x+1\\rvert +\\lvert x+2\\rvert$，可以证明其在 $[-2,-1]$ 中任意位置取到最小值 $1$。\n\n##### 后记\n\n后来，全国三卷的考生们又回想起了被参数方程支配的恐惧。\n\n##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN", "translations": {"en": {"title": "[THUPC 2019] Inequalities", "background": "", "description": "> Time goes back to June 7, 2017. In the afternoon, the sunlight is just right.\n>\n> You, in the examination room, keep writing without stopping. Amid the rustling sounds, you fill in an answer sheet meant for your past and future selves.\n>\n> Just like you have practiced countless times, you jump straight to the last big problem on this math paper. For the either-or question, you directly choose the latter. After quickly skimming the statement, your furrowed brows gradually relax.\n>\n> “This is in the bag.”\n>\n> You do not dare to pause for even a moment, and you move one small step closer to your dream.\n\nGiven two $n$-dimensional real vectors $\\vec{a}=(a_1,a_2,\\dots,a_n)$ and $\\vec{b}=(b_1,b_2,\\dots,b_n)$, define $n$ functions $f_1,f_2,\\dots,f_n$ with domain $\\mathbb{R}$:\n\n$$f_k(x)=\\sum_{i=1}^{k} \\lvert a_ix+b_i\\rvert \\quad (k=1,2,\\dots,n)$$\n\nNow, for each $k=1,2,\\dots,n$, find the minimum value of $f_k$ over $\\mathbb{R}$. It can be proven that the minimum always exists.", "inputFormat": "The first line contains an integer $n$, representing the length of the vectors and the number of functions.\n\nThe next two lines each contain $n$ integers, describing the components of vectors $\\vec{a}$ and $\\vec{b}$, separated by spaces.\n\nFor all input data, it holds that $1\\le n\\le 5\\times 10^5$ and $\\lvert a_i\\rvert ,\\lvert b_i\\rvert <10^5$.", "outputFormat": "Output $n$ lines. The $i$-th line ($i=1,2,\\dots,n$) contains a real number, representing the minimum value of $f_i$ over $\\mathbb{R}$.\n\nYour output will be considered correct if the absolute error or relative error compared with the standard answer is less than $10^{-6}$.", "hint": "### Sample Explanation\n\n$f_1(x)=\\lvert x+1\\rvert$, which obviously achieves its minimum value $0$ at $x=-1$.\n\n$f_2(x)=\\lvert x+1\\rvert +\\lvert x+2\\rvert$. It can be proven that it achieves its minimum value $1$ at any point in $[-2,-1]$.\n\n##### Postscript\n\nLater, the students who took the third national exam paper once again recalled the fear of being dominated by parametric equations.\n\n##### Copyright Information\n\nFrom THUPC (THU Programming Contest, Tsinghua University Programming Contest) 2019.\n\nResources such as solutions can be found at <https://github.com/wangyurzee7/THUPC2019>.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUPC 2019] 不等式", "background": "", "description": "> 时光回到 2017 年 6 月 7 日。午后，阳光正好。\n>\n> 现在的你，在考场中笔耕不辍。在刷刷声中，你填写着交给从前和未来的自己的答卷。\n> \n> 像无数次训练过的那样，你直接跳到了这张数学试卷的最后一道大题，二选一的题目直接选择了后者。快速地掠过了题目描述，紧缩的眉头渐渐放松。\n> \n> 「稳了。」\n>\n> 你一刻也不敢停留，又向你的梦想靠近了一小步。\n\n已知两个 $n$ 维实向量 $\\vec{a}=(a_1,a_2,\\dots,a_n),\\vec{b}=(b_1,b_2,\\dots,b_n)$，定义 $n$ 个定义域为 $\\mathbb{R}$ 函数 $f_1,f_2,\\dots,f_n$：\n\n$$f_k(x)=\\sum_{i=1}^{k} \\lvert a_ix+b_i\\rvert \\quad (k=1,2,\\dots,n)$$\n\n现在，对于每个 $k=1,2,\\dots,n$，试求 $f_k$ 在 $\\mathbb{R}$ 上的最小值。可以证明最小值一定存在。", "inputFormat": "第一行一个整数 $n$，表示向量的长度及函数的个数。\n\n接下来两行，每行 $n$ 个整数，分别描述向量 $\\vec{a},\\vec{b}$ 的各个分量，以空格隔开。\n\n对于所有的输入数据，都满足 $1\\le n\\le 5\\times 10^5,\\lvert a_i\\rvert ,\\lvert b_i\\rvert <10^5$。", "outputFormat": "输出 $n$ 行，第 $i$（$i=1,2,\\dots,n$） 行为一个实数，表示 $f_i$ 在 $\\mathbb{R}$ 上的最小值。\n\n输出与标准答案的绝对误差或相对误差小于 $10^{-6}$ 就会被算作正确。", "hint": "### 样例解释\n\n$f_1(x)=\\lvert x+1\\rvert$，显然在 $x=-1$ 处取到最小值 $0$；\n\n$f_2(x)=\\lvert x+1\\rvert +\\lvert x+2\\rvert$，可以证明其在 $[-2,-1]$ 中任意位置取到最小值 $1$。\n\n##### 后记\n\n后来，全国三卷的考生们又回想起了被参数方程支配的恐惧。\n\n##### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN"}}}
{"pid": "P5382", "type": "P", "difficulty": 6, "samples": [["7 8\n2 2 1 1 3 3 4\n100 100 40 20 100 50 40\n1 3\n2 3\n1 4\n2 4\n3 5\n4 6\n3 7\n4 7", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "THUPC"], "title": "[THUPC 2019] 改善生活", "background": "", "description": "「改善生活」是小 Z 创建的一个群聊。在群聊里，小 Z 和他的 $n-1$ 个朋友们（共 $n$ 名群友，小 Z 的编号为 $1$，他的朋友们的编号从 $2$ 至 $n$）无话不说，畅谈甚欢。然而，经常水群会被冠以水王的名号，这让小 Z 头痛不已。\n\n今天，小 Z 预见到了群里可能会有 $n$ 个话题（编号从 $1$ 至 $n$）。其中，第 $i$ 个话题是 $c_i$ 号群友（当然也有可能是小 Z 自己）感兴趣的话题，这意味着该话题如果出现，这位群友将会进行 $w_i$ 分钟的**激烈发言**。方便起见，你可以认为，除此之外，群友不会进行激烈发言。\n\n所有 $n$ 个话题之间有 $m$ 组引导关系，每组引导关系的形式是一个二元组 $\\left(u,v\\right)$，它表示如果 $u$ 号话题出现，**必定**会导致 $v$ 号话题出现。\n\n巧合的是，小 Z 发现，所有他自己的**不同**话题都不存在**直接或间接**的引导关系。\n\n由于期中考试的临近，除小 Z 外的群友们都忙于复习，因此他们不会主动发起话题（发起话题指让一个话题出现，下同），也就是说，**所有** $c_i\\neq 1$ **的话题都只能由引导关系直接或间接引出**。这让想要水群、却又希望摆脱水王名号的小 Z 左右为难。因此，他决定主动发起**一个或以上**的**自己感兴趣**的话题，来诱导其他话题的出现，致使**水群最多的另一位群友激烈发言的时间**与**小 Z 自己激烈发言的时间**的比值尽可能大。即最大化下面这个式子：\n\n$$\\frac{\\max\\limits_{k=2}^n \\text{sum}\\left(k\\right)}{\\text{sum}\\left(1\\right)}$$\n\n其中，$\\text{sum}\\left(k\\right)$ 表示所有**出现**且**群友 $k$ 感兴趣**的话题的 $w$ 值总和。\n\n为避免精度误差，你只需要求出最大值**向下取整**的结果即可。", "inputFormat": "第一行两个正整数 $n,m$，分别表示话题数（恰好也是群人数）、引导关系组数。\n\n第二行 $n$ 个正整数 $c_1,\\dots, c_n$（$1\\leq c_i\\leq n$），依次描述对各话题感兴趣的群友编号。保证至少存在一个$i$ 使得 $c_i=1$。\n\n第三行 $n$ 个正整数 $w_1,\\dots, w_n$（$1\\leq w_i\\leq 100$），依次描述各话题感兴趣的群友将激烈发言的时间。\n\n接下来 $m$ 行描述引导关系，每行两个正整数 $u,v$（$1\\leq u,v\\leq n$），描述一组引导关系 $\\left(u,v\\right)$，具体意义见【题目描述】，**保证所有不同的 $c_i=1$ 的话题之间两两不存在直接或间接的引导关系**。\n\n对于每一行，如果行内包含多个数，则用单个空格将它们隔开。\n\n保证 $1\\leq n\\leq 700$，$1\\leq m\\leq 60000$。", "outputFormat": "一行一个**整数**，表示所求式子最大值**向下取整**的结果，即不超过该值的最大整数。", "hint": "### 样例解释\n\n小 Z 可以选择发起编号为 3 和 4 的话题，这将致使编号为 5、6、7 的话题出现，并引发 3 号群友时长 $150$ 分钟的激烈发言、以及 4 号群友时长 $40$ 分钟的激烈发言。由于 $3$ 号群友激烈发言时间更长，且小 Z 自己的激烈发言时长为 $60$ 分钟，因此所求最大比值为 $\\frac{150}{60}=2.5$，这个值向下取整的结果是 $2$。\n\n可以证明小 Z 不存在更优的策略。\n\n### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN", "translations": {"en": {"title": "[THUPC 2019] Improve Life", "background": "", "description": "\"Improve Life\" is a group chat created by Xiao Z. In the group chat, Xiao Z and his $n-1$ friends (there are $n$ members in total; Xiao Z is numbered $1$, and his friends are numbered from $2$ to $n$) talk about everything and have a great time. However, chatting too much is often labeled as being the \"chat king\", which gives Xiao Z a headache.\n\nToday, Xiao Z foresees that there may be $n$ topics in the group (numbered from $1$ to $n$). Topic $i$ is a topic that member $c_i$ (possibly Xiao Z himself) is interested in. This means that if this topic appears, this member will make an **intense speech** for $w_i$ minutes. For convenience, you may assume that apart from this, members will not make intense speeches.\n\nAmong all $n$ topics, there are $m$ guiding relationships. Each guiding relationship is an ordered pair $\\left(u,v\\right)$, meaning that if topic $u$ appears, it will **definitely** cause topic $v$ to appear.\n\nCoincidentally, Xiao Z发现 that among all of his own **different** topics, there is no **direct or indirect** guiding relationship.\n\nBecause the midterm exams are coming, all members except Xiao Z are busy studying, so they will not proactively start topics (starting a topic means making a topic appear; same below). That is, **all** topics with $c_i\\neq 1$ **can only be triggered directly or indirectly by guiding relationships**. This puts Xiao Z in a dilemma: he wants to chat a lot, but also wants to get rid of the \"chat king\" label. Therefore, he decides to proactively start **one or more** topics **that he is interested in**, to induce other topics to appear, so that the ratio of **the maximum intense speaking time among other members** to **Xiao Z's own intense speaking time** is as large as possible. That is, maximize the following expression:\n\n$$\\frac{\\max\\limits_{k=2}^n \\text{sum}\\left(k\\right)}{\\text{sum}\\left(1\\right)}$$\n\nHere, $\\text{sum}\\left(k\\right)$ denotes the sum of $w$ values over all topics that **appear** and that **member $k$ is interested in**.\n\nTo avoid precision errors, you only need to output the result of **rounding down** the maximum value.", "inputFormat": "The first line contains two positive integers $n,m$, representing the number of topics (which is also exactly the number of group members) and the number of guiding relationships.\n\nThe second line contains $n$ positive integers $c_1,\\dots, c_n$ ($1\\leq c_i\\leq n$), describing the member number who is interested in each topic in order. It is guaranteed that there exists at least one $i$ such that $c_i=1$.\n\nThe third line contains $n$ positive integers $w_1,\\dots, w_n$ ($1\\leq w_i\\leq 100$), describing the time of intense speech for the member interested in each topic.\n\nThe next $m$ lines describe the guiding relationships. Each line contains two positive integers $u,v$ ($1\\leq u,v\\leq n$), describing a guiding relationship $\\left(u,v\\right)$. See the **Description** for the exact meaning. It is **guaranteed that between any two different topics with $c_i=1$, there is neither a direct nor an indirect guiding relationship**.\n\nFor each line, if it contains multiple numbers, they are separated by a single space.\n\nConstraints: $1\\leq n\\leq 700$, $1\\leq m\\leq 60000$.", "outputFormat": "Output a single **integer** on one line: the result of **rounding down** the maximum value of the required expression, i.e., the largest integer not exceeding that value.", "hint": "### Sample Explanation\n\nXiao Z can choose to start topics numbered 3 and 4. This will cause topics numbered 5, 6, and 7 to appear, and trigger an intense speech of $150$ minutes by member 3, and $40$ minutes by member 4. Since member 3 speaks for a longer time, and Xiao Z's own intense speaking time is $60$ minutes, the maximum ratio is $\\frac{150}{60}=2.5$, and rounding it down gives $2$.\n\nIt can be proven that Xiao Z has no better strategy.\n\n### Copyright Information\n\nFrom THUPC (THU Programming Contest, Tsinghua University Programming Contest) 2019.\n\nResources such as solutions can be found at <https://github.com/wangyurzee7/THUPC2019>.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUPC 2019] 改善生活", "background": "", "description": "「改善生活」是小 Z 创建的一个群聊。在群聊里，小 Z 和他的 $n-1$ 个朋友们（共 $n$ 名群友，小 Z 的编号为 $1$，他的朋友们的编号从 $2$ 至 $n$）无话不说，畅谈甚欢。然而，经常水群会被冠以水王的名号，这让小 Z 头痛不已。\n\n今天，小 Z 预见到了群里可能会有 $n$ 个话题（编号从 $1$ 至 $n$）。其中，第 $i$ 个话题是 $c_i$ 号群友（当然也有可能是小 Z 自己）感兴趣的话题，这意味着该话题如果出现，这位群友将会进行 $w_i$ 分钟的**激烈发言**。方便起见，你可以认为，除此之外，群友不会进行激烈发言。\n\n所有 $n$ 个话题之间有 $m$ 组引导关系，每组引导关系的形式是一个二元组 $\\left(u,v\\right)$，它表示如果 $u$ 号话题出现，**必定**会导致 $v$ 号话题出现。\n\n巧合的是，小 Z 发现，所有他自己的**不同**话题都不存在**直接或间接**的引导关系。\n\n由于期中考试的临近，除小 Z 外的群友们都忙于复习，因此他们不会主动发起话题（发起话题指让一个话题出现，下同），也就是说，**所有** $c_i\\neq 1$ **的话题都只能由引导关系直接或间接引出**。这让想要水群、却又希望摆脱水王名号的小 Z 左右为难。因此，他决定主动发起**一个或以上**的**自己感兴趣**的话题，来诱导其他话题的出现，致使**水群最多的另一位群友激烈发言的时间**与**小 Z 自己激烈发言的时间**的比值尽可能大。即最大化下面这个式子：\n\n$$\\frac{\\max\\limits_{k=2}^n \\text{sum}\\left(k\\right)}{\\text{sum}\\left(1\\right)}$$\n\n其中，$\\text{sum}\\left(k\\right)$ 表示所有**出现**且**群友 $k$ 感兴趣**的话题的 $w$ 值总和。\n\n为避免精度误差，你只需要求出最大值**向下取整**的结果即可。", "inputFormat": "第一行两个正整数 $n,m$，分别表示话题数（恰好也是群人数）、引导关系组数。\n\n第二行 $n$ 个正整数 $c_1,\\dots, c_n$（$1\\leq c_i\\leq n$），依次描述对各话题感兴趣的群友编号。保证至少存在一个$i$ 使得 $c_i=1$。\n\n第三行 $n$ 个正整数 $w_1,\\dots, w_n$（$1\\leq w_i\\leq 100$），依次描述各话题感兴趣的群友将激烈发言的时间。\n\n接下来 $m$ 行描述引导关系，每行两个正整数 $u,v$（$1\\leq u,v\\leq n$），描述一组引导关系 $\\left(u,v\\right)$，具体意义见【题目描述】，**保证所有不同的 $c_i=1$ 的话题之间两两不存在直接或间接的引导关系**。\n\n对于每一行，如果行内包含多个数，则用单个空格将它们隔开。\n\n保证 $1\\leq n\\leq 700$，$1\\leq m\\leq 60000$。", "outputFormat": "一行一个**整数**，表示所求式子最大值**向下取整**的结果，即不超过该值的最大整数。", "hint": "### 样例解释\n\n小 Z 可以选择发起编号为 3 和 4 的话题，这将致使编号为 5、6、7 的话题出现，并引发 3 号群友时长 $150$ 分钟的激烈发言、以及 4 号群友时长 $40$ 分钟的激烈发言。由于 $3$ 号群友激烈发言时间更长，且小 Z 自己的激烈发言时长为 $60$ 分钟，因此所求最大比值为 $\\frac{150}{60}=2.5$，这个值向下取整的结果是 $2$。\n\n可以证明小 Z 不存在更优的策略。\n\n### 版权信息\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。", "locale": "zh-CN"}}}
{"pid": "P5383", "type": "P", "difficulty": 7, "samples": [["3\n1 1 1", "1 2 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "普通多项式转下降幂多项式", "background": "这是一道模板题", "description": "已知普通多项式 $F(x)=\\displaystyle\\sum_{i=0}^{n-1}a_ix^{i}$。\n\n求下降幂多项式 $G(x)=\\displaystyle\\sum_{i=0}^{n-1}b_ix^{\\underline{i}}$。\n\n使得 $G(x)=F(x)$。\n\n所有运算均在 $\\bmod\\ 998244353$ 意义下进行。", "inputFormat": "第一行一个正整数 $n$，如题所述。\n\n第二行 $n$ 个数，第 $i$ 个数表示 $a_{i-1}$。", "outputFormat": "一行 $n$ 个数，第 $i$ 个数为 $b_{i-1}$。", "hint": "对于所有数据 $a_i\\in\\lbrack0,998244353)$。\n\n本题一共 $10$ 个点。\n\n其中 $3$ 个点 $n=2000$。\n\n另外 $7$ 个点 $n=10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Convert an Ordinary Polynomial to a Falling-Factorial Polynomial", "background": "This is a template problem.", "description": "Given an ordinary polynomial $F(x)=\\displaystyle\\sum_{i=0}^{n-1}a_ix^{i}$.\n\nFind a falling-factorial polynomial $G(x)=\\displaystyle\\sum_{i=0}^{n-1}b_ix^{\\underline{i}}$.\n\nSuch that $G(x)=F(x)$.\n\nAll operations are performed modulo $998244353$.", "inputFormat": "The first line contains a positive integer $n$, as described above.\n\nThe second line contains $n$ numbers. The $i$-th number represents $a_{i-1}$.", "outputFormat": "Output one line with $n$ numbers. The $i$-th number is $b_{i-1}$.", "hint": "For all testdata, $a_i\\in\\lbrack0,998244353)$.\n\nThis problem has a total of $10$ subtasks.\n\nAmong them, $3$ subtasks have $n=2000$.\n\nThe other $7$ subtasks have $n=10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "普通多项式转下降幂多项式", "background": "这是一道模板题", "description": "已知普通多项式 $F(x)=\\displaystyle\\sum_{i=0}^{n-1}a_ix^{i}$。\n\n求下降幂多项式 $G(x)=\\displaystyle\\sum_{i=0}^{n-1}b_ix^{\\underline{i}}$。\n\n使得 $G(x)=F(x)$。\n\n所有运算均在 $\\bmod\\ 998244353$ 意义下进行。", "inputFormat": "第一行一个正整数 $n$，如题所述。\n\n第二行 $n$ 个数，第 $i$ 个数表示 $a_{i-1}$。", "outputFormat": "一行 $n$ 个数，第 $i$ 个数为 $b_{i-1}$。", "hint": "对于所有数据 $a_i\\in\\lbrack0,998244353)$。\n\n本题一共 $10$ 个点。\n\n其中 $3$ 个点 $n=2000$。\n\n另外 $7$ 个点 $n=10^5$。", "locale": "zh-CN"}}}
{"pid": "P5384", "type": "P", "difficulty": 6, "samples": [["5 2\n1 2 1 4\n2 1\n3 2", "1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "O2优化", "深度优先搜索 DFS", "差分"], "title": "[Cnoi2019] 雪松果树", "background": "幻想乡，冬。\n\n一年一度，生长在高山上的雪松果树又结果了。\n\nCirno 不知从哪弄到了 $1,2,3\\cdots9$ 颗雪松果,然后很开心的吃掉了其中 $6$ 颗，最后还剩最后 $1$ 颗。\n\nCirno 因为以后吃不到雪松果而感到忧愁，于是决定种在美丽的雾之湖畔。\n\n第一天，发芽。\n\n第二天，雪松果树长成了一颗参天大树，上面长满了雪松果。\n\nCirno 在雪松果成熟之前早有一些问题想知道，但现在她忙于收集雪松果，就把问题丢给了你。", "description": "雪松果树是一个以 $1$ 为根有着 $N$ 个节点的树。\n\n除此之外，Cirno 还有 $Q$ 个询问，每个询问是一个二元组 $(u,k)$，表示询问 $u$ 节点的 $k$-cousin 有多少个。\n\n我们定义:\n\n> 节点 $u$ 的 $1$-father 为 路径 $(1, u)$ （不含 u）上距 u 最近的节点\n>\n> 节点 $u$ 的 $k$-father 为 节点 「$u$ 的 $(k-1)$-father」 的 1-father\n>\n> 节点 $u$ 的 $k$-son 为所有 $k$-father 为 $u$ 的节点\n>\n> 节点 $u$ 的 $k$-cousin 为 节点「 $u$ 的 $k$-father」的 $k$-son (不包含 $u$ 本身)", "inputFormat": "第一行，两个整数 $N$, $Q$\n\n第二行，$N-1$ 个整数，第 $i$ 个表示 $i+1$ 号节点的 1-father\n\n以下 $Q$ 行，每行一个二元组$(u,k)$", "outputFormat": "一行，$Q$ 个数，每一个表示一个询问的答案。若 u 不存在 k-father，输出 0。", "hint": "数据范围：\n|数据点编号|$N\\le$|$Q\\le$|特殊性质|\n|----|----|----|-----|\n|1,2|$100$|$100$||\n|3,4|$100$|$10^6$||\n|5,6|$10^5$|$100$||\n|7|$10^4$|$5000$||\n|8,9,10|$10^5$|$10^5$||\n|11,12,13,14|$10^6$|$10^6$|**树随机生成**|\n|15,16,17,18,19,20|$10^6$|$10^6$||\n\n另外存在一组记 $20$ 分的 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[Cnoi2019] Cedar Cone Tree.", "background": "Gensokyo, winter.\n\nOnce a year, the cedar cone trees growing on the high mountains bear fruit again.\n\nCirno somehow got $1,2,3\\cdots9$ cedar cones, then happily ate $6$ of them, and in the end only $1$ cone was left.\n\nCirno felt sad because she would not be able to eat cedar cones in the future, so she decided to plant it by the beautiful Misty Lake.\n\nOn the first day, it sprouted.\n\nOn the second day, the cedar cone tree grew into a towering tree, covered with cedar cones.\n\nCirno had some questions she wanted to know before the cedar cones ripened, but now she was busy collecting cedar cones, so she threw the questions to you.", "description": "The cedar cone tree is a tree with $N$ nodes rooted at $1$.\n\nIn addition, Cirno has $Q$ queries. Each query is an ordered pair $(u,k)$, asking how many $k$-cousins node $u$ has.\n\nWe define:\n\n> The 1-father of node $u$ is the node on the path $(1, u)$ (excluding $u$) that is closest to $u$.\n>\n> The $k$-father of node $u$ is the 1-father of the node “the $(k-1)$-father of $u$”.\n>\n> The $k$-son of node $u$ is the set of all nodes whose $k$-father is $u$.\n>\n> The $k$-cousin of node $u$ is the $k$-son of the node “the $k$-father of $u$” (excluding $u$ itself).", "inputFormat": "The first line contains two integers $N$ and $Q$.\n\nThe second line contains $N-1$ integers. The $i$-th integer denotes the 1-father of node $i+1$.\n\nThe following $Q$ lines each contain an ordered pair $(u,k)$.", "outputFormat": "Output one line with $Q$ numbers, where each number is the answer to a query. If $u$ does not have a $k$-father, output $0$.", "hint": "Constraints:\n|Test Point ID|$N\\le$|$Q\\le$|Special Property|\n|----|----|----|-----|\n|1,2|$100$|$100$||\n|3,4|$100$|$10^6$||\n|5,6|$10^5$|$100$||\n|7|$10^4$|$5000$||\n|8,9,10|$10^5$|$10^5$||\n|11,12,13,14|$10^6$|$10^6$|**The tree is generated randomly**|\n|15,16,17,18,19,20|$10^6$|$10^6$||\n\nIn addition, there is a set of hack testdata worth $20$ points.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Cnoi2019] 雪松果树", "background": "幻想乡，冬。\n\n一年一度，生长在高山上的雪松果树又结果了。\n\nCirno 不知从哪弄到了 $1,2,3\\cdots9$ 颗雪松果,然后很开心的吃掉了其中 $6$ 颗，最后还剩最后 $1$ 颗。\n\nCirno 因为以后吃不到雪松果而感到忧愁，于是决定种在美丽的雾之湖畔。\n\n第一天，发芽。\n\n第二天，雪松果树长成了一颗参天大树，上面长满了雪松果。\n\nCirno 在雪松果成熟之前早有一些问题想知道，但现在她忙于收集雪松果，就把问题丢给了你。", "description": "雪松果树是一个以 $1$ 为根有着 $N$ 个节点的树。\n\n除此之外，Cirno 还有 $Q$ 个询问，每个询问是一个二元组 $(u,k)$，表示询问 $u$ 节点的 $k$-cousin 有多少个。\n\n我们定义:\n\n> 节点 $u$ 的 $1$-father 为 路径 $(1, u)$ （不含 u）上距 u 最近的节点\n>\n> 节点 $u$ 的 $k$-father 为 节点 「$u$ 的 $(k-1)$-father」 的 1-father\n>\n> 节点 $u$ 的 $k$-son 为所有 $k$-father 为 $u$ 的节点\n>\n> 节点 $u$ 的 $k$-cousin 为 节点「 $u$ 的 $k$-father」的 $k$-son (不包含 $u$ 本身)", "inputFormat": "第一行，两个整数 $N$, $Q$\n\n第二行，$N-1$ 个整数，第 $i$ 个表示 $i+1$ 号节点的 1-father\n\n以下 $Q$ 行，每行一个二元组$(u,k)$", "outputFormat": "一行，$Q$ 个数，每一个表示一个询问的答案。若 u 不存在 k-father，输出 0。", "hint": "数据范围：\n|数据点编号|$N\\le$|$Q\\le$|特殊性质|\n|----|----|----|-----|\n|1,2|$100$|$100$||\n|3,4|$100$|$10^6$||\n|5,6|$10^5$|$100$||\n|7|$10^4$|$5000$||\n|8,9,10|$10^5$|$10^5$||\n|11,12,13,14|$10^6$|$10^6$|**树随机生成**|\n|15,16,17,18,19,20|$10^6$|$10^6$||\n\n另外存在一组记 $20$ 分的 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P5385", "type": "P", "difficulty": 6, "samples": [["5 5 4 0\n1 2\n3 4\n2 3\n4 5\n1 5\n1 3\n2 5\n3 4\n5 5", "2\n1\n3\n4"], ["见附件中 sample2.in", "见附件中 sample2.out"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "O2优化", "动态树 LCT", "可持久化线段树"], "title": "[Cnoi2019] 须臾幻境", "background": "这曾今有一个凄婉哀伤的故事，但是被出题人删档弄丢了。", "description": "初始时，你有一个 $n$ 个结点 $m$ 条边的无向图 $G$，结点的编号依次为 $1,2,\\cdots,n$。\n\n现在将 $G$ 中所有 $m$ 条边依次编号，排成一个长度为 $m$ 边序列 $E=(e_1,e_2,\\cdots,e_m)$，其中 $e_i=(u_i,v_i)$ 是一个二元组，表示一个连接 $u_i$ 与 $v_i$ 的无向边。\n\n然后 Cirno 会给你 $q$ 个询问二元组 $( l, r )$，表示询问「如果只保留 $e_l,e_{l+1},\\cdots e_r$ 这个区间内的边的话，图中的联通块的个数」。\n\n时间紧急，你需要设计尽可能快的算法解决 Cirno 的询问，而且由于在某些情况下询问之间也许互相依赖，你的程序需要保持在线运行。", "inputFormat": "第一行，四个整数，用空格隔开，分别表示 $n$, $m$, $q$, $t$, 其中 $t$ 表示强制在线参数，用于解密真实的询问。\n\n接下来的 $m$ 行，其中第 $i$ 行包含两个整数 $u_i$ 与 $v_i$，用空格隔开，表示边序列 $E$。\n\n再接下来 $q$ 行，每行两个整数 $l', r'$，用空格隔开，表示一组加密后的询问。\n\n真实的询问二元组 $(l,r)$ 由以下方式解密\n\n```plain-text\nDecodeQuery( l', r', m, t, last_ans )\n\t(l, r) <- (l', r')\n    IF t > 0 THEN \n        l <- (l + t * last_ans) Mod |E| + 1\n        r <- (r + t * last_ans) Mod |E| + 1\n    IF l' > r' THEN \n        Swap(l, r)\n    RETURN (l, r)\n```\n\n其中 `last_ans` 表示上一次询问的答案，初始时 `last_ans = 0`.", "outputFormat": "$q$ 行，表示每个询问的答案。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k2c1fizv.png)\n\n**数据范围与约定**\n\n对于 $100\\%$ 的数据保证，$1\\le |V| \\le 10^5, 1\\le |E| \\le 2\\times 10^5, 1\\le q \\le 10^5, t \\in \\{0,1\\}$。**注意数据可能包含重边和自环**。\n\n**子任务**\n\nSubtask1（$15$ points）：$|V|, |E|, q \\le 5000$；\n\nSubtask2（$25$ points）：$t = 0$；\n\nSubtask3（$20$ points）：$|V| \\le 10^4, |E|, q \\le 3\\times 10^4$\n\nSubtask3（$40$ points）：无特殊限制。", "locale": "zh-CN", "translations": {"en": {"title": "[Cnoi2019] Momentary Illusion Realm.", "background": "There used to be a sad and touching story here, but the problem setter deleted the file and it was lost.", "description": "Initially, you are given an undirected graph $G$ with $n$ vertices and $m$ edges. The vertices are numbered $1,2,\\cdots,n$.\n\nNow, number all $m$ edges in $G$ in order and arrange them into an edge sequence of length $m$: $E=(e_1,e_2,\\cdots,e_m)$, where $e_i=(u_i,v_i)$ is an ordered pair representing an undirected edge connecting $u_i$ and $v_i$.\n\nThen Cirno will give you $q$ query pairs $(l,r)$, asking: “If we only keep the edges $e_l,e_{l+1},\\cdots,e_r$ in this interval, what is the number of connected components in the graph?”\n\nTime is tight. You need to design an algorithm as fast as possible to answer Cirno’s queries. Also, since in some cases queries may depend on each other, your program must run online.", "inputFormat": "The first line contains four integers separated by spaces: $n$, $m$, $q$, $t$, where $t$ is the forced-online parameter used to decrypt the real queries.\n\nThe next $m$ lines describe the edges. The $i$-th line contains two integers $u_i$ and $v_i$ separated by a space, representing the edge sequence $E$.\n\nThe next $q$ lines each contain two integers $l', r'$ separated by spaces, representing an encrypted query.\n\nThe real query pair $(l,r)$ is decrypted as follows.\n\n```plain-text\nDecodeQuery( l', r', m, t, last_ans )\n\t(l, r) <- (l', r')\n    IF t > 0 THEN \n        l <- (l + t * last_ans) Mod |E| + 1\n        r <- (r + t * last_ans) Mod |E| + 1\n    IF l' > r' THEN \n        Swap(l, r)\n    RETURN (l, r)\n```\n\nHere, `last_ans` is the answer to the previous query. Initially, `last_ans = 0`.", "outputFormat": "Output $q$ lines, each being the answer to one query.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k2c1fizv.png)\n\n**Constraints and Notes**\n\nFor $100\\%$ of the testdata, it is guaranteed that $1\\le |V| \\le 10^5$, $1\\le |E| \\le 2\\times 10^5$, $1\\le q \\le 10^5$, and $t \\in \\{0,1\\}$. **Note that the testdata may contain multiple edges and self-loops**.\n\n**Subtasks**\n\nSubtask 1 ($15$ points): $|V|, |E|, q \\le 5000$.\n\nSubtask 2 ($25$ points): $t = 0$.\n\nSubtask 3 ($20$ points): $|V| \\le 10^4$, $|E|, q \\le 3\\times 10^4$.\n\nSubtask 4 ($40$ points): No special restrictions.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Cnoi2019] 须臾幻境", "background": "这曾今有一个凄婉哀伤的故事，但是被出题人删档弄丢了。", "description": "初始时，你有一个 $n$ 个结点 $m$ 条边的无向图 $G$，结点的编号依次为 $1,2,\\cdots,n$。\n\n现在将 $G$ 中所有 $m$ 条边依次编号，排成一个长度为 $m$ 边序列 $E=(e_1,e_2,\\cdots,e_m)$，其中 $e_i=(u_i,v_i)$ 是一个二元组，表示一个连接 $u_i$ 与 $v_i$ 的无向边。\n\n然后 Cirno 会给你 $q$ 个询问二元组 $( l, r )$，表示询问「如果只保留 $e_l,e_{l+1},\\cdots e_r$ 这个区间内的边的话，图中的联通块的个数」。\n\n时间紧急，你需要设计尽可能快的算法解决 Cirno 的询问，而且由于在某些情况下询问之间也许互相依赖，你的程序需要保持在线运行。", "inputFormat": "第一行，四个整数，用空格隔开，分别表示 $n$, $m$, $q$, $t$, 其中 $t$ 表示强制在线参数，用于解密真实的询问。\n\n接下来的 $m$ 行，其中第 $i$ 行包含两个整数 $u_i$ 与 $v_i$，用空格隔开，表示边序列 $E$。\n\n再接下来 $q$ 行，每行两个整数 $l', r'$，用空格隔开，表示一组加密后的询问。\n\n真实的询问二元组 $(l,r)$ 由以下方式解密\n\n```plain-text\nDecodeQuery( l', r', m, t, last_ans )\n\t(l, r) <- (l', r')\n    IF t > 0 THEN \n        l <- (l + t * last_ans) Mod |E| + 1\n        r <- (r + t * last_ans) Mod |E| + 1\n    IF l' > r' THEN \n        Swap(l, r)\n    RETURN (l, r)\n```\n\n其中 `last_ans` 表示上一次询问的答案，初始时 `last_ans = 0`.", "outputFormat": "$q$ 行，表示每个询问的答案。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k2c1fizv.png)\n\n**数据范围与约定**\n\n对于 $100\\%$ 的数据保证，$1\\le |V| \\le 10^5, 1\\le |E| \\le 2\\times 10^5, 1\\le q \\le 10^5, t \\in \\{0,1\\}$。**注意数据可能包含重边和自环**。\n\n**子任务**\n\nSubtask1（$15$ points）：$|V|, |E|, q \\le 5000$；\n\nSubtask2（$25$ points）：$t = 0$；\n\nSubtask3（$20$ points）：$|V| \\le 10^4, |E|, q \\le 3\\times 10^4$\n\nSubtask3（$40$ points）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P5386", "type": "P", "difficulty": 7, "samples": [["4 1\n1 2 3 4\n1 4 2 4", "6"]], "limits": {"time": [3000, 3000, 3000, 7000, 7000, 7000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "莫队", "分块"], "title": "[Cnoi2019] 数字游戏", "background": "", "description": "给定一个 $1\\sim n$ 的排列 $\\pi$，以及 $q$ 个询问，每个询问包含一个整数四元组 $( l, r, x, y )$，表示查询有多少个整数二元组 $( u, v )$ 满足：\n - $l\\le u\\le v\\le r$；\n - 且对于任意 $\\forall u\\le i\\le v$，有 $x\\le\\pi_i\\le y$。", "inputFormat": "第一行，两个整数 $n$，$q$。\n\n第二行 $n$ 个整数，表示 $\\pi$。\n\n以下 $q$ 行，每行一个四元组询问。", "outputFormat": "$q$ 行，每一行表示一个询问的答案。", "hint": "子任务 1（$34$ points）：$1\\le n, q \\le 3\\times10^4$。\n\n子任务 2（$66$ points）：$1\\le n, q \\le 2\\times10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[Cnoi2019] Number Game", "background": "", "description": "Given a permutation $\\pi$ of $1 \\sim n$, and $q$ queries. Each query contains an integer quadruple $( l, r, x, y )$, asking how many integer pairs $( u, v )$ satisfy:\n- $l \\le u \\le v \\le r$;\n- and for all $\\forall u \\le i \\le v$, we have $x \\le \\pi_i \\le y$.", "inputFormat": "The first line contains two integers $n$ and $q$.\n\nThe second line contains $n$ integers, representing $\\pi$.\n\nIn the next $q$ lines, each line contains one query quadruple.", "outputFormat": "Output $q$ lines, where each line is the answer to one query.", "hint": "Subtask 1 ($34$ points): $1 \\le n, q \\le 3 \\times 10^4$.\n\nSubtask 2 ($66$ points): $1 \\le n, q \\le 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Cnoi2019] 数字游戏", "background": "", "description": "给定一个 $1\\sim n$ 的排列 $\\pi$，以及 $q$ 个询问，每个询问包含一个整数四元组 $( l, r, x, y )$，表示查询有多少个整数二元组 $( u, v )$ 满足：\n - $l\\le u\\le v\\le r$；\n - 且对于任意 $\\forall u\\le i\\le v$，有 $x\\le\\pi_i\\le y$。", "inputFormat": "第一行，两个整数 $n$，$q$。\n\n第二行 $n$ 个整数，表示 $\\pi$。\n\n以下 $q$ 行，每行一个四元组询问。", "outputFormat": "$q$ 行，每一行表示一个询问的答案。", "hint": "子任务 1（$34$ points）：$1\\le n, q \\le 3\\times10^4$。\n\n子任务 2（$66$ points）：$1\\le n, q \\le 2\\times10^5$。", "locale": "zh-CN"}}}
{"pid": "P5387", "type": "P", "difficulty": 6, "samples": [["4 5", "312"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论", "2019", "快速沃尔什变换 FWT"], "title": "[Cnoi2019] 人形演舞", "background": "由于出题人都退役了, 所以题目背景咕咕咕~了.", "description": "Cirno 与 Marisa 之间有一个博弈:\n\n首先给定 一个 **序列** $V$, 所有的数字都是在 $[1, m]$ 之间。\n\n每次一个人可以选取 $x \\in V, y \\in [1, x]$, 且 $ x \\oplus y \\in [0, x)$ , 然后把  $x$ 变为 $x \\oplus y$。\n\n$\\oplus$ 表示按位异或。\n\n当一个人不能操作时, 则视作失败。\n\n假定 Cirno 和 Marisa 都使用最优策略。\n\n现在 Cirno 想知道自己先手时获胜的方案数对 $998244353$ 取模后是多少。", "inputFormat": "一行，两个整数 $|V|, m$", "outputFormat": "一行，表示答案.", "hint": "对于 100% 的数据，$|V| \\le 10^{18}, m \\le 10^6$。\n\n采用捆绑测试。", "locale": "zh-CN", "translations": {"en": {"title": "[Cnoi2019] Humanoid Danmaku.", "background": "Since the problem setters have all retired, the background has been put off indefinitely.", "description": "There is a game between Cirno and Marisa:\n\nFirst, a **sequence** $V$ is given, and all numbers are in $[1, m]$.\n\nOn each turn, a player may choose $x \\in V$, $y \\in [1, x]$, and require that $x \\oplus y \\in [0, x)$, then change $x$ into $x \\oplus y$.\n\n$\\oplus$ denotes bitwise XOR.\n\nIf a player cannot make a move, then that player is considered to lose.\n\nAssume that both Cirno and Marisa use optimal strategies.\n\nNow Cirno wants to know, when she moves first, what is the number of winning initial sequences modulo $998244353$.", "inputFormat": "One line with two integers $|V|$ and $m$.", "outputFormat": "One line, the answer.", "hint": "For $100\\%$ of the testdata, $|V| \\le 10^{18}$ and $m \\le 10^6$.\n\nThis problem uses bundled tests.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Cnoi2019] 人形演舞", "background": "由于出题人都退役了, 所以题目背景咕咕咕~了.", "description": "Cirno 与 Marisa 之间有一个博弈:\n\n首先给定 一个 **序列** $V$, 所有的数字都是在 $[1, m]$ 之间。\n\n每次一个人可以选取 $x \\in V, y \\in [1, x]$, 且 $ x \\oplus y \\in [0, x)$ , 然后把  $x$ 变为 $x \\oplus y$。\n\n$\\oplus$ 表示按位异或。\n\n当一个人不能操作时, 则视作失败。\n\n假定 Cirno 和 Marisa 都使用最优策略。\n\n现在 Cirno 想知道自己先手时获胜的方案数对 $998244353$ 取模后是多少。", "inputFormat": "一行，两个整数 $|V|, m$", "outputFormat": "一行，表示答案.", "hint": "对于 100% 的数据，$|V| \\le 10^{18}, m \\le 10^6$。\n\n采用捆绑测试。", "locale": "zh-CN"}}}
{"pid": "P5388", "type": "P", "difficulty": 7, "samples": [["3 4", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2019", "组合数学", "快速数论变换 NTT"], "title": "[Cnoi2019] 最终幻想", "background": "理论上来说，压轴的应该是一道数据结构题，可是它咕咕咕~了.", "description": "你有一个 $n$ 维超球, 求使用 $k$ 个 $n-1$ 维超平面可以将这个 $n$ 维超球划分成多少个 $n$ 维块。\n\n答案对 $998244353$ 取模。", "inputFormat": "输入两个数 $n,k$。", "outputFormat": "一行，表示答案。", "hint": "Subtask1( 21pts ) : $n \\le 10^6$\n\nSubtask2( 7pts )   : $k \\le n$\n\nSubtask3( 72pts ) : 无特殊限制\n\n对于 100% 的数据 $n, k \\in [1,998244353)$", "locale": "zh-CN", "translations": {"en": {"title": "[Cnoi2019] Final Fantasy", "background": "In theory, the final problem should be a data structure problem, but it got delayed again and again.", "description": "You have an $n$-dimensional hypersphere. Find how many $n$-dimensional regions it can be divided into using $k$ $(n-1)$-dimensional hyperplanes.\n\nTake the answer modulo $998244353$.", "inputFormat": "Input two numbers $n, k$.", "outputFormat": "One line, the answer.", "hint": "Subtask 1 (21 pts): $n \\le 10^6$.\n\nSubtask 2 (7 pts): $k \\le n$.\n\nSubtask 3 (72 pts): No special restrictions.\n\nConstraints: For $100\\%$ of the testdata, $n, k \\in [1, 998244353)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Cnoi2019] 最终幻想", "background": "理论上来说，压轴的应该是一道数据结构题，可是它咕咕咕~了.", "description": "你有一个 $n$ 维超球, 求使用 $k$ 个 $n-1$ 维超平面可以将这个 $n$ 维超球划分成多少个 $n$ 维块。\n\n答案对 $998244353$ 取模。", "inputFormat": "输入两个数 $n,k$。", "outputFormat": "一行，表示答案。", "hint": "Subtask1( 21pts ) : $n \\le 10^6$\n\nSubtask2( 7pts )   : $k \\le n$\n\nSubtask3( 72pts ) : 无特殊限制\n\n对于 100% 的数据 $n, k \\in [1,998244353)$", "locale": "zh-CN"}}}
