{"pid": "P3573", "type": "P", "difficulty": 6, "samples": [["6 5\n1 3\n1 4\n3 6\n3 4\n4 5\n", "1 2\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "线段树", "POI（波兰）", "Special Judge", "可持久化线段树"], "title": "[POI 2014] RAJ-Rally", "background": "", "description": "  An annual bicycle rally will soon begin in Byteburg.\n\nThe bikers of Byteburg are natural long distance cyclists.\n\nLocal representatives of motorcyclists, long feuding the cyclists,  have decided to sabotage the event.\n\nThere are ![](http://main.edu.pl/images/OI21/raj-en-tex.1.png) intersections in Byteburg, connected with one way streets.\n\nStrangely enough, there are no cycles in the street network - if one can ride from  intersection ![](http://main.edu.pl/images/OI21/raj-en-tex.2.png) to intersection ![](http://main.edu.pl/images/OI21/raj-en-tex.3.png), then it is definitely impossible to get from ![](http://main.edu.pl/images/OI21/raj-en-tex.4.png) to ![](http://main.edu.pl/images/OI21/raj-en-tex.5.png).\n\nThe rally's route will lead through Byteburg's streets.\n\nThe motorcyclists plan to ride their blazing machines in the early morning of the rally day  to one intersection and completely block it.\n\nThe cyclists' association will then of course determine an alternative route  but it could happen that this new route will be relatively short,  and the cyclists will thus be unable to exhibit their remarkable endurance.\n\nClearly, this is the motorcyclists' plan - they intend to block such an intersection  that the longest route that does not pass through it is as short as \n", "inputFormat": "In the first line of the standard input, there are two integers, N and M(2<=N<=500 000,1<=M<=1 000 000), separated by a single space, that specify the number of intersections and streets in Byteburg. The intersections are numbered from   to  . The   lines that follow describe the street network: in the  -th of these lines, there are two integers, Ai, Bi(1<=Ai,Bi<=N,Ai<>Bi), separated by a single space, that signify that there is a one way street from the intersection no. Ai to the one no. Bi\n", "outputFormat": "The first and only line of the standard output should contain two integers separated by a single space.\n\nThe first of these should be the number of the intersection that the motorcyclists should block,  and the second - the maximum number of streets that the cyclists can then ride along in their rally.\n\nIf there are many solutions, your program can choose one of them arbitrarily.", "hint": "感谢@zyh2015 提供spj\n", "locale": "en", "translations": {"en": {"title": "[POI 2014] RAJ-Rally", "background": "", "description": "  An annual bicycle rally will soon begin in Byteburg.\n\nThe bikers of Byteburg are natural long distance cyclists.\n\nLocal representatives of motorcyclists, long feuding the cyclists,  have decided to sabotage the event.\n\nThere are ![](http://main.edu.pl/images/OI21/raj-en-tex.1.png) intersections in Byteburg, connected with one way streets.\n\nStrangely enough, there are no cycles in the street network - if one can ride from  intersection ![](http://main.edu.pl/images/OI21/raj-en-tex.2.png) to intersection ![](http://main.edu.pl/images/OI21/raj-en-tex.3.png), then it is definitely impossible to get from ![](http://main.edu.pl/images/OI21/raj-en-tex.4.png) to ![](http://main.edu.pl/images/OI21/raj-en-tex.5.png).\n\nThe rally's route will lead through Byteburg's streets.\n\nThe motorcyclists plan to ride their blazing machines in the early morning of the rally day  to one intersection and completely block it.\n\nThe cyclists' association will then of course determine an alternative route  but it could happen that this new route will be relatively short,  and the cyclists will thus be unable to exhibit their remarkable endurance.\n\nClearly, this is the motorcyclists' plan - they intend to block such an intersection  that the longest route that does not pass through it is as short as \n", "inputFormat": "In the first line of the standard input, there are two integers, N and M(2<=N<=500 000,1<=M<=1 000 000), separated by a single space, that specify the number of intersections and streets in Byteburg. The intersections are numbered from   to  . The   lines that follow describe the street network: in the  -th of these lines, there are two integers, Ai, Bi(1<=Ai,Bi<=N,Ai<>Bi), separated by a single space, that signify that there is a one way street from the intersection no. Ai to the one no. Bi\n", "outputFormat": "The first and only line of the standard output should contain two integers separated by a single space.\n\nThe first of these should be the number of the intersection that the motorcyclists should block,  and the second - the maximum number of streets that the cyclists can then ride along in their rally.\n\nIf there are many solutions, your program can choose one of them arbitrarily.", "hint": "感谢@zyh2015 提供spj\n", "locale": "en"}, "zh-CN": {"title": "[POI 2014] RAJ-Rally", "background": "", "description": "给定一个 $n$ 个点 $m$ 条边的有向无环图，每条边长度都是 $1$。\n\n请找到一个点，使得删掉这个点后剩余的图中的最长路径最短。", "inputFormat": "第一行包含两个正整数 $n$，$m$（$2\\le n\\le5\\times10^5$，$1\\le m\\le10^6$），表示点数、边数。\n\n接下来 $m$ 行每行包含两个正整数 $a_i,b_i$（$1\\le a_i,b_i\\le n,a_i\\ne b_i$），表示 $a_i$ 到 $b_i$ 有一条边。", "outputFormat": "包含一行两个整数 $x$，$y$，用一个空格隔开，$x$ 为要删去的点，$y$ 为删除 $x$ 后图中的最长路径的长度，如果有多组解请输出任意一组。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3574", "type": "P", "difficulty": 5, "samples": [["6\n1 8 9 6 3 2\n1 3\n2 3\n3 4\n4 5\n4 6\n", "11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2014", "POI（波兰）", "树形 DP"], "title": "[POI 2014] FAR-FarmCraft", "background": "", "description": "In a village called Byteville, there are $n$ houses connected with $n-1$ roads.\n\nFor each pair of houses, there is a unique way to get from one to another.\n\nThe houses are numbered from 1 to $n$.\n\nThe house no. 1 belongs to the village administrator Byteasar.\n\nAs part of enabling modern technologies for rural areas framework, $n$ computers have been delivered    to Byteasar's house.\n\nEvery house is to be supplied with a computer, and it is Byteasar's task to distribute them.\n\nThe citizens of Byteville have already agreed to play the most recent version of FarmCraft (the game) as soon as they have their computers.\n\nByteasar has loaded all the computers on his pickup truck and is about to set out to deliver the goods.\n\nHe has just the right amount of gasoline to drive each road twice.\n\nIn each house, Byteasar leaves one computer, and immediately continues on his route.\n\nIn each house, as soon as house dwellers get their computer, they turn it on and install FarmCraft.\n\nThe time it takes to install and set up the game very much depends on one's tech savviness, which is fortunately known for each household.\n\nAfter he delivers all the computers, Byteasar will come back to his house and install the game on his computer.\n\nThe travel time along each road linking two houses is exactly 1 minute, and (due to citizens' eagerness to play) the time to unload a computer is negligible.\n\nHelp Byteasar in determining a delivery order that allows all Byteville's citizens    (including Byteasar) to start playing together as soon as possible.\n\nIn other words, find an order that minimizes the time when everyone has FarmCraft installed.", "inputFormat": "The first line of the standard input contains a single integer $n$($2\\le n\\le 500\\ 000$) that gives the number of houses in Byteville.\n\nThe second line contains $n$ integers $c_1,c_2,\\cdots,c_n$ ($1\\le c_i\\le 10^9$),separated by single spaces; $c_i$ is the installation time (in minutes) for the dwellers of house no. i.\n\nThe next $n-1$ lines specify the roads linking the houses.\n\nEach such line contains two positive integers $a$ and $b$ ($1\\le a<b\\le n$), separated by a single space.These indicate that there is a direct road between the houses no. $a$ and $b$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer:\n\nthe (minimum) number of minutes after which all citizens will be able to play FarmCraft together.\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/6971.png) \n\n给一棵树，走过每条边需要花费一个时间，安装软件又需要花费一个时间，需要遍历整棵树并回到起点，想让所有点中到达时间+安装时间的最大值最小，问这个值是多少\n", "locale": "en", "translations": {"en": {"title": "[POI 2014] FAR-FarmCraft", "background": "", "description": "In a village called Byteville, there are $n$ houses connected with $n-1$ roads.\n\nFor each pair of houses, there is a unique way to get from one to another.\n\nThe houses are numbered from 1 to $n$.\n\nThe house no. 1 belongs to the village administrator Byteasar.\n\nAs part of enabling modern technologies for rural areas framework, $n$ computers have been delivered    to Byteasar's house.\n\nEvery house is to be supplied with a computer, and it is Byteasar's task to distribute them.\n\nThe citizens of Byteville have already agreed to play the most recent version of FarmCraft (the game) as soon as they have their computers.\n\nByteasar has loaded all the computers on his pickup truck and is about to set out to deliver the goods.\n\nHe has just the right amount of gasoline to drive each road twice.\n\nIn each house, Byteasar leaves one computer, and immediately continues on his route.\n\nIn each house, as soon as house dwellers get their computer, they turn it on and install FarmCraft.\n\nThe time it takes to install and set up the game very much depends on one's tech savviness, which is fortunately known for each household.\n\nAfter he delivers all the computers, Byteasar will come back to his house and install the game on his computer.\n\nThe travel time along each road linking two houses is exactly 1 minute, and (due to citizens' eagerness to play) the time to unload a computer is negligible.\n\nHelp Byteasar in determining a delivery order that allows all Byteville's citizens    (including Byteasar) to start playing together as soon as possible.\n\nIn other words, find an order that minimizes the time when everyone has FarmCraft installed.", "inputFormat": "The first line of the standard input contains a single integer $n$($2\\le n\\le 500\\ 000$) that gives the number of houses in Byteville.\n\nThe second line contains $n$ integers $c_1,c_2,\\cdots,c_n$ ($1\\le c_i\\le 10^9$),separated by single spaces; $c_i$ is the installation time (in minutes) for the dwellers of house no. i.\n\nThe next $n-1$ lines specify the roads linking the houses.\n\nEach such line contains two positive integers $a$ and $b$ ($1\\le a<b\\le n$), separated by a single space.These indicate that there is a direct road between the houses no. $a$ and $b$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer:\n\nthe (minimum) number of minutes after which all citizens will be able to play FarmCraft together.\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/6971.png) \n\n给一棵树，走过每条边需要花费一个时间，安装软件又需要花费一个时间，需要遍历整棵树并回到起点，想让所有点中到达时间+安装时间的最大值最小，问这个值是多少\n", "locale": "en"}, "zh-CN": {"title": "[POI 2014] FAR-FarmCraft", "background": "", "description": "在一个叫做比特村的小村庄中，有 $n-1$ 条路连接着这个村庄中的全部 $n$ 个房子。\n\n每两个房子之间都有一条唯一的通路。这些房子的编号为 $1$ 至 $n$。\n\n$1$ 号房子属于村庄的管理员比特安萨尔。\n\n为了提升村庄的科技使用水平，$n$ 台电脑被快递到了比特安萨尔的房子。每个房子都应该有一台电脑，且分发电脑的任务就落在了比特安萨尔的肩上。\n\n比特村的居民一致同意去玩农场物语这个游戏的最新快照版，而且好消息是他们很快就要得到他们最新的高配置电脑了。\n\n比特安萨尔将所有电脑都装在了他的卡车上，而且他准备好完成这个艰巨的任务了。\n\n**他的汽油恰好够走每条路两遍。**\n\n在每个房子边，比特安萨尔把电脑贴心的配送给居民，且立即前往下一个房子。（配送过程不花费任何时间）\n\n只要每间房子的居民拿到了他们的新电脑，它们就会立即开始安装农场物语。安装农场物语所用的时间根据居民的科技素养而定。幸运的是，每间房子中居民的科技素养都是已知的。\n\n在比特安萨尔配送完所有电脑后，他会回到他自己的 $1$ 号房子去安装他自己的农场物语。\n\n用卡车开过每条路的时间恰好是 $1$ 分钟，而居民开电脑箱的时间可以忽略不计。（因为他们太想玩农场物语了）\n\n请你帮助比特安萨尔算出从开始配送到所有居民都玩上了农场物语的最少时间。", "inputFormat": "第一行包含一个整数 $n(2 \\leq n \\leq 5\\times 10^5)$，代表比特村中有多少房子。\n\n第二行包含 $n$ 个整数 $c_1, c_2, ⋯, c_n(1 \\leq c_i \\leq 10^9)$，每个数都被单个空格隔开。$c_i$ 是第 $i$ 号房间中居民安装农场物语所用的时间。\n\n接下来的 $n-1$ 行代表了每一条路的两个顶点。两个顶点 $a$ 和 $b$ 满足 $1 \\leq a < b \\leq n$，两个数之间有一个空格。", "outputFormat": "一行，包含一个整数，代表题目中所说的最小时间。\n\n感谢@deadpool123 提供的翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3575", "type": "P", "difficulty": 6, "samples": [["6 4\n2 2 1 3 3 1\n3 2 4 11\n", "4\nNIE\n3\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2014", "倍增", "POI（波兰）", "栈"], "title": "[POI 2014] DOO-Around the world", "background": "", "description": "After trying hard for many years, Byteasar has finally received a pilot license.\n\nTo celebrate the fact, he intends to buy himself an airplane and fly around the planet  3-SATurn (as you may have guessed, this is the planet on which Byteotia is located).\n\nSpecifically, Byteasar plans to fly along the equator.\n\nUnfortunately, the equator is rather long, necessitating refuels.\n\n  The flight range (on full tank) of each aircraft is known.\n\nThere is a number of airports along the equator, and a plane can be refueled when it lands on one.\n\nSince buying an airplane is a big decision, Byteasar asks your help.\n\nHe is about to present you with a list of different plane models he is considering.\n\nNaturally, these differ in their flight range.\n\nFor each plane model, he would like to know the minimum number of landings  (including the final one) he would have to make in order to complete the journey.\n\nNote that for each airplane model, the journey may start at a different airport.\n\n通过几年的努力，Byteasar最终拿到了飞行员驾驶证。为了庆祝这一事实，他打算买一架飞机并且绕Byteotia星球赤道飞行一圈。但不幸的是赤道非常长所以需要中途加几次油。现在已知赤道上面所有飞机场，所有飞机从飞机场起飞降落也可以加油。因为买飞机是个十分重大的决定，Byteasar决定寻求你的帮助。他将会让你模拟不同的飞行路线。自然这些飞机一次能走的航程是不同的。对于每次模拟，他想要知道最少需要降落多少次（包括最后一次）。需要注意的是起点可以任意选取。\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $s$ ($2\\le n\\le 1\\ 000\\ 000$, $1\\le s\\le 100$),separated by a single space,  denoting the number of airports along the equator and the number of airplane models Byteasar is considering.\n\nThe second line contains $n$ positive integers $l_1,l_2,\\cdots,l_n$ ($l_1+l_2+\\cdots+l_n\\le 10^9$), separated by single spaces, specifying the distances between successive airports along the equator.\n\nThe number $l_i$ is the distance between the $i$-th and $(i+1)$-st (or $n$-th and first if $i=n$) in kilometers.\n\nThe third line contains $s$ integers $d_1,d_2,\\cdots,d_s$ ($1\\le d_i\\le l_1+l_2+\\cdots+l_n$), separated by single spaces. The number $d_i$ is the $i$-th airplane model's flight range in kilometers, i.e., the maximum distance it can fly before landing and refueling.\n", "outputFormat": "Your program should print $s$ lines to the standard output: the $i$-th of these should contain a single integer, namely, the minimum lumber of flight segments (and thus also landings) necessary to fly the $i$-th airplane around the planet 3-SATurn along the equator, starting at an airport of choice, or the word NIE (Polish for no) if it is impossible to complete the journey with this airplane.\n", "hint": "通过几年的努力，Byteasar最终拿到了飞行员驾驶证。为了庆祝这一事实，他打算买一架飞机并且绕Byteotia星球赤道飞行一圈。但不幸的是赤道非常长所以需要中途加几次油。现在已知赤道上面所有飞机场，所有飞机从飞机场起飞降落也可以加油。因为买飞机是个十分重大的决定，Byteasar决定寻求你的帮助。他将会让你模拟不同的飞行路线。自然这些飞机一次能走的航程是不同的。对于每次模拟，他想要知道最少需要降落多少次（包括最后一次）。需要注意的是起点可以任意选取。\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] DOO-Around the world", "background": "", "description": "After striving for many years, Byteasar has finally obtained a pilot license. To celebrate, he intends to buy an airplane and fly around the planet 3-SATurn (where Byteotia is located), specifically along the equator. The equator is long, so refueling is necessary.\n\nThere are airports along the equator, and a plane can refuel when it lands at one. Each airplane model has a known flight range on a full tank. Byteasar is considering several different models, which naturally differ in flight range. For each model, determine the minimum number of landings (including the final one) needed to complete a full lap along the equator, starting at an airport of choice. If it is impossible to complete the journey with a given model, report that as well. Note that the starting airport may be chosen independently for each model.", "inputFormat": "The first line contains two integers $n$ and $s$ ($2 \\le n \\le 1\\,000\\,000$, $1 \\le s \\le 100$), separated by a single space, denoting the number of airports along the equator and the number of airplane models Byteasar is considering.\n\nThe second line contains $n$ positive integers $l_1, l_2, \\cdots, l_n$ ($l_1 + l_2 + \\cdots + l_n \\le 10^9$), separated by single spaces, specifying the distances between successive airports along the equator. The number $l_i$ is the distance between the $i$-th and $(i+1)$-st airports (or between the $n$-th and the first if $i = n$), in kilometers.\n\nThe third line contains $s$ integers $d_1, d_2, \\cdots, d_s$ ($1 \\le d_i \\le l_1 + l_2 + \\cdots + l_n$), separated by single spaces. The number $d_i$ is the $i$-th airplane model’s flight range in kilometers, i.e., the maximum distance it can fly before landing and refueling.", "outputFormat": "Print $s$ lines. The $i$-th line should contain a single integer, namely, the minimum number of flight segments (and thus also landings) necessary to fly the $i$-th airplane around the planet 3-SATurn along the equator, starting at an airport of choice, or the word NIE (Polish for “no”) if it is impossible to complete the journey with this airplane.", "hint": "After several years of effort, Byteasar finally obtained a pilot license. To celebrate, he plans to buy an airplane and fly a lap around the equator of the planet Byteotia. Unfortunately, the equator is very long, so he needs to refuel en route. All airports along the equator are known, and an airplane can refuel when it lands at an airport. Because buying an airplane is a major decision, Byteasar seeks your help. He will ask you to simulate different flight routes. Naturally, different airplanes have different ranges per full tank. For each simulation, he wants to know the minimum number of landings required (including the final one). Note that the starting point can be chosen arbitrarily.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] DOO-Around the world", "background": "", "description": "After trying hard for many years, Byteasar has finally received a pilot license.\n\nTo celebrate the fact, he intends to buy himself an airplane and fly around the planet  3-SATurn (as you may have guessed, this is the planet on which Byteotia is located).\n\nSpecifically, Byteasar plans to fly along the equator.\n\nUnfortunately, the equator is rather long, necessitating refuels.\n\n  The flight range (on full tank) of each aircraft is known.\n\nThere is a number of airports along the equator, and a plane can be refueled when it lands on one.\n\nSince buying an airplane is a big decision, Byteasar asks your help.\n\nHe is about to present you with a list of different plane models he is considering.\n\nNaturally, these differ in their flight range.\n\nFor each plane model, he would like to know the minimum number of landings  (including the final one) he would have to make in order to complete the journey.\n\nNote that for each airplane model, the journey may start at a different airport.\n\n通过几年的努力，Byteasar最终拿到了飞行员驾驶证。为了庆祝这一事实，他打算买一架飞机并且绕Byteotia星球赤道飞行一圈。但不幸的是赤道非常长所以需要中途加几次油。现在已知赤道上面所有飞机场，所有飞机从飞机场起飞降落也可以加油。因为买飞机是个十分重大的决定，Byteasar决定寻求你的帮助。他将会让你模拟不同的飞行路线。自然这些飞机一次能走的航程是不同的。对于每次模拟，他想要知道最少需要降落多少次（包括最后一次）。需要注意的是起点可以任意选取。\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $s$ ($2\\le n\\le 1\\ 000\\ 000$, $1\\le s\\le 100$),separated by a single space,  denoting the number of airports along the equator and the number of airplane models Byteasar is considering.\n\nThe second line contains $n$ positive integers $l_1,l_2,\\cdots,l_n$ ($l_1+l_2+\\cdots+l_n\\le 10^9$), separated by single spaces, specifying the distances between successive airports along the equator.\n\nThe number $l_i$ is the distance between the $i$-th and $(i+1)$-st (or $n$-th and first if $i=n$) in kilometers.\n\nThe third line contains $s$ integers $d_1,d_2,\\cdots,d_s$ ($1\\le d_i\\le l_1+l_2+\\cdots+l_n$), separated by single spaces. The number $d_i$ is the $i$-th airplane model's flight range in kilometers, i.e., the maximum distance it can fly before landing and refueling.\n", "outputFormat": "Your program should print $s$ lines to the standard output: the $i$-th of these should contain a single integer, namely, the minimum lumber of flight segments (and thus also landings) necessary to fly the $i$-th airplane around the planet 3-SATurn along the equator, starting at an airport of choice, or the word NIE (Polish for no) if it is impossible to complete the journey with this airplane.\n", "hint": "通过几年的努力，Byteasar最终拿到了飞行员驾驶证。为了庆祝这一事实，他打算买一架飞机并且绕Byteotia星球赤道飞行一圈。但不幸的是赤道非常长所以需要中途加几次油。现在已知赤道上面所有飞机场，所有飞机从飞机场起飞降落也可以加油。因为买飞机是个十分重大的决定，Byteasar决定寻求你的帮助。他将会让你模拟不同的飞行路线。自然这些飞机一次能走的航程是不同的。对于每次模拟，他想要知道最少需要降落多少次（包括最后一次）。需要注意的是起点可以任意选取。\n", "locale": "zh-CN"}}}
{"pid": "P3576", "type": "P", "difficulty": 6, "samples": [["7 5 3\n3 4 1 9 11\n1 2\n1 4\n4 3\n4 5\n4 6\n6 7\n", "21\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2014", "二分", "POI（波兰）", "树形 DP"], "title": "[POI 2014] MRO-Ant colony", "background": "[English Edition](/paste/44plylwf)", "description": "正在寻找食物的蚂蚁们来到了一座山。\n\n这座山有 $n$ 个洞穴，并有 $n-1$ 条道路连接这些洞穴。也就是说，所有的洞穴和道路组成了一个树形结构。\n\n对于每个只有一条道路连接的洞穴，都有一个出入口使得该洞穴与外界相连。\n\n在**每个出入口**处，都有 $g$ 群蚂蚁，第 $i$ 群蚂蚁的大小为 $m_i$。\n\n蚂蚁群会一个接一个地进入山中，当且仅当山中没有蚂蚁，下一群蚂蚁才会进入。\n\n进入山后，蚂蚁们会按如下方式行动：\n\n- 如果蚂蚁们进入了一个洞穴，该洞穴有 $d$ 条道路与之相连（不包括它们进入该洞穴经过的道路），则蚂蚁们会分为大小相等的 $d$ 个蚁群，每个蚁群各选择一条道路，使得一个道路恰好有一条蚁群经过，特别地，如果 $d=0$（即蚁群到达了出口），蚂蚁们会从该出口离开山。\n- 根据上文，假如这个蚁群有 $x$ 只蚂蚁，则每个蚁群会有 $\\left \\lfloor \\dfrac{x}{d} \\right \\rfloor$ 只蚂蚁，多余的蚂蚁将会消失（至于怎么消失，这并不重要 :)）。\n\n下面这张图就是一个例子：大小为 $m$ 的蚁群到达了一个洞穴，该洞穴有 $3$ 条道路（除了它们进入该洞穴时经过的道路），则该蚁群分割成了三个大小为 $\\left \\lfloor \\dfrac{m}{3} \\right \\rfloor$ 的蚁群。\n\n![](https://cdn.luogu.com.cn/upload/pic/6972.png)\n\n在其中一条道路上，有一只食蚁兽，当经过该道路的蚁群大小恰好为 $k$ 时，它会把这个蚁群的蚂蚁全部吃掉。\n\n现在请你求出食蚁兽一共吃掉多少只蚂蚁。", "inputFormat": "第一行三个整数 $n, g, k$。\n\n之后一行 $g$ 个整数，分别为 $m_1, m_2,\\dots, m_g$。\n\n之后 $n-1$ 行，每行两个整数 $a, b$，表示在 $a, b$ 之间有一条边。\n\n输入的第一条边是食蚁兽所在的边。", "outputFormat": "输出一行一个整数， 表示所有被吃掉的蚁群的大小之和。", "hint": "对于 $100\\%$ 的数据，$2\\le n,g\\le10^6$，$1\\le k,m_i\\le10^9$，$1\\le a_i,b_i\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] MRO-Ant colony", "background": "[English Edition](/paste/44plylwf)", "description": "Ants searching for food have come to a mountain.\n\nThis mountain has $n$ caves and $n-1$ roads connecting these caves. In other words, all caves and roads form a tree.\n\nFor each cave that is connected by exactly one road, there is an entrance that connects that cave to the outside.\n\nAt each entrance, there are $g$ swarms of ants. The size of the $i$-th swarm is $m_i$.\n\nThe swarms enter the mountain one after another; the next swarm enters if and only if there are no ants in the mountain.\n\nOnce inside, the ants move as follows:\n- If a swarm enters a cave that is connected to $d$ roads (excluding the road they used to enter this cave), then the swarm splits into $d$ swarms of equal size, and each swarm chooses one road so that each road is taken by exactly one swarm. In particular, if $d=0$ (i.e., the swarm reaches an exit), the ants leave the mountain through that exit.\n- According to the above, if this swarm has $x$ ants, then each of the $d$ swarms has $\\left\\lfloor \\dfrac{x}{d} \\right\\rfloor$ ants, and the remaining ants disappear (how they disappear is not important :)).\n\nThe figure below shows an example: a swarm of size $m$ arrives at a cave that has $3$ roads (other than the one they came from), and the swarm splits into three swarms of size $\\left\\lfloor \\dfrac{m}{3} \\right\\rfloor$ each.\n\n![](https://cdn.luogu.com.cn/upload/pic/6972.png)\n\nOn one of the roads, there is an anteater. Whenever a swarm passing along that road has size exactly $k$, it eats that entire swarm.\n\nNow, please compute how many ants the anteater eats in total.", "inputFormat": "The first line contains three integers $n, g, k$.\n\nThe next line contains $g$ integers $m_1, m_2, \\dots, m_g$.\n\nThen follow $n-1$ lines, each containing two integers $a, b$, indicating that there is an edge between $a$ and $b$.\n\nThe first edge in the input is the edge where the anteater is located.", "outputFormat": "Output a single integer, the sum of the sizes of all eaten swarms.", "hint": "For $100\\%$ of the testdata, $2 \\le n, g \\le 10^6$, $1 \\le k, m_i \\le 10^9$, $1 \\le a_i, b_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] MRO-Ant colony", "background": "[English Edition](/paste/44plylwf)", "description": "正在寻找食物的蚂蚁们来到了一座山。\n\n这座山有 $n$ 个洞穴，并有 $n-1$ 条道路连接这些洞穴。也就是说，所有的洞穴和道路组成了一个树形结构。\n\n对于每个只有一条道路连接的洞穴，都有一个出入口使得该洞穴与外界相连。\n\n在**每个出入口**处，都有 $g$ 群蚂蚁，第 $i$ 群蚂蚁的大小为 $m_i$。\n\n蚂蚁群会一个接一个地进入山中，当且仅当山中没有蚂蚁，下一群蚂蚁才会进入。\n\n进入山后，蚂蚁们会按如下方式行动：\n\n- 如果蚂蚁们进入了一个洞穴，该洞穴有 $d$ 条道路与之相连（不包括它们进入该洞穴经过的道路），则蚂蚁们会分为大小相等的 $d$ 个蚁群，每个蚁群各选择一条道路，使得一个道路恰好有一条蚁群经过，特别地，如果 $d=0$（即蚁群到达了出口），蚂蚁们会从该出口离开山。\n- 根据上文，假如这个蚁群有 $x$ 只蚂蚁，则每个蚁群会有 $\\left \\lfloor \\dfrac{x}{d} \\right \\rfloor$ 只蚂蚁，多余的蚂蚁将会消失（至于怎么消失，这并不重要 :)）。\n\n下面这张图就是一个例子：大小为 $m$ 的蚁群到达了一个洞穴，该洞穴有 $3$ 条道路（除了它们进入该洞穴时经过的道路），则该蚁群分割成了三个大小为 $\\left \\lfloor \\dfrac{m}{3} \\right \\rfloor$ 的蚁群。\n\n![](https://cdn.luogu.com.cn/upload/pic/6972.png)\n\n在其中一条道路上，有一只食蚁兽，当经过该道路的蚁群大小恰好为 $k$ 时，它会把这个蚁群的蚂蚁全部吃掉。\n\n现在请你求出食蚁兽一共吃掉多少只蚂蚁。", "inputFormat": "第一行三个整数 $n, g, k$。\n\n之后一行 $g$ 个整数，分别为 $m_1, m_2,\\dots, m_g$。\n\n之后 $n-1$ 行，每行两个整数 $a, b$，表示在 $a, b$ 之间有一条边。\n\n输入的第一条边是食蚁兽所在的边。", "outputFormat": "输出一行一个整数， 表示所有被吃掉的蚁群的大小之和。", "hint": "对于 $100\\%$ 的数据，$2\\le n,g\\le10^6$，$1\\le k,m_i\\le10^9$，$1\\le a_i,b_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P3577", "type": "P", "difficulty": 6, "samples": [["6 6\n3 8 5 6 2 2\n1 2\n2 3\n1 3\n3 4\n4 5\n4 6\n", "7\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2014", "POI（波兰）"], "title": "[POI 2014] TUR-Tourism", "background": "", "description": "King Byteasar believes that Byteotia, a land full of beautiful sights, should attract lots of tourists,    who should spend lots of money, which should eventually find their way to the royal treasury.\n\nBut reality does not live up to his dream.\n\nSo the king instructed his councilor to look into this issue.\n\nThe councilor found out that foreigners keep away from Byteotia due to its sparse road network.\n\nLet us remark that there are $n$ towns in Byteotia, connected by $m$ two way roads, each road linking two different towns.\n\nThe roads may lead through picturesque overflies and somewhat less picturesque tunnels.\n\nThere is no guarantee that every town can be reached from every other town.\n\nThe councilor observed that the current road network does not allow for a long journey.\n\nNamely, wherever one starts the journey, it is impossible to visit more than 10 towns without passing through some town twice.\n\nDue to limited funds in the treasury, no new roads will be constructed at the time.\n\nInstead, Byteasar has decided to build a network of tourist information points (TIPs),    staffed by officers who are to advertise the short trips that are available.\n\nFor each town, there should be a TIP either in this town or one of the towns directly    linked by a road.\n\nMoreover, the cost of building the TIP is known for each town.\n\nHelp the king by finding the cheapest way of building TIPs that will satisfy aforementioned condition.\n\n", "inputFormat": "The first line of the standard input contains two integers $n$, $m$ ($2\\le n\\le 20\\ 000$ ,$0\\le m\\le 25\\ 000$), separated by a single space,    that specify the number of towns and roads in Byteotia respectively.\n\nThe towns are numbered from $1$ to $n$.\n\nThe second line of input contains $n$ integers $c_1,c_2,\\cdots,c_n$ ($0\\le c_i\\le 10\\ 000$),    separated by single spaces; the number $c_i$ specifies the cost of building a TIP in the town no. $i$.\n\nThen, a description of the Byteotian road network follows. The $i$-th of the following $m$ lines contains two integers $a_i$,$b_i$ ($1\\le a_i<b_i\\le n$), separated by a single space, that indicate that the towns no. $a_i$ and $b_i$ are linked by a road. There is at most one (direct) road between any pair of towns.\n", "outputFormat": "Your program should print out one integer to the standard output: the total cost of building all the TIPs.\n\n ![](https://cdn.luogu.com.cn/upload/pic/6974.png) \n\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2014] TUR-Tourism", "background": "", "description": "King Byteasar believes that Byteotia, a land full of beautiful sights, should attract lots of tourists,    who should spend lots of money, which should eventually find their way to the royal treasury.\n\nBut reality does not live up to his dream.\n\nSo the king instructed his councilor to look into this issue.\n\nThe councilor found out that foreigners keep away from Byteotia due to its sparse road network.\n\nLet us remark that there are $n$ towns in Byteotia, connected by $m$ two way roads, each road linking two different towns.\n\nThe roads may lead through picturesque overflies and somewhat less picturesque tunnels.\n\nThere is no guarantee that every town can be reached from every other town.\n\nThe councilor observed that the current road network does not allow for a long journey.\n\nNamely, wherever one starts the journey, it is impossible to visit more than 10 towns without passing through some town twice.\n\nDue to limited funds in the treasury, no new roads will be constructed at the time.\n\nInstead, Byteasar has decided to build a network of tourist information points (TIPs),    staffed by officers who are to advertise the short trips that are available.\n\nFor each town, there should be a TIP either in this town or one of the towns directly    linked by a road.\n\nMoreover, the cost of building the TIP is known for each town.\n\nHelp the king by finding the cheapest way of building TIPs that will satisfy aforementioned condition.\n\n", "inputFormat": "The first line of the standard input contains two integers $n$, $m$ ($2\\le n\\le 20\\ 000$ ,$0\\le m\\le 25\\ 000$), separated by a single space,    that specify the number of towns and roads in Byteotia respectively.\n\nThe towns are numbered from $1$ to $n$.\n\nThe second line of input contains $n$ integers $c_1,c_2,\\cdots,c_n$ ($0\\le c_i\\le 10\\ 000$),    separated by single spaces; the number $c_i$ specifies the cost of building a TIP in the town no. $i$.\n\nThen, a description of the Byteotian road network follows. The $i$-th of the following $m$ lines contains two integers $a_i$,$b_i$ ($1\\le a_i<b_i\\le n$), separated by a single space, that indicate that the towns no. $a_i$ and $b_i$ are linked by a road. There is at most one (direct) road between any pair of towns.\n", "outputFormat": "Your program should print out one integer to the standard output: the total cost of building all the TIPs.\n\n ![](https://cdn.luogu.com.cn/upload/pic/6974.png) \n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2014] TUR-Tourism", "background": "", "description": "国王 Byteasar 认为 Byteotia 是一个充满美丽景色的地方，应该吸引大量游客，他们应该花很多钱，这些钱最终应该流入皇家国库。\n\n但现实并没有达到他的梦想。\n\n因此，国王指示他的顾问调查这个问题。\n\n顾问发现外国人因为 Byteotia 稀疏的道路网络而避开这里。\n\n我们注意到 Byteotia 有 $n$ 个城镇，由 $m$ 条双向道路连接，每条道路连接两个不同的城镇。\n\n这些道路可能经过风景如画的高架桥和不那么美观的隧道。\n\n不能保证每个城镇都可以从其他城镇到达。\n\n顾问观察到当前的道路网络不允许进行长途旅行。\n\n也就是说，无论从哪里开始旅行，都不可能在不经过某个城镇两次的情况下访问超过 10 个城镇。\n\n由于国库资金有限，目前不会修建新的道路。\n\n相反，Byteasar 决定建立一个旅游信息点（TIPs）网络，由官员负责宣传可用的短途旅行。\n\n对于每个城镇，应该在该城镇或通过道路直接连接的城镇之一设立一个 TIP。\n\n此外，每个城镇建设 TIP 的成本是已知的。\n\n通过找到满足上述条件的最便宜的建设 TIP 的方式来帮助国王。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$（$2 \\le n \\le 20\\ 000$，$0 \\le m \\le 25\\ 000$），用一个空格分隔，分别指定 Byteotia 的城镇和道路的数量。\n\n城镇编号从 $1$ 到 $n$。\n\n输入的第二行包含 $n$ 个整数 $c_1,c_2,\\cdots,c_n$（$0 \\le c_i \\le 10\\ 000$），用空格分隔；数字 $c_i$ 指定在第 $i$ 个城镇建设 TIP 的成本。\n\n接下来是 Byteotia 道路网络的描述。接下来的 $m$ 行中的第 $i$ 行包含两个整数 $a_i$ 和 $b_i$（$1 \\le a_i < b_i \\le n$），用一个空格分隔，表示第 $a_i$ 个城镇和第 $b_i$ 个城镇之间有一条道路。任何一对城镇之间最多只有一条（直接）道路。", "outputFormat": "你的程序应输出一个整数到标准输出：建设所有 TIP 的总成本。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3578", "type": "P", "difficulty": 6, "samples": [["5\n3 1 1 3\n2 1\n1 4\n3 4\n5 6\n5 2\n1 2 1 3 2\n", "1 2 1 2 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "POI（波兰）", "树套树", "线性代数"], "title": "[POI 2014] LAM-Solar lamps", "background": "", "description": "Byteasar has a large and pretty garden.\n\nAs he would like to be able to appreciate its beauty even after dusk,he installed lamps across the garden.\n\nThe lamps are directional, i.e., they illuminate only a certain angle, common to them all.\n\nMoreover, Byteasar has aligned them so that they all face the same direction.\n\nLast but not least, these are solar lamps, i.e., they come with solar panelsbut no batteries, strangely enough!  You might think the panels are thus useless,and each lamp will require electricity at night, but not quite: A lamp will produce lightif a sufficient number of lamps illuminate it.\n\nBy now, Byteasar has even come up with an order he is going supply the lamps with electricity,thus turning them on.\n\nFor simplicity, we number the lamps from 1 to $n$ in this order, i.e., the lamp no. $i$ is supplied with electricity at time $i$.  The only thing left for Byteasar (and you, of course!) is tofigure out when exactly each lamp will start emitting light.  Help Byteasar by writing a programthat will determine the answer to this question.\n\n给N盏灯，没盏灯能照到的角度范围是相同的，第i盏灯在第i秒或者被ki盏灯照到后都会亮起，问所有灯都在什么时刻亮起\n", "inputFormat": "The first line of the standard input contains a single integer $n$($1\\le n\\le 200\\ 000$): the number of lamps Byteasar installed.\n\nIn the second line of input, there are four integers $X_1,Y_1,X_2,Y_2$ ($-10^9\\le X_i,Y_i\\le 10^9$, $(X_i,Y_i)\\ne(0,0)$), separated by single spaces,that describe the area illuminated by every lamp.\n\nNamely, if there is a lamp located at the point $(x,y)$, then it illuminatesthe area (together with its edge) within the smaller of the two angles formed by tworays that both originate at $(x,y)$ such that the i-th (for $i=1,2$) ray passes through $(x+X_i,y+Y_i)$. This angle is always smaller than 180 degrees.\n\nThe $n$ input lines that follow specify the locations of the lamps: the $i$-th such line contains two integers $x_i,y_i$ ($-10^9\\le x_i,y_i\\le 10^9$) separated by a single space, that indicate that the lamp no.$i$ is located at the point $(x_i,y_i)$. You may assume that no two lamps share their location.\n\nThe last line of the input contains $n$ integers $k_1,k_2,\\cdots,k_n$ ($1\\le k_i\\le n$), separated by single spaces, that signify that if the lamp no. i is in the area illuminated by at least $k_i$ other lamps, then it will start emitting light as well.\n", "outputFormat": "Your program should print out to the standard output a single line with $n$ integers $t_1,t_2,\\cdots,t_n$, separated by single spaces.\n\nThe number $t_i$ should be the time when the lamp no. $i$ starts producing light.\n", "hint": "给N盏灯，没盏灯能照到的角度范围是相同的，第i盏灯在第i秒或者被ki盏灯照到后都会亮起，问所有灯都在什么时刻亮起\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] LAM-Solar lamps", "background": "", "description": "Byteasar has a large and pretty garden.\n\nAs he would like to be able to appreciate its beauty even after dusk, he installed lamps across the garden.\n\nThe lamps are directional, i.e., they illuminate only a certain angle, common to them all. Moreover, Byteasar has aligned them so that they all face the same direction.\n\nLast but not least, these are solar lamps, i.e., they come with solar panels but no batteries, strangely enough! You might think the panels are thus useless, and each lamp will require electricity at night, but not quite: a lamp will produce light if a sufficient number of lamps illuminate it.\n\nBy now, Byteasar has even come up with an order in which he is going to supply the lamps with electricity, thus turning them on. For simplicity, we number the lamps from 1 to $n$ in this order, i.e., lamp no. $i$ is supplied with electricity at time $i$. The only thing left for Byteasar (and you, of course!) is to figure out when exactly each lamp will start emitting light. Help Byteasar by writing a program that determines the answer to this question.", "inputFormat": "The first line contains a single integer $n$ ($1 \\le n \\le 200\\,000$): the number of lamps Byteasar installed.\n\nThe second line contains four integers $X_1, Y_1, X_2, Y_2$ ($-10^9 \\le X_i, Y_i \\le 10^9$, $(X_i, Y_i) \\ne (0, 0)$), separated by single spaces, that describe the area illuminated by every lamp.\n\nNamely, if there is a lamp located at the point $(x, y)$, then it illuminates the area (together with its edge) within the smaller of the two angles formed by two rays that both originate at $(x, y)$ such that the $i$-th (for $i = 1, 2$) ray passes through $(x + X_i, y + Y_i)$. This angle is always smaller than 180 degrees.\n\nEach of the next $n$ lines specifies the location of a lamp: the $i$-th such line contains two integers $x_i, y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$), separated by a single space, indicating that lamp no. $i$ is located at the point $(x_i, y_i)$. You may assume that no two lamps share their location.\n\nThe last line contains $n$ integers $k_1, k_2, \\cdots, k_n$ ($1 \\le k_i \\le n$), separated by single spaces, signifying that if lamp no. $i$ is in the area illuminated by at least $k_i$ other lamps, then it will start emitting light as well.", "outputFormat": "Print a single line with $n$ integers $t_1, t_2, \\cdots, t_n$, separated by single spaces.\n\nThe number $t_i$ should be the time when lamp no. $i$ starts producing light.", "hint": "There are $n$ lamps. Each lamp has the same angular illumination range and faces the same direction. Lamp $i$ lights up at time $i$, or earlier if it is illuminated by at least $k_i$ other lamps. Determine the time when each lamp lights up.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] LAM-Solar lamps", "background": "", "description": "Byteasar has a large and pretty garden.\n\nAs he would like to be able to appreciate its beauty even after dusk,he installed lamps across the garden.\n\nThe lamps are directional, i.e., they illuminate only a certain angle, common to them all.\n\nMoreover, Byteasar has aligned them so that they all face the same direction.\n\nLast but not least, these are solar lamps, i.e., they come with solar panelsbut no batteries, strangely enough!  You might think the panels are thus useless,and each lamp will require electricity at night, but not quite: A lamp will produce lightif a sufficient number of lamps illuminate it.\n\nBy now, Byteasar has even come up with an order he is going supply the lamps with electricity,thus turning them on.\n\nFor simplicity, we number the lamps from 1 to $n$ in this order, i.e., the lamp no. $i$ is supplied with electricity at time $i$.  The only thing left for Byteasar (and you, of course!) is tofigure out when exactly each lamp will start emitting light.  Help Byteasar by writing a programthat will determine the answer to this question.\n\n给N盏灯，没盏灯能照到的角度范围是相同的，第i盏灯在第i秒或者被ki盏灯照到后都会亮起，问所有灯都在什么时刻亮起\n", "inputFormat": "The first line of the standard input contains a single integer $n$($1\\le n\\le 200\\ 000$): the number of lamps Byteasar installed.\n\nIn the second line of input, there are four integers $X_1,Y_1,X_2,Y_2$ ($-10^9\\le X_i,Y_i\\le 10^9$, $(X_i,Y_i)\\ne(0,0)$), separated by single spaces,that describe the area illuminated by every lamp.\n\nNamely, if there is a lamp located at the point $(x,y)$, then it illuminatesthe area (together with its edge) within the smaller of the two angles formed by tworays that both originate at $(x,y)$ such that the i-th (for $i=1,2$) ray passes through $(x+X_i,y+Y_i)$. This angle is always smaller than 180 degrees.\n\nThe $n$ input lines that follow specify the locations of the lamps: the $i$-th such line contains two integers $x_i,y_i$ ($-10^9\\le x_i,y_i\\le 10^9$) separated by a single space, that indicate that the lamp no.$i$ is located at the point $(x_i,y_i)$. You may assume that no two lamps share their location.\n\nThe last line of the input contains $n$ integers $k_1,k_2,\\cdots,k_n$ ($1\\le k_i\\le n$), separated by single spaces, that signify that if the lamp no. i is in the area illuminated by at least $k_i$ other lamps, then it will start emitting light as well.\n", "outputFormat": "Your program should print out to the standard output a single line with $n$ integers $t_1,t_2,\\cdots,t_n$, separated by single spaces.\n\nThe number $t_i$ should be the time when the lamp no. $i$ starts producing light.\n", "hint": "给N盏灯，没盏灯能照到的角度范围是相同的，第i盏灯在第i秒或者被ki盏灯照到后都会亮起，问所有灯都在什么时刻亮起\n", "locale": "zh-CN"}}}
{"pid": "P3579", "type": "P", "difficulty": 5, "samples": [["4\n3 9 8 8\n1 10 11 15\n4 7 22 23\n2 5 19 24\n", "8\n7\n2\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2014", "POI（波兰）", "最大公约数 gcd", "整除分块"], "title": "[POI 2014] PAN-Solar Panels", "background": "", "description": "对于 $n$ 组询问，每组询问给定四个整数 $a,b,c,d$，从区间 $[a,b]$ 和 $[c,d]$ 中任意选取两个整数 $x$ 和 $y$，求 $\\gcd(x,y)$ 的最大值是多少。", "inputFormat": "第一行一个整数 $n$ 代表询问数。   \n接下来 $n$ 行每行代表一个询问，四个整数 $a,b,c,d$ 代表两个区间的范围。", "outputFormat": "$n$ 行每行一个整数代表区间 $[a,b]$ 和 $[c,d]$ 中任意选取两个整数 $x$ 和 $y$，$\\gcd(x,y)$ 的最大值。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000$，$1 \\le a \\le b \\le 10^9$，$1 \\le c\\le d \\le 10^9$。\n\n### 说明\n\nTranslated by @一只书虫仔。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] PAN-Solar Panels", "background": "", "description": "For $n$ queries, each query is given four integers $a, b, c, d$. Choose any two integers $x$ and $y$ from the intervals $[a, b]$ and $[c, d]$, respectively, and find the maximum possible value of $\\gcd(x, y)$.", "inputFormat": "The first line contains an integer $n$ representing the number of queries.  \nThe next $n$ lines each contain a query: four integers $a, b, c, d$ specifying the two intervals.", "outputFormat": "Output $n$ lines, each containing a single integer: the maximum possible value of $\\gcd(x, y)$ when choosing $x$ from $[a, b]$ and $y$ from $[c, d]$.", "hint": "### Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 1000$, $1 \\le a \\le b \\le 10^9$, $1 \\le c \\le d \\le 10^9$.\n\n### Notes\n\nTranslated by @一只书虫仔。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] PAN-Solar Panels", "background": "", "description": "对于 $n$ 组询问，每组询问给定四个整数 $a,b,c,d$，从区间 $[a,b]$ 和 $[c,d]$ 中任意选取两个整数 $x$ 和 $y$，求 $\\gcd(x,y)$ 的最大值是多少。", "inputFormat": "第一行一个整数 $n$ 代表询问数。   \n接下来 $n$ 行每行代表一个询问，四个整数 $a,b,c,d$ 代表两个区间的范围。", "outputFormat": "$n$ 行每行一个整数代表区间 $[a,b]$ 和 $[c,d]$ 中任意选取两个整数 $x$ 和 $y$，$\\gcd(x,y)$ 的最大值。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000$，$1 \\le a \\le b \\le 10^9$，$1 \\le c\\le d \\le 10^9$。\n\n### 说明\n\nTranslated by @一只书虫仔。", "locale": "zh-CN"}}}
{"pid": "P3580", "type": "P", "difficulty": 6, "samples": [["3 4\n1 8 11\n", "20\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2014", "二分", "树状数组", "POI（波兰）"], "title": "[POI 2014] ZAL-Freight", "background": "", "description": "The train stations in Upper Bytown and Lower Bytown are connected with a single track rail link.\n\nIt takes the train $s$ minutes to travel between them in either direction.\n\nHowever, the trains departing a station have to be spaced at least one minute apart.\n\nMoreover, at all times, all the trains on the rail link have to go in the same direction.\n\nAccording to the timetable at our disposal, $n$ cargo trains destined for Lower Bytown are to pass  through the Upper Bytown.  They are to be loaded with goods in Lower Bytown and then return to  Upper Bytown.  For simplicity, we assume that loading the goods on the train takes virtually no time.\n\nWe are to determine the minimum possible time of the last train returning to Upper Bytown.\n\n有两个城镇，从A到B需要的时间为S，然后有N辆列车需要从A到B再回来，任何时刻铁路上只能有向着同一个方向前进的列车，然后每辆列车有一个从A出发的最早出站时间，问所有列车全部回到A站的最早时间\n", "inputFormat": "The first line of the standard input contains two integers $n$, $s$($1\\le n\\le 1\\ 000\\ 000$, $1\\le s\\le 10^9$),    separated by a single space, that specify the number of trains and the one-way travel time respectively.\n\nThe second line contains $n$ integers $t_1,t_2,\\cdots,t_n$ ($0\\le t_1\\le t_2\\le\\cdots\\le t_n\\le 10^9$),separated by a single space, that specify the arrival times of successive trains at the Upper Bytown station.\n", "outputFormat": "Your program should print out a single line with a single integer to the standard output:\n\nthe minimum possible time of the last train returning to Upper Bytown.\n", "hint": "\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] ZAL-Freight", "background": "", "description": "The train stations in Upper Bytown and Lower Bytown are connected with a single-track rail link.\n\nIt takes the train $s$ minutes to travel between them in either direction.\n\nHowever, the trains departing a station have to be spaced at least one minute apart.\n\nMoreover, at all times, all the trains on the rail link have to go in the same direction.\n\nAccording to the timetable at our disposal, $n$ cargo trains destined for Lower Bytown are to pass through Upper Bytown. They are to be loaded with goods in Lower Bytown and then return to Upper Bytown. For simplicity, we assume that loading the goods on the train takes virtually no time.\n\nWe are to determine the minimum possible time of the last train returning to Upper Bytown.\n\nIn summary: there are two towns. It takes $s$ minutes to go from A to B. There are $n$ trains that need to go from A to B and then come back. At any moment, only trains moving in the same direction may be on the track. Each train has an earliest departure time from A. Find the earliest time by which all trains have returned to station A.", "inputFormat": "The first line of the standard input contains two integers $n$, $s$ ($1\\le n\\le 1\\ 000\\ 000$, $1\\le s\\le 10^9$), separated by a single space, that specify the number of trains and the one-way travel time respectively.\n\nThe second line contains $n$ integers $t_1,t_2,\\cdots,t_n$ ($0\\le t_1\\le t_2\\le\\cdots\\le t_n\\le 10^9$), separated by a single space, that specify the arrival times of successive trains at the Upper Bytown station.", "outputFormat": "Print a single integer: the minimum possible time of the last train returning to Upper Bytown.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] ZAL-Freight", "background": "", "description": "The train stations in Upper Bytown and Lower Bytown are connected with a single track rail link.\n\nIt takes the train $s$ minutes to travel between them in either direction.\n\nHowever, the trains departing a station have to be spaced at least one minute apart.\n\nMoreover, at all times, all the trains on the rail link have to go in the same direction.\n\nAccording to the timetable at our disposal, $n$ cargo trains destined for Lower Bytown are to pass  through the Upper Bytown.  They are to be loaded with goods in Lower Bytown and then return to  Upper Bytown.  For simplicity, we assume that loading the goods on the train takes virtually no time.\n\nWe are to determine the minimum possible time of the last train returning to Upper Bytown.\n\n有两个城镇，从A到B需要的时间为S，然后有N辆列车需要从A到B再回来，任何时刻铁路上只能有向着同一个方向前进的列车，然后每辆列车有一个从A出发的最早出站时间，问所有列车全部回到A站的最早时间\n", "inputFormat": "The first line of the standard input contains two integers $n$, $s$($1\\le n\\le 1\\ 000\\ 000$, $1\\le s\\le 10^9$),    separated by a single space, that specify the number of trains and the one-way travel time respectively.\n\nThe second line contains $n$ integers $t_1,t_2,\\cdots,t_n$ ($0\\le t_1\\le t_2\\le\\cdots\\le t_n\\le 10^9$),separated by a single space, that specify the arrival times of successive trains at the Upper Bytown station.\n", "outputFormat": "Your program should print out a single line with a single integer to the standard output:\n\nthe minimum possible time of the last train returning to Upper Bytown.\n", "hint": "\n", "locale": "zh-CN"}}}
{"pid": "P3581", "type": "P", "difficulty": 7, "samples": [["5 2 3\n1 3\n5 4", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2015", "POI（波兰）", "哈希 hashing"], "title": "[POI 2015 R1] 圆桌巫师 Sorcerers of the Round Table", "background": "", "description": "$n$ 个人（编号为 $1 \\sim n$）围着圆桌坐成一圈。座位相邻的两个人，其编号之差的绝对值不可以超过 $p$。他们之中有些人不喜欢别人。如果 $a$ 不喜欢 $b$，那么 $b$ 不能坐在 $a$ 右边的那一个位置上。现在，假设第 $n$ 个人的座位已经固定，要给剩下的人安排座位，共有几种合法方案？", "inputFormat": "第一行包含三个整数 $n,k,p$（$1\\le n\\le {10}^6$，$0\\le k\\le {10}^5$，$0\\le p\\le 3$）。接下来 $k$ 行，每行含两个整数 $a_i, b_i$（$1\\le a_i, b_i \\le n$，$a_i \\neq b_i$），表示 $a_i$ 不喜欢 $b_i$。同一组 $a_i,b_i$ 不会重复输入。\n", "outputFormat": "输出一个整数，表示方案数模 ${10}^9+7$ 后的值。", "hint": "原题名称：Czarnoksiężnicy okrągłego stołu。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R1] Sorcerers of the Round Table", "background": "", "description": "There are $n$ people (numbered $1 \\sim n$) sitting in a circle around a round table. For any two people sitting in adjacent seats, the absolute difference of their numbers must not exceed $p$. Among them, some people dislike others. If $a$ dislikes $b$, then $b$ cannot sit in the seat immediately to the right of $a$. Now, assuming the seat of person $n$ has been fixed, how many valid seating arrangements are there for the remaining people?", "inputFormat": "The first line contains three integers $n,k,p$ ($1\\le n\\le {10}^6$, $0\\le k\\le {10}^5$, $0\\le p\\le 3$).  \nThe next $k$ lines each contain two integers $a_i, b_i$ ($1\\le a_i, b_i \\le n$, $a_i \\neq b_i$), meaning $a_i$ dislikes $b_i$. The same pair $a_i,b_i$ will not be repeated.", "outputFormat": "Output a single integer, which is the number of valid arrangements modulo ${10}^9+7$.", "hint": "Original title: Czarnoksiężnicy okrągłego stołu.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R1] 圆桌巫师 Sorcerers of the Round Table", "background": "", "description": "$n$ 个人（编号为 $1 \\sim n$）围着圆桌坐成一圈。座位相邻的两个人，其编号之差的绝对值不可以超过 $p$。他们之中有些人不喜欢别人。如果 $a$ 不喜欢 $b$，那么 $b$ 不能坐在 $a$ 右边的那一个位置上。现在，假设第 $n$ 个人的座位已经固定，要给剩下的人安排座位，共有几种合法方案？", "inputFormat": "第一行包含三个整数 $n,k,p$（$1\\le n\\le {10}^6$，$0\\le k\\le {10}^5$，$0\\le p\\le 3$）。接下来 $k$ 行，每行含两个整数 $a_i, b_i$（$1\\le a_i, b_i \\le n$，$a_i \\neq b_i$），表示 $a_i$ 不喜欢 $b_i$。同一组 $a_i,b_i$ 不会重复输入。\n", "outputFormat": "输出一个整数，表示方案数模 ${10}^9+7$ 后的值。", "hint": "原题名称：Czarnoksiężnicy okrągłego stołu。", "locale": "zh-CN"}}}
{"pid": "P3582", "type": "P", "difficulty": 5, "samples": [["9 4\n2 3 1 1 4 1 2 4 1\n5 3 6 6", "15"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "线段树", "POI（波兰）", "扫描线"], "title": "[POI 2015 R1] 影迷 Movie-goer", "background": "", "description": "共有 $m$ 部电影，编号为 $1,2,\\ldots,m$，第 $i$ 部电影的好看值为 $w_i$。\n\n在 $n$ 天之中，每天会放映一部电影，第 $i$ 天放映的是第 $f_i$ 部。\n\n你可以选择 $l,r$（$1\\le l\\le r\\le n$），并观看第 $l,l+1,\\ldots,r$ 天内所有的电影。\n\n但如果同一部电影你观看多于一次，你会感到无聊，于是无法获得这部电影的好看值。\n\n现在，您需要最大化观看且仅观看过一次的电影的好看值的总和。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行包含 $n$ 个整数，第 $i$ 个表示 $f_i$。\n\n第三行包含 $m$ 个整数，第 $i$ 个表示 $w_i$。", "outputFormat": "一行一个整数，表示仅观看过一次的电影的好看值的总和的最大值。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le m\\le n\\le 10^6$，$1\\le f_i\\le m$，$1\\le w_i\\le 10^6$。\n\n----\n\n原题名称：Kinoman。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R1] Movie-goer", "background": "", "description": "There are $m$ movies, numbered $1, 2, \\ldots, m$. The $i$-th movie has value $w_i$.\n\nOver $n$ days, exactly one movie is shown per day; on day $i$, movie $f_i$ is shown.\n\nYou may choose $l, r$ ($1 \\le l \\le r \\le n$) and watch all movies shown on days $l, l+1, \\ldots, r$.\n\nHowever, if you watch the same movie more than once, you get bored and therefore cannot obtain this movie’s value.\n\nNow you need to maximize the total value of the movies that are watched exactly once.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe second line contains $n$ integers; the $i$-th is $f_i$.\n\nThe third line contains $m$ integers; the $i$-th is $w_i$.", "outputFormat": "Print one integer, the maximum possible sum of values of movies watched exactly once.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le m \\le n \\le 10^6$, $1 \\le f_i \\le m$, and $1 \\le w_i \\le 10^6$.\n\n----\n\nOriginal problem name: Kinoman.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R1] 影迷 Movie-goer", "background": "", "description": "共有 $m$ 部电影，编号为 $1,2,\\ldots,m$，第 $i$ 部电影的好看值为 $w_i$。\n\n在 $n$ 天之中，每天会放映一部电影，第 $i$ 天放映的是第 $f_i$ 部。\n\n你可以选择 $l,r$（$1\\le l\\le r\\le n$），并观看第 $l,l+1,\\ldots,r$ 天内所有的电影。\n\n但如果同一部电影你观看多于一次，你会感到无聊，于是无法获得这部电影的好看值。\n\n现在，您需要最大化观看且仅观看过一次的电影的好看值的总和。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行包含 $n$ 个整数，第 $i$ 个表示 $f_i$。\n\n第三行包含 $m$ 个整数，第 $i$ 个表示 $w_i$。", "outputFormat": "一行一个整数，表示仅观看过一次的电影的好看值的总和的最大值。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le m\\le n\\le 10^6$，$1\\le f_i\\le m$，$1\\le w_i\\le 10^6$。\n\n----\n\n原题名称：Kinoman。", "locale": "zh-CN"}}}
{"pid": "P3583", "type": "P", "difficulty": 7, "samples": [["30", "4 15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2015", "POI（波兰）"], "title": "[POI 2015 R1] 平方和 Squares", "background": "", "description": "考虑将正整数 $n$ 拆分成几个不同的平方数之和，比如 $30 = 1^2 + 2^2 + 5^2 = 1^2 + 2^2 + 3^2 + 4^2$，而 $8$ 不存在这样的拆分。\n\n用 $k(n)$ 表示 $n$ 的拆分中，最大的底数最小可能是多少。如果 $n$ 不存在这样的拆分，则令 $k(n) = \\infty$。例如：$k(1) = 1$，$k(8) = \\infty$，$k(378) = 12$，$k(380) = 10$。\n\n定义一个数 $x$ 被称为“超重”的，当且仅当存在 $y > x$，使得 $k(y) < k(x)$。从上面的例子可知，$378$ 是一个“超重”的数。\n\n给定 $n$，你需要：\n\n1. 求出 $k(n)$。\n2. 求出 $1 \\sim n$ 中有几个“超重”的数。", "inputFormat": "输入仅一行，包含一个正整数 $n$。", "outputFormat": "输出一行包含两个整数，分别为对上述两个问题的答案。如果 $k(n) = \\infty$，则输出一个减号 `-` 代替。", "hint": "**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le {10}^{18}$。\n\n----\n\n原题名称：Kwadraty。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R1] Sum of Squares", "background": "", "description": "Consider expressing a positive integer $n$ as a sum of several distinct squares. For example, $30 = 1^2 + 2^2 + 5^2 = 1^2 + 2^2 + 3^2 + 4^2$, while $8$ has no such decomposition.\n\nLet $k(n)$ denote the minimal possible value of the largest base among all such decompositions of $n$. If no such decomposition exists, set $k(n) = \\infty$. For example: $k(1) = 1$, $k(8) = \\infty$, $k(378) = 12$, $k(380) = 10$.\n\nA number $x$ is called \"overweight\" if and only if there exists $y > x$ such that $k(y) < k(x)$. From the examples above, $378$ is an \"overweight\" number.\n\nGiven $n$, you need to:\n1. Compute $k(n)$.\n2. Count how many \"overweight\" numbers are in the range from $1$ to $n$.", "inputFormat": "The input contains a single line with a positive integer $n$.", "outputFormat": "Output one line containing two integers, which are the answers to the two questions above. If $k(n) = \\infty$, output a minus sign `-` instead.", "hint": "Constraints\n\nFor 100 % of the testdata, $1 \\le n \\le 10^{18}$.\n\nOriginal title: Kwadraty.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R1] 平方和 Squares", "background": "", "description": "考虑将正整数 $n$ 拆分成几个不同的平方数之和，比如 $30 = 1^2 + 2^2 + 5^2 = 1^2 + 2^2 + 3^2 + 4^2$，而 $8$ 不存在这样的拆分。\n\n用 $k(n)$ 表示 $n$ 的拆分中，最大的底数最小可能是多少。如果 $n$ 不存在这样的拆分，则令 $k(n) = \\infty$。例如：$k(1) = 1$，$k(8) = \\infty$，$k(378) = 12$，$k(380) = 10$。\n\n定义一个数 $x$ 被称为“超重”的，当且仅当存在 $y > x$，使得 $k(y) < k(x)$。从上面的例子可知，$378$ 是一个“超重”的数。\n\n给定 $n$，你需要：\n\n1. 求出 $k(n)$。\n2. 求出 $1 \\sim n$ 中有几个“超重”的数。", "inputFormat": "输入仅一行，包含一个正整数 $n$。", "outputFormat": "输出一行包含两个整数，分别为对上述两个问题的答案。如果 $k(n) = \\infty$，则输出一个减号 `-` 代替。", "hint": "**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le {10}^{18}$。\n\n----\n\n原题名称：Kwadraty。", "locale": "zh-CN"}}}
{"pid": "P3584", "type": "P", "difficulty": 5, "samples": [["5\n5 3 7 2 9\n", "2 3 3 5 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2015", "POI（波兰）", "Special Judge"], "title": "[POI 2015 R1] 贪吃鬼 Gluttons", "background": "", "description": "圆桌上摆放着 $n$ 份食物，围成一圈，第 $i$ 份食物所含热量为 $c_i$。相邻两份食物之间坐着一个人，共有 $n$ 个人。每个人有两种选择，吃自己左边或者右边的食物。如果两个人选择了同一份食物，这两个人会平分这份食物，每人获得一半的热量。 假如某个人改变自己的选择后（其他 $n-1$ 个人的选择不变），可以使自己获得比原先更多的热量，那么这个人会不满意。请你给每个人指定应该吃哪一份食物，使得所有人都能够满意。", "inputFormat": "第一行一个整数 $n$，表示食物的数量（即人数，食物和人都从 $1\\sim n$ 编号）。  \n第二行包含 $n$ 个整数 $c_1,c_2,\\dots,c_n$。这里约定，第 $i$（$1\\le i<n$）个人左边是第 $i$ 份食物，右边是第 $i+1$ 份食物；而第 $n$ 个人左边是第 $n$ 份食物，右边是第 $1$ 份食物。", "outputFormat": "如果不存在这样的方案，仅输出一行 `NIE`。  \n如果存在这样的方案，输出一行共 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个人选择的食物的编号。如果有多组这样的方案，输出任意一个即可。", "hint": "**【数据范围】**\n\n对于所有数据，$2\\leqslant n\\leqslant 10^6$，$1\\leqslant c_i\\leqslant 10^9$。\n\n----\n\n原题名称：Łasuchy\n\n感谢 @KSkun 为本题提供 SPJ。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R1] Gluttons", "background": "", "description": "There are $n$ dishes placed around a round table, forming a circle. The $i$-th dish contains $c_i$ calories. Between every pair of adjacent dishes sits one person, so there are $n$ people in total. Each person can choose to eat either the dish on their left or the dish on their right. If two people choose the same dish, they split it equally, and each receives half of that dish’s calories. If a person can obtain strictly more calories than before by changing only their own choice (while the choices of the other $n-1$ people remain unchanged), then that person is dissatisfied. Please assign which dish each person should eat so that everyone is satisfied.", "inputFormat": "The first line contains an integer $n$, the number of dishes (which is also the number of people; both dishes and people are numbered from $1$ to $n$).  \nThe second line contains $n$ integers $c_1, c_2, \\dots, c_n$. We stipulate that for person $i$ ($1 \\le i < n$), the dish on the left is dish $i$, and the dish on the right is dish $i+1$; for person $n$, the dish on the left is dish $n$, and the dish on the right is dish $1$.", "outputFormat": "If no such assignment exists, output a single line NIE.  \nIf such an assignment exists, output one line with $n$ integers, where the $i$-th integer is the index of the dish chosen by person $i$. If multiple valid assignments exist, output any one of them.", "hint": "Constraints\n\nFor all testdata, $2 \\leqslant n \\leqslant 10^6$, $1 \\leqslant c_i \\leqslant 10^9$.\n\n----\n\nOriginal title: Łasuchy.\n\nThanks to @KSkun for providing the SPJ for this problem.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R1] 贪吃鬼 Gluttons", "background": "", "description": "圆桌上摆放着 $n$ 份食物，围成一圈，第 $i$ 份食物所含热量为 $c_i$。相邻两份食物之间坐着一个人，共有 $n$ 个人。每个人有两种选择，吃自己左边或者右边的食物。如果两个人选择了同一份食物，这两个人会平分这份食物，每人获得一半的热量。 假如某个人改变自己的选择后（其他 $n-1$ 个人的选择不变），可以使自己获得比原先更多的热量，那么这个人会不满意。请你给每个人指定应该吃哪一份食物，使得所有人都能够满意。", "inputFormat": "第一行一个整数 $n$，表示食物的数量（即人数，食物和人都从 $1\\sim n$ 编号）。  \n第二行包含 $n$ 个整数 $c_1,c_2,\\dots,c_n$。这里约定，第 $i$（$1\\le i<n$）个人左边是第 $i$ 份食物，右边是第 $i+1$ 份食物；而第 $n$ 个人左边是第 $n$ 份食物，右边是第 $1$ 份食物。", "outputFormat": "如果不存在这样的方案，仅输出一行 `NIE`。  \n如果存在这样的方案，输出一行共 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个人选择的食物的编号。如果有多组这样的方案，输出任意一个即可。", "hint": "**【数据范围】**\n\n对于所有数据，$2\\leqslant n\\leqslant 10^6$，$1\\leqslant c_i\\leqslant 10^9$。\n\n----\n\n原题名称：Łasuchy\n\n感谢 @KSkun 为本题提供 SPJ。", "locale": "zh-CN"}}}
{"pid": "P3585", "type": "P", "difficulty": 3, "samples": [["2\n3 4 4 2\nxx..\n.xx.\nxx..\nx.\n.x\nx.\n..\n2 2 2 2\nxx\nxx\n.x\nx.\n", "TAK\nNIE\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2015", "POI（波兰）"], "title": "[POI 2015 R1] 印章 Seal", "background": "", "description": "一张 $n\\times m$ 的方格纸，有些格子需要印成黑色，剩下的格子需要保留白色。\n\n你有一个 $a\\times b$ 的印章，有些格子是凸起（会沾上墨水）的。你需要判断能否用这个印章印出纸上的图案。印的过程中需要满足以下要求： \n\n1. 印章不可以旋转。 \n2. 不能把墨水印到纸外面。 \n3. 纸上的同一个格子不可以印多次。 ", "inputFormat": "第一行一个整数 $q$（$1\\leq q\\leq 10$），表示测试点数量。 \n\n接下来 $q$ 个测试点，每个测试点中： \n\n第一行包含 $4$ 个整数 $n,m,a,b$（$1\\leq n,m,a,b\\leq 10^3$）。 \n\n接下来 $n$ 行，每行 $m$ 个字符，描述纸上的图案。`.` 表示留白，`x` 表示需要染黑。 \n\n接下来 $a$ 行，每行 $b$ 个字符，描述印章。`.` 表示不沾墨水，`x` 表示沾墨水。 ", "outputFormat": "对于每个测试点，输出 `TAK`（是）或 `NIE`（否）。 ", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R1] Seal", "background": "", "description": "On an $n\\times m$ grid paper, some cells should be stamped black, and the remaining cells should be left white.\n\nYou have an $a\\times b$ stamp in which some cells are raised (will pick up ink). Determine whether you can use this stamp to produce the pattern on the paper, under the following rules:\n1. The stamp cannot be rotated.\n2. You cannot stamp outside the paper.\n3. No cell on the paper may be stamped more than once.", "inputFormat": "The first line contains an integer $q$ ($1\\leq q\\leq 10$), the number of test cases.\n\nThen for each of the $q$ test cases:\n- The first line contains $4$ integers $n, m, a, b$ ($1\\leq n, m, a, b\\leq 10^3$).\n- The next $n$ lines, each with $m$ characters, describe the target pattern on the paper. `.` means blank, `x` means black.\n- The next $a$ lines, each with $b$ characters, describe the stamp. `.` means not inked, `x` means inked.", "outputFormat": "For each test case, output `TAK` (yes) or `NIE` (no).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R1] 印章 Seal", "background": "", "description": "一张 $n\\times m$ 的方格纸，有些格子需要印成黑色，剩下的格子需要保留白色。\n\n你有一个 $a\\times b$ 的印章，有些格子是凸起（会沾上墨水）的。你需要判断能否用这个印章印出纸上的图案。印的过程中需要满足以下要求： \n\n1. 印章不可以旋转。 \n2. 不能把墨水印到纸外面。 \n3. 纸上的同一个格子不可以印多次。 ", "inputFormat": "第一行一个整数 $q$（$1\\leq q\\leq 10$），表示测试点数量。 \n\n接下来 $q$ 个测试点，每个测试点中： \n\n第一行包含 $4$ 个整数 $n,m,a,b$（$1\\leq n,m,a,b\\leq 10^3$）。 \n\n接下来 $n$ 行，每行 $m$ 个字符，描述纸上的图案。`.` 表示留白，`x` 表示需要染黑。 \n\n接下来 $a$ 行，每行 $b$ 个字符，描述印章。`.` 表示不沾墨水，`x` 表示沾墨水。 ", "outputFormat": "对于每个测试点，输出 `TAK`（是）或 `NIE`（否）。 ", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3586", "type": "P", "difficulty": 6, "samples": [["3 8\nU 1 5\nU 2 7\nZ 2 6\nU 3 1\nZ 2 6\nU 2 2\nZ 2 6\nZ 2 1\n", "NIE\nTAK\nNIE\nTAK\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "平衡树", "树状数组", "POI（波兰）"], "title": "[POI 2015 R2] 物流 Logistics", "background": "", "description": "维护一个长度为 $n$ 的序列，一开始都是 $0$，支持以下两种操作：\n\n1. `U k a` 将序列中第 $k$ 个数修改为 $a$。\n2. `Z c s` 在这个序列上，每次选出 $c$ 个正数，并将它们都减去 $1$，询问能否进行 $s$ 次操作。\n\n每次询问独立，即每次询问不会对序列进行修改。\n", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示序列长度和操作次数。\n\n接下来 $m$ 行为 $m$ 个操作。", "outputFormat": "包含若干行，对于每个 `Z` 询问，若可行，输出 `TAK`，否则输出 `NIE`。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq 10^6$，$1\\leq k,c\\leq n$，$0\\leq a\\leq 10^9$，$1\\leq s\\leq 10^9$。\n\n----\n\n原题名称：Logistyka。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R2] Logistics", "background": "", "description": "Maintain a sequence of length $n$, initially all $0$, supporting the following two operations:\n\n1. `U k a`: set the $k$-th number in the sequence to $a$.\n2. `Z c s`: on this sequence, each time choose $c$ positive numbers and subtract $1$ from each; ask whether it is possible to perform $s$ such operations.\n\nEach query is independent, i.e., each query does not modify the sequence.", "inputFormat": "The first line contains two positive integers $n, m$, denoting the length of the sequence and the number of operations.\n\nThe next $m$ lines contain the $m$ operations.", "outputFormat": "Output several lines. For each `Z` query, print `TAK` if it is possible; otherwise, print `NIE`.", "hint": "**Constraints**\n\nFor $100\\%$ of the testdata, $1\\leq n,m\\leq 10^6$, $1\\leq k,c\\leq n$, $0\\leq a\\leq 10^9$, $1\\leq s\\leq 10^9$.\n\nOriginal title: Logistyka.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R2] 物流 Logistics", "background": "", "description": "维护一个长度为 $n$ 的序列，一开始都是 $0$，支持以下两种操作：\n\n1. `U k a` 将序列中第 $k$ 个数修改为 $a$。\n2. `Z c s` 在这个序列上，每次选出 $c$ 个正数，并将它们都减去 $1$，询问能否进行 $s$ 次操作。\n\n每次询问独立，即每次询问不会对序列进行修改。\n", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示序列长度和操作次数。\n\n接下来 $m$ 行为 $m$ 个操作。", "outputFormat": "包含若干行，对于每个 `Z` 询问，若可行，输出 `TAK`，否则输出 `NIE`。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq 10^6$，$1\\leq k,c\\leq n$，$0\\leq a\\leq 10^9$，$1\\leq s\\leq 10^9$。\n\n----\n\n原题名称：Logistyka。", "locale": "zh-CN"}}}
{"pid": "P3587", "type": "P", "difficulty": 6, "samples": [["9 5\n2 5 3 2 2 4 1 1 3", "4 3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "线段树", "二分", "单调队列", "POI（波兰）", "哈希 hashing"], "title": "[POI 2015 R2] 项链分割 Necklace partition", "background": "", "description": "长度为 $n$ 的一串项链，每颗珠子是 $k$ 种颜色之一。第 $i$ 颗与第 $i-1,i+1$ 颗珠子相邻，第 $n$ 颗与第 $1$ 颗也相邻。\n\n切两刀，把项链断成两条链。要求每种颜色的珠子只能出现在其中一条链中。\n\n求方案数量（保证至少存在一种），以及切成的两段长度之差绝对值的最小值。", "inputFormat": "第一行 $n,k$（$2\\leq k\\leq n\\leq 10^6$）。颜色从 $1$ 到 $k$ 标号。\n\n接下来 $n$ 个数，按顺序表示每颗珠子的颜色。（保证 $k$ 种颜色各出现至少一次）。 ", "outputFormat": "一行两个整数：方案数量，和长度差的最小值。", "hint": "**【样例解释】**\n\n四种方法中较短的一条分别是 $(5),(4),(1,1),(4,1,1)$。相差最小值 $6-3=3$。 \n\n----\n\n原题名称：Podział naszyjnika。 ", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R2] Necklace Partition", "background": "", "description": "There is a circular necklace with $n$ beads, each bead being one of $k$ colors. Bead $i$ is adjacent to beads $i - 1$ and $i + 1$, and bead $n$ is also adjacent to bead $1$.\n\nCut the necklace at two positions to split it into two linear segments. For each color, all beads of that color must appear in exactly one of the two segments.\n\nCompute the number of valid ways (it is guaranteed that at least one exists), and the minimum absolute difference between the lengths of the two segments.", "inputFormat": "The first line contains $n, k$ ($2 \\leq k \\leq n \\leq 10^6$). Colors are labeled from $1$ to $k$.\n\nThe next $n$ integers, in order, give the color of each bead. (It is guaranteed that each of the $k$ colors appears at least once.)", "outputFormat": "Output one line with two integers: the number of valid ways, and the minimum absolute difference between the lengths of the two segments.", "hint": "【Sample Explanation】\n\nAmong the four ways, the shorter segment is respectively $(5)$, $(4)$, $(1,1)$, $(4,1,1)$. The minimum difference is $6 - 3 = 3$.\n\n----\n\nOriginal title: Podział naszyjnika.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R2] 项链分割 Necklace partition", "background": "", "description": "长度为 $n$ 的一串项链，每颗珠子是 $k$ 种颜色之一。第 $i$ 颗与第 $i-1,i+1$ 颗珠子相邻，第 $n$ 颗与第 $1$ 颗也相邻。\n\n切两刀，把项链断成两条链。要求每种颜色的珠子只能出现在其中一条链中。\n\n求方案数量（保证至少存在一种），以及切成的两段长度之差绝对值的最小值。", "inputFormat": "第一行 $n,k$（$2\\leq k\\leq n\\leq 10^6$）。颜色从 $1$ 到 $k$ 标号。\n\n接下来 $n$ 个数，按顺序表示每颗珠子的颜色。（保证 $k$ 种颜色各出现至少一次）。 ", "outputFormat": "一行两个整数：方案数量，和长度差的最小值。", "hint": "**【样例解释】**\n\n四种方法中较短的一条分别是 $(5),(4),(1,1),(4,1,1)$。相差最小值 $6-3=3$。 \n\n----\n\n原题名称：Podział naszyjnika。 ", "locale": "zh-CN"}}}
{"pid": "P3588", "type": "P", "difficulty": 6, "samples": [["5 2 2\n2 7\n5 3\n1 4 2 2 3\n4 5 1 4", "TAK\n6 7 1000000000 6 3"], ["3 2 1\n2 3\n3 5\n1 3 1 2\n", "NIE\n"], ["2 1 1\n1 1000000000\n1 2 1 2", "NIE\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "线段树", "POI（波兰）", "Special Judge", "记忆化搜索", "拓扑排序"], "title": "[POI 2015 R2] 沙漠 Desert", "background": null, "description": "给定一个长度为 $n$ 的正整数序列 $a$，每个数都在 $1$ 到 $10^9$ 范围内，告诉你其中 $s$ 个数，并给出 $m$ 条信息，每条信息包含三个数 $l,r,k$ 以及接下来 $k$ 个正整数，表示 $a_l, a_{l+1}, \\ldots, a_{r-1}, a_r$ 里这 $k$ 个数中的任意一个都比任意一个剩下的 $r-l+1-k$ 个数大（严格大于，即没有等号）。\n\n请任意构造出一组满足条件的方案，或者判断无解。", "inputFormat": "第一行包含三个正整数 $n,s,m$（$1 \\leq s \\leq n  \\leq 10^5$，$1 \\leq m \\leq 2 \\times 10^5$）。接下来 $s$ 行，每行包含两个正整数 $p_i,d_i$,表示已知 $a_{p_i}=d_i$，保证 $p_i$ 递增。\n\n接下来 $m$ 行,每行一开始为三个正整数 $l_i,r_i,k_i$（$1 \\leq l_i < r_i \\leq n$，$1 \\leq k_i \\leq r_i-l_i$），接下来 $k_i$ 个正整数 $x_1..x_2...x_{k_i}$（$l_i \\leq x_1 < x_2 < ... < x_{k_i} \\leq r_i$），表示这 $k_i$ 个数中的任意一个都比任意一个剩下的 $r_i-l_i+1-k_i$ 个数大。（$\\sum k \\leq 3 \\times 10^5$）", "outputFormat": "若无解，则输出 `NIE`。否则第一行输出 `TAK`，第二行输出 $n$ 个正整数，依次输出序列 $a$ 中每个数。", "hint": "原题名称：Pustynia。\n\n本题另外提供两组额外样例，可以在附件中下载。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R2] Desert", "background": "", "description": "Given a positive integer sequence $a$ of length $n$, where each number is in the range $1$ to $10^9$. You are told $s$ of the numbers, and given $m$ pieces of information. Each piece contains three numbers $l, r, k$ followed by $k$ positive integers, meaning that among $a_l, a_{l+1}, \\ldots, a_{r-1}, a_r$, each of the values at those $k$ positions is strictly greater than each of the values at the remaining $r - l + 1 - k$ positions (strictly greater; no equality).\n\nConstruct any sequence that satisfies all the conditions, or determine that there is no solution.", "inputFormat": "The first line contains three positive integers $n, s, m$ ($1 \\leq s \\leq n \\leq 10^5$, $1 \\leq m \\leq 2 \\times 10^5$). The next $s$ lines each contain two positive integers $p_i, d_i$, meaning $a_{p_i} = d_i$. It is guaranteed that the $p_i$ are in increasing order.\n\nThe next $m$ lines: each line begins with three positive integers $l_i, r_i, k_i$ ($1 \\leq l_i < r_i \\leq n$, $1 \\leq k_i \\leq r_i - l_i$), followed by $k_i$ positive integers $x_1, x_2, \\ldots, x_{k_i}$ ($l_i \\leq x_1 < x_2 < \\cdots < x_{k_i} \\leq r_i$), indicating that in $a_{l_i}, a_{l_i+1}, \\ldots, a_{r_i}$, each of these $k_i$ positions has a value strictly greater than each of the other $r_i - l_i + 1 - k_i$ positions. ($\\sum k_i \\leq 3 \\times 10^5$.)", "outputFormat": "If there is no solution, output `NIE`. Otherwise, output `TAK` on the first line, and on the second line output $n$ positive integers, the sequence $a$ in order.", "hint": "Original title: Pustynia.\n\nTwo additional sample tests are provided and can be downloaded from the attachments.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R2] 沙漠 Desert", "background": null, "description": "给定一个长度为 $n$ 的正整数序列 $a$，每个数都在 $1$ 到 $10^9$ 范围内，告诉你其中 $s$ 个数，并给出 $m$ 条信息，每条信息包含三个数 $l,r,k$ 以及接下来 $k$ 个正整数，表示 $a_l, a_{l+1}, \\ldots, a_{r-1}, a_r$ 里这 $k$ 个数中的任意一个都比任意一个剩下的 $r-l+1-k$ 个数大（严格大于，即没有等号）。\n\n请任意构造出一组满足条件的方案，或者判断无解。", "inputFormat": "第一行包含三个正整数 $n,s,m$（$1 \\leq s \\leq n  \\leq 10^5$，$1 \\leq m \\leq 2 \\times 10^5$）。接下来 $s$ 行，每行包含两个正整数 $p_i,d_i$,表示已知 $a_{p_i}=d_i$，保证 $p_i$ 递增。\n\n接下来 $m$ 行,每行一开始为三个正整数 $l_i,r_i,k_i$（$1 \\leq l_i < r_i \\leq n$，$1 \\leq k_i \\leq r_i-l_i$），接下来 $k_i$ 个正整数 $x_1..x_2...x_{k_i}$（$l_i \\leq x_1 < x_2 < ... < x_{k_i} \\leq r_i$），表示这 $k_i$ 个数中的任意一个都比任意一个剩下的 $r_i-l_i+1-k_i$ 个数大。（$\\sum k \\leq 3 \\times 10^5$）", "outputFormat": "若无解，则输出 `NIE`。否则第一行输出 `TAK`，第二行输出 $n$ 个正整数，依次输出序列 $a$ 中每个数。", "hint": "原题名称：Pustynia。\n\n本题另外提供两组额外样例，可以在附件中下载。", "locale": "zh-CN"}}}
{"pid": "P3589", "type": "P", "difficulty": 5, "samples": [["9 5 6 4 3\n101\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2015", "POI（波兰）"], "title": "[POI 2015 R2] 快速阅读课程 Speed reading course", "background": "", "description": "给定 $n,a,b,p$，其中 $n,a$ 互质。 \n\n定义一个长度为 $n$ 的 01 串 $c_0c_1\\cdots c_{n-1}$，其中 $c_i$ 等于 0 当且仅当 $(ai+b) \\bmod n < p$。 \n\n给定一个长为 $m$ 的小 01 串，求出小串在大串中出现了几次。 ", "inputFormat": "第一行包含整数 $n,a,b,p,m$（$2\\leq n\\leq 10^9$，$1\\le p,a,b,m<n$，$1\\le m\\le 10^6$）。保证 $n$ 和 $a$ 互质。 \n\n第二行一个长度为 $m$ 的 01 串。 ", "outputFormat": "一个整数，表示小串在大串中出现了几次。 ", "hint": "**【样例解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qd6imu53.png)\n\n----\n\n原题名称：Kurs szybkiego czytania ", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R2] Speed Reading Course", "background": "", "description": "Given $n,a,b,p$, where $n$ and $a$ are coprime.\n\nDefine a binary string $c_0 c_1 \\cdots c_{n-1}$ of length $n$, where $c_i$ equals $0$ if and only if $(ai+b) \\bmod n < p$.\n\nGiven a binary string of length $m$, count how many times the small string appears in the big string.", "inputFormat": "The first line contains integers $n,a,b,p,m$ ($2\\leq n\\leq 10^9$, $1\\le p,a,b,m<n$, $1\\le m\\le 10^6$). It is guaranteed that $n$ and $a$ are coprime.\n\nThe second line contains a binary string of length $m$.", "outputFormat": "Output a single integer, the number of occurrences of the small string in the big string.", "hint": "Bold Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qd6imu53.png)\n\n----\n\nOriginal title: Kurs szybkiego czytania.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R2] 快速阅读课程 Speed reading course", "background": "", "description": "给定 $n,a,b,p$，其中 $n,a$ 互质。 \n\n定义一个长度为 $n$ 的 01 串 $c_0c_1\\cdots c_{n-1}$，其中 $c_i$ 等于 0 当且仅当 $(ai+b) \\bmod n < p$。 \n\n给定一个长为 $m$ 的小 01 串，求出小串在大串中出现了几次。 ", "inputFormat": "第一行包含整数 $n,a,b,p,m$（$2\\leq n\\leq 10^9$，$1\\le p,a,b,m<n$，$1\\le m\\le 10^6$）。保证 $n$ 和 $a$ 互质。 \n\n第二行一个长度为 $m$ 的 01 串。 ", "outputFormat": "一个整数，表示小串在大串中出现了几次。 ", "hint": "**【样例解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qd6imu53.png)\n\n----\n\n原题名称：Kurs szybkiego czytania ", "locale": "zh-CN"}}}
{"pid": "P3590", "type": "P", "difficulty": 6, "samples": [["9\nCBBSSBCSC", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "线段树", "树状数组", "POI（波兰）"], "title": "[POI 2015 R2] 三座塔 Three towers", "background": "", "description": "给定一个长度为 $n$ 的仅包含 $\\texttt B$、$\\texttt C$、$\\texttt S$ 三种字符的字符串，请找到最长的一段连续子串，使得这一段要么只有一种字符，要么有多种字符，但是没有任意两种字符出现次数相同。", "inputFormat": "第一行包含一个正整数 $n$（$1\\leq n\\leq 10^6$），表示字符串的长度。\n\n第二行一个长度为 $n$ 的字符串。", "outputFormat": "包含一行一个正整数，即最长的满足条件的子串的长度。", "hint": "**【样例解释】**\n\n选择 $\\texttt {BSSBCS}$ 这个子串。\n\n----\n\n原题名称：Trzy wieże。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R2] Three Towers", "background": "", "description": "Given a string of length $n$ containing only the characters $\\texttt B$, $\\texttt C$, and $\\texttt S$, find the longest contiguous substring such that it either contains only one kind of character, or it contains multiple kinds of characters but no two characters occur the same number of times.", "inputFormat": "The first line contains a positive integer $n$ ($1 \\leq n \\leq 10^6$), the length of the string.\nThe second line contains a string of length $n$.", "outputFormat": "Output a single positive integer: the length of the longest substring that satisfies the condition.", "hint": "**Sample Explanation**\n\nChoose the substring $\\texttt {BSSBCS}$.\n\n----\n\nOriginal title: Trzy wieże.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R2] 三座塔 Three towers", "background": "", "description": "给定一个长度为 $n$ 的仅包含 $\\texttt B$、$\\texttt C$、$\\texttt S$ 三种字符的字符串，请找到最长的一段连续子串，使得这一段要么只有一种字符，要么有多种字符，但是没有任意两种字符出现次数相同。", "inputFormat": "第一行包含一个正整数 $n$（$1\\leq n\\leq 10^6$），表示字符串的长度。\n\n第二行一个长度为 $n$ 的字符串。", "outputFormat": "包含一行一个正整数，即最长的满足条件的子串的长度。", "hint": "**【样例解释】**\n\n选择 $\\texttt {BSSBCS}$ 这个子串。\n\n----\n\n原题名称：Trzy wieże。", "locale": "zh-CN"}}}
{"pid": "P3591", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 4 5\n1 2\n2 3\n3 4\n3 5\n4 1 5 2 3\n1 3 1 1\n", "10\n6\n10\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "POI（波兰）", "分块", "根号分治"], "title": "[POI 2015 R3] 访问 Visits", "background": "", "description": "给定一棵 $n$ 个点的树，树上每条边的长度都为 $1$，第 $i$ 个点的权值为 $a_i$。 \n\nByteasar 想要走遍这整棵树，他会按照某个 $1$ 到 $n$ 的全排列 $b$ 走 $n-1$ 次，第 $i$ 次他会从 $b_i$ 点走到 $b_{i + 1}$ 点，并且这一次的步伐大小为 $c_i$。 \n\n对于一次行走，假设起点为 $x$，终点为 $y$，步伐为 $k$，那么 Byteasar 会从 $x$ 开始，每步往前走 $k$ 条边，数据保证了每次行走的距离是 $k$ 的倍数。 \n\n请帮助 Byteasar 统计出每一次行走时经过的所有点的权值和。", "inputFormat": "第一行包含一个正整数 $n$（$2 \\le n \\le 50000$）。表示节点的个数。 \n\n第二行包含 $n$ 个正整数，其中第 $i$ 个数为 $a_i$（$1 \\le a_i \\le 10000$），分别表示每个点的权值。 \n\n接下来 $n-1$ 行，每行包含两个正整数 $u,v$（$1 \\le u,v \\le n$），表示 $u$ 与 $v$ 之间有一条边。 \n\n接下来一行包含 $n$ 个互不相同的正整数，其中第 $i$ 个数为 $b_i$（$1 \\le b_i \\le n$），表示行走路线。 \n\n接下来一行包含 $n-1$ 个正整数，其中第 $i$ 个数为 $c_i$（$1 \\le c_i < n$），表示每次行走的步伐大小。", "outputFormat": "包含 $n-1$ 行，每行一个正整数，依次输出每次行走时经过的所有点的权值和。", "hint": "原题名称：Odwiedziny。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R3] Visits", "background": "", "description": "You are given a tree with $n$ vertices. Each edge has length $1$, and the weight of vertex $i$ is $a_i$.\n\nByteasar wants to traverse the whole tree. He will follow a permutation $b$ of $1$ to $n$ and make $n-1$ walks. On the $i$-th walk, he goes from vertex $b_i$ to vertex $b_{i+1}$, and the step size for this walk is $c_i$.\n\nFor a single walk, suppose the start is $x$, the end is $y$, and the step size is $k$. Byteasar starts at $x$ and moves forward along the unique path from $x$ to $y$, taking steps of exactly $k$ edges each time. The testdata guarantees that the distance of each walk is a multiple of $k$.\n\nPlease help Byteasar compute, for each walk, the sum of the weights of all vertices he visits during that walk.", "inputFormat": "- The first line contains a positive integer $n$ ($2 \\le n \\le 50000$), the number of vertices.\n- The second line contains $n$ positive integers, where the $i$-th number is $a_i$ ($1 \\le a_i \\le 10000$), the weight of vertex $i$.\n- The next $n-1$ lines each contain two positive integers $u, v$ ($1 \\le u, v \\le n$), indicating that there is an edge between $u$ and $v$.\n- The next line contains $n$ distinct positive integers, where the $i$-th number is $b_i$ ($1 \\le b_i \\le n$), describing the route (a permutation).\n- The next line contains $n-1$ positive integers, where the $i$-th number is $c_i$ ($1 \\le c_i < n$), the step size for the $i$-th walk.", "outputFormat": "Output $n-1$ lines. The $i$-th line should contain one positive integer: the sum of the weights of all vertices visited during the $i$-th walk.", "hint": "Original title: Odwiedziny.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R3] 访问 Visits", "background": "", "description": "给定一棵 $n$ 个点的树，树上每条边的长度都为 $1$，第 $i$ 个点的权值为 $a_i$。 \n\nByteasar 想要走遍这整棵树，他会按照某个 $1$ 到 $n$ 的全排列 $b$ 走 $n-1$ 次，第 $i$ 次他会从 $b_i$ 点走到 $b_{i + 1}$ 点，并且这一次的步伐大小为 $c_i$。 \n\n对于一次行走，假设起点为 $x$，终点为 $y$，步伐为 $k$，那么 Byteasar 会从 $x$ 开始，每步往前走 $k$ 条边，数据保证了每次行走的距离是 $k$ 的倍数。 \n\n请帮助 Byteasar 统计出每一次行走时经过的所有点的权值和。", "inputFormat": "第一行包含一个正整数 $n$（$2 \\le n \\le 50000$）。表示节点的个数。 \n\n第二行包含 $n$ 个正整数，其中第 $i$ 个数为 $a_i$（$1 \\le a_i \\le 10000$），分别表示每个点的权值。 \n\n接下来 $n-1$ 行，每行包含两个正整数 $u,v$（$1 \\le u,v \\le n$），表示 $u$ 与 $v$ 之间有一条边。 \n\n接下来一行包含 $n$ 个互不相同的正整数，其中第 $i$ 个数为 $b_i$（$1 \\le b_i \\le n$），表示行走路线。 \n\n接下来一行包含 $n-1$ 个正整数，其中第 $i$ 个数为 $c_i$（$1 \\le c_i < n$），表示每次行走的步伐大小。", "outputFormat": "包含 $n-1$ 行，每行一个正整数，依次输出每次行走时经过的所有点的权值和。", "hint": "原题名称：Odwiedziny。", "locale": "zh-CN"}}}
{"pid": "P3592", "type": "P", "difficulty": 6, "samples": [["7 5\n1 4 7\n3 7 13\n5 6 20\n6 7 1\n1 2 5", "43\n5 5 13 13 20 20 13"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2015", "POI（波兰）", "Special Judge", "区间 DP"], "title": "[POI 2015 R3] 洗车 Car washes", "background": "", "description": "有 $n$ 家洗车店从左往右排成一排，每家店都有一个正整数价格 $p_i$。有 $m$ 个人要来消费，第 $i$ 个人会驶过第 $a_i$ 个开始一直到第 $b_i$ 个洗车店，且会选择这些店中最便宜的一个进行一次消费。但是如果这个最便宜的价格大于 $c_i$，那么这个人就不洗车了。请给每家店指定一个价格，使得所有人花的钱的总和最大。", "inputFormat": "第一行包含两个正整数 $n,m$（$1 \\le n \\le 50$，$1 \\le m \\le 4000$）。接下来 $m$ 行，每行包含三个正整数 $a_i,b_i,c_i$（$1 \\le a_i \\le b_i \\le n$，$1 \\le c_i \\le 5\\times 10^5$）。", "outputFormat": "第一行输出一个正整数，即消费总额的最大值。第二行输出 $n$ 个正整数，依次表示每家洗车店的价格 $p_i$，要求 $1 \\le p_i \\le 5\\times 10^5$。若有多组最优解，输出任意一组。", "hint": "原题名称：Myjnie。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R3] Car Washes", "background": "", "description": "There are $n$ car wash shops arranged in a row from left to right. Each shop has a positive integer price $p_i$. There are $m$ customers. The $i$-th customer will drive past shops from the $a_i$-th to the $b_i$-th, inclusive, and will choose the cheapest shop among these to buy one wash. However, if this cheapest price is greater than $c_i$, then this person does not buy a wash. Assign a price to each shop so that the total amount spent by all customers is maximized.", "inputFormat": "The first line contains two positive integers $n, m$ ($1 \\le n \\le 50$, $1 \\le m \\le 4000$).  \nThe next $m$ lines each contain three positive integers $a_i, b_i, c_i$ ($1 \\le a_i \\le b_i \\le n$, $1 \\le c_i \\le 5\\times 10^5$).", "outputFormat": "On the first line, output a single positive integer — the maximum total spending.  \nOn the second line, output $n$ positive integers, representing the prices $p_i$ of each shop from left to right, with $1 \\le p_i \\le 5\\times 10^5$. If there are multiple optimal solutions, output any of them.", "hint": "Original title: Myjnie.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R3] 洗车 Car washes", "background": "", "description": "有 $n$ 家洗车店从左往右排成一排，每家店都有一个正整数价格 $p_i$。有 $m$ 个人要来消费，第 $i$ 个人会驶过第 $a_i$ 个开始一直到第 $b_i$ 个洗车店，且会选择这些店中最便宜的一个进行一次消费。但是如果这个最便宜的价格大于 $c_i$，那么这个人就不洗车了。请给每家店指定一个价格，使得所有人花的钱的总和最大。", "inputFormat": "第一行包含两个正整数 $n,m$（$1 \\le n \\le 50$，$1 \\le m \\le 4000$）。接下来 $m$ 行，每行包含三个正整数 $a_i,b_i,c_i$（$1 \\le a_i \\le b_i \\le n$，$1 \\le c_i \\le 5\\times 10^5$）。", "outputFormat": "第一行输出一个正整数，即消费总额的最大值。第二行输出 $n$ 个正整数，依次表示每家洗车店的价格 $p_i$，要求 $1 \\le p_i \\le 5\\times 10^5$。若有多组最优解，输出任意一组。", "hint": "原题名称：Myjnie。", "locale": "zh-CN"}}}
