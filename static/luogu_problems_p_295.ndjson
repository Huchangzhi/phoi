{"pid": "P6970", "type": "P", "difficulty": 6, "samples": [["6 7\n1 2\n2 1\n2 3\n1 4\n4 1\n4 5\n5 6\n", "WDLDWL\nDWLLWL \n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Game on Graph", "background": "", "description": "\n\nGennady and Georgiy are playing interesting game on a directed graph. The graph has $n$ vertices and $m$ arcs, loops are allowed. Gennady and Georgiy have a token placed in one of the graph vertices. Players take turns moving the token along one of the arcs that starts in the vertex the token is currently in. When there is no such arc, then this player loses the game.\n\nFor each initial position of the token and the player who is moving first, your task is to determine what kind of result the game is going to have. Does it seem to be easy? Not so much.\n\nOn one side, Gennady is having a lot of fun playing this game, so he wants to play as long as possible. He even prefers a strategy that leads to infinite game to a strategy that makes him a winner. But if he cannot make the game infinite, then he obviously prefers winning to losing.\n\nOn the other side, Georgiy has a lot of other work, so he does not want to play the game infinitely. Georgiy wants to win the game, but if he cannot win, then he prefers losing game to making it infinite.\n\nBoth players are playing optimally. Both players know preferences of the other player.\n\n", "inputFormat": "\n\nIn the first line there are two integers -- the number of vertices $n (1 \\le n \\le 100 000)$ and the number of arcs $m (1 \\le m \\le 200 000)$ . In the next $m$ lines there are two integers a and $b$ on each line, denoting an arc from vertex a to vertex $b$ . Vertices are numbered from $1$ to $n$ . Each $(a , b)$ tuple appears at most once.\n\n", "outputFormat": "\n\nIn the first line print $n$ characters -- i-th character should denote the result of the game if Gennady starts in vertex $i$ . In the second line print $n$ characters -- i-th character should denote the result of the game if Georgiy starts in vertex $i$ . The result of the game is denoted by `W` if the starting player wins the game, `L` if the starting player loses the game, and `D` (draw) if the game runs infinitely.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Game on Graph", "background": "", "description": "\n\nGennady and Georgiy are playing interesting game on a directed graph. The graph has $n$ vertices and $m$ arcs, loops are allowed. Gennady and Georgiy have a token placed in one of the graph vertices. Players take turns moving the token along one of the arcs that starts in the vertex the token is currently in. When there is no such arc, then this player loses the game.\n\nFor each initial position of the token and the player who is moving first, your task is to determine what kind of result the game is going to have. Does it seem to be easy? Not so much.\n\nOn one side, Gennady is having a lot of fun playing this game, so he wants to play as long as possible. He even prefers a strategy that leads to infinite game to a strategy that makes him a winner. But if he cannot make the game infinite, then he obviously prefers winning to losing.\n\nOn the other side, Georgiy has a lot of other work, so he does not want to play the game infinitely. Georgiy wants to win the game, but if he cannot win, then he prefers losing game to making it infinite.\n\nBoth players are playing optimally. Both players know preferences of the other player.\n\n", "inputFormat": "\n\nIn the first line there are two integers -- the number of vertices $n (1 \\le n \\le 100 000)$ and the number of arcs $m (1 \\le m \\le 200 000)$ . In the next $m$ lines there are two integers a and $b$ on each line, denoting an arc from vertex a to vertex $b$ . Vertices are numbered from $1$ to $n$ . Each $(a , b)$ tuple appears at most once.\n\n", "outputFormat": "\n\nIn the first line print $n$ characters -- i-th character should denote the result of the game if Gennady starts in vertex $i$ . In the second line print $n$ characters -- i-th character should denote the result of the game if Georgiy starts in vertex $i$ . The result of the game is denoted by `W` if the starting player wins the game, `L` if the starting player loses the game, and `D` (draw) if the game runs infinitely.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Game on Graph", "background": null, "description": "Gennady 和 Georgiy 在玩一个有向图上的游戏。这个图有 $n$ 个点 $m$ 条边，两人轮流操作，每次可以将棋子沿着其中一条边移动，不能移动者输。\n\n你要对于每个点，分别求出以这个点为起点开始游戏，两人分别作为先手，最终会输，赢，还是平局（游戏无限循环）。\n\n其中，Gennady 因为玩得很开心，所以他更期望将游戏变为平局；Georgiy 还有很多其他事，所以他更期望游戏不要平局。当然，在不平局的基础上，两人都更希望赢。", "inputFormat": "第一行两个数 $n$，$m$ 表示有 $n$ 个点 $m$ 条边。  \n接下来 $m$ 行每行两个数 $a,b$ 表示一条由 $a$ 至 $b$ 的边。", "outputFormat": "两行，第一行表示分别以每一个点为起点 Gennady 先手的胜负情况；第二行表示分别以每一个点为起点 Georgiy 先手的胜负情况。`W` 表示赢，`L` 表示输，`D` 表示平局。\n\nby a___", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P6971", "type": "P", "difficulty": 0, "samples": [["5 2\n6 6\n4 1\n4 2\n4 5\n5 3\n4 3\n1 1\n", "yes\n5\n"], ["3 3\n10 1\n10 3\n", "no\n"], ["2 2\n2 1\n1 1\n", "yes\n1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Jenga Boom", "background": "", "description": "\n\nJane is a game designer and she designs the next version of Jenga Boom, where the blocks have dimensions of $1 \\times w \\times w_n$ instead of the ordinary $1 \\times 2 \\times 6$ . As usual, the initial tower is created at the game start. It consists of the blocks in levels of $n$ blocks placed next to each other along their long sides and at a right angle to the previous level. Players remove blocks from the tower in turns, until the tower collapses.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13998/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%208.10.49.png)\n\nInitial tower\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13998/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%208.11.00.png)\n\nThe tower before collapse\n\nJane wants to build a game simulator that helps her to decide the best $n$ and $w$ . The simulator shall compute the moment when the tower collapses if blocks are removed in the specified order. Tower collapses if there is a cross-section between levels such that the center of the mass of the levels above it does not belong to or is at the edge of the convex hull of the previous level projection.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $w$ that define the dimensions of the block as described in the problem statement $(1 \\le n , w \\le 10 000)$ . The second line also contains two integers: $h$ -- the number of levels in the tower and $m$ -- the number of removed blocks $(1 \\le h , m \\le 5 000)$ .\n\nThe next $m$ lines contain coordinates of the removed blocks with two integers each: $l_{i}$ -- the level of the block, counting from the bottom and $k_{i}$ -- the position of the block, counting from the edge nearest to the players $(1 \\le l_{i} \\le h$ ; $1 \\le k_{i} \\le n)$ . Blocks are removed one by one and no block is removed twice.\n\n", "outputFormat": "\n\nIn the first line output `yes` if the tower collapses, and `no` otherwise. In the former case, output the number of the block (starting from $1$) , that was removed just before the collapse, in the next line.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Jenga Boom", "background": "", "description": "\n\nJane is a game designer and she designs the next version of Jenga Boom, where the blocks have dimensions of $1 \\times w \\times w_n$ instead of the ordinary $1 \\times 2 \\times 6$ . As usual, the initial tower is created at the game start. It consists of the blocks in levels of $n$ blocks placed next to each other along their long sides and at a right angle to the previous level. Players remove blocks from the tower in turns, until the tower collapses.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13998/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%208.10.49.png)\n\nInitial tower\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13998/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%208.11.00.png)\n\nThe tower before collapse\n\nJane wants to build a game simulator that helps her to decide the best $n$ and $w$ . The simulator shall compute the moment when the tower collapses if blocks are removed in the specified order. Tower collapses if there is a cross-section between levels such that the center of the mass of the levels above it does not belong to or is at the edge of the convex hull of the previous level projection.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $w$ that define the dimensions of the block as described in the problem statement $(1 \\le n , w \\le 10 000)$ . The second line also contains two integers: $h$ -- the number of levels in the tower and $m$ -- the number of removed blocks $(1 \\le h , m \\le 5 000)$ .\n\nThe next $m$ lines contain coordinates of the removed blocks with two integers each: $l_{i}$ -- the level of the block, counting from the bottom and $k_{i}$ -- the position of the block, counting from the edge nearest to the players $(1 \\le l_{i} \\le h$ ; $1 \\le k_{i} \\le n)$ . Blocks are removed one by one and no block is removed twice.\n\n", "outputFormat": "\n\nIn the first line output `yes` if the tower collapses, and `no` otherwise. In the former case, output the number of the block (starting from $1$) , that was removed just before the collapse, in the next line.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Jenga Boom", "background": "", "description": "设有一个塔，它的积木块是 $1\\times w\\times (w\\times n)$ 的长方体，每层由 $n$ 个积木块，每两层交错摆放，共有 $h$ 层。有 $m$ 个抽积木的操作，对于第 $i$ 个操作给出从底往上数的第 $l_i$ 层和从左后方往右前方数的第 $k_i$ 块。某一层的左边或右边加上中间 (如果 $n$ 为偶数，那么忽略中间) 的积木块全被抽完，则塔倒塌。", "inputFormat": "第一行为 $n$ 和 $w$ ，($1\\le n,w\\le10000$) 。第二行为 $h$ 和 $m$  ,($1\\le h,m\\le5000$)。接下来的 $m$ 行为 $l_i$ 和 $k_i$ ($1\\le l_i\\le h;1\\le k_i\\le n$) 。一块积木只能移动一次。", "outputFormat": "如果塔能倒塌，则输出 \"yes\" 。否则输出 \"no\" 。对于第一种情况，在下一行输出倒塌前一步的编号 $i$ 。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6972", "type": "P", "difficulty": 5, "samples": [["3 3\n..*\n.*.\n*.*\n3 3\n**.\n..*\n.*.\n5 2\n.*\n*.\n**\n.*\n*.\n", "YES\n0 2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Kids Designing Kids", "background": "", "description": "\n\nKevin and Kimberly have freckles on their foreheads.\n\nThey both drew their freckle pictures on sheets of paper. Each picture is a rectangle of `pixels`: every cell either has a freckle or it has no freckle.\n\nThey are jokingly proposing that when they grow up, marry, and have a child, her freckle picture is produced as a result of the following procedure:\n\nKevin's and Kimberly's pictures are moved by a parallel translation, and then in each cell a child has a freckle if and only if exactly one of the parents has a freckle in this position.\n\nNow they wonder, whether there is a parallel translation that gives their child a specific freckle picture (for example, a lightning), and what is this parallel translation.\n\n", "inputFormat": "\n\nThe first line contains two integers, $h_{1 }and w_{1} (1 \\le h_{1}, w_{1} \\le 1000)$ -- the height and the width of Kevin's freckle picture. Each of the next $h_{1}$ lines consists of $w_{1}$ characters $‘ \\times '$ and $‘. '.$ Character $‘ \\times '$ means that there is a freckle, and $‘. '$ that there is not.\n\nThe next lines contain Kimberly's picture in the same format. Its height and width $h_2$ and $w_2$ follow the same constraints.\n\nIt is guaranteed that Kevin and Kimberly have at least one freckle each.\n\nThe next lines contain the picture they want for their child in the same format. Its dimensions $h_{3}$ and $w_{3}$ also have the same constraints.\n\n", "outputFormat": "\n\nIn the first line output `YES` if the desired picture can be produced, and `NO` otherwise.\n\nIf the answer is positive, then in the second line output two integers, $x$ and $y$ , with the following meaning: if you overlay the pictures so that their upper left corners coincide, then move Kimberly's picture $x$ cells right (negative number means moving picture left) and $y$ cells down (negative number means moving picture up), and then apply the procedure described above, the resulting picture can be moved by a parallel translation to coincide with the third picture from the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Kids Designing Kids", "background": "", "description": "\n\nKevin and Kimberly have freckles on their foreheads.\n\nThey both drew their freckle pictures on sheets of paper. Each picture is a rectangle of `pixels`: every cell either has a freckle or it has no freckle.\n\nThey are jokingly proposing that when they grow up, marry, and have a child, her freckle picture is produced as a result of the following procedure:\n\nKevin's and Kimberly's pictures are moved by a parallel translation, and then in each cell a child has a freckle if and only if exactly one of the parents has a freckle in this position.\n\nNow they wonder, whether there is a parallel translation that gives their child a specific freckle picture (for example, a lightning), and what is this parallel translation.\n\n", "inputFormat": "\n\nThe first line contains two integers, $h_{1 }and w_{1} (1 \\le h_{1}, w_{1} \\le 1000)$ -- the height and the width of Kevin's freckle picture. Each of the next $h_{1}$ lines consists of $w_{1}$ characters $‘ \\times '$ and $‘. '.$ Character $‘ \\times '$ means that there is a freckle, and $‘. '$ that there is not.\n\nThe next lines contain Kimberly's picture in the same format. Its height and width $h_2$ and $w_2$ follow the same constraints.\n\nIt is guaranteed that Kevin and Kimberly have at least one freckle each.\n\nThe next lines contain the picture they want for their child in the same format. Its dimensions $h_{3}$ and $w_{3}$ also have the same constraints.\n\n", "outputFormat": "\n\nIn the first line output `YES` if the desired picture can be produced, and `NO` otherwise.\n\nIf the answer is positive, then in the second line output two integers, $x$ and $y$ , with the following meaning: if you overlay the pictures so that their upper left corners coincide, then move Kimberly's picture $x$ cells right (negative number means moving picture left) and $y$ cells down (negative number means moving picture up), and then apply the procedure described above, the resulting picture can be moved by a parallel translation to coincide with the third picture from the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Kids Designing Kids", "background": null, "description": "凯文和金伯利的额头上都有雀斑。  \n\n他们都在纸上画了自己的雀斑图。每幅图都是一个由像素组成的矩形：每个单元格要么有雀斑，要么没有雀斑。  \n\n他们开玩笑地提议，当他们长大、结婚并有了孩子时，孩子的雀斑图是通过以下过程产生的：  \n\n凯文和金伯利的图通过平行平移移动，然后在每个单元格中，只有当且仅当父母中有一个人在这个位置有雀斑时，孩子才有雀斑。  \n\n现在他们想知道，是否存在一个平行平移可以使他们的孩子获得特定的雀斑图（例如，一个闪电），以及这个平行平移是什么。", "inputFormat": "第一行包含两个整数 $h_{1}$ 和 $w_{1}$ $(1 \\le h_{1}, w_{1} \\le 1000)$——凯文的雀斑图的高度和宽度。接下来的 $h_{1}$ 行中的每一行由 $w_{1}$ 个字符组成，字符为 `*` 和 `.`。字符 `*` 表示有雀斑，而 `.` 表示没有雀斑。  \n\n接下来的几行以相同的格式包含金伯利的图。其高度和宽度 $h_2$ 和 $w_2$ 遵循相同的约束条件。  \n\n保证凯文和金伯利各自至少有一个雀斑。  \n\n接下来的几行以相同的格式包含他们想要给孩子的图。其尺寸 $h_{3}$ 和 $w_{3}$ 也遵循相同的约束条件。", "outputFormat": "在第一行输出 `YES` 如果可以生成所需的图，否则输出 `NO`。  \n\n如果答案是肯定的，那么在第二行输出两个整数 $x$ 和 $y$，其含义如下：如果将图像叠加，使它们的左上角重合，然后将金伯利的图向右移动 $x$ 个单元格（负数表示向左移动图像）和向下移动 $y$ 个单元格（负数表示向上移动图像），然后应用上述过程，结果图可以通过平行平移移动以与输入文件中的第三幅图重合。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6973", "type": "P", "difficulty": 6, "samples": [["1 35\n", "[2], [3], [2, 3], [5], [2, 5], [7],\n"], ["36 41\n", " [3, 5\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] List of Primes", "background": "", "description": "Lidia likes sets of prime numbers. When she is bored, she starts writing them down into the Extremely Long Notebook for Prime Sets.\n\nElements of each set are written down in ascending order. Each set of prime numbers appears in her notebook eventually. A set with a smaller sum always appears before a set with a larger sum. Sets with the same sum are sorted in ascending lexicographical order: they are compared by the first element, if the first elements are equal, then by second element, and so on.\n\nJust in case someone decides to parse her notebook, she writes down her sets in a machine-readable JSON format. Of course, she puts a space after each comma. Here's the beginning of her notebook:\n\n$[2], [3], [2 , 3], [5], [2 , 5], [7], [3 , 5], [2 , 7], [2 , 3 , 5], [3 , 7], [11], [2 , 3 , 7], [5 , 7], [2 , 11], [13], [2 , 5 , 7],$\n\nLidia wants to double-check her work, so here is her request for you: given two integers, $a$ and $b$ , output a substring of her notebook from the position $a$ to the position $b$ (inclusive, counting from $1$) .\n\n", "inputFormat": "\n\nThe first line contains two integers, $a$ and $b$ ($1 \\le a \\le b \\le 10^{18}; b - a \\le 10^{5}$).\n\n", "outputFormat": "\n\nOutput the substring of the notebook described in the problem statement from the position $a$ to the position $b$ . You must write a line with exactly $b - a + 1$ characters, including any leading or trailing spaces.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] List of Primes", "background": "", "description": "Lidia likes sets of prime numbers. When she is bored, she starts writing them down into the Extremely Long Notebook for Prime Sets.\n\nElements of each set are written down in ascending order. Each set of prime numbers appears in her notebook eventually. A set with a smaller sum always appears before a set with a larger sum. Sets with the same sum are sorted in ascending lexicographical order: they are compared by the first element, if the first elements are equal, then by second element, and so on.\n\nJust in case someone decides to parse her notebook, she writes down her sets in a machine-readable JSON format. Of course, she puts a space after each comma. Here's the beginning of her notebook:\n\n$[2], [3], [2 , 3], [5], [2 , 5], [7], [3 , 5], [2 , 7], [2 , 3 , 5], [3 , 7], [11], [2 , 3 , 7], [5 , 7], [2 , 11], [13], [2 , 5 , 7],$\n\nLidia wants to double-check her work, so here is her request for you: given two integers, $a$ and $b$ , output a substring of her notebook from the position $a$ to the position $b$ (inclusive, counting from $1$) .\n\n", "inputFormat": "\n\nThe first line contains two integers, $a$ and $b$ ($1 \\le a \\le b \\le 10^{18}; b - a \\le 10^{5}$).\n\n", "outputFormat": "\n\nOutput the substring of the notebook described in the problem statement from the position $a$ to the position $b$ . You must write a line with exactly $b - a + 1$ characters, including any leading or trailing spaces.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] List of Primes", "background": "", "description": "Lidia 喜欢质数集合。当她感到无聊时，她就开始把它们写在极长的质数集合笔记本上。\n\n每个集合的元素按升序排列。每个质数集合最终都会出现在她的笔记本上。和较小的集合总是出现在和较大的集合之前。和相同的集合按字典序升序排列：它们首先比较第一个元素，如果第一个元素相同，则比较第二个元素，依此类推。\n\n以防有人决定解析她的笔记本，她将她的集合写成机器可读的 JSON 格式。当然，她在每个逗号后面加了一个空格。以下是她笔记本的开头：\n\n$[2], [3], [2 , 3], [5], [2 , 5], [7], [3 , 5], [2 , 7], [2 , 3 , 5], [3 , 7], [11], [2 , 3 , 7], [5 , 7], [2 , 11], [13], [2 , 5 , 7],$\n\nLidia 想要仔细检查她的工作，所以她请求你：给定两个整数 $a$ 和 $b$，输出她的笔记本中从位置 $a$ 到位置 $b$（包括，位置从 $1$ 开始计数）的子字符串。", "inputFormat": "第一行包含两个整数，$a$ 和 $b$ ($1 \\le a \\le b \\le 10^{18}; b - a \\le 10^{5}$)。", "outputFormat": "输出题目描述中从位置 $a$ 到位置 $b$ 的笔记本子字符串。你必须输出一行，恰好包含 $b - a + 1$ 个字符，包括任何前导或尾随空格。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6974", "type": "P", "difficulty": 2, "samples": [["3 7\nR 2\nC 3\nR 2\nR 1\nC 2\nC 1\nR 3\n", "12\n10\n0\n5\n5\n4\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Adjustment Office", "background": "", "description": "Garrison and Anderson are working in a company named “Adjustment Office”. In competing companies workers change the reality, in this company they try to predict the future.\n\nThey are given a big square board $n\\times n$. Initially in each cell $(x, y)$ of this board the value of $x + y$ is written $(1\\leq x, y\\leq n$). They know that in the future there will be two types of queries on the board:\n- “R $r$” — sum up all values in row $r$, print the result and set all values in row $r$ to zero;\n- “C $c$” — sum up all values in column $c$, print the result and set all values in column $c$ to zero.\n\nThey have predicted what queries and results there will be. They need to ensure that they have correctly predicted the results. Help them by computing the results of the queries.\n", "inputFormat": "The first line of the input contains two integers $n$ and $q$ $(1\\leq n\\leq10^6$, $1\\leq q\\leq10^5$) — the size of the square and the number of queries.\n\nEach of the next $q$ lines contains the description of the query. Each query is either “R $r$” $(1\\leq r\\leq n$) or “C $c$” $(1\\leq c\\leq n$).", "outputFormat": "The output file shall contain $q$ lines. The $i$ - th line shall contain one integer — the result of the $i$ - th query. ", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Adjustment Office", "background": "", "description": "Garrison and Anderson are working in a company named “Adjustment Office”. In competing companies workers change the reality, in this company they try to predict the future.\n\nThey are given a big square board $n\\times n$. Initially in each cell $(x, y)$ of this board the value of $x + y$ is written $(1\\leq x, y\\leq n$). They know that in the future there will be two types of queries on the board:\n- “R $r$” — sum up all values in row $r$, print the result and set all values in row $r$ to zero;\n- “C $c$” — sum up all values in column $c$, print the result and set all values in column $c$ to zero.\n\nThey have predicted what queries and results there will be. They need to ensure that they have correctly predicted the results. Help them by computing the results of the queries.\n", "inputFormat": "The first line of the input contains two integers $n$ and $q$ $(1\\leq n\\leq10^6$, $1\\leq q\\leq10^5$) — the size of the square and the number of queries.\n\nEach of the next $q$ lines contains the description of the query. Each query is either “R $r$” $(1\\leq r\\leq n$) or “C $c$” $(1\\leq c\\leq n$).", "outputFormat": "The output file shall contain $q$ lines. The $i$ - th line shall contain one integer — the result of the $i$ - th query. ", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Adjustment Office", "background": "", "description": "加里森和安德森在一家名为“Adjustment Office”的公司工作。在竞争公司中，员工改变现实，而在这家公司中，他们尝试预测未来。\n\n他们得到一个 $n \\times n$ 的大方板。最初在这个方板的每个单元格 $(x, y)$ 中写着 $x + y$ 的值（$1 \\leq x, y \\leq n$）。他们知道在未来将会有两种类型的查询：\n- “R $r$”——计算第 $r$ 行的所有值之和，打印结果并将第 $r$ 行的所有值设为零；\n- “C $c$”——计算第 $c$ 列的所有值之和，打印结果并将第 $c$ 列的所有值设为零。\n\n他们已经预测了将会有哪些查询和结果。他们需要确保他们正确预测了结果。请帮助他们计算查询的结果。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $q$（$1 \\leq n \\leq 10^6$，$1 \\leq q \\leq 10^5$）——方板的大小和查询的数量。\n\n接下来的 $q$ 行中的每一行包含一个查询的描述。每个查询要么是“R $r$”（$1 \\leq r \\leq n$），要么是“C $c$”（$1 \\leq c \\leq n$）。", "outputFormat": "输出文件应包含 $q$ 行。第 $i$ 行应包含一个整数——第 $i$ 个查询的结果。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6975", "type": "P", "difficulty": 6, "samples": [["6 1\n7 1 2 5 6 2 3 4\n", "42\n"], ["15 3\n9 1 2 3 4 5 6 7 8 3\n7 2 9 10 11 12 13 10\n5 2 14 9 15 10\n", "216\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Cactus Jubilee", "background": "", "description": "\n\nThis is the $20-th$ Northeastern European Regional Contest $(NEERC).$ Cactus problems had become a NEERC tradition. The first Cactus problem was given in $2005$ , so there is a jubilee -- $10$ years of Cactus.\n\nCactus is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus.\n\nYou are given a cactus. Let's move an edge -- remove one of graph's edges, but connect a different pair of vertices with an edge, so that a graph still remains a cactus. How many ways are there to perform such a move?\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11737/1.png)\n\nFor example, in the left cactus above (given in the first sample), there are $42$ ways to perform an edge move. In the right cactus (given in the second sample), which is the classical NEERC cactus since the original problem in $2005$ , there are $216$ ways to perform a move.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n \\le 50 000 , 0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer $k_{i} (2 \\le k_{i} \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in a path are distinct. Path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file.\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nWrite to the output file a single integer -- the number of ways to move an edge in the cactus.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Cactus Jubilee", "background": "", "description": "\n\nThis is the $20-th$ Northeastern European Regional Contest $(NEERC).$ Cactus problems had become a NEERC tradition. The first Cactus problem was given in $2005$ , so there is a jubilee -- $10$ years of Cactus.\n\nCactus is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus.\n\nYou are given a cactus. Let's move an edge -- remove one of graph's edges, but connect a different pair of vertices with an edge, so that a graph still remains a cactus. How many ways are there to perform such a move?\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11737/1.png)\n\nFor example, in the left cactus above (given in the first sample), there are $42$ ways to perform an edge move. In the right cactus (given in the second sample), which is the classical NEERC cactus since the original problem in $2005$ , there are $216$ ways to perform a move.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n \\le 50 000 , 0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer $k_{i} (2 \\le k_{i} \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in a path are distinct. Path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file.\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nWrite to the output file a single integer -- the number of ways to move an edge in the cactus.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Cactus Jubilee", "background": "", "description": "定义一种无向连通图叫`仙人掌图（Cactus图）`。仙人掌图中没有重边和自环，并且其中的每一条边至多位于一个简单环上。简单地说，`仙人掌图`是树的一种泛化形式，其中允许出现一些环。\n\n现在有一个`仙人掌图`，你每次可以移动一条边（移除图的一条边，并将另一对顶点用一条边连接起来）。问如果要让后来得到的新图仍然是`仙人掌图`，有多少种移动边的办法？", "inputFormat": "第一行包含两个整数n和m，分别表示图中的顶点数（顶点的编号分别为${1,2,3,...,n}$）和边的数目，且满足\n$$1≤n≤50000,0≤m≤50000$$\n\n第2~m+1行，每一行表示一条路径（从一个顶点出发一直往后走，直到当前所在的顶点没有任何未走过一条边）。\n\n（译者注：虽然应该都能看出来了，但是还是用一个递归函数更浅显易懂）\n\n设路径的开始点为$q_1$，$E_i$表示第$i$个点的边,$vis$数组中存储已经走过了的边，则整条路径可定义为：\n```\n1.x←q1\n2.f(x)\n\t1.add(vis[],x)\n\t2.for i∈Ex do\n\t1.if i not in vis[] then\n\t\t1.call f(i->to)\n3.print(vis[])\n```\n即：每一行的开始有一个整数$k_i$，满足\n$2≤k_i≤1000$，紧接着有$k_i$个整数，表示这条路径所经过的顶点$q_i$，满足$q_i∈[1,n]$。\n\n数据保证路径中的相邻顶点是不同的。\n\n在路径中可以多次到达同一个顶点，但在整个输入文件中，每条边只遍历一次。\n\n数据保证输入文件中的图形是仙人掌。", "outputFormat": "输出文件中只有一个整数，即移动`仙人掌图`中一条边的方法数。", "hint": "$$1≤n≤50000,0≤m≤50000,2≤k_i≤1000,q_i∈[1,n]$$", "locale": "zh-CN"}}}
{"pid": "P6976", "type": "P", "difficulty": 6, "samples": [["6\n1 5\n2 4\n5 2\n5\n1 3\n2 5\n3 4\n6 3\n6 6\n", "2\n1\n1\n3\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Distance on Triangulation", "background": "", "description": "\n\nYou have a convex polygon. The vertices of the polygon are successively numbered from $1$ to $n$ . You also have a triangulation of this polygon, given as a list of $n − 3$ diagonals.\n\nYou are also given $q$ queries. Each query consists of two vertex indices. For each query, find the shortest distance between these two vertices, provided that you can move by the sides and by the given diagonals of the polygon, and the distance is measured as the total number of sides and diagonals you have traversed.\n\n", "inputFormat": "\n\nThe first line of the input file contains an integer $n$ -- the number of vertices of the polygon $(4 \\le n \\le 50 000)$ .\n\nEach of the following $n−3$ lines contains two integers $a_{i}, b_{i}$ -- the ends of the i-th diagonal $(1 \\le a_{i}, b_{i} \\le n , a_{i} ≠ b_{i}).$\n\nThe next line contains an integer $q$ -- the number of queries $(1 \\le q \\le 100 000)$ .\n\nEach of the following $q$ lines contains two integers $x_{i}, y_{i}$ -- the vertices in the i-th query $(1 \\le x_{i}, y_{i} \\le n)$ .\n\nIt is guaranteed that no diagonal coincides with a side of the polygon, and that no two diagonals coincide or intersect.\n\n", "outputFormat": "\n\nFor each query output a line containing the shortest distance.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Distance on Triangulation", "background": "", "description": "\n\nYou have a convex polygon. The vertices of the polygon are successively numbered from $1$ to $n$ . You also have a triangulation of this polygon, given as a list of $n − 3$ diagonals.\n\nYou are also given $q$ queries. Each query consists of two vertex indices. For each query, find the shortest distance between these two vertices, provided that you can move by the sides and by the given diagonals of the polygon, and the distance is measured as the total number of sides and diagonals you have traversed.\n\n", "inputFormat": "\n\nThe first line of the input file contains an integer $n$ -- the number of vertices of the polygon $(4 \\le n \\le 50 000)$ .\n\nEach of the following $n−3$ lines contains two integers $a_{i}, b_{i}$ -- the ends of the i-th diagonal $(1 \\le a_{i}, b_{i} \\le n , a_{i} ≠ b_{i}).$\n\nThe next line contains an integer $q$ -- the number of queries $(1 \\le q \\le 100 000)$ .\n\nEach of the following $q$ lines contains two integers $x_{i}, y_{i}$ -- the vertices in the i-th query $(1 \\le x_{i}, y_{i} \\le n)$ .\n\nIt is guaranteed that no diagonal coincides with a side of the polygon, and that no two diagonals coincide or intersect.\n\n", "outputFormat": "\n\nFor each query output a line containing the shortest distance.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Distance on Triangulation", "background": null, "description": "你有一个凸多边形。多边形的顶点按顺序从 $1$ 到 $n$ 编号。你还有这个多边形的一个三角剖分，给出为 $n-3$ 条对角线的列表。\n\n你还会得到 $q$ 个查询。每个查询由两个顶点索引组成。对于每个查询，找到这两个顶点之间的最短距离，前提是你可以通过多边形的边和给定的对角线移动，距离以你经过的边和对角线的总数来衡量。", "inputFormat": "输入文件的第一行包含一个整数 $n$ —— 多边形的顶点数 $(4 \\le n \\le 50 000)$。\n\n接下来的 $n-3$ 行中的每一行包含两个整数 $a_{i}, b_{i}$ —— 第 $i$ 条对角线的两个端点 $(1 \\le a_{i}, b_{i} \\le n , a_{i} \n\\neq b_{i})$。\n\n下一行包含一个整数 $q$ —— 查询的数量 $(1 \\le q \\le 100 000)$。\n\n接下来的 $q$ 行中的每一行包含两个整数 $x_{i}, y_{i}$ —— 第 $i$ 个查询中的顶点 $(1 \\le x_{i}, y_{i} \\le n)$。\n\n保证没有对角线与多边形的边重合，并且没有两条对角线重合或相交。", "outputFormat": "对于每个查询，输出一行包含最短距离。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6977", "type": "P", "difficulty": 2, "samples": [["3 8\n5 0 3 12 1 10\n4 1 1 23 20\n4 1 5 17 49\n", "94\n"], ["3 10\n2 1 3\n1 1\n2 2 5\n", "354\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Easy Problemset", "background": "", "description": "\n\nPerhaps one of the hardest problems of any ACM ICPC contest is to create a problemset with a reasonable number of easy problems. On Not Easy European Regional Contest this problem is solved as follows.\n\nThere are $n$ jury members (judges). They are numbered from $1$ to $n$ . Judge number $i$ had prepared $p_{i}$ easy problems before the jury meeting. Each of these problems has a hardness between $0$ and $49$ (the higher the harder). Each judge also knows a very large (say infinite) number of hard problems (their hardness is $50$) . Judges need to select $k$ problems to be used on the contest during this meeting.\n\nThey start to propose problems in the ascending order of judges numbers. The first judge takes the first problem from his list of remaining easy problems (or a hard problem, if he has already proposed all his easy problems) and proposes it. The proposed problem is selected for the contest if its hardness is greater than or equal to the total hardness of the problems selected so far, otherwise it is considered too easy. Then the second judge does the same etc. ; after the n-th judge, the first one proposes his next problem, and so on. This procedure is stopped immediately when $k$ problems are selected.\n\nIf all judges have proposed all their easy problems, but they still have selected less than $k$ problems, then they take some hard problems to complete the problemset regardless of the total hardness.\n\nYour task is to calculate the total hardness of the problemset created by the judges.\n\n", "inputFormat": "\n\nThe first line of the input file contains the number of judges $n (2 \\le n \\le 10)$ and the number of problems $k (8 \\le k \\le 14)$ . The i-th of the following $n$ lines contains the description of the problems prepared by the i-th judge. It starts with $p_{i} (1 \\le p_{i} \\le 10)$ followed by $p_{i}$ non negative integers between $0$ and $49$ -- the hardnesses of the problems prepared by the i-th judge in the order they will be proposed.\n\n", "outputFormat": "\n\nOutput the only integer -- the total hardness of the selected problems.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Easy Problemset", "background": "", "description": "\n\nPerhaps one of the hardest problems of any ACM ICPC contest is to create a problemset with a reasonable number of easy problems. On Not Easy European Regional Contest this problem is solved as follows.\n\nThere are $n$ jury members (judges). They are numbered from $1$ to $n$ . Judge number $i$ had prepared $p_{i}$ easy problems before the jury meeting. Each of these problems has a hardness between $0$ and $49$ (the higher the harder). Each judge also knows a very large (say infinite) number of hard problems (their hardness is $50$) . Judges need to select $k$ problems to be used on the contest during this meeting.\n\nThey start to propose problems in the ascending order of judges numbers. The first judge takes the first problem from his list of remaining easy problems (or a hard problem, if he has already proposed all his easy problems) and proposes it. The proposed problem is selected for the contest if its hardness is greater than or equal to the total hardness of the problems selected so far, otherwise it is considered too easy. Then the second judge does the same etc. ; after the n-th judge, the first one proposes his next problem, and so on. This procedure is stopped immediately when $k$ problems are selected.\n\nIf all judges have proposed all their easy problems, but they still have selected less than $k$ problems, then they take some hard problems to complete the problemset regardless of the total hardness.\n\nYour task is to calculate the total hardness of the problemset created by the judges.\n\n", "inputFormat": "\n\nThe first line of the input file contains the number of judges $n (2 \\le n \\le 10)$ and the number of problems $k (8 \\le k \\le 14)$ . The i-th of the following $n$ lines contains the description of the problems prepared by the i-th judge. It starts with $p_{i} (1 \\le p_{i} \\le 10)$ followed by $p_{i}$ non negative integers between $0$ and $49$ -- the hardnesses of the problems prepared by the i-th judge in the order they will be proposed.\n\n", "outputFormat": "\n\nOutput the only integer -- the total hardness of the selected problems.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Easy Problemset", "background": "", "description": "或许在任何 ACM ICPC 比赛中最难的问题之一就是创建一个包含合理数量简单题目的题集。在 Not Easy 欧洲区域赛中，这个问题是这样解决的。\n\n有 $n$ 名评委（裁判）。他们从 $1$ 到 $n$ 编号。编号为 $i$ 的裁判在评委会议之前准备了 $p_{i}$ 道简单题目。这些题目的难度在 $0$ 到 $49$ 之间（数值越大越难）。每位裁判还知道大量（可以说是无限多）难题（它们的难度为 $50$）。裁判们需要在这次会议中选择 $k$ 道题目用于比赛。\n\n他们开始按裁判编号的升序提出题目。第一位裁判从他剩余的简单题目列表中取出第一道题（如果他已经提出了所有简单题目，则取一道难题）并提出。如果提出的题目难度大于或等于目前已选题目的总难度，则该题目被选中用于比赛，否则被认为太简单。然后第二位裁判也这样做，依此类推；在第 $n$ 位裁判之后，第一位裁判提出他的下一道题，如此循环。这个过程在选出 $k$ 道题目时立即停止。\n\n如果所有裁判都提出了他们的所有简单题目，但仍然选出的题目少于 $k$ 道，那么他们将不顾总难度，选择一些难题来完成题集。\n\n你的任务是计算由裁判们创建的题集的总难度。", "inputFormat": "输入文件的第一行包含裁判的数量 $n (2 \\le n \\le 10)$ 和题目的数量 $k (8 \\le k \\le 14)$。接下来的 $n$ 行中的第 $i$ 行包含第 $i$ 位裁判准备的题目的描述。它以 $p_{i} (1 \\le p_{i} \\le 10)$ 开始，后跟 $p_{i}$ 个介于 $0$ 和 $49$ 之间的非负整数——即第 $i$ 位裁判准备的题目的难度，按他们将提出的顺序排列。", "outputFormat": "输出一个整数——所选题目的总难度。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6978", "type": "P", "difficulty": 4, "samples": [["10 7\n2 2\n2 4\n5 1\n5 3\n8 2\n7 5\n9 4\n", "4.5 4.5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2015", "二分", "Special Judge", "最短路", "生成树", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Froggy Ford（征集SPJ）", "background": "", "description": "\n\nFiona designs a new computer game Froggy Ford. In this game, a player helps a frog to cross a river using stone fords. Frog leaps from the river's shore to the first stone ford, than to the second one and so on, until it reaches the other shore. Unfortunately, frog is pretty weak and its leap distance is quite limited. Thus, a player should choose the optimal route -- the route that minimizes the largest leap required to traverse the route.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11740/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11740/2.png)\n\nOptimal route\n\nOptimal route with added stone\n\nFiona thinks that this game is not challenging enough, so she plans to add a possibility to place a new stone in the river. She asks you to write a program that determines such a location of the new stone that minimizes the largest leap required to traverse the optimal route.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $w$ -- the width of the river and $n$ -- the number of stones in it $(1 \\le w \\le 10^{9}, 0 \\le n \\le 1000)$ .\n\nEach of the following $n$ lines contains two integers $x_{i}, y_{i}$ -- the coordinates of the stones $(0 < x_{i} < w , −10^{9} \\le y_i \\le 10^{9}).$ Coordinates of all stones are distinct. River shores have coordinates $x = 0$ and $x = w$ .\n\n", "outputFormat": "\n\nWrite to the output file two real numbers $x_{+}$ and $y_{+} (0 < x_{+} < w , −10^{9} \\le y_{+} \\le 10^{9})$ -- the coordinates of the stone to add. This stone shall minimize the largest leap required to traverse the optimal route. If a new stone cannot provide any improvement to the optimal route, then an arbitrary pair of $x_{+}$ and $y_{+}$ satisfying the constraints can be written, even coinciding with one of the existing stones. Your answer shall be precise up to three digits after the decimal point.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Froggy Ford（征集SPJ）", "background": "", "description": "\n\nFiona designs a new computer game Froggy Ford. In this game, a player helps a frog to cross a river using stone fords. Frog leaps from the river's shore to the first stone ford, than to the second one and so on, until it reaches the other shore. Unfortunately, frog is pretty weak and its leap distance is quite limited. Thus, a player should choose the optimal route -- the route that minimizes the largest leap required to traverse the route.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11740/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11740/2.png)\n\nOptimal route\n\nOptimal route with added stone\n\nFiona thinks that this game is not challenging enough, so she plans to add a possibility to place a new stone in the river. She asks you to write a program that determines such a location of the new stone that minimizes the largest leap required to traverse the optimal route.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $w$ -- the width of the river and $n$ -- the number of stones in it $(1 \\le w \\le 10^{9}, 0 \\le n \\le 1000)$ .\n\nEach of the following $n$ lines contains two integers $x_{i}, y_{i}$ -- the coordinates of the stones $(0 < x_{i} < w , −10^{9} \\le y_i \\le 10^{9}).$ Coordinates of all stones are distinct. River shores have coordinates $x = 0$ and $x = w$ .\n\n", "outputFormat": "\n\nWrite to the output file two real numbers $x_{+}$ and $y_{+} (0 < x_{+} < w , −10^{9} \\le y_{+} \\le 10^{9})$ -- the coordinates of the stone to add. This stone shall minimize the largest leap required to traverse the optimal route. If a new stone cannot provide any improvement to the optimal route, then an arbitrary pair of $x_{+}$ and $y_{+}$ satisfying the constraints can be written, even coinciding with one of the existing stones. Your answer shall be precise up to three digits after the decimal point.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Froggy Ford", "background": null, "description": "Fiona 设计了一款新的电脑游戏 **Froggy Ford**。在这个游戏中，玩家帮助一只青蛙利用河中石墩过河。青蛙从河岸跳到第一个石墩，然后跳到第二个石墩，依此类推，直到到达对岸。不幸的是，青蛙相当虚弱，其跳跃距离相当有限。因此，玩家应该选择最优路径——即最小化完成该路径所需的最大跳跃距离的路径。\n\n:::align{center}\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3doa91gk.png)\n\n最优路径\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vpvs91yd.png)\n\n添加石墩后的最优路径\n\n:::\n\nFiona 认为这个游戏还不够有挑战性，因此她计划添加在河中放置一个新石墩的功能。她请你编写一个程序，确定新石墩的位置，使得完成最优路径所需的最大跳跃距离最小化。", "inputFormat": "输入文件的第一行包含两个整数 $w$ ——河的宽度，以及 $n$ ——河中石墩的数量 $(1 \\le w \\le 10^{9}, 0 \\le n \\le 1000)$。\n\n接下来的 $n$ 行，每行包含两个整数 $x_{i}, y_{i}$ ——石墩的坐标 $(0 < x_{i} < w , −10^{9} \\le y_i \\le 10^{9})$。所有石墩的坐标互不相同。河岸的坐标为 $x = 0$ 和 $x = w$。", "outputFormat": "向输出文件写入两个实数 $x_{+}$ 和 $y_{+} (0 < x_{+} < w , −10^{9} \\le y_{+} \\le 10^{9})$ ——要添加的石墩的坐标。该石墩应能使完成最优路径所需的最大跳跃距离最小化。如果新石墩无法对最优路径提供任何改进，则可以输出满足约束的任意一对 $x_{+}$ 和 $y_{+}$，甚至可以与现有某个石墩的坐标重合。你的答案应精确到小数点后三位。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P6979", "type": "P", "difficulty": 3, "samples": [["2 3\n1 1 1 6\n2 4 0 5\n", "8\n4 1\n"], ["2 2\n0 7 2 8\n2 5 0 6\n", "-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Generators", "background": "", "description": "\n\nLittle Roman is studying linear congruential generators -- one of the oldest and best known pseudorandom number generator algorithms. Linear congruential generator (LCG) starts with a non-negative integer number $x_{0}$ also known as seed and produces an infinite sequence of non-negative integer numbers $x_{i} (0 \\le x_{i} < c)$ which are given by the following recurrence relation:\n\n$x_{i+1} = (ax_{i} + b)$ mod $c$\n\nhere a , $b$ , and $c$ are non-negative integer numbers and $0 \\le x_{0} < c$ .\n\nRoman is curious about relations between sequences generated by different LCGs. In particular, he has $n$ different LCGs with parameters $a^{(j)}, b^{(j)},$ and $c^{(j)}$ for $1 \\le j \\le n$ , where the j-th LCG is generating a sequence $x_{i}^{(j)}.$ He wants to pick one number from each of the sequences generated by each LCG so that the sum of the numbers is the maximum one, but is not divisible by the given integer number $k$ .\n\nFormally, Roman wants to find integer numbers $t_{j} \\ge 0$ for $1 \\le j \\le n$ to maximize $s = Σ^{n}_{j=1} x_{t_{j}}^{(j)}  subject$ to constraint that $s$ mod $k ≠ 0$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains two integer numbers $n$ and $k (1 \\le n \\le 10 000 , 1 \\le k \\le 10^{9}).$ The following $n$ lines describe LCGs. Each line contains four integer numbers $x_{0}^{(j)}, a^{(j)}, b^{(j)},$ and $c^{(j)} (0 \\le a^{(j)}, b^{(j)} \\le 1000 , 0 \\le x_{0}^{(j)} < c^{(j)} \\le 1000)$ .\n\n", "outputFormat": "\n\nIf Roman's problem has a solution, then write on the first line of the output file a single integer $s$ -- the maximum sum not divisible by $k$ , followed on the next line by $n$ integer numbers $t_{j} (0 \\le t_{j} \\le 10^{9})$ specifying some solution with this sum.\n\nOtherwise, write to the output file a single line with the number $−1$ .\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Generators", "background": "", "description": "\n\nLittle Roman is studying linear congruential generators -- one of the oldest and best known pseudorandom number generator algorithms. Linear congruential generator (LCG) starts with a non-negative integer number $x_{0}$ also known as seed and produces an infinite sequence of non-negative integer numbers $x_{i} (0 \\le x_{i} < c)$ which are given by the following recurrence relation:\n\n$x_{i+1} = (ax_{i} + b)$ mod $c$\n\nhere a , $b$ , and $c$ are non-negative integer numbers and $0 \\le x_{0} < c$ .\n\nRoman is curious about relations between sequences generated by different LCGs. In particular, he has $n$ different LCGs with parameters $a^{(j)}, b^{(j)},$ and $c^{(j)}$ for $1 \\le j \\le n$ , where the j-th LCG is generating a sequence $x_{i}^{(j)}.$ He wants to pick one number from each of the sequences generated by each LCG so that the sum of the numbers is the maximum one, but is not divisible by the given integer number $k$ .\n\nFormally, Roman wants to find integer numbers $t_{j} \\ge 0$ for $1 \\le j \\le n$ to maximize $s = Σ^{n}_{j=1} x_{t_{j}}^{(j)}  subject$ to constraint that $s$ mod $k ≠ 0$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains two integer numbers $n$ and $k (1 \\le n \\le 10 000 , 1 \\le k \\le 10^{9}).$ The following $n$ lines describe LCGs. Each line contains four integer numbers $x_{0}^{(j)}, a^{(j)}, b^{(j)},$ and $c^{(j)} (0 \\le a^{(j)}, b^{(j)} \\le 1000 , 0 \\le x_{0}^{(j)} < c^{(j)} \\le 1000)$ .\n\n", "outputFormat": "\n\nIf Roman's problem has a solution, then write on the first line of the output file a single integer $s$ -- the maximum sum not divisible by $k$ , followed on the next line by $n$ integer numbers $t_{j} (0 \\le t_{j} \\le 10^{9})$ specifying some solution with this sum.\n\nOtherwise, write to the output file a single line with the number $−1$ .\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Generators", "background": "", "description": "罗曼在学习线性同余发生器——最古老，也是最广为人知的伪随机数生成算法之一。线性同余发生器（LCG）以 $x_0$ 为随机种子，生成很多非负整数 $x_i$ ,它遵循以下规则：\n\n给定非负整数 $a,b,c\\space(0≤x_0<c)$ ，\n$x_{i+1} = (ax_i+b)\\space mod \\space c$\n\n罗曼很好奇由不同LCG产生的序列之间的关系。特别地，他有 $n$ 个不同的LCG，含有参数 $a^{(j)}, b^{(j)}, c^{(j)}\\space(1≤j≤n)$。第 $j$ 个LCG会生成一个序列 $x_i^{(j)}$ 。\n\n他希望能从每个LCG产生的序列中挑出一个数，使他们的和最大，且不被给定的 $k$ 整除。\n\n**格式化一点来说**，他希望找到整数 $t_j \\space(t_j>0,1≤j≤n)$ ，使$s=\\sum\\limits_{j=1}^nx_{t_j}^{(j)}$最大，且$s\\not\\equiv0(mod\\space k)$。", "inputFormat": "第 $1$ 行包括两个整数$n,k$。\n\n$(1≤n≤10000,1≤k≤10^9)$\n\n\n接下来 $n$ 行描述LCG，每行包括4个整数：$x_0^{(j)},a^{(j)}, b^{(j)}, c^{(j)}$ 。\n\n$(0≤a^{(j)}, b^{(j)}≤1000,0≤x_0^{(j)}<c^{(j)}≤1000)$", "outputFormat": "如果有解，第 $1$ 行输出 $s$，第 $2$ 行输出 $n$ 个 $t_j$ 。\n\n$(0≤t_j≤10^9)$ 。\n\n如果无解，输出 $-1$ 。", "hint": "时间限制：1秒\n\n空间限制：256MB", "locale": "zh-CN"}}}
{"pid": "P6980", "type": "P", "difficulty": 6, "samples": [["3 3 4\n...\n.x.\n...\n.x.\nxxx\n.x.\n...\n.x.\n...\n...\n.x.\n...\n", "Yes\n"], ["8 1 1\nxxxxxxxx\n", "No\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Hypercube", "background": "", "description": "\n\nConsider a $4-hypercube$ also known as tesseract. A unit solid tesseract is a 4D figure that is equal to the convex hull of $16$ points with Cartesian coordinates $(±½, ±½, ±½, ±½)$ -- its vertices. It has $32$ edges $(1D), 24$ square faces $(2D),$ and $8$ cubic $3-faces$ (3D) also known as cells. We study hollow tesseracts and define a tesseract as a boundary of a solid tesseract. Thus, a tesseract is a connected union of $8$ solid cubes (its cells) that intersect between each other at $24$ tesseract's square faces, $32$ edges, and $16$ vertices.\n\nLet's cut a tesseract along $17$ of its $24$ faces, so that it still remains connected via $7$ faces that were left intact. Unfold the tesseract into a 3D hyperplane by rotating its constituting cubes along the faces that were left intact until all its cells lie in the same 3D hyperplane. The result is called a $3-net$ of a tesseract. This process is a natural generalization of how a 3D cube is cut and unfolded onto a 2D plane to produce a $2-net$ of a cube that consists of $6$ squares.\n\nIn this problem you are given a tree-like $8-polycube$ in 3D space also known as octocube. An octocube is a collection of $8$ unit cubical cells joined face-to-face. More formally, intersection of each pair of cubical cells constituting an octocube is either empty, a point, a unit line $(1D),$ or a unit square $(2D).$ The given octocube is tree-like in the following sense. Consider an adjacency graph of the octocube -- a graph with $8$ vertices corresponding to its $8$ cells. There is an edge in the adjacency graph between pairs of adjacent cells. Two cells of an octocube are called adjacent when their intersection is a square. Cells that intersect at a point or a line are not considered adjacent. An octocube is called tree-like when its adjacency graph is a tree.\n\nYour task is to determine whether the given tree-like octocube constitutes a $3-net$ of a tesseract. That is, whether this octocube being put onto a hyperplane in 4D space can be folded in 4D space along the squares of intersection between its cells into a tesseract.\n\nFor example, look at the leftmost picture below. It shows a wire-frame of the tree-like octocube. Rotate cell $GHLKG_{1}H_{1}L_{1}K_{1}$ around a plane GHLK and cell $FGKJF_{2}G_{2}K_{2}J_{2}$ around a plane FGKJ at angle $90$ degrees in $4-th$ dimension outside of the original hyperplane. As a result, point $G_{1}$ joins with $G_{2}$ and $K_{1}$ joins with $K_{2}.$ The face $GKK_{2}G_{2}$ is glued to face $GKK_{1}G_{1}.$ The result is shown on the right. The $4-th$ dimension is orthographically projected onto the $3$ shown in perspective. The points that have moved out of the original hyperplane are marked with hollow dots.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/1.png)\n\nRotate $EFJIE_{1}F_{1}J_{1}I_{1}$ around EFJI and $EHLIE_{2}H_{2}L_{2}I_{2}$ around EHLI. The result is shown on the following picture on the left. The remaining steps are as follows. Rotate MNOPQRST around MNOP, then rotate both MNOPQRST and IJKLMNOP around IJKL and rotate ABCDEFGH around EFGH. The last step is to glue all faces that meet together to get a tesseract that is shown on the right.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/2.png)\n\n", "inputFormat": "\n\nThe first line of the input file contains there integers $m , n , k$ -- the width, the depth, and the height of the box that contains the given octocube $(1 \\le m , n , k \\le 8)$ . The following $k$ groups of lines describe rectangular slices of the box from top to bottom. Each slice is described by $n$ rows with $m$ characters each. The characters on a line are either $‘. ',$ denoting an empty space, or $‘x',$ denoting a unit cube. The input file is guaranteed to describe a tree-like octocube.\n\n", "outputFormat": "\n\nWrite to the output file a single word `Yes` if the given octocube can be folded into a tesseract or `No` otherwise.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Hypercube", "background": "", "description": "\n\nConsider a $4-hypercube$ also known as tesseract. A unit solid tesseract is a 4D figure that is equal to the convex hull of $16$ points with Cartesian coordinates $(±½, ±½, ±½, ±½)$ -- its vertices. It has $32$ edges $(1D), 24$ square faces $(2D),$ and $8$ cubic $3-faces$ (3D) also known as cells. We study hollow tesseracts and define a tesseract as a boundary of a solid tesseract. Thus, a tesseract is a connected union of $8$ solid cubes (its cells) that intersect between each other at $24$ tesseract's square faces, $32$ edges, and $16$ vertices.\n\nLet's cut a tesseract along $17$ of its $24$ faces, so that it still remains connected via $7$ faces that were left intact. Unfold the tesseract into a 3D hyperplane by rotating its constituting cubes along the faces that were left intact until all its cells lie in the same 3D hyperplane. The result is called a $3-net$ of a tesseract. This process is a natural generalization of how a 3D cube is cut and unfolded onto a 2D plane to produce a $2-net$ of a cube that consists of $6$ squares.\n\nIn this problem you are given a tree-like $8-polycube$ in 3D space also known as octocube. An octocube is a collection of $8$ unit cubical cells joined face-to-face. More formally, intersection of each pair of cubical cells constituting an octocube is either empty, a point, a unit line $(1D),$ or a unit square $(2D).$ The given octocube is tree-like in the following sense. Consider an adjacency graph of the octocube -- a graph with $8$ vertices corresponding to its $8$ cells. There is an edge in the adjacency graph between pairs of adjacent cells. Two cells of an octocube are called adjacent when their intersection is a square. Cells that intersect at a point or a line are not considered adjacent. An octocube is called tree-like when its adjacency graph is a tree.\n\nYour task is to determine whether the given tree-like octocube constitutes a $3-net$ of a tesseract. That is, whether this octocube being put onto a hyperplane in 4D space can be folded in 4D space along the squares of intersection between its cells into a tesseract.\n\nFor example, look at the leftmost picture below. It shows a wire-frame of the tree-like octocube. Rotate cell $GHLKG_{1}H_{1}L_{1}K_{1}$ around a plane GHLK and cell $FGKJF_{2}G_{2}K_{2}J_{2}$ around a plane FGKJ at angle $90$ degrees in $4-th$ dimension outside of the original hyperplane. As a result, point $G_{1}$ joins with $G_{2}$ and $K_{1}$ joins with $K_{2}.$ The face $GKK_{2}G_{2}$ is glued to face $GKK_{1}G_{1}.$ The result is shown on the right. The $4-th$ dimension is orthographically projected onto the $3$ shown in perspective. The points that have moved out of the original hyperplane are marked with hollow dots.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/1.png)\n\nRotate $EFJIE_{1}F_{1}J_{1}I_{1}$ around EFJI and $EHLIE_{2}H_{2}L_{2}I_{2}$ around EHLI. The result is shown on the following picture on the left. The remaining steps are as follows. Rotate MNOPQRST around MNOP, then rotate both MNOPQRST and IJKLMNOP around IJKL and rotate ABCDEFGH around EFGH. The last step is to glue all faces that meet together to get a tesseract that is shown on the right.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/2.png)\n\n", "inputFormat": "\n\nThe first line of the input file contains there integers $m , n , k$ -- the width, the depth, and the height of the box that contains the given octocube $(1 \\le m , n , k \\le 8)$ . The following $k$ groups of lines describe rectangular slices of the box from top to bottom. Each slice is described by $n$ rows with $m$ characters each. The characters on a line are either $‘. ',$ denoting an empty space, or $‘x',$ denoting a unit cube. The input file is guaranteed to describe a tree-like octocube.\n\n", "outputFormat": "\n\nWrite to the output file a single word `Yes` if the given octocube can be folded into a tesseract or `No` otherwise.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Hypercube", "background": "", "description": "考虑一个 $4$-超立方体，也称为四维超正方体。一个单位实心四维超正方体是一个四维图形，它等于 $16$ 个点的凸包，这些点的笛卡尔坐标为 $(\\pm\\frac{1}{2}, \\pm\\frac{1}{2}, \\pm\\frac{1}{2}, \\pm\\frac{1}{2})$，即它的顶点。它有 $32$ 条边（$1D$），$24$ 个正方形面（$2D$），以及 $8$ 个立方体 $3$-面（$3D$），也称为单元。我们研究空心四维超正方体，并将四维超正方体定义为一个实心四维超正方体的边界。因此，四维超正方体是 $8$ 个实心立方体（其单元）的连接联合，这些立方体在四维超正方体的 $24$ 个正方形面、$32$ 条边和 $16$ 个顶点之间相交。\n\n让我们沿着四维超正方体的 $24$ 个面中的 $17$ 个面切割它，使其仍然通过剩下的 $7$ 个未被切割的面保持连接。通过沿着未被切割的面旋转其构成立方体，将四维超正方体展开到三维超平面中，直到其所有单元都位于同一三维超平面中。结果称为四维超正方体的 $3$-网。这一过程是三维立方体如何被切割并展开到二维平面上以产生由 $6$ 个正方形组成的立方体的 $2$-网的自然推广。\n\n在这个问题中，给定一个树状的 $8$-多立方体，也称为八立方体。八立方体是由 $8$ 个单位立方单元面对面连接而成的集合。更正式地说，构成八立方体的每对立方单元的交集要么为空，要么是一个点、一个单位线（$1D$），或一个单位正方形（$2D$）。给定的八立方体在以下意义上是树状的。考虑八立方体的邻接图——一个有 $8$ 个顶点的图，对应于其 $8$ 个单元。邻接图中存在一条边连接相邻单元对。当两个八立方体的单元的交集是一个正方形时，它们被称为相邻。当它们在一个点或一条线上相交时，不被认为是相邻的。当其邻接图是树时，八立方体被称为树状。\n\n你的任务是确定给定的树状八立方体是否构成四维超正方体的 $3$-网。也就是说，这个八立方体是否可以放置在四维空间的超平面上，并沿其单元之间的交叉正方形在四维空间中折叠成一个四维超正方体。\n\n例如，看看下面最左边的图片。它显示了树状八立方体的线框。将单元 $GHLKG_{1}H_{1}L_{1}K_{1}$ 绕平面 $GHLK$ 旋转，将单元 $FGKJF_{2}G_{2}K_{2}J_{2}$ 绕平面 $FGKJ$ 在第四维度上旋转 $90$ 度，超出原始超平面。结果，点 $G_{1}$ 与 $G_{2}$ 结合，$K_{1}$ 与 $K_{2}$ 结合。面 $GKK_{2}G_{2}$ 粘合到面 $GKK_{1}G_{1}$。结果如右图所示。第四维度正交投影到所示的三维透视图中。那些从原始超平面移出的点用空心点标记。\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/1.png)\n\n旋转 $EFJIE_{1}F_{1}J_{1}I_{1}$ 绕 $EFJI$，旋转 $EHLIE_{2}H_{2}L_{2}I_{2}$ 绕 $EHLI$。结果如下面左图所示。剩下的步骤如下。绕 $MNOPQRST$ 旋转，然后绕 $IJKL$ 旋转 $MNOPQRST$ 和 $IJKLMNOP$，最后绕 $EFGH$ 旋转 $ABCDEFGH$。最后一步是将所有相遇的面粘合在一起，得到右图所示的四维超正方体。\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/2.png)", "inputFormat": "输入文件的第一行包含三个整数 $m, n, k$——包含给定八立方体的盒子的宽度、深度和高度 $(1 \\le m, n, k \\le 8)$。接下来的 $k$ 组行描述了从上到下的盒子的矩形切片。每个切片由 $n$ 行组成，每行有 $m$ 个字符。行上的字符要么是 ‘.’，表示空格，要么是 ‘x’，表示单位立方体。输入文件保证描述了一个树状八立方体。", "outputFormat": "输出文件中写入一个单词 `Yes`，如果给定的八立方体可以折叠成一个四维超正方体，否则写入 `No`。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6981", "type": "P", "difficulty": 6, "samples": [["7\n42 1 100 200 20\n239 1 100 50 50\n1111 1 101 30 15\n1234 1 100 300 15\n4321 2 99 125 25\n5678 1 101 30 30\n8765 2 101 100 20\n", "42 4321 100 30\n239 4321 100 50\n1111 4321 101 30\n1234 4321 100 15\n5678 8765 101 30\n\n42 1 100 170 20 10\n1234 1 100 285 15 15\n8765 2 101 70 20 20\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Iceberg Orders", "background": "", "description": "\n\nYou are working for Metagonia stock exchange. Recently traders in Metagonia had heard about Iceberg orders traded on London stock exchange and asked your employer to add such functionality as well. A stock exchange is an engine that receives orders and generates trades.\n\nAn iceberg order is a quintuple of integers (ID, $T , P , V$ , TV). Each order has an identifier ID (unique among all orders), type $T$ (which is equal to either BUY $= 1$ or SELL $= 2)$ , price $P$ , total remaining volume $V$ and tip volume TV. For each order, exchange additionally keeps track of its current volume CV and priority PR. There is also a global priority counter of the exchange GP. An order book of the exchange is a set of orders.\n\nTrades that are generated by the exchange are quadruples of integers (BUY ID, SELL ID, $P , V)$ . Each trade has BUY ID and SELL ID -- identifiers of matching BUY and SELL orders, trade price $P$ , and trade volume $V$ .\n\nWhen an order is received by the exchange it is matched against orders currently on the order book. This is done as follows. Suppose an order a is received with $T_{a} =$ SELL. Among all orders currently on the order book we look for an order $b$ such that $T_{b} =$ BUY and $P_{b} \\ge P_{a}.$ We select such an order $b$ with the largest price, and if there are several -- one with the smallest priority. If there is such an order $b$ , then a trade $t$ is generated with BUY $ID_{t} = ID_{b}$ and SELL $ID_{t} = ID_{a}$ at trade price $P_{t} = P_{b}$ with trade volume $V_{t} = mi_n(V_{a}, CV_{b}). V_{a}, V_{b},$ and $CV_{b}$ are all decreased by trade volume. If $V_{b} = 0$ after this, then the order $b$ is removed from the order book. If $CV_{b} = 0$ (but $V_{b} > 0)$ then we set current volume of order $b$ to $CV_{b} = mi_n(V_{b}, TV_{b}),$ set $PR_{b} =$ GP, and increment GP. We continue these operations of selecting $b$ and generating trades until either $V_{a} = 0$ or there are no more orders $b$ on the order book which satisfy the condition. In the latter case, we add order a to the order book with $CV_{a} = mi_n(V_{a}, TV_{a})$ and $PR_{a} =$ GP, and then increment GP. When the process of matching the order a is finished with several trades between the same pair of orders a and $b$ (and there can be lots of them!), they are all united into a single trade with the volume equal to the sum of individual trade volumes.\n\nIf $T_{a} =$ BUY we are looking for an order $b$ with $T_{b} =$ SELL and $P_{b} \\le P_{a}$ and select such an order $b$ with the smallest price and the smallest priority among those. The rest of the matching process is as described above, with trades having BUY $ID_{t} = ID_{a},$ SELL $ID_{t} = ID_{b}, P_{t} = P_{b},$ and $V_{t} = mi_n(V_{a}, CV_{b}).$\n\nInitially the order book is empty. You are presented with several orders that are received by the exchange one by one. You need to print generated trades and the order book state after all orders are processed.\n\nHint: The priority and GP are introduced in the problem statement only for the purpose of a formal description of the algorithm. The actual implementation does not have to keep track of priority. Typically, an exchange simply keeps a priority-ordered list of orders of each type at each price in its order book.\n\n", "inputFormat": "\n\nThe first line of the input contains the number of orders $n (1 \\le n \\le 50 000)$ . Each of the following $n$ lines represent an order. Each order is given by a space-separated quintuple ID $T P V$ TV , where $1 \\le $ ID $ \\le 1 000 000 , T = 1$ for BUY and $T = 2$ for SELL, $1 \\le P \\le 100 000$ and $1 \\le $ TV $ \\le V \\le 1 000 000 000$ .\n\n", "outputFormat": "\n\nFor each order print all trades generated by processing this order, in ascending order of pairs (BUY ID, SELL ID), each trade on its own line. Each trade shall be printed as a space-separated quadruple of integers BUY ID SELL ID $P V$ . It is guaranteed that the total number of trades would not exceed $100 000$ . Print a blank line after all trades, followed by the order book. Each order that is still on the book shall be printed as a space-separated sextuple ID $T P V$ TV CV, sorted first by $P$ and then by PR.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Iceberg Orders", "background": "", "description": "\n\nYou are working for Metagonia stock exchange. Recently traders in Metagonia had heard about Iceberg orders traded on London stock exchange and asked your employer to add such functionality as well. A stock exchange is an engine that receives orders and generates trades.\n\nAn iceberg order is a quintuple of integers (ID, $T , P , V$ , TV). Each order has an identifier ID (unique among all orders), type $T$ (which is equal to either BUY $= 1$ or SELL $= 2)$ , price $P$ , total remaining volume $V$ and tip volume TV. For each order, exchange additionally keeps track of its current volume CV and priority PR. There is also a global priority counter of the exchange GP. An order book of the exchange is a set of orders.\n\nTrades that are generated by the exchange are quadruples of integers (BUY ID, SELL ID, $P , V)$ . Each trade has BUY ID and SELL ID -- identifiers of matching BUY and SELL orders, trade price $P$ , and trade volume $V$ .\n\nWhen an order is received by the exchange it is matched against orders currently on the order book. This is done as follows. Suppose an order a is received with $T_{a} =$ SELL. Among all orders currently on the order book we look for an order $b$ such that $T_{b} =$ BUY and $P_{b} \\ge P_{a}.$ We select such an order $b$ with the largest price, and if there are several -- one with the smallest priority. If there is such an order $b$ , then a trade $t$ is generated with BUY $ID_{t} = ID_{b}$ and SELL $ID_{t} = ID_{a}$ at trade price $P_{t} = P_{b}$ with trade volume $V_{t} = mi_n(V_{a}, CV_{b}). V_{a}, V_{b},$ and $CV_{b}$ are all decreased by trade volume. If $V_{b} = 0$ after this, then the order $b$ is removed from the order book. If $CV_{b} = 0$ (but $V_{b} > 0)$ then we set current volume of order $b$ to $CV_{b} = mi_n(V_{b}, TV_{b}),$ set $PR_{b} =$ GP, and increment GP. We continue these operations of selecting $b$ and generating trades until either $V_{a} = 0$ or there are no more orders $b$ on the order book which satisfy the condition. In the latter case, we add order a to the order book with $CV_{a} = mi_n(V_{a}, TV_{a})$ and $PR_{a} =$ GP, and then increment GP. When the process of matching the order a is finished with several trades between the same pair of orders a and $b$ (and there can be lots of them!), they are all united into a single trade with the volume equal to the sum of individual trade volumes.\n\nIf $T_{a} =$ BUY we are looking for an order $b$ with $T_{b} =$ SELL and $P_{b} \\le P_{a}$ and select such an order $b$ with the smallest price and the smallest priority among those. The rest of the matching process is as described above, with trades having BUY $ID_{t} = ID_{a},$ SELL $ID_{t} = ID_{b}, P_{t} = P_{b},$ and $V_{t} = mi_n(V_{a}, CV_{b}).$\n\nInitially the order book is empty. You are presented with several orders that are received by the exchange one by one. You need to print generated trades and the order book state after all orders are processed.\n\nHint: The priority and GP are introduced in the problem statement only for the purpose of a formal description of the algorithm. The actual implementation does not have to keep track of priority. Typically, an exchange simply keeps a priority-ordered list of orders of each type at each price in its order book.\n\n", "inputFormat": "\n\nThe first line of the input contains the number of orders $n (1 \\le n \\le 50 000)$ . Each of the following $n$ lines represent an order. Each order is given by a space-separated quintuple ID $T P V$ TV , where $1 \\le $ ID $ \\le 1 000 000 , T = 1$ for BUY and $T = 2$ for SELL, $1 \\le P \\le 100 000$ and $1 \\le $ TV $ \\le V \\le 1 000 000 000$ .\n\n", "outputFormat": "\n\nFor each order print all trades generated by processing this order, in ascending order of pairs (BUY ID, SELL ID), each trade on its own line. Each trade shall be printed as a space-separated quadruple of integers BUY ID SELL ID $P V$ . It is guaranteed that the total number of trades would not exceed $100 000$ . Print a blank line after all trades, followed by the order book. Each order that is still on the book shall be printed as a space-separated sextuple ID $T P V$ TV CV, sorted first by $P$ and then by PR.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Iceberg Orders", "background": "", "description": "你正在为 Metagonia 证券交易所工作。最近，Metagonia 的交易员听说了伦敦证券交易所的冰山订单，并要求你的雇主也增加这种功能。证券交易所是一个接收订单并生成交易的引擎。\n\n冰山订单是一个五元组整数 (ID, $T , P , V$ , TV)。每个订单都有一个标识符 ID（在所有订单中唯一），类型 $T$（等于 BUY $= 1$ 或 SELL $= 2$），价格 $P$，总剩余量 $V$ 和显示量 TV。对于每个订单，交易所还会跟踪其当前量 CV 和优先级 PR。交易所还有一个全局优先级计数器 GP。交易所的订单簿是一组订单。\n\n交易所生成的交易是一个四元组整数 (BUY ID, SELL ID, $P , V$)。每笔交易都有 BUY ID 和 SELL ID —— 匹配的买入和卖出订单的标识符，交易价格 $P$ 和交易量 $V$。\n\n当交易所收到一个订单时，它会与当前订单簿上的订单进行匹配。具体操作如下。假设收到一个订单 a，其 $T_{a} =$ SELL。在所有当前订单簿上的订单中，我们寻找一个订单 $b$，使得 $T_{b} =$ BUY 且 $P_{b} \\ge P_{a}$。我们选择这样的订单 $b$，其价格最大，如果有多个，则选择优先级最小的。如果存在这样的订单 $b$，则生成交易 $t$，其 BUY $ID_{t} = ID_{b}$ 和 SELL $ID_{t} = ID_{a}$，交易价格 $P_{t} = P_{b}$，交易量 $V_{t} = \\min(V_{a}, CV_{b})$。$V_{a}, V_{b},$ 和 $CV_{b}$ 都减少交易量。如果 $V_{b} = 0$ 之后，该订单 $b$ 从订单簿中移除。如果 $CV_{b} = 0$（但 $V_{b} > 0$），则我们设置订单 $b$ 的当前量为 $CV_{b} = \\min(V_{b}, TV_{b})$，设置 $PR_{b} =$ GP，并增加 GP。我们继续选择 $b$ 和生成交易的操作，直到 $V_{a} = 0$ 或者没有更多满足条件的订单 $b$ 在订单簿上。在后一种情况下，我们将订单 a 添加到订单簿中，$CV_{a} = \\min(V_{a}, TV_{a})$ 和 $PR_{a} =$ GP，然后增加 GP。当订单 a 的匹配过程结束时，如果在同一对订单 a 和 $b$ 之间有多个交易（可能有很多！），它们都合并为一个交易，交易量等于各个交易量的总和。\n\n如果 $T_{a} =$ BUY，我们寻找一个订单 $b$，使得 $T_{b} =$ SELL 且 $P_{b} \\le P_{a}$，并在其中选择价格最小且优先级最小的订单 $b$。其余的匹配过程如上所述，交易的 BUY $ID_{t} = ID_{a},$ SELL $ID_{t} = ID_{b}, P_{t} = P_{b},$ 和 $V_{t} = \\min(V_{a}, CV_{b})$。\n\n最初订单簿是空的。你将看到几个订单，一个接一个地被交易所接收。你需要打印生成的交易以及所有订单处理完后的订单簿状态。\n\n提示：优先级和 GP 在问题陈述中仅用于算法的形式描述。实际实现不必跟踪优先级。通常，交易所只需在其订单簿中保持每个价格的每种类型的订单的优先级排序列表。", "inputFormat": "输入的第一行包含订单数量 $n (1 \\le n \\le 50 000)$。接下来的 $n$ 行中的每一行代表一个订单。每个订单由一个以空格分隔的五元组 ID $T P V$ TV 给出，其中 $1 \\le $ ID $ \\le 1 000 000 , T = 1$ 表示 BUY，$T = 2$ 表示 SELL，$1 \\le P \\le 100 000$ 且 $1 \\le $ TV $ \\le V \\le 1 000 000 000$。", "outputFormat": "对于每个订单，打印处理该订单生成的所有交易，按 (BUY ID, SELL ID) 对的升序排列，每个交易占一行。每个交易应打印为一个以空格分隔的四元组整数 BUY ID SELL ID $P V$。保证交易总数不超过 $100 000$。在所有交易之后打印一个空行，接着是订单簿。订单簿上仍然存在的每个订单应打印为一个以空格分隔的六元组 ID $T P V$ TV CV，首先按 $P$ 排序，然后按 PR 排序。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6982", "type": "P", "difficulty": 6, "samples": [["2\n1\n0\n1\n2", "01\n11\n10\n00"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Jump", "background": "", "description": "Consider a toy interactive problem ONEMAX which is defined as follows.\n\nYou know an integer $n$ and there is a hidden bit - string $S$ of length $n$. The only thing you may do is to present the system a bit - string $Q$ of length $n$, and the system will return the number $\\text{ONEMAX}(Q)$ — the number of bits which coincide in $Q$ and $S$ at the corresponding positions. The name of ONEMAX problem stems from the fact that this problem and a simpler one explaining when $S = 11\\ldots11$, so that the problem turns into maximization (MAX) of the number of ones (ONE).\n\nWhen $n$ is even, there is a similar (but harder) interactive problem called JUMP. The simplest way to describe the JUMP is by using ONEMAX:\n$$\n\\text{JUMP}(Q)=\n\\begin{cases}\n\\text{ONEMAX}(Q) & \\text{if } \\text{ONEMAX}(Q)=n \\text{ or } \\text{ONEMAX}(Q)=n/2; \\\\\n0 & \\text{otherwise.}\n\\end{cases}\n$$\nBasically, the only nonzero values of ONEMAX which you can see with JUMP are $n$ (which means you've found the hidden string $S$) and $n/2$.\n\nGiven an even integer $n$ — the problem size, you have to solve the JUMP problem for the hidden string $S$ by making interactive JUMP queries. Your task is to eventually make a query $Q$ such that $Q = S$.\n\n### Interaction protocol\n\nFirst, the testing system tells the length of the bit - string $n$. Then, your solution asks the queries and the system answers them as given by the JUMP definition. When a solution asks the query $Q$ such that $Q = S$, the system answers $n$ and terminates, so if your solution, after reading the answer $n$, tries reading or writing anything, it will fail.\n\nThe limit on the number of queries is $n + 500$. If your solution asks a $(n + 501)$ - th query, then you will receive the “Wrong Answer” outcome. You will also receive this outcome if your solution terminates too early.\n\nIf your query contains wrong characters (neither 0, nor 1), or has a wrong length (not equal to $n$), the system will terminate the testing and you will receive the “Presentation Error” outcome.\n\nYou will receive the “Time Limit Exceeded” outcome and other errors for the usual violations.\n\nFinally, if everything is OK (e.g. your solution finds the hidden string) on every test, you will receive the “Accepted” outcome, in this case you will have solved the problem.", "inputFormat": "The first line of the input stream contains an even number $n$ ($2\\leq n\\leq1000$). The next lines of the input stream consist of the answers to the corresponding queries. Each answer is an integer — either $0$, $n/2$, or $n$. Each answer is on its own line.", "outputFormat": "To make a query, print a line which contains a string of length $n$ which consists of characters $0$ and $1$ only. Don't forget to put a newline character and to flush the output stream after you print your query. ", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NEERC 2015] Jump", "background": "", "description": "Consider a toy interactive problem ONEMAX which is defined as follows.\n\nYou know an integer $n$ and there is a hidden bit - string $S$ of length $n$. The only thing you may do is to present the system a bit - string $Q$ of length $n$, and the system will return the number $\\text{ONEMAX}(Q)$ — the number of bits which coincide in $Q$ and $S$ at the corresponding positions. The name of ONEMAX problem stems from the fact that this problem and a simpler one explaining when $S = 11\\ldots11$, so that the problem turns into maximization (MAX) of the number of ones (ONE).\n\nWhen $n$ is even, there is a similar (but harder) interactive problem called JUMP. The simplest way to describe the JUMP is by using ONEMAX:\n$$\n\\text{JUMP}(Q)=\n\\begin{cases}\n\\text{ONEMAX}(Q) & \\text{if } \\text{ONEMAX}(Q)=n \\text{ or } \\text{ONEMAX}(Q)=n/2; \\\\\n0 & \\text{otherwise.}\n\\end{cases}\n$$\nBasically, the only nonzero values of ONEMAX which you can see with JUMP are $n$ (which means you've found the hidden string $S$) and $n/2$.\n\nGiven an even integer $n$ — the problem size, you have to solve the JUMP problem for the hidden string $S$ by making interactive JUMP queries. Your task is to eventually make a query $Q$ such that $Q = S$.\n\n### Interaction protocol\n\nFirst, the testing system tells the length of the bit - string $n$. Then, your solution asks the queries and the system answers them as given by the JUMP definition. When a solution asks the query $Q$ such that $Q = S$, the system answers $n$ and terminates, so if your solution, after reading the answer $n$, tries reading or writing anything, it will fail.\n\nThe limit on the number of queries is $n + 500$. If your solution asks a $(n + 501)$ - th query, then you will receive the “Wrong Answer” outcome. You will also receive this outcome if your solution terminates too early.\n\nIf your query contains wrong characters (neither 0, nor 1), or has a wrong length (not equal to $n$), the system will terminate the testing and you will receive the “Presentation Error” outcome.\n\nYou will receive the “Time Limit Exceeded” outcome and other errors for the usual violations.\n\nFinally, if everything is OK (e.g. your solution finds the hidden string) on every test, you will receive the “Accepted” outcome, in this case you will have solved the problem.", "inputFormat": "The first line of the input stream contains an even number $n$ ($2\\leq n\\leq1000$). The next lines of the input stream consist of the answers to the corresponding queries. Each answer is an integer — either $0$, $n/2$, or $n$. Each answer is on its own line.", "outputFormat": "To make a query, print a line which contains a string of length $n$ which consists of characters $0$ and $1$ only. Don't forget to put a newline character and to flush the output stream after you print your query. ", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6983", "type": "P", "difficulty": 6, "samples": [["4 6\n1 4\n4 1\n4 2\n2 1\n3 4\n1 3\n", "1 3 4 2 1\n"], ["4 3\n1 4\n1 4\n2 2\n", "There is no route, Karl!\n"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] King’s Inspection", "background": "", "description": "\n\nKing Karl is a responsible and diligent ruler. Each year he travels across his country to make certain that all cities are doing well.\n\nThere are $n$ cities in his country and $m$ roads. In order to control the travelers, each road is unidirectional, that is a road from city a to city $b$ can not be passed from $b$ to a .\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11745/1.png)\n\nKarl wants to travel along the roads in such a way that he starts in the capital, visits every non-capital city exactly once, and finishes in the capital again.\n\nAs a transport minister, you are obliged to find such a route, or to determine that such a route doesn't exist.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $m (2 \\le n \\le 100 000 , 0 \\le m \\le n + 20)$ -- the number of cities and the number of roads in the country.\n\nEach of the next $m$ lines contains two integers $a_{i}$ and $b_{i} (1 \\le a_{i}, b_{i} \\le n)$ , meaning that there is a one-way road from city $a_{i}$ to city $b_{i}.$ Cities are numbered from $1$ to $n$ . The capital is numbered as $1$ .\n\n", "outputFormat": "\n\nIf there is a route that passes through each non-capital city exactly once, starting and finishing in the capital, then output $n + 1$ space-separated integers -- a list of cities along the route. Do output the capital city both in the beginning and in the end of the route.\n\nIf there is no desired route, output `There is no route, Karl!` (without quotation marks).\n\n", "hint": "Time limit: 10 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] King’s Inspection", "background": "", "description": "\n\nKing Karl is a responsible and diligent ruler. Each year he travels across his country to make certain that all cities are doing well.\n\nThere are $n$ cities in his country and $m$ roads. In order to control the travelers, each road is unidirectional, that is a road from city a to city $b$ can not be passed from $b$ to a .\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11745/1.png)\n\nKarl wants to travel along the roads in such a way that he starts in the capital, visits every non-capital city exactly once, and finishes in the capital again.\n\nAs a transport minister, you are obliged to find such a route, or to determine that such a route doesn't exist.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $m (2 \\le n \\le 100 000 , 0 \\le m \\le n + 20)$ -- the number of cities and the number of roads in the country.\n\nEach of the next $m$ lines contains two integers $a_{i}$ and $b_{i} (1 \\le a_{i}, b_{i} \\le n)$ , meaning that there is a one-way road from city $a_{i}$ to city $b_{i}.$ Cities are numbered from $1$ to $n$ . The capital is numbered as $1$ .\n\n", "outputFormat": "\n\nIf there is a route that passes through each non-capital city exactly once, starting and finishing in the capital, then output $n + 1$ space-separated integers -- a list of cities along the route. Do output the capital city both in the beginning and in the end of the route.\n\nIf there is no desired route, output `There is no route, Karl!` (without quotation marks).\n\n", "hint": "Time limit: 10 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] King’s Inspection", "background": "", "description": "国王 Karl 是一位负责且勤勉的统治者。每年他都会在全国各地巡游，以确保所有城市都运转良好。\n\n他的国家有 $n$ 个城市和 $m$ 条道路。为了控制旅行者，每条道路都是单向的，即从城市 $a$ 到城市 $b$ 的道路不能从 $b$ 到 $a$ 通过。\n\nKarl 想要沿着这些道路旅行，他希望从首都出发，恰好访问每个非首都城市一次，并最终回到首都。\n\n作为交通部长，你有责任找到这样一条路线，或者确定这样的路线不存在。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$ $(2 \\le n \\le 100000, 0 \\le m \\le n + 20)$ —— 国家中的城市数量和道路数量。\n\n接下来的 $m$ 行中的每一行包含两个整数 $a_{i}$ 和 $b_{i}$ $(1 \\le a_{i}, b_{i} \\le n)$，表示有一条从城市 $a_{i}$ 到城市 $b_{i}$ 的单向道路。城市编号从 $1$ 到 $n$。首都编号为 $1$。", "outputFormat": "如果存在一条路线可以恰好经过每个非首都城市一次，并且起点和终点都是首都，则输出 $n + 1$ 个以空格分隔的整数——表示沿途经过的城市列表。请在路线的开头和结尾都输出首都城市。\n\n如果没有符合条件的路线，则输出 `There is no route, Karl!`（不带引号）。", "hint": "时间限制：10 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6984", "type": "P", "difficulty": 6, "samples": [["8 4\n3\n4\n2\n1\n3\n3\n2\n4\n", "5\n"], ["3 100\n3\n3\n3\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Landscape Improved", "background": "", "description": "\n\nLouis $L$ Le Roi-Univers has ordered to improve the landscape that is seen from the royal palace. His Majesty prefers to see a high mountain.\n\nThe Chief Landscape Manager is going to raise a mountain for Louis. He represents a landscape as a flat picture on a grid of unit squares. Some of the squares are already filled with rock, while others are empty. This greatly simplifies the design. Unit squares are small enough, and the landscape seems to be smooth from the royal palace.\n\nThe Chief Landscape Manager has a plan of the landscape -- the heights of all rock-filled columns for each unit of width. He is going to add at most $n$ square units of stones atop of the existing landscape to make a mountain with as high peak as possible. Unfortunately, piles of stones are quite unstable. A unit square of stones may be placed only exactly on top of the other filled square of stones or rock, moreover the squares immediately to the bottom-left and to bottom-right of it should be already filled.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11746/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11746/2.png)\n\nExisting landscape\n\nImproved landscape\n\nYour task is to help The Chief Landscape Manager to determine the maximum height of the highest mountain he can build.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $w$ -- the width of the existing landscape and $n$ -- the maximum number of squares of stones to add $(1 \\le w \\le 100 000 , 0 \\le n \\le 10^{18}).$\n\nEach of the following $w$ lines contains a single integer $h_{i}$ -- the height of the existing landscape column $(1 \\le h_{i} \\le 10^{9}).$\n\n", "outputFormat": "\n\nThe output file shall contain the single integer -- the maximum possible landscape height after at most $n$ unit squares of stones are added in a stable way.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Landscape Improved", "background": "", "description": "\n\nLouis $L$ Le Roi-Univers has ordered to improve the landscape that is seen from the royal palace. His Majesty prefers to see a high mountain.\n\nThe Chief Landscape Manager is going to raise a mountain for Louis. He represents a landscape as a flat picture on a grid of unit squares. Some of the squares are already filled with rock, while others are empty. This greatly simplifies the design. Unit squares are small enough, and the landscape seems to be smooth from the royal palace.\n\nThe Chief Landscape Manager has a plan of the landscape -- the heights of all rock-filled columns for each unit of width. He is going to add at most $n$ square units of stones atop of the existing landscape to make a mountain with as high peak as possible. Unfortunately, piles of stones are quite unstable. A unit square of stones may be placed only exactly on top of the other filled square of stones or rock, moreover the squares immediately to the bottom-left and to bottom-right of it should be already filled.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11746/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11746/2.png)\n\nExisting landscape\n\nImproved landscape\n\nYour task is to help The Chief Landscape Manager to determine the maximum height of the highest mountain he can build.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $w$ -- the width of the existing landscape and $n$ -- the maximum number of squares of stones to add $(1 \\le w \\le 100 000 , 0 \\le n \\le 10^{18}).$\n\nEach of the following $w$ lines contains a single integer $h_{i}$ -- the height of the existing landscape column $(1 \\le h_{i} \\le 10^{9}).$\n\n", "outputFormat": "\n\nThe output file shall contain the single integer -- the maximum possible landscape height after at most $n$ unit squares of stones are added in a stable way.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Landscape Improved", "background": "", "description": "路易斯 $L$ Le Roi-Univers 下令改善从皇宫看到的景观。陛下希望看到一座高山。  \n\n首席景观经理打算为路易斯建造一座山。他将景观表示为单位方格网格上的平面图。一些方格已经被岩石填满，而其他方格是空的。这大大简化了设计。单位方格足够小，从皇宫看去，景观似乎是平滑的。  \n\n首席景观经理有一个景观计划——每个单位宽度的所有岩石填充列的高度。他打算在现有景观上最多添加 $n$ 个单位方格的石头，以建造一座尽可能高的山峰。不幸的是，石头堆非常不稳定。一个单位方格的石头只能精确地放在其他填充的石头或岩石方格的正上方，而且其左下方和右下方的方格应该已经被填满。  \n\n现有景观  \n\n改进后的景观  \n\n你的任务是帮助首席景观经理确定他能建造的最高山峰的最大高度。", "inputFormat": "输入文件的第一行包含两个整数 $w$ ——现有景观的宽度和 $n$ ——最多可以添加的石头方格数 $(1 \\le w \\le 100 000 , 0 \\le n \\le 10^{18})$。  \n\n接下来的 $w$ 行中的每一行包含一个整数 $h_{i}$ ——现有景观列的高度 $(1 \\le h_{i} \\le 10^{9})$。", "outputFormat": "输出文件应包含一个整数——在最多添加 $n$ 个单位方格的石头后，景观可能达到的最大高度。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6985", "type": "P", "difficulty": 3, "samples": [["2 2\n", "2\n1 1 1 1\n2 2 2 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Alter Board", "background": "", "description": "Little Dima gave his little brother Petya interactive chess board of size $n \\times m$ as a present. There are many awesome features of this board but one is Petya's favorite. He can choose any rectangle formed by board squares and perform an inversion. Every white cell in the inverted rectangle becomes black and every black one becomes white.\n\nIn the initial state the board is colored in chess style, namely every cell is either black or white and every two cells that share a side have different colors. Little Petya wants to perform several inversions described above to turn all cells into the same color. He is impatient, so he asks you to provide him with instructions to do it with the minimal number of inversions.", "inputFormat": "Contains two integers $n$ and $m (1 \\le n , m \\le 50) -$ the number of rows and columns on the board, respectively.", "outputFormat": "\nThe first line must contain the number of inversions $k$ required to transform the board.\n\nThe following $k$ lines must describe inversions, one per line. Each line must contains $4$ integers $-$ row and column of one of the corners of the corresponding rectangle and row and column of the opposite corner. Any two opposite corners can be used to specify a rectangle.\n\nRows of the board are numbered from $1$ to $n$ . Columns of the board are numbered from $1$ to $m$ . ", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Alter Board", "background": "", "description": "Little Dima gave his little brother Petya interactive chess board of size $n \\times m$ as a present. There are many awesome features of this board but one is Petya's favorite. He can choose any rectangle formed by board squares and perform an inversion. Every white cell in the inverted rectangle becomes black and every black one becomes white.\n\nIn the initial state the board is colored in chess style, namely every cell is either black or white and every two cells that share a side have different colors. Little Petya wants to perform several inversions described above to turn all cells into the same color. He is impatient, so he asks you to provide him with instructions to do it with the minimal number of inversions.", "inputFormat": "Contains two integers $n$ and $m (1 \\le n , m \\le 50) -$ the number of rows and columns on the board, respectively.", "outputFormat": "\nThe first line must contain the number of inversions $k$ required to transform the board.\n\nThe following $k$ lines must describe inversions, one per line. Each line must contains $4$ integers $-$ row and column of one of the corners of the corresponding rectangle and row and column of the opposite corner. Any two opposite corners can be used to specify a rectangle.\n\nRows of the board are numbered from $1$ to $n$ . Columns of the board are numbered from $1$ to $m$ . ", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Alter Board", "background": "", "description": "小 Dima 给了他的小弟弟 Petya 一个大小为 $n \\times m$ 的交互式棋盘作为礼物。这个棋盘有很多很棒的功能，但有一个是 Petya 最喜欢的。他可以选择由棋盘方格形成的任意矩形并进行反转。被反转矩形中的每个白色单元格变为黑色，每个黑色单元格变为白色。\n\n在初始状态下，棋盘是以国际象棋风格着色的，即每个单元格要么是黑色，要么是白色，并且每两个共享一条边的单元格具有不同的颜色。小 Petya 想执行上述几个反转操作以将所有单元格变为相同的颜色。他很不耐烦，所以他请你提供指令，以最少的反转次数完成。", "inputFormat": "包含两个整数 $n$ 和 $m (1 \\le n , m \\le 50)$ —— 棋盘上的行数和列数。", "outputFormat": "第一行必须包含将棋盘转换所需的反转次数 $k$。\n\n接下来的 $k$ 行必须描述反转，每行一个。每行必须包含 $4$ 个整数 —— 对应矩形的一个角的行和列以及相对角的行和列。可以使用任意两个相对角来指定一个矩形。\n\n棋盘的行从 $1$ 到 $n$ 编号。棋盘的列从 $1$ 到 $m$ 编号。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n特殊评测提供者：@[shenyouran](/user/137367)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6986", "type": "P", "difficulty": 0, "samples": [["2 5 5\n2 2 1\n2 2 4\n", "5.5 5\n2 0.75\n"], ["2 5 5\n2 2 2\n2 2 4\n", "-1 -1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Burrito King（征集SPJ）", "background": "", "description": "\n\nTwo friends Albert and Barney came to the newly opened restaurant `Burrito King`. The restaurant had opened just yesterday, and Albert has got a special gift card, which allows the friends to get a free burrito. However, there is a constraint on the amount of ingredients -- the burrito can contain at most $g_i$ grams of ingredient $\\(i\\)$ for all $\\(i\\)$ from $1$ to $\\(n\\).$\n\nThere are two satisfaction parameters $\\(a_i\\)$ and $\\(b_i\\)$ for each ingredient -- the amount of Albert's joy per gram of the corresponding ingredient, and the amount of Barney's unhappiness per gram, correspondingly.\n\nTherefore, the total Albert's joy from the burrito is equal to:\n\n$\\[\\su_m_{i=1}^{n}{s_i \\cdot a_i}\\]$\n\nThe total Barney's unhappiness from the burrito is equal to:\n\n$\\[\\su_m_{i=1}^{n}{s_i \\cdot b_i}\\]$\n\nHere $\\(s_i\\)$ is the number of grams of the $\\(i\\)-th$ ingredient in the burrito. Note, that $\\(s_i\\)$ is not necessarily an integer, and $0 \\le \\(s_i\\) \\le \\(g_i\\).$\n\nAlbert wants to make his total joy from the burrito to be at least $\\(A\\).$ Barney is his best friend, so Albert wants Barney's total unhappiness to be no more than $\\(B\\).$ Among all possible burritos that satisfy the above constrains, Albert wants to choose one that maximises his total joy.\n\nYour task is to help Albert to choose $\\(s_i\\)$ to satisfy these conditions or to find out that there is no solution.\n\n", "inputFormat": "\n\nThe first line contains three integers $\\(n\\), \\(A\\),$ and $\\(B\\) (1 \\le \\(n\\) \\le 100 000 , 0 \\le \\(A\\), \\(B\\) \\le 10^{9}),$ the number of ingredients, the least amount of Albert's joy and the maximal amount of Barney's unhappiness. Each of the following $\\(n\\)$ lines contains a description of an ingredient: three integers $\\(g_i\\), \\(a_i\\), \\(b_i\\) (0 \\le \\(g_i\\), \\(a_i\\), \\(b_i\\) \\le 100)$ -- the maximal number of grams allowed, the amount of Albert's joy per gram and the amount of Barney's unhappiness per gram.\n\n", "outputFormat": "\n\nThe first line of the output must contain two real numbers -- the maximal amount of his joy and the amount of Barney's unhappiness that Albert can obtain, satisfying the conditions in the problem statement, or $`−1 −1`,$ if Albert cannot satisfy the conditions.\n\nIf the conditions are satisfiable the second line must contain $\\(n\\)$ real numbers -- the amount of each ingredient in grams.\n\nYour output must have an absolute or relative error of at most $10−8$ .\n\nAny way to reach maximal Albert's joy that satisfies the given conditions can be printed.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Burrito King（征集SPJ）", "background": "", "description": "\n\nTwo friends Albert and Barney came to the newly opened restaurant `Burrito King`. The restaurant had opened just yesterday, and Albert has got a special gift card, which allows the friends to get a free burrito. However, there is a constraint on the amount of ingredients -- the burrito can contain at most $g_i$ grams of ingredient $\\(i\\)$ for all $\\(i\\)$ from $1$ to $\\(n\\).$\n\nThere are two satisfaction parameters $\\(a_i\\)$ and $\\(b_i\\)$ for each ingredient -- the amount of Albert's joy per gram of the corresponding ingredient, and the amount of Barney's unhappiness per gram, correspondingly.\n\nTherefore, the total Albert's joy from the burrito is equal to:\n\n$\\[\\su_m_{i=1}^{n}{s_i \\cdot a_i}\\]$\n\nThe total Barney's unhappiness from the burrito is equal to:\n\n$\\[\\su_m_{i=1}^{n}{s_i \\cdot b_i}\\]$\n\nHere $\\(s_i\\)$ is the number of grams of the $\\(i\\)-th$ ingredient in the burrito. Note, that $\\(s_i\\)$ is not necessarily an integer, and $0 \\le \\(s_i\\) \\le \\(g_i\\).$\n\nAlbert wants to make his total joy from the burrito to be at least $\\(A\\).$ Barney is his best friend, so Albert wants Barney's total unhappiness to be no more than $\\(B\\).$ Among all possible burritos that satisfy the above constrains, Albert wants to choose one that maximises his total joy.\n\nYour task is to help Albert to choose $\\(s_i\\)$ to satisfy these conditions or to find out that there is no solution.\n\n", "inputFormat": "\n\nThe first line contains three integers $\\(n\\), \\(A\\),$ and $\\(B\\) (1 \\le \\(n\\) \\le 100 000 , 0 \\le \\(A\\), \\(B\\) \\le 10^{9}),$ the number of ingredients, the least amount of Albert's joy and the maximal amount of Barney's unhappiness. Each of the following $\\(n\\)$ lines contains a description of an ingredient: three integers $\\(g_i\\), \\(a_i\\), \\(b_i\\) (0 \\le \\(g_i\\), \\(a_i\\), \\(b_i\\) \\le 100)$ -- the maximal number of grams allowed, the amount of Albert's joy per gram and the amount of Barney's unhappiness per gram.\n\n", "outputFormat": "\n\nThe first line of the output must contain two real numbers -- the maximal amount of his joy and the amount of Barney's unhappiness that Albert can obtain, satisfying the conditions in the problem statement, or $`−1 −1`,$ if Albert cannot satisfy the conditions.\n\nIf the conditions are satisfiable the second line must contain $\\(n\\)$ real numbers -- the amount of each ingredient in grams.\n\nYour output must have an absolute or relative error of at most $10−8$ .\n\nAny way to reach maximal Albert's joy that satisfies the given conditions can be printed.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Burrito King（征集SPJ）", "background": "", "description": "两个朋友阿尔伯特和巴尼来到新开的 Burrito King 厅。这家餐厅昨天刚刚开业，阿尔伯特收到了一张特殊的礼品卡，可以让他们免费得到一份墨西哥卷饼。然而，配料的数量是有限制的。第 $i$ 种配料最多可以含有 $g_i$ 克（$1\\le i\\le n$）。\n\n每种成分都有两个满意度参数 $a_i$ 和 $b_i$。分别指每克相应成分的阿尔伯特获得的快乐量和每克巴尼获得的不快乐量。因此，阿尔伯特从墨西哥卷饼中获得的全部快乐等于：\n$$\\sum_{i=1}^{n}s_i\\cdot a_i$$\n巴尼对墨西哥卷饼的全部不快乐等于：\n$$\\sum_{i=1}^{n}s_i\\cdot b_i$$\n这里 $s_i$ 是墨西哥卷饼中第 $i$ 种配料分的克数。注意，$s_i$ 不一定是整数，并且 $0\\le s_i\\le g_i$。\n\n阿尔伯特想让他从墨西哥卷饼中获得的全部快乐至少是 $A$。巴尼是他最好的朋友，所以阿尔伯特希望巴尼的全部不快乐不超过 $B$。在所有可能满足上述限制的卷饼中，阿尔伯特想选择一种能最大限度地增加他全部快乐的卷饼。\n\n您的任务是帮助阿尔伯特选择 $s_i$ 来满足这些条件，或者发现没有解决方案。", "inputFormat": "第一行包含三个整数 $N$、$A$ 和 $B$（$1\\le N \\le 10^{5},0\\le A,B\\le 10^{9}$）。\n\n以下 $N$ 行都包含一种配料的描述：三个整数 $g_i$、 $a_i$、 $b_i$（$0\\le g_i,a_i,b_i\\le 100$），分别指第 $i$ 种配料的最大含有克数、每克阿尔伯特获得的快乐的量和每克巴尼获得的不快乐的量。", "outputFormat": "输出的第一行必须包含两个实数，指满足问题陈述中的条件时，阿尔伯特能获得的最大快乐量和巴尼的不快乐量，或者 `-1`（如果阿尔伯特不能满足条件）。\n\n如果条件可以满足，第二行包含 $N$ 个实数  $s_i$，单位为克。\n\n**您的输出必误差最多为 $10^{-8}$。任何满足给定条件的方法都判为正确。**", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6987", "type": "P", "difficulty": 6, "samples": [["c(c,t(loop(3),c(c,loop(6))),loop(c,c,t(c,loop(4))))\n", "15 1\n19 1 2 9 10 11 12 13 10 15 9 14 2 3 4 5 6 7 8 3\n"], ["c\n", "2 1\n2 1 2\n"], ["c(2)\n", "3 1\n3 1 2 3\n"], ["c(3)\n", "4 1\n4 1 2 3 4\n"], ["t(c(3),c,c)\n", "6 2\n2 1 2\n5 3 1 4 5 6\n"], ["c(2,t(c(2),c,c))\n", "9 3\n3 2 1 3\n3 4 5 6\n5 1 7 5 8 9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Cactus Generator（征集SPJ）", "background": "", "description": "\n\nNEERC featured a number of problems about cactuses -- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed.\n\nIn $2005$ , the first year where a problem about cactuses appeared, the problem was called simply `Cactus`. In $2007$ it was `Cactus Reloaded`, in $2010$ it was called `Cactus Revolution`, and in $2013$ it was called `Cactus Automorphisms`. Here is an example of cactus that was used in those problems:\n\n![](/upload/images2/cactus.png)\n\nFor four years judges had to generate test files for cactuses with thousands of vertices. Of course, a number of test generators of ever-increasing complexity were built, culminating with a domain-specific language called CGL -- Cactus Generator Language. CGL can compactly define a big cactus for purposes of a test. In this problem you have to parse a simplified version of this language, which we call SCGL -- Simple Cactus Generator Language, and output a resulting cactus.\n\nA cactus has to be output by listing the minimal set of edge-distinct paths that cover the whole graph.\n\nThe syntax of SCGL cactus definition is represented by the graph non-terminal in the grammar that is given below using the Extended Backus-Naur Form:\n\ngraph $=$ `c`\n\n$|$ `c(` list `)`\n\n$|$ `loop(` list `)`\n\n$|$ `t(` list `)`\n\nlist $=$ graph ${$ `,` graph $}$\n\n$|$ (number $|$ range $|$ variable ) $[$ `,` graph $]$\n\nnumber $=$ nzdig ${$ `0` $|$ nzdig $}$\n\nnzdig $=$ `1` $|$ `2` $| \\cdots |$ `8` $|$ `9`\n\nrange $=$ `range(` variable `,` numvar `,` numvar `)`\n\nvariable $=$ `A` $|$ `B` $| \\cdots |$ `Y` $|$ `Z`\n\nnumvar $=$ number $|$ variable\n\nA graph production rule denotes a graph with two labeled vertices -- the first and the last. Graphs definition rules have the following semantics:\n\nThe basic building block $c$ denotes a graph with just two vertices (one is the first and the other one is the last) and one edge.\n\nThe $c(σ)$ rule connects a specified list of graphs $σ$ from left to right into a chain, merging the last vertex of the first graph in the list with the first vertex of the second graph in the list, the last vertex of the second graph with the first of the third one, and so on. The resulting graph's first vertex is the first vertex of the first graph in the list, and the resulting graph's last vertex is the last vertex of the last graph in the list.\n\nThe $loo_p(σ)$ rule connects a specified list of graphs $σ$ from left to right, merging the last vertex of the first graph in the list with the first vertex of the second graph in the list, and so on like in $c(σ),$ while the last vertex of the last graph in the list is merged with the first vertex of the first graph in the list to form a loop. The resulting graph's first and last vertices are the first and the last vertices of the first graph in the list. Loop can be applied only to lists with more than one graph.\n\nThe $t(σ)$ rule connects a specified list of graphs $σ,$ merging their first vertices. The resulting graph's first and last vertices are the first and the last vertices of the first graph in the list.\n\nThe list of graphs is either specified explicitly, by a comma-separated list, or using a list repetition with a number, a range, or a variable, optionally followed by a comma and a graph. When a graph is not explicitly specified in a list repetition, then the given graph is assumed to be $c$ .\n\nThe simplest list repetition is defined using a number non-terminal. It denotes a list of graphs with the specified integer number of copies of the given graph.\n\nA range list repetition is defined by $range(ν, α, β)$ rule which has three components -- a variable $ν,$ and numbers $α$ and $β.$ If $ξ$ character sequence is a graph, then $c|loo_p|t(range(ν, α, β), ξ)$ are called rangeenabled rules and the variable $ν$ is called a bound variable in $ξ.$ In the context of a range-enabled rule, $ξ$ is repeated $|β − α| + 1$ times to form a list. Every occurrence of variable $ν$ in $ξ$ is replaced by consecutive integer numbers between $α$ and $β$ inclusive in ascending order. That produces a list of $|β −α|+ 1$ graphs, which are then connected according the specification of the corresponding range-enabled rule. The $α$ and $β$ themselves might refer to variables that are bound in the outer range-enabled rule.\n\nIn a well-formed graph:\n\neach variable non-terminal (a letter from A to $Z)$ occurs at most once as $ν$ in $range(ν, α, β)$ rules;\n\nall other occurrences of variable non-terminal that are allowed by the grammar are bound.\n\nNote, that if a character sequence $ξ$ is a graph, then $ξ, c(ξ),$ c(1 , $ξ), t(ξ),$ and t(1 , $ξ)$ all denote the same graph. On the other hand, neither $loo_p(ξ)$ nor loop(1 , $ξ)$ are allowed.\n\nThe following examples illustrate these basic rules. The graphs have their first and last vertices marked with letters $F$ and $L$ correspondingly.\n\n![](/upload/images2/cactus1.png)\n\n![](/upload/images2/cactus2.png)\n\n", "inputFormat": "\n\nThe input file contains a single line with a well-formed cactus definition in SCGL. While the syntax and semantics of SCGL themselves do not guarantee that the resulting graph is a cactus, the input file for this problem always defines a cactus -- every edge belongs to at most one simple cycle and there are no multiple edges between vertices. For example, neither loop(3 , $loo_p(3))$ nor $loo_p(2)$ are possible.\n\nThe line in the input file is at most $1000$ characters long and defines a cactus with at most $50 000$ vertices. Integer numbers represented by number non-terminals do not exceed $50 000$ .\n\n", "outputFormat": "\n\nThe first line of the output file must contain two integer numbers $n$ and $m$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ , where $1$ is the number of the first vertex of the graph and $n$ is the number of the last vertex of the graph. The other vertices can be numbered arbitrarily. Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the minimal number of such paths.\n\nEach of the following $m$ lines must contain a path in the graph. A path starts with an integer number $k_{i} (k_{i} \\ge 2)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. A path can go to the same vertex multiple times, but every edge must be traversed exactly once in the whole output file.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Cactus Generator（征集SPJ）", "background": "", "description": "\n\nNEERC featured a number of problems about cactuses -- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed.\n\nIn $2005$ , the first year where a problem about cactuses appeared, the problem was called simply `Cactus`. In $2007$ it was `Cactus Reloaded`, in $2010$ it was called `Cactus Revolution`, and in $2013$ it was called `Cactus Automorphisms`. Here is an example of cactus that was used in those problems:\n\n![](/upload/images2/cactus.png)\n\nFor four years judges had to generate test files for cactuses with thousands of vertices. Of course, a number of test generators of ever-increasing complexity were built, culminating with a domain-specific language called CGL -- Cactus Generator Language. CGL can compactly define a big cactus for purposes of a test. In this problem you have to parse a simplified version of this language, which we call SCGL -- Simple Cactus Generator Language, and output a resulting cactus.\n\nA cactus has to be output by listing the minimal set of edge-distinct paths that cover the whole graph.\n\nThe syntax of SCGL cactus definition is represented by the graph non-terminal in the grammar that is given below using the Extended Backus-Naur Form:\n\ngraph $=$ `c`\n\n$|$ `c(` list `)`\n\n$|$ `loop(` list `)`\n\n$|$ `t(` list `)`\n\nlist $=$ graph ${$ `,` graph $}$\n\n$|$ (number $|$ range $|$ variable ) $[$ `,` graph $]$\n\nnumber $=$ nzdig ${$ `0` $|$ nzdig $}$\n\nnzdig $=$ `1` $|$ `2` $| \\cdots |$ `8` $|$ `9`\n\nrange $=$ `range(` variable `,` numvar `,` numvar `)`\n\nvariable $=$ `A` $|$ `B` $| \\cdots |$ `Y` $|$ `Z`\n\nnumvar $=$ number $|$ variable\n\nA graph production rule denotes a graph with two labeled vertices -- the first and the last. Graphs definition rules have the following semantics:\n\nThe basic building block $c$ denotes a graph with just two vertices (one is the first and the other one is the last) and one edge.\n\nThe $c(σ)$ rule connects a specified list of graphs $σ$ from left to right into a chain, merging the last vertex of the first graph in the list with the first vertex of the second graph in the list, the last vertex of the second graph with the first of the third one, and so on. The resulting graph's first vertex is the first vertex of the first graph in the list, and the resulting graph's last vertex is the last vertex of the last graph in the list.\n\nThe $loo_p(σ)$ rule connects a specified list of graphs $σ$ from left to right, merging the last vertex of the first graph in the list with the first vertex of the second graph in the list, and so on like in $c(σ),$ while the last vertex of the last graph in the list is merged with the first vertex of the first graph in the list to form a loop. The resulting graph's first and last vertices are the first and the last vertices of the first graph in the list. Loop can be applied only to lists with more than one graph.\n\nThe $t(σ)$ rule connects a specified list of graphs $σ,$ merging their first vertices. The resulting graph's first and last vertices are the first and the last vertices of the first graph in the list.\n\nThe list of graphs is either specified explicitly, by a comma-separated list, or using a list repetition with a number, a range, or a variable, optionally followed by a comma and a graph. When a graph is not explicitly specified in a list repetition, then the given graph is assumed to be $c$ .\n\nThe simplest list repetition is defined using a number non-terminal. It denotes a list of graphs with the specified integer number of copies of the given graph.\n\nA range list repetition is defined by $range(ν, α, β)$ rule which has three components -- a variable $ν,$ and numbers $α$ and $β.$ If $ξ$ character sequence is a graph, then $c|loo_p|t(range(ν, α, β), ξ)$ are called rangeenabled rules and the variable $ν$ is called a bound variable in $ξ.$ In the context of a range-enabled rule, $ξ$ is repeated $|β − α| + 1$ times to form a list. Every occurrence of variable $ν$ in $ξ$ is replaced by consecutive integer numbers between $α$ and $β$ inclusive in ascending order. That produces a list of $|β −α|+ 1$ graphs, which are then connected according the specification of the corresponding range-enabled rule. The $α$ and $β$ themselves might refer to variables that are bound in the outer range-enabled rule.\n\nIn a well-formed graph:\n\neach variable non-terminal (a letter from A to $Z)$ occurs at most once as $ν$ in $range(ν, α, β)$ rules;\n\nall other occurrences of variable non-terminal that are allowed by the grammar are bound.\n\nNote, that if a character sequence $ξ$ is a graph, then $ξ, c(ξ),$ c(1 , $ξ), t(ξ),$ and t(1 , $ξ)$ all denote the same graph. On the other hand, neither $loo_p(ξ)$ nor loop(1 , $ξ)$ are allowed.\n\nThe following examples illustrate these basic rules. The graphs have their first and last vertices marked with letters $F$ and $L$ correspondingly.\n\n![](/upload/images2/cactus1.png)\n\n![](/upload/images2/cactus2.png)\n\n", "inputFormat": "\n\nThe input file contains a single line with a well-formed cactus definition in SCGL. While the syntax and semantics of SCGL themselves do not guarantee that the resulting graph is a cactus, the input file for this problem always defines a cactus -- every edge belongs to at most one simple cycle and there are no multiple edges between vertices. For example, neither loop(3 , $loo_p(3))$ nor $loo_p(2)$ are possible.\n\nThe line in the input file is at most $1000$ characters long and defines a cactus with at most $50 000$ vertices. Integer numbers represented by number non-terminals do not exceed $50 000$ .\n\n", "outputFormat": "\n\nThe first line of the output file must contain two integer numbers $n$ and $m$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ , where $1$ is the number of the first vertex of the graph and $n$ is the number of the last vertex of the graph. The other vertices can be numbered arbitrarily. Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the minimal number of such paths.\n\nEach of the following $m$ lines must contain a path in the graph. A path starts with an integer number $k_{i} (k_{i} \\ge 2)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. A path can go to the same vertex multiple times, but every edge must be traversed exactly once in the whole output file.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Cactus Generator（征集SPJ）", "background": "", "description": "NEERC 以大量关于仙人掌的题目为特色——每条边属于至多一个简单环连通的无向图。直观的说，仙人掌是一种一些环被允许的广义树。\n\n2005年，第一个有关仙人掌的问题出现，这个问题被简单的叫做[“仙人掌”](https://codeforces.com/gym/101334)。在2007年是[“仙人掌再来”](https://codeforces.com/gym/100273)，在2010年叫做[“仙人掌变革”](https://codeforces.com/gym/101309)，以及2013年是[“仙人掌自同构”](https://codeforces.com/gym/100307)。以下是这些问题中使用的仙人掌例子：\n\n![](/upload/images2/cactus.png)\n\n四年来评测必须为顶点以千数的仙人掌生成测试文件。当然，复杂性日益增加的大量数据发生器被建立，最终有一个被称为 CGL（Cactus Generator Language，仙人掌发生器语言）的领域特定语言。CGL 可以为测试的目的简洁地定义一个大仙人掌。本题中你要解析该语言的我们称为 SCGL（Simple Cactus Generator Language，简单仙人掌发生器语言）的一个简化版本，输出一个仙人掌作结果。\n\n一个仙人掌要以列出边的极小集（覆盖全图的不同路径）输出。\n\nSCGL 仙人掌定义的语法由语法中的指定的用下面的扩展巴科斯-诺尔范式的非终止图表示：\n\n$$\n\\begin{aligned}\ngraph &= “\\texttt{\\textup{c}}”&&&&&&&&&&&&&&&&&&&&&&&&&&&\\\\\n&| “\\texttt{\\textup{c(}}” list “\\texttt{\\textup{)}}”\\\\\n&| “\\texttt{\\textup{loop(}}” list “\\texttt{\\textup{)}}”\\\\\n&| “\\texttt{\\textup{t(}}” list “\\texttt{\\textup{)}}”\\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\nlist &= graph \\{ “\\texttt{\\textup{,}}” graph \\}&&&&&&&&&&&&\\\\\n&|(number | range | variable ) [ “\\texttt{\\textup{,}}” graph ]\\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\n&number = nzdig \\{ “\\texttt{\\textup{0}}” | nzdig \\}\\\\\n&nzdig = “\\texttt{\\textup{1}}” | “\\texttt{\\textup{2}}” | \\cdots | “\\texttt{\\textup{8}}” | “\\texttt{\\textup{9}}”\\\\\n&range = “\\texttt{\\textup{range(}}” variable “\\texttt{\\textup{,}}” numvar “\\texttt{\\textup{,}}” numvar “\\texttt{\\textup{)}}”\\\\\n&variable = “\\texttt{\\textup{A}}” | “\\texttt{\\textup{B}}” | \\cdots | “\\texttt{\\textup{Y}}” | “\\texttt{\\textup{Z}}”\\\\\n&numvar = number | variable\n\\end{aligned}\n$$\n\n一个图的制造规则表示一个有两个点标记的图——首和尾。图定义规则有以下语义：\n\n- 基本建立块 $c$ 列表示一个仅有两个点（一首一尾）标记与一边的图。\n\n- $c(σ)$ 规则对于含有 $n$ 个图的指定图列表 $σ$ 将第 $i$ 图尾顶点与第 $i+1$ 图首顶点合并，加入列表。（$i\\in\\mathbb{N}^*,1\\le i< n$）结果图的首顶点为第一图首顶点，尾顶点为第 $n$ 图尾顶点。\n\n- $loop(σ)$ 规则与 $c(σ)$相似，但第 $n$ 图尾顶点与第一图首顶点合并,加入列表。结果图的首尾顶点为列表中第一图首尾顶点。环仅可被应用于一图以上的列表。\n\n- $t(σ)$ 规则连接一个指定图列表 $σ$，合并他们的首顶点。结果图的首尾顶点为列表中第一图首尾顶点。\n\n图列表不是以一逗号分隔列表明确指定，就是用一个有一个数字、范围或变量的选择性地跟随一个逗号或图的可重列表指定。当一图非于一可重列表中明确指定，则该指定图被假定为 $c$。\n\n最简单的可重列表用一个非终止数定义。它表示一个有指定整数个指定图的副本的列表。\n\n一个可重范围列表由有三个组件（变量 $ν$，数字 $α$ 与 $β$）的 $range(ν, α, β)$ 规则定义。若 $ξ$ 字符序列为一图，则 $c|loop|t(range(ν, α, β), ξ)$ 被称为范围启用规则，变量 $ν$ 被称为 $ξ$ 中的一个约束变量。在一个范围启用规则的语境中，$ξ$ 被重复 $|β − α| + 1$ 次以建立列表。变量 $ν$ 于 $ξ$ 中的每次出现按升序由连续的 $α$ 与 $β$ 之间的整数（包括 $α$ 与 $β$）取代。 那产出一个包括 $|β −α|+ 1$ 个图的列表，通过相应的范围启用规则的规范连接。$α$ 与 $β$ 自身可能指被约束于外范围启用规则的变量。\n\n在一个语法正确的图中：\n\n- 每一个非终止变量（一个从 A 到 Z 的字母）作为 $range(ν, α, β)$ 规则中的 $ν$ 至多存在一次；\n\n- 非终止变量的语法允许的所有其他事件被绑定。\n\n注意，若一字符序列 $ξ$ 为一图，那么 $ξ, c(ξ), c(1 , ξ), t(ξ),$ 与 $t(1 , ξ)$ 都指此一图。另一方面，不论 $loop(ξ)$ 还是 $loop(1 , ξ)$ 都不被允许。\n\n下列例子说明这些基本规则。这些图有以 F 与 L 相应标记的始末点。\n\n![](/upload/images2/cactus1.png)\n\n![](/upload/images2/cactus2.png)", "inputFormat": "输入文件包含一行，含有一个 SCGL 定义。定义格式正确，总描述一仙人掌，每条边属于至多一个简单环，无重边。比如，$loop(3 , loop(3))$ 与 $loop(2)$ 都不可能。\n\n输入文件中该行至多长 $1000$ 字符，定义的仙人掌至多 $50000$ 个顶点。由非终止数代列表的整数不超过 $50000$。", "outputFormat": "输出文件第一行必须包含两个整数 $n$ 与 $m$。$n$ 为图顶点数。顶点由 $1$ 到 $n$ 编号，$1$ 为首点编号，$n$ 为图尾点编号。其他点可随意编号。图中边由一个边不重路径集代表，$m$为该集合最小路径数。\n\n后 $m$ 行，每行必须包含图中一条路径。一条路径以一个整数 $k_{i} (k_{i} \\ge 2)$ 开始，后随 $k_{i}$ 个整数从 $1$ 到 $n$。这 $k_{i}$ 个整数代列表一条路径的顶点。一条路径可经过同一顶点多次，但每条边必须在整个输出文件中刚好经过一次。\n\n### 注释\n此题中出现的的EBNF：\n\n非终端符号为被定义的语言的句法部分。\n\n终端符号为由一个或多个字符组成的序列，是构成语言的不可约元素。\n\n本题中一条语法规则形如$元标识符=定义列表$\n\n定义列表形如$主要句法|主要句法|\\cdots$。\n\n其中主要句法为可选序列、重复序列、分组序列、元标识符、终端字符串、空序列之一。\n\n可选序列形如[定义列表]，重复序列形如{定义列表}，分组序列形如(定义列表)。\n\n元标识符是以字母开头的字母数字序列，即非终端符号的名称。\n\n由语法定义的语言的终端符号由终端字符串表示，终端字符串形如“一个或多个除该引号符号以外的任何终端字符的序列” 。\n\nEBNF的终端符号称为终端字符，是字母、数字, 与`=|{}“()[]`字符之一。\n\n需要注意的是，这里给出的EBNF不完整，但足以解决题目。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6988", "type": "P", "difficulty": 6, "samples": [["3000 6000 1600 0 3000\n", "50974.56\n"], ["3000 6000 1600 3441 4228\n", "40728.90\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Damage Assessment", "background": "", "description": "\n\nA tank car that transports gasoline via rail road has a shape of cylinder with two spherical caps at the sides. The cylinder has a diameter $\\(d\\)$ and a length $\\(l\\).$ The spherical caps have a radius $\\(r\\) (\\(2r\\) \\ge \\(d\\)).$ There was the rail road accident and the tank car had derailed. It now lies on the ground and some of the stored gasoline had flown out. The damage assessment must be performed. The location of the tank on the ground was established by measuring its tilt as the height difference $\\(t\\)$ from the bottom points of the cylinder on its left and right sides $(0 \\le \\(t\\) \\le \\(l\\)).$ The level of gasoline in the tank was established by measuring the height difference $\\(h\\)$ from the bottom point of the cylinder and the top level of gasoline. For the purpose of this problem, the top level of gasoline always intersects the cylinder part of the tank $(0 \\le \\(h\\) \\le \\(t + d \\sqrt{1 - (t/l)^2}).$\n\nYour task is to figure out how much gasoline was left in the tank.\n\n![](/upload/images2/dmaage.png)\n\n", "inputFormat": "\n\nThe input file consists of a single line with five integer numbers -- $\\(d\\), \\(l\\), \\(r\\), \\(t\\)$ and $\\(h\\),$ which represent the diameter and the length of the tank's cylinder part, the radius of its spherical caps, tilt and gasoline level measurements. They are all expressed in millimeters ($1$ millimeter $= 10^{−3}$ meters), they satisfy all constraints expressed in the problem statement and $\\(d\\), \\(l\\) \\ge 100 , \\(d\\), \\(l\\), \\(r\\) \\le 10 000$ .\n\n", "outputFormat": "\n\nWrite a single real number to the output file -- the volume of gasoline in the tank in liters ($1$ liter $= 10^{−3}$ cubic meters). The absolute error of the answer must not exceed $0$ . $1$ liters.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Damage Assessment", "background": "", "description": "\n\nA tank car that transports gasoline via rail road has a shape of cylinder with two spherical caps at the sides. The cylinder has a diameter $\\(d\\)$ and a length $\\(l\\).$ The spherical caps have a radius $\\(r\\) (\\(2r\\) \\ge \\(d\\)).$ There was the rail road accident and the tank car had derailed. It now lies on the ground and some of the stored gasoline had flown out. The damage assessment must be performed. The location of the tank on the ground was established by measuring its tilt as the height difference $\\(t\\)$ from the bottom points of the cylinder on its left and right sides $(0 \\le \\(t\\) \\le \\(l\\)).$ The level of gasoline in the tank was established by measuring the height difference $\\(h\\)$ from the bottom point of the cylinder and the top level of gasoline. For the purpose of this problem, the top level of gasoline always intersects the cylinder part of the tank $(0 \\le \\(h\\) \\le \\(t + d \\sqrt{1 - (t/l)^2}).$\n\nYour task is to figure out how much gasoline was left in the tank.\n\n![](/upload/images2/dmaage.png)\n\n", "inputFormat": "\n\nThe input file consists of a single line with five integer numbers -- $\\(d\\), \\(l\\), \\(r\\), \\(t\\)$ and $\\(h\\),$ which represent the diameter and the length of the tank's cylinder part, the radius of its spherical caps, tilt and gasoline level measurements. They are all expressed in millimeters ($1$ millimeter $= 10^{−3}$ meters), they satisfy all constraints expressed in the problem statement and $\\(d\\), \\(l\\) \\ge 100 , \\(d\\), \\(l\\), \\(r\\) \\le 10 000$ .\n\n", "outputFormat": "\n\nWrite a single real number to the output file -- the volume of gasoline in the tank in liters ($1$ liter $= 10^{−3}$ cubic meters). The absolute error of the answer must not exceed $0$ . $1$ liters.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Damage Assessment", "background": "", "description": "一个通过铁路运输汽油的罐车形状为两侧带有球形端盖的圆柱体。圆柱体的直径为 $d$，长度为 $l$。球形端盖的半径为 $r$（$2r \\ge d$）。发生了铁路事故，罐车脱轨，现在躺在地上，部分储存的汽油已经流出。需要进行损失评估。通过测量圆柱体左侧和右侧底部点的高度差 $t$ 来确定罐车在地上的位置（$0 \\le t \\le l$）。通过测量圆柱体底部点和汽油顶部水平面的高度差 $h$ 来确定罐内汽油的水平面。为了解决这个问题，汽油的顶部水平面总是与罐车的圆柱部分相交（$0 \\le h \\le t + d \\sqrt{1 - (t/l)^2}$）。\n\n你的任务是计算罐车中剩余的汽油量。\n\n![](/upload/images2/dmaage.png)", "inputFormat": "输入文件由一行组成，包含五个整数 $d, l, r, t$ 和 $h$，分别表示罐车圆柱部分的直径和长度、球形端盖的半径、倾斜度和汽油水平测量值。它们都以毫米为单位（$1$ 毫米 $= 10^{-3}$ 米），满足题目中表达的所有约束条件，并且 $d, l \\ge 100 , d, l, r \\le 10 000$。", "outputFormat": "输出文件中写一个实数，表示罐车中汽油的体积，以升为单位（$1$ 升 $= 10^{-3}$ 立方米）。答案的绝对误差不得超过 $0.1$ 升。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6989", "type": "P", "difficulty": 6, "samples": [["2\nR 1 1 2\nP 2 2 1\n", "2\nP 1 2 1\nS 1 1 1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2014", "Special Judge", "模拟退火", "随机调整", "有限状态自动机", "随机化", "构造", "ICPC", "Ad-hoc", "NERC/NEERC"], "title": "[NEERC 2014] Epic Win!", "background": "", "description": "\n\nA game of rock-paper-scissors is played by two players who simultaneously show out their moves: Rock, Paper , or Scissors. If their moves are the same, it's a draw. Otherwise, Rock beats Scissors, Paper beats Rock, and Scissors beat Paper .\n\nThe described procedure can be repeated many times. In this problem, two Finite State Machines (FSMs) will compete in a series of rounds. (Formally speaking, by FSMs we mean Moore machines in this problem. )\n\nAn FSM for playing rock-paper-scissors has finitely many states. Each state is described by the following: what move the FSM will make in the upcoming round, and what will be the new state in case of its opponent playing Rock, Paper , and Scissors.\n\n![](/upload/images2/epic.png)\n\nFortunately, you know your opponent FSM -- the entire scheme except for one thing: you do not know the initial state of that FSM.\n\nYour task is to design your own FSM to fight the given one. Your FSM must beat the opponent in at least $99\\%$ of the first $1$ billion rounds. That's what we call an epic win!\n\n", "inputFormat": "\n\nThe input file contains a description of the opponent FSM in the following format.\n\nThe first line contains an integer $n (1 \\le n \\le 100)$ -- the number of states in the FSM. States are numbered from $1$ to $n$ . Each of the following $n$ lines contains a description of the state: a character $c_{i}$ denoting the move made by FSM and integers $r_{i}, p_{i}, s_{i}$ denoting the next state in case of seeing Rock, Paper, or Scissors respectively $(c_{i}$ can be `R`, `P`, or `S`; $1 \\le r_{i}, p_{i}, s_{i} \\le n$\n\n", "outputFormat": "\n\nWrite to the output the description of your FSM in the same format.\n\nThe initial state of your FSM is the first state.\n\nThe number of states may not exceed $50 000$ .\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Epic Win!", "background": "", "description": "\n\nA game of rock-paper-scissors is played by two players who simultaneously show out their moves: Rock, Paper , or Scissors. If their moves are the same, it's a draw. Otherwise, Rock beats Scissors, Paper beats Rock, and Scissors beat Paper .\n\nThe described procedure can be repeated many times. In this problem, two Finite State Machines (FSMs) will compete in a series of rounds. (Formally speaking, by FSMs we mean Moore machines in this problem. )\n\nAn FSM for playing rock-paper-scissors has finitely many states. Each state is described by the following: what move the FSM will make in the upcoming round, and what will be the new state in case of its opponent playing Rock, Paper , and Scissors.\n\n![](/upload/images2/epic.png)\n\nFortunately, you know your opponent FSM -- the entire scheme except for one thing: you do not know the initial state of that FSM.\n\nYour task is to design your own FSM to fight the given one. Your FSM must beat the opponent in at least $99\\%$ of the first $1$ billion rounds. That's what we call an epic win!\n\n", "inputFormat": "\n\nThe input file contains a description of the opponent FSM in the following format.\n\nThe first line contains an integer $n (1 \\le n \\le 100)$ -- the number of states in the FSM. States are numbered from $1$ to $n$ . Each of the following $n$ lines contains a description of the state: a character $c_{i}$ denoting the move made by FSM and integers $r_{i}, p_{i}, s_{i}$ denoting the next state in case of seeing Rock, Paper, or Scissors respectively $(c_{i}$ can be `R`, `P`, or `S`; $1 \\le r_{i}, p_{i}, s_{i} \\le n$\n\n", "outputFormat": "\n\nWrite to the output the description of your FSM in the same format.\n\nThe initial state of your FSM is the first state.\n\nThe number of states may not exceed $50 000$ .\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Epic Win!", "background": "", "description": "在游戏「石头、剪子、布」中，两名玩家分别同时出示自己的行动：*石头*、*剪子*、或*布*。如果两人的行动一致，则平局。否则*石头*打败*剪子*、*布*打败*石头*、*剪子*打败*布*。\n\n上述过程可以重复多次。在本题中，两台有限状态自动机（Finite State Machines，FSM）将游玩多轮「石头、剪子、布」（准确地说，本题中的 FSM 特指 Moore 状态机）。\n\n一台被设计用来游玩「石头、剪子、布」的 FSM 有着有限的状态。每个状态由以下信息描述：下一轮中本台自动机将会出示怎样的行动，以及当下一轮中对手出示了*石头*、*剪子*、或*布*时应该转移到的新状态。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j121iya3.png)\n\n幸运的是，你知道对手的 FSM：你知道它所有的结构，但唯独不知道它的初始状态。\n\n你的任务是设计一台你自己的 FSM 去和对手的进行对战。你的 FSM 必须在前十亿（${10}^9$）轮中打败对手至少 $99 \\%$ 轮。这就是所谓的史诗般的胜利（epic win）！\n\n\n对手的 FSM 持续出示*石头*或*布*（取决于初始状态）直到它接收到*剪子*：接收到*剪子*将导致它的行为改变。\n\n一种打败这样的 FSM 的方法是出示*布*。如果对手持续出示*石头*，只需继续出示*布*即可胜利。如果对手出示了*布*，通过出示一次*剪子*让它的行为改变，接下来它就会持续出示*石头*，然后你就可以用*布*打败它了。", "inputFormat": "从标准输入中读入对对手的 FSM 的描述，按如下格式：\n\n第一行一个正整数 $n$，表示 FSM 中的状态数。所有状态从 $1$ 到 $n$ 编号。\n\n接下来 $n$ 行，每行描述一个状态：一个字符 $c_i$ 以及三个正整数 $r_i, p_i, s_i$，分别表示该状态的行动、以及当对手出示了*石头*、*布*、或*剪子*后应该转移到的新状态的编号，其中 $c_i$ 只可能为 $\\{\\texttt{R}, \\texttt{P}, \\texttt{S}\\}$ 之一，如果为 $\\texttt{R}$ 则意味着行动为出示*石头*，如果为 $\\texttt{P}$ 则意味着行动为出示*布*，如果为 $\\texttt{S}$ 行动为出示*剪子*。", "outputFormat": "将你设计的 FSM 以相同格式输出到标准输出中。\n\n你的 FSM 的初始状态是 $1$ 号状态。\n\n你的 FSM 的状态数量不应超过 $50000$。\n\n**【样例解释】**", "hint": "对于全部数据，$1 \\le n \\le 100$，$c_i \\in \\{\\texttt{R}, \\texttt{P}, \\texttt{S}\\}$，$1 \\le r_i, p_i, s_i \\le n$。\n\n**翻译来源**：IOI 2021 集训队第一部分作业，PinkRabbit。", "locale": "zh-CN"}}}
