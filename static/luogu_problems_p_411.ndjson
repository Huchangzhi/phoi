{"pid": "P9337", "type": "P", "difficulty": 7, "samples": [["3 4\n1 1 3\n2 3 1\n1 2\n1 3\n2 3\n1 1", "0\n1\n1\n0"]], "limits": {"time": [9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2001", "O2优化", "Ynoi"], "title": "[Ynoi2001] 冷たい部屋、一人", "background": "&emsp;冷たい部屋の隅に 射し込んできた夕陽だったら   \n&emsp;冰冷房间的角落 洒满夕阳的光辉   \n&emsp;近づいてみても感情は無くて 裏切りも無い   \n&emsp;再怎么接近也没有感情 没有变化   \n\n&emsp;今日も明日も一人で きっとそれが普通のことで   \n&emsp;就算今后都是一个人 也只是很平常的事   \n&emsp;交わす言葉も無く 一日を終える時   \n&emsp;交谈也无法改变 这一天的终结   \n\n&emsp;例えば 優しさはどれくらいの   \n&emsp;例如 温柔究竟是怎样的   \n&emsp;ぬくもりかも知らないで   \n&emsp;连获取温暖都不知道   \n&emsp;そんなにそんなに簡単じゃない   \n&emsp;那么那样不是很简单吗   \n&emsp;心の距離   \n&emsp;心的距离   \n\n&emsp;冷たい部屋の隅に 小さくなったまま   \n&emsp;冰冷房间的角落 就这样变小吧   \n![](https://cdn.luogu.com.cn/upload/image_hosting/6uukzjeq.png)", "description": "给定 $n,m$，以及序列 $a_1,a_2,\\dots,a_n$ 和 $1,2,\\dots,n$ 的排列 $y_1,y_2,\\dots,y_n$，你需要回答 $m$ 个询问。\n\n对每个询问，给定 $l,r$，查询：\n\n$\\sum\\limits_{i=1}^n\\sum\\limits_{j=i+1}^n [a_i=a_j]\\cdot\\prod_{k=i}^j [l\\le y_k\\le r]$；\n\n其中 $[\\mathrm{cond}]$ 在条件 $\\mathrm{cond}$ 为真时值为 $1$，否则值为 $0$。", "inputFormat": "第一行两个数 $n,m$；\n\n第二行 $n$ 个整数 $a_1,\\dots,a_n$；\n\n第三行 $n$ 个整数 $y_1,\\dots,y_n$；\n\n接下来 $m$ 行，每行两个数 $l,r$ 表示一个询问。", "outputFormat": "$m$ 行，每行一个整数，表示相应的答案。", "hint": "Idea：Ynoi&nzhtl1477，Solution：Ynoi&ccz181078，Code：ccz181078，Data：ccz181078&Terry2022\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le 5\\times 10^5$；$1\\le a_i\\le n$；$1\\le y_i\\le n$，$y_i$ 互不相同；对每个询问，$1\\le l\\le r\\le n$。\n\n对于 $20\\%$ 的数据，满足 $n,m\\le 100$。\n\n对于 $40\\%$ 的数据，$n,m\\le 5000$\n\n对于 $60\\%$ 的数据，$n,m\\le 2\\times 10^5$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2001] 冷たい部屋、一人", "background": "&emsp;冷たい部屋の隅に 射し込んできた夕陽だったら   \n&emsp;冰冷房间的角落 洒满夕阳的光辉   \n&emsp;近づいてみても感情は無くて 裏切りも無い   \n&emsp;再怎么接近也没有感情 没有变化   \n\n&emsp;今日も明日も一人で きっとそれが普通のことで   \n&emsp;就算今后都是一个人 也只是很平常的事   \n&emsp;交わす言葉も無く 一日を終える時   \n&emsp;交谈也无法改变 这一天的终结   \n\n&emsp;例えば 優しさはどれくらいの   \n&emsp;例如 温柔究竟是怎样的   \n&emsp;ぬくもりかも知らないで   \n&emsp;连获取温暖都不知道   \n&emsp;そんなにそんなに簡単じゃない   \n&emsp;那么那样不是很简单吗   \n&emsp;心の距離   \n&emsp;心的距离   \n\n&emsp;冷たい部屋の隅に 小さくなったまま   \n&emsp;冰冷房间的角落 就这样变小吧   \n![](https://cdn.luogu.com.cn/upload/image_hosting/6uukzjeq.png)", "description": "给定 $n,m$，以及序列 $a_1,a_2,\\dots,a_n$ 和 $1,2,\\dots,n$ 的排列 $y_1,y_2,\\dots,y_n$，你需要回答 $m$ 个询问。\n\n对每个询问，给定 $l,r$，查询：\n\n$\\sum\\limits_{i=1}^n\\sum\\limits_{j=i+1}^n [a_i=a_j]\\cdot\\prod_{k=i}^j [l\\le y_k\\le r]$；\n\n其中 $[\\mathrm{cond}]$ 在条件 $\\mathrm{cond}$ 为真时值为 $1$，否则值为 $0$。", "inputFormat": "第一行两个数 $n,m$；\n\n第二行 $n$ 个整数 $a_1,\\dots,a_n$；\n\n第三行 $n$ 个整数 $y_1,\\dots,y_n$；\n\n接下来 $m$ 行，每行两个数 $l,r$ 表示一个询问。", "outputFormat": "$m$ 行，每行一个整数，表示相应的答案。", "hint": "Idea：Ynoi&nzhtl1477，Solution：Ynoi&ccz181078，Code：ccz181078，Data：ccz181078&Terry2022\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le 5\\times 10^5$；$1\\le a_i\\le n$；$1\\le y_i\\le n$，$y_i$ 互不相同；对每个询问，$1\\le l\\le r\\le n$。\n\n对于 $20\\%$ 的数据，满足 $n,m\\le 100$。\n\n对于 $40\\%$ 的数据，$n,m\\le 5000$\n\n对于 $60\\%$ 的数据，$n,m\\le 2\\times 10^5$", "locale": "zh-CN"}}}
{"pid": "P9338", "type": "P", "difficulty": 7, "samples": [["5 2\nAABABABBAB", "2\n"], ["5 3\nAABABABBAB", "0"], ["3 1\nBBBAAA", "9"], ["10 3\nABABBBBABBABABABAAAA", "37"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2023", "O2优化", "斜率优化", "凸完全单调性（wqs 二分）", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] 合唱 / Chorus", "background": "", "description": "在舞台上，有 $2N$ 只海狸排成一列。它们是合唱团的成员。每只海狸唱着高音部或低音部。这些信息由一个字符串 $S$ 给出。具体地，如果 $S$ 的第 $i$ 个字符是 $A$，编号为 $i$ 的海狸（从右边看台来看）唱高音。如果 $S$ 的第 $i$ 个字符是 $B$，编号为 $i$ 的海狸唱低音。有 $N$ 只海狸唱高音，有 $N$ 只海狸唱低音。\n\n从现在起，这些海狸将要演唱 $K$ 首歌。然而，因为所有歌曲非常复杂，每只海狸只唱一首歌曲，不会唱其他歌曲。此外，为了使歌声更加美妙，每首歌曲必须满足以下条件：\n\n+ 至少有一只海狸唱这首歌。\n\n+ 唱这首歌的唱高音和唱低音的海狸数量应当相等。\n\n+ 如果只考虑唱这首歌的海狸，所有唱高音的海狸都在唱低音的海狸的右边。\n\n指挥家 Bitaro 想找到一种方案，给出哪些海狸唱哪首歌，满足以上所有条件。由于 Bitaro 特别聪明，他注意到这可能无法实现。为了应对这个问题，Bitaro 将交换相邻两只海狸的位置多次，以便有一种方式可以调配海狸，从而满足上述条件。\n\n由于 Bitaro 认为效率很重要，所以他想最小化要执行的操作数。然而，这是一个非常困难的问题。由于您是一位出色的程序员，Bitaro 请求您解决此问题。\n\n编写一份程序，在给出合唱与演唱歌曲数量 $K$ 的信息时，计算 Bitaro 需要执行的最小操作数。请注意，在本任务的限制下，可以执行操作多次，以便有一种方式可以在海狸之间分配歌曲，满足上述条件。", "inputFormat": "从标准输入读取以下数据:\n\n> $N\\ K$\n> \n> $S$", "outputFormat": "向标准输出写入一行。输出应该包含 Bitaro 需要执行的最小操作数。", "hint": "**【样例解释 #1】**\n\n在该样例输入中，例如 Bitaro 可以进行如下操作。下划线表示被交换的两个海狸的位置。\n\n1. 交换从舞台右侧数第 3 个和第 4 个海狸。  \n   操作后，表示海狸部件分布的字符串变为 $\\text{`\\texttt{AA\\underline{AB}BABBAB}'}$。\n2. 交换从舞台右侧数第 8 个和第 9 个海狸。  \n   操作后，字符串变为 $\\text{`\\texttt{AAABBAB\\underline{AB}B}'}$。\n\n操作完成后，Bitaro 可以按如下方式分配歌曲：\n- 从舞台右侧数第 1, 2, 3, 4, 5, 7 个海狸演唱第一首歌\n- 从舞台右侧数第 6, 8, 9, 10 个海狸演唱第二首歌\n\n这种分配方式满足条件。若操作次数少于 2 次，则不存在满足条件的分配方式。因此输出 2。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n不进行任何操作时，Bitaro 可以按如下方式分配歌曲：\n- 从舞台右侧数第 1, 2, 3, 5 个海狸演唱第一首歌\n- 从舞台右侧数第 4, 6, 7, 8 个海狸演唱第二首歌  \n- 从舞台右侧数第 9, 10 个海狸演唱第三首歌\n\n这种分配方式满足条件。因此输出 0。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #4】**\n\n该样例满足所有子任务的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\le N \\le 10^6$，$1 \\le K \\le N$，$S$ 是长度为 $2N$ 的字符串，且其中字符 $\\verb!A!$ 和 $\\verb!B!$ 各出现 $N$ 次。保证 $N,K$ 均为整数。\n\n| 子任务编号 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $1$ | $16$ | $N \\le 10$ |\n| $2$ | $24$ | $N \\le 500$ |\n| $3$ | $21$ | $N \\le 5000$ |\n| $4$ | $26$ | $N \\le 10^5$ |\n| $5$ | $13$ | 无 |\n\n提示说明部分，翻译由 DeepSeek R1 完成", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2023] Chorus", "background": null, "description": "On the stage, $2N$ beavers are standing in a row. They are members of the chorus. Each beaver sings either the alto part or the bass part of the chorus. This information is given by a string $S$. Precisely, the $i$-th beaver ($1\\le i\\le 2N$) from the stage right (i.e., from left when seen from the audience seats) sings the alto part if the $i$-th character of $S$ is $\\text{`\\texttt{A}'}$. The $i$-th beaver sings the bass part if the $i$-th character of S is $\\text{`\\texttt{B}'}$. There are $N$ beavers singing the alto part, and $N$ beavers singing the bass part.\n\nFrom now, the beavers will sing $K$ songs. However, since all the songs are very difficult, each beaver sings exactly one song only, and does not sing other songs. Moreover, in order to make singing voice more beautiful, for every song, the following conditions should be satisfied.\n\n- At least one beaver sings the song.\n- The number of beavers singing the alto part of the song is equal to the number of beavers singing the bass part of the song.\n- If we consider the beavers singing the song only, every alto beaver stands the stage right of every bass beaver.\n\nBitaro, the conductor, tried to find a way to allot songs to beavers which satisfies the conditions. Since Bitaro is bright, he notices that it might be impossible to allot songs to beavers.\n\nIn order to cope with this issue, Bitaro will perform the following operation several times so that there is a way to allot songs to beavers which satisfies the conditions.\n\n- Swap the position of two adjacent beavers.\n\nSince Bitaro thinks efficiency is important, he wants to minimize the number of operations. However, it turns out to be a surprisingly difficult problem. Since you are a brilliant programmer, Bitaro asks you to solve this problem.\n\nWrite a program which, given information of the chorus and the number of songs $K$, calculates the minimum\nnumber of operations Bitaro needs to perform. Note that, under the constraints of this task, it is possible to perform the operations several times so that there is a way to allot songs to beavers which satisfies the conditions.", "inputFormat": "Read the following data from the standard input.\n\n> $N\\ K$\n> \n> $S$", "outputFormat": "Write one line to the standard output. The output should contain the minimum number of operations Bitaro needs to perform.", "hint": "**【样例解释 #1】**\n\nIn this sample input, for example, Bitaro can perform the following operations. Here, the underline denotes the positions of the two beavers swapped by Bitaro.\n\n1. Swap the third beaver and the fourth beaver from the stage right.  \n  After this operation, the string which denotes the parts of the beavers from the stage right becomes\n$\\text{`\\texttt{AA\\underline{AB}BABBAB}'}$.\n2. Swap the eighth beaver and the ninth beaver from the stage right.  \n  After this operation, the string which denotes the parts of the beavers from the stage right becomes\n$\\text{`\\texttt{AAABBAB\\underline{AB}B}'}$.  \n\nAfter these operations, Bitaro can allot songs to beavers as follows.\n\n- From the stage right, the $1, 2, 3, 4, 5, 7$-th beavers sing the first song.\n- From the stage right, the $6, 8, 9, 10$-th beavers sing the second song.\n\nThis way to allot songs to beavers satisfies the conditions.\n\nIf the number of operations is less than $2$, there does not exist a way to allot songs to beavers which satisfies the conditions. Therefore, output $2$.\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\nWithout performing operations, Bitaro can allot songs to beavers as follows.\n\n- From the stage right, the $1, 2, 3, 5$-th beavers sing the first song.\n- From the stage right, the $4, 6, 7, 8$-th beavers sing the second song.\n- From the stage right, the $9, 10$-th beavers sing the third song.\n\nThis way to allot songs to beavers satisfies the conditions. Therefore, output $0$.\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #4】**\n\n该样例满足所有子任务的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1\\le N\\le 10^6$，$1\\le K\\le N$，$S$ 是一个长度为 $2N$ 的字符串，且在 $S$ 中，字母 $\\verb!A!$ 和 $\\verb!B!$ 均出现了 $N$ 次。保证 $N,K$ 均为整数。\n\n| 子任务编号 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $1$ | $16$ | $N\\le 10$ |\n| $2$ | $24$ | $N\\le 500$ |\n| $3$ | $21$ | $N\\le 5000$ |\n| $4$ | $26$ | $N\\le 10^5$ |\n| $5$ | $13$ | 无 |\n", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] 合唱 / Chorus", "background": "", "description": "在舞台上，有 $2N$ 只海狸排成一列。它们是合唱团的成员。每只海狸唱着高音部或低音部。这些信息由一个字符串 $S$ 给出。具体地，如果 $S$ 的第 $i$ 个字符是 $A$，编号为 $i$ 的海狸（从右边看台来看）唱高音。如果 $S$ 的第 $i$ 个字符是 $B$，编号为 $i$ 的海狸唱低音。有 $N$ 只海狸唱高音，有 $N$ 只海狸唱低音。\n\n从现在起，这些海狸将要演唱 $K$ 首歌。然而，因为所有歌曲非常复杂，每只海狸只唱一首歌曲，不会唱其他歌曲。此外，为了使歌声更加美妙，每首歌曲必须满足以下条件：\n\n+ 至少有一只海狸唱这首歌。\n\n+ 唱这首歌的唱高音和唱低音的海狸数量应当相等。\n\n+ 如果只考虑唱这首歌的海狸，所有唱高音的海狸都在唱低音的海狸的右边。\n\n指挥家 Bitaro 想找到一种方案，给出哪些海狸唱哪首歌，满足以上所有条件。由于 Bitaro 特别聪明，他注意到这可能无法实现。为了应对这个问题，Bitaro 将交换相邻两只海狸的位置多次，以便有一种方式可以调配海狸，从而满足上述条件。\n\n由于 Bitaro 认为效率很重要，所以他想最小化要执行的操作数。然而，这是一个非常困难的问题。由于您是一位出色的程序员，Bitaro 请求您解决此问题。\n\n编写一份程序，在给出合唱与演唱歌曲数量 $K$ 的信息时，计算 Bitaro 需要执行的最小操作数。请注意，在本任务的限制下，可以执行操作多次，以便有一种方式可以在海狸之间分配歌曲，满足上述条件。", "inputFormat": "从标准输入读取以下数据:\n\n> $N\\ K$\n> \n> $S$", "outputFormat": "向标准输出写入一行。输出应该包含 Bitaro 需要执行的最小操作数。", "hint": "**【样例解释 #1】**\n\n在该样例输入中，例如 Bitaro 可以进行如下操作。下划线表示被交换的两个海狸的位置。\n\n1. 交换从舞台右侧数第 3 个和第 4 个海狸。  \n   操作后，表示海狸部件分布的字符串变为 $\\text{`\\texttt{AA\\underline{AB}BABBAB}'}$。\n2. 交换从舞台右侧数第 8 个和第 9 个海狸。  \n   操作后，字符串变为 $\\text{`\\texttt{AAABBAB\\underline{AB}B}'}$。\n\n操作完成后，Bitaro 可以按如下方式分配歌曲：\n- 从舞台右侧数第 1, 2, 3, 4, 5, 7 个海狸演唱第一首歌\n- 从舞台右侧数第 6, 8, 9, 10 个海狸演唱第二首歌\n\n这种分配方式满足条件。若操作次数少于 2 次，则不存在满足条件的分配方式。因此输出 2。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n不进行任何操作时，Bitaro 可以按如下方式分配歌曲：\n- 从舞台右侧数第 1, 2, 3, 5 个海狸演唱第一首歌\n- 从舞台右侧数第 4, 6, 7, 8 个海狸演唱第二首歌  \n- 从舞台右侧数第 9, 10 个海狸演唱第三首歌\n\n这种分配方式满足条件。因此输出 0。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #4】**\n\n该样例满足所有子任务的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\le N \\le 10^6$，$1 \\le K \\le N$，$S$ 是长度为 $2N$ 的字符串，且其中字符 $\\verb!A!$ 和 $\\verb!B!$ 各出现 $N$ 次。保证 $N,K$ 均为整数。\n\n| 子任务编号 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $1$ | $16$ | $N \\le 10$ |\n| $2$ | $24$ | $N \\le 500$ |\n| $3$ | $21$ | $N \\le 5000$ |\n| $4$ | $26$ | $N \\le 10^5$ |\n| $5$ | $13$ | 无 |\n\n提示说明部分，翻译由 DeepSeek R1 完成", "locale": "zh-CN"}}}
{"pid": "P9339", "type": "P", "difficulty": 7, "samples": [["7\n1 1 1 1 1 1 1\n3\n1 2 3", "3\n2 1 7\n2 2 6\n3 3 4 5"], ["5\n5 3 1 2 4\n1\n4", "-1"], ["7\n5 4 4 2 1 1 1\n2\n2 6", "7\n6 1 2 3 4 5 6\n2 2 1\n2 3 1\n2 4 1\n2 7 1\n2 3 2\n2 3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "O2优化", "背包 DP", "二分图", "bitset", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] 曲奇 / Cookies", "background": "", "description": "莉婕喜欢做饼干。她制作了 $N$ 种饼干。第 $i$ 种饼干有 $A_i$ 个。为了出售她制作的饼干，她将它们装入盒子中。但是，应该满足以下条件。\n\n+ 对于每个盒子，其中的饼干种类应不同。\n\n+ 对于每个盒子，其中的饼干数量应等于以下 $M$ 个数字之一：$B_1,B_2,⋯ ,B_M$。\n\n编写一个程序，给出莉婕制作的饼干信息和将饼干装箱的条件，确定是否可能将所有饼干包装到盒子中。此外，如果可以将所有饼干包装在盒子中，则您的程序应输出最少的盒子数量。", "inputFormat": "从标准输入读取以下数据。\n> $N$  \n> $A _ 1 \\ A _ 2 \\ \\cdots \\ A _ N$  \n> $M$  \n> $B _ 1 \\ B _ 2 \\ \\cdots \\ B _ M$", "outputFormat": "如果可以将所有的饼干装入盒子并且满足上述条件，则设 $x$ 是所需的盒子数，$c_k$ 是第 $k$ 个盒子中的饼干数 $(1≤k≤x)$，$v_{k,1},v_{k,2},⋯ ,v_{k,c_k}$ 是第 $k$ 个盒子中的饼干种类。请将这些数字按以下格式编写到标准输出。\n> $x$  \n> $c _ 1 \\ v _ {1, 1} \\ v _ {1, 2} \\ \\cdots \\ v _ {1, c _ 1}$  \n> $c _ 2 \\ v _ {2, 1} \\ v _ {2, 2} \\ \\cdots \\ v _ {2, c _ 2}$  \n> $\\vdots$  \n> $c _ x \\ v _ {x, 1} \\ v _ {x, 2} \\ \\cdots \\ v _ {x, c _ x}$ \n\n在此，使用的盒子数量 $x$ 应该是可能的最小数量。如果有多种方式可以满足条件地将饼干装入盒子，请输出其中任何一种方法。\n\n如果无法将所有饼干包装在盒子中以满足条件，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于该样例输入，可以按照以下方式将 $7$ 个饼干装入 $3$ 个盒子中满足条件：\n\n+ 将第 $1$ 类和第 $7$ 类的饼干装入第一个盒子中。每种类型放 $1$ 个。\n+ 将第 $2$ 类和第 $6$ 类的饼干装入第二个盒子中。每种类型放 $1$ 个。\n+ 将第 $3$ 类、第 $4$ 类和第 $5$ 类的饼干装入第三个盒子中。每种类型放 $1$ 个。\n\n因为不能用少于或等于 $2$ 个盒子来包装 $7$ 个饼干，所以以上方法是正确的。判断为正确答案。还有其他正确方法。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\leq N \\leq 15 000$，$A _ i \\geq 1$（$1 \\leq i \\leq n$），$A _ 1 + A _ 2 + \\cdots + A _ N \\leq 15 000$，$1 \\leq M \\leq N$，$1 \\leq B _ j \\leq N$（$1 \\leq j \\leq M$），$B _ j < B _ {j + 1}$（$1 \\leq j \\leq M - 1$），保证所有输入均为整数。\n\n| **子任务编号** | **分值** | **限制** |\n| :----------: | :----------: | :----------: |\n| $1$ | $6$ | $N \\leq 500$，$A _ i = 1$（$1 \\leq i \\leq N$） |\n| $2$ | $7$ | $N \\leq 500$，$M = 1$ |\n| $3$ | $12$ | $A _ 1 + A _ 2 + \\cdots + A _ N \\leq 15$ |\n| $4$ | $45$ | $A _ 1 + A _ 2 + \\cdots + A _ N \\leq 500$ |\n| $5$ | $15$ | $A _ 1 + A _ 2 + \\cdots + A _ N \\leq 3000$ |\n| $6$ | $15$ | 没有额外的限制 |\n\nTranslate by @[ZeXic_B](https://www.luogu.com.cn/user/661274)", "locale": "zh-CN", "translations": {"en": {"title": "[JOISC 2023] Cookies", "background": null, "description": "Rie likes to make cookies. She made $N$ types of cookies. She made $A _ i$ cookies of type $i(1 \\leq i \\leq N)$. In order to sell the cookies made by her, she will pack them into boxes. However, the following conditions should be satisfied.\n\n- For every box, the types of the cookies in it should be different.\n- For every box, the number of cookies in it should be equal to one of the following $M$ numbers: $B _ 1, B _ 2, \\cdots, B _ M$.\n\nWrite a program which, given information of cookies made by Rie and the conditions to pack the cookies into boxes, determines whether it is possible to pack all the cookies into boxes. Moreover, if it is possible to pack all the cookies into boxes, your program should output a way to pack the cookies into the minimum number of boxes.", "inputFormat": "Read the following data from the standard input.\n\n> $N$  \n> $A _ 1 \\ A _ 2 \\ \\cdots \\ A _ N$  \n> $M$  \n> $B _ 1 \\ B _ 2 \\ \\cdots \\ B _ M$", "outputFormat": "If it is possible to pack all the cookies into boxes so that the conditions are satisfied, let $x$ be the number of used boxes, $c _ k$ be the number of cookies in the $k$-th box ($1\\leq k \\leq x$), and $v _ {k, 1}, v _ {k, 2}, \\cdots, v _ {k, c _ k}$ be the types of the cookies in the $k$-th box. Write these numbers to the standard output as in the following format.\n\n> $x$  \n> $c _ 1 \\ v _ {1, 1} \\ v _ {1, 2} \\ \\cdots \\ v _ {1, c _ 1}$  \n> $c _ 2 \\ v _ {2, 1} \\ v _ {2, 2} \\ \\cdots \\ v _ {2, c _ 2}$  \n> $\\vdots$  \n> $c _ x \\ v _ {x, 1} \\ v _ {x, 2} \\ \\cdots \\ v _ {x, c _ x}$  \n\nHere, the number of used boxes $x$ should be the minimum possible number. If there are several ways to pack the cookies into boxes satisfying the conditions, output any one of them.\n\nIf it is impossible to pack all the cookies into boxes so that the conditions are satisfied, write $-1$ to the standard output.", "hint": "**【样例解释 #1】**\n\nIn this sample input, it is possible to pack the $7$ cookies into $3$ boxes so that the conditions are satisfied as follows.\n\n- Pack cookies of types $1, 7$ into the first box. Pack one cookie for each type.\n- Pack cookies of types $2, 6$ into the second box. Pack one cookie for each type.\n- Pack cookies of types $3, 4, 5$ into the third box. Pack one cookie for each type.\n\nYour program is judged as correct if it outputs the above way to pack the cookies because it is impossible to pack the $7$ cookies into less than or equal to $2$ boxes so that the conditions are satisfied. There are other ways to pack the cookies which are judged as correct.\n\nThis sample input satisfies the constraints of Subtasks 1, 3, 4, 5, 6.\n\n**【样例解释 #2】**\n\nIn this sample input, it is impossible to pack the $15$ cookies into boxes so that the conditions are satisfied.\n\nTherefore, output $-1$.\n\nThis sample input satisfies the constraints of Subtasks 2, 3, 4, 5, 6.\n\n**【样例解释 #3】**\n\nThis sample input satisfies the constraints of Subtasks 4, 5, 6.\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\leq N \\leq 15 000$，$A _ i \\geq 1$（$1 \\leq i \\leq n$），$A _ 1 + A _ 2 + \\cdots + A _ N \\leq 15 000$，$1 \\leq M \\leq N$，$1 \\leq B _ j \\leq N$（$1 \\leq j \\leq M$），$B _ j < B _ {j + 1}$（$1 \\leq j \\leq M - 1$），保证所有输入均为整数。\n\n| **子任务编号** | **分值** | **限制** |\n| :----------: | :----------: | :----------: |\n| $1$ | $6$ | $N \\leq 500$，$A _ i = 1$（$1 \\leq i \\leq N$） |\n| $2$ | $7$ | $N \\leq 500$，$M = 1$ |\n| $3$ | $12$ | $A _ 1 + A _ 2 + \\cdots + A _ N \\leq 15$ |\n| $4$ | $45$ | $A _ 1 + A _ 2 + \\cdots + A _ N \\leq 500$ |\n| $5$ | $15$ | $A _ 1 + A _ 2 + \\cdots + A _ N \\leq 3000$ |\n| $6$ | $15$ | 没有额外的限制 |\n", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] 曲奇 / Cookies", "background": "", "description": "莉婕喜欢做饼干。她制作了 $N$ 种饼干。第 $i$ 种饼干有 $A_i$ 个。为了出售她制作的饼干，她将它们装入盒子中。但是，应该满足以下条件。\n\n+ 对于每个盒子，其中的饼干种类应不同。\n\n+ 对于每个盒子，其中的饼干数量应等于以下 $M$ 个数字之一：$B_1,B_2,⋯ ,B_M$。\n\n编写一个程序，给出莉婕制作的饼干信息和将饼干装箱的条件，确定是否可能将所有饼干包装到盒子中。此外，如果可以将所有饼干包装在盒子中，则您的程序应输出最少的盒子数量。", "inputFormat": "从标准输入读取以下数据。\n> $N$  \n> $A _ 1 \\ A _ 2 \\ \\cdots \\ A _ N$  \n> $M$  \n> $B _ 1 \\ B _ 2 \\ \\cdots \\ B _ M$", "outputFormat": "如果可以将所有的饼干装入盒子并且满足上述条件，则设 $x$ 是所需的盒子数，$c_k$ 是第 $k$ 个盒子中的饼干数 $(1≤k≤x)$，$v_{k,1},v_{k,2},⋯ ,v_{k,c_k}$ 是第 $k$ 个盒子中的饼干种类。请将这些数字按以下格式编写到标准输出。\n> $x$  \n> $c _ 1 \\ v _ {1, 1} \\ v _ {1, 2} \\ \\cdots \\ v _ {1, c _ 1}$  \n> $c _ 2 \\ v _ {2, 1} \\ v _ {2, 2} \\ \\cdots \\ v _ {2, c _ 2}$  \n> $\\vdots$  \n> $c _ x \\ v _ {x, 1} \\ v _ {x, 2} \\ \\cdots \\ v _ {x, c _ x}$ \n\n在此，使用的盒子数量 $x$ 应该是可能的最小数量。如果有多种方式可以满足条件地将饼干装入盒子，请输出其中任何一种方法。\n\n如果无法将所有饼干包装在盒子中以满足条件，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于该样例输入，可以按照以下方式将 $7$ 个饼干装入 $3$ 个盒子中满足条件：\n\n+ 将第 $1$ 类和第 $7$ 类的饼干装入第一个盒子中。每种类型放 $1$ 个。\n+ 将第 $2$ 类和第 $6$ 类的饼干装入第二个盒子中。每种类型放 $1$ 个。\n+ 将第 $3$ 类、第 $4$ 类和第 $5$ 类的饼干装入第三个盒子中。每种类型放 $1$ 个。\n\n因为不能用少于或等于 $2$ 个盒子来包装 $7$ 个饼干，所以以上方法是正确的。判断为正确答案。还有其他正确方法。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\leq N \\leq 15 000$，$A _ i \\geq 1$（$1 \\leq i \\leq n$），$A _ 1 + A _ 2 + \\cdots + A _ N \\leq 15 000$，$1 \\leq M \\leq N$，$1 \\leq B _ j \\leq N$（$1 \\leq j \\leq M$），$B _ j < B _ {j + 1}$（$1 \\leq j \\leq M - 1$），保证所有输入均为整数。\n\n| **子任务编号** | **分值** | **限制** |\n| :----------: | :----------: | :----------: |\n| $1$ | $6$ | $N \\leq 500$，$A _ i = 1$（$1 \\leq i \\leq N$） |\n| $2$ | $7$ | $N \\leq 500$，$M = 1$ |\n| $3$ | $12$ | $A _ 1 + A _ 2 + \\cdots + A _ N \\leq 15$ |\n| $4$ | $45$ | $A _ 1 + A _ 2 + \\cdots + A _ N \\leq 500$ |\n| $5$ | $15$ | $A _ 1 + A _ 2 + \\cdots + A _ N \\leq 3000$ |\n| $6$ | $15$ | 没有额外的限制 |\n\nTranslate by @[ZeXic_B](https://www.luogu.com.cn/user/661274)", "locale": "zh-CN"}}}
{"pid": "P9340", "type": "P", "difficulty": 6, "samples": [["7 6 2\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n2 3 6 4 5 7\n1 3\n4 6", "4\n6"], ["8 8 9\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 6 4 3 5 2 4 7\n3 5\n4 6\n6 8\n1 4\n2 3\n6 8\n5 5\n2 8\n1 2", "3\n4\n6\n6\n3\n6\n1\n6\n3"], ["10 7 9\n6 5\n3 6\n9 3\n8 3\n7 8\n7 1\n2 5\n7 10\n8 4\n9 4 10 1 10 7 6\n4 4\n1 3\n1 3\n6 7\n3 6\n3 3\n1 5\n2 5\n1 2", "1\n6\n6\n4\n3\n1\n7\n5\n4"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] 旅行 / Tourism", "background": null, "description": "JOI 王国是一个由 $N$ 个岛屿组成的岛国，编号从 $1$ 到 $N$。这些岛屿通过 $N - 1$ 座桥相连，编号从 $1$ 到 $N - 1$。桥 $i\\ (1 \\leq i \\leq N - 1)$ 双向连接岛屿 $A_i$ 和岛屿 $B_i$。可以通过若干座桥从任意一个岛屿到达另一个岛屿。在 JOI 王国，有 $M$ 个观光景点，编号从 $1$ 到 $M$。观光景点 $j\\ (1 \\leq j \\leq M)$ 位于岛屿 $C_j$。有 $Q$ 位旅行者，他们计划参观 JOI 王国的观光景点。旅行者编号从 $1$ 到 $Q$。每位旅行者按以下方式旅行。\n\n1. 旅行者选择一个岛屿 $x\\ (1 \\leq x \\leq N)$。乘坐飞机，旅行者到达岛屿 $x$。\n2. 旅行者进行若干次以下动作。动作的顺序和种类是任意的。\n\n    - 旅行者选择当前岛屿上的一个观光景点，并参观。\n    - 旅行者通过桥梁移动到另一个岛屿。\n\n3. 乘坐飞机，旅行者离开 JOI 王国。旅行者 $k\\ (1 \\leq k \\leq Q)$ 想要参观所有的观光景点 $L_k, L_k+1, \\ldots, R_k$。然而，由于预算有限，旅行者 $k$ 希望最小化至少访问一次的岛屿数量。", "inputFormat": "从标准输入读取以下数据。\n\n> $N\\ M\\ Q$\n\n> \n\n> $A_1\\ B_1$\n\n> \n\n> $A_2\\ B_2$\n\n> \n\n> $\\vdots$\n\n> \n\n> $A_{N-1}\\ B_{N-1}$\n\n> \n\n> $C_1\\ C_2\\ \\cdots\\ C_M$\n\n> \n\n> $L_1\\ R_1$\n\n> \n\n> $L_2\\ R_2$\n\n> \n\n> $\\vdots$\n\n> \n\n> $L_Q\\ R_Q$", "outputFormat": "向标准输出写入 $Q$ 行。输出的第 $k$ 行 $(1 \\leq k \\leq Q)$ 应包含旅行者 $k$ 至少访问一次的岛屿的最小可能数量。", "hint": "**【样例解释 #1】**\n\n旅行者 1 按以下方式旅行，并参观所有的观光景点 1, 2, 3。\n1. 旅行者 1 到达岛屿 2。\n2. 旅行者 1 参观岛屿 2 上的观光景点 1。\n3. 旅行者 1 通过桥梁 1 从岛屿 2 移动到岛屿 1。\n4. 旅行者 1 通过桥梁 2 从岛屿 1 移动到岛屿 3。\n5. 旅行者 1 参观岛屿 3 上的观光景点 2。\n6. 旅行者 1 通过桥梁 5 从岛屿 3 移动到岛屿 6。\n7. 旅行者 1 参观岛屿 6 上的观光景点 3。\n8. 旅行者 1 从岛屿 6 出发，离开 JOI 王国。\n\n岛屿 1, 2, 3, 6 是旅行者 1 至少访问一次的四个岛屿。如果旅行者 1 至少访问一次的岛屿数量小于或等于 3，则不可能参观所有的观光景点 1, 2, 3。因此，第一行输出 4。旅行者 2 按以下方式旅行，并参观所有的观光景点 4, 5, 6。\n1. 旅行者 2 到达岛屿 3。\n2. 旅行者 2 通过桥梁 6 从岛屿 3 移动到岛屿 7。\n3. 旅行者 2 参观岛屿 7 上的观光景点 6。\n4. 旅行者 2 通过桥梁 6 从岛屿 7 移动到岛屿 3。\n5. 旅行者 2 通过桥梁 2 从岛屿 3 移动到岛屿 1。\n6. 旅行者 2 通过桥梁 1 从岛屿 1 移动到岛屿 2。\n7. 旅行者 2 通过桥梁 3 从岛屿 2 移动到岛屿 4。\n8. 旅行者 2 参观岛屿 4 上的观光景点 4。\n9. 旅行者 2 通过桥梁 3 从岛屿 4 移动到岛屿 2。\n10. 旅行者 2 通过桥梁 4 从岛屿 2 移动到岛屿 5。\n11. 旅行者 2 参观岛屿 5 上的观光景点 5。\n12. 旅行者 2 从岛屿 5 出发，离开 JOI 王国。\n\n岛屿 1, 2, 3, 4, 5, 7 是旅行者 2 至少访问一次的六个岛屿。如果旅行者 2 至少访问一次的岛屿数量小于或等于 5，则不可能参观所有的观光景点 4, 5, 6。因此，第二行输出 6。此样例输入满足子任务 1, 2, 4, 5, 6 的约束。\n\n岛屿 1, 2, 3, 4, 5, 7 是旅行者 2 至少访问一次的六个岛屿。如果旅行者 2 至少访问一次的岛屿数量小于或等于 5，则不可能参观所有的观光景点 4, 5, 6。因此，第二行输出 6。\n\n此样例输入满足子任务 1, 2, 4, 5, 6 的约束。\n\n**【样例解释 #2】**\n\n此样例输入满足子任务 1, 2, 3, 6 的约束。\n\n**【样例解释 #3】**\n\n此样例输入满足子任务 1, 2, 6 的约束。\n\n**【数据范围】**\n\n- $1 \\leq N \\leq 100 000$。\n- $1 \\leq M \\leq 100 000$。\n- $1 \\leq Q \\leq 100 000$。\n- $1 \\leq A_i \\leq N\\ (1 \\leq i \\leq N - 1)$。\n- $1 \\leq B_i \\leq N\\ (1 \\leq i \\leq N - 1)$。\n- 可以通过若干座桥从任意一个岛屿到达另一个岛屿。\n- $1 \\leq C_j \\leq N\\ (1 \\leq j \\leq M)$。\n- $1 \\leq L_k \\leq R_k \\leq M\\ (1 \\leq k \\leq Q)$。\n- 给定的值都是整数。\n\n**【子任务】**\n\n1. (5 分) $N \\leq 300, M \\leq 300, Q \\leq 300$。\n2. (5 分) $N \\leq 2 000, M \\leq 2 000, Q \\leq 2 000$。\n3. (7 分) $A_i = i, B_i = i + 1\\ (1 \\leq i \\leq N - 1)$。\n4. (18 分) $L_1 = 1, R_{k} + 1 = L_{k+1}\\ (1 \\leq k \\leq Q - 1), R_Q = M$。\n5. (24 分) $A_i = \\lfloor\\frac{i+1}2\\rfloor, B_i = i + 1\\ (1 \\leq i \\leq N-1)$。这里，$\\lfloor x\\rfloor$ 是不超过 x 的最大整数。\n6. (41 分) 无额外约束。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2023] Tourism", "background": null, "description": "JOI Kingdom is an insular country consisting of $N$ islands, numbered from $1$ to $N$. The islands are connected by $N − 1$ bridges, numbered from $1$ to $N − 1$. The bridge $i\\ (1 ≤ i ≤ N − 1)$ connects the island $A_i$ and the island $B_i$ bidirectionally. It is possible to travel from any island to any other island by passing through a number of\nbridges.\nIn JOI Kingdom, there are $M$ sightseeing spots, numbered from $1$ to $M$. The sightseeing spot $j\\ (1 ≤ j ≤ M)$ is located in the island $C_j$.\nThere are $Q$ travelers. They plan to visit sightseeing spots in JOI Kingdom. The travelers are numbered from $1$ to $Q$. Each traveler makes a trip in the following way.\n\n1. The traveler chooses an island $x\\ (1 ≤ x ≤ N)$. Taking an airplane, the traveler arrives at the island $x$.\n2. The traveler takes the following actions a number of times. The order and the kinds of actions are arbitrary.\n\n    - The traveler chooses a sightseeing spot in the current island, and visits there.\n    - The traveler moves to another island by passing through a bridge.\n\n3. Taking an airplane, the traveler leaves JOI Kingdom.\n    The traveler $k\\ (1 ≤ k ≤ Q)$ wants to visit all of the sightseeing spots $L_k, L_k+1, . . . , R_k$. However, since the budget is limited, the traveler $k$ wants to minimize the number of islands where the traveler $k$ visits at least once.\n\nWrite a program which, given information of JOI Kingdom and the travelers, calculates, for each $k\\ (1 ≤ k ≤ Q)$, the minimum possible number of islands where the traveler $k​$ visits at least once.", "inputFormat": "Read the following data from the standard input.\n\n> $N\\ M\\ Q$\n> \n> $A_1\\ B_1$\n> \n> $A_2\\ B_2$\n> \n> $\\vdots$\n> \n> $A_{N−1}\\ B_{N−1}$\n> \n> $C_1\\ C_2\\ · · ·\\ C_M$\n> \n> $L_1\\ R_1$\n> \n> $L_2\\ R_2$\n> \n> $\\vdots$\n> \n> $L_Q\\ R_Q$", "outputFormat": "Write $Q$ lines to the standard output. The $k$-th line $(1 ≤ k ≤ Q)$ of output should contain the minimum possible number of islands where the traveler $k$ visits at least once.", "hint": "**【样例解释 #1】**\n\nThe traveler 1 makes a trip in the following way, and visits all of the sightseeing spots 1, 2, 3.\n1. The traveler 1 arrives at the island 2.\n2. The traveler 1 visits the sightseeing spot 1 in the island 2.\n3. The traveler 1 moves from the island 2 to the island 1 by passing through the bridge 1.\n4. The traveler 1 moves from the island 1 to the island 3 by passing through the bridge 2.\n5. The traveler 1 visits the sightseeing spot 2 in the island 3.\n6. The traveler 1 moves from the island 3 to the island 6 by passing through the bridge 5.\n7. The traveler 1 visits the sightseeing spot 3 in the island 6.\n8. The traveler 1 departs from the island 6 and leaves JOI Kingdom.\n\nThe islands 1, 2, 3, 6 are the four islands where the traveler 1 visits at least once. If the number of islands traveler 1 visits at least once is less than or equal to 3, it is impossible to visit all of the sightseeing spots 1, 2, 3.\nTherefore, output 4 in the first line.\nThe traveler 2 makes a trip in the following way, and visits all of the sightseeing spots 4, 5, 6.\n1. The traveler 2 arrives at the island 3.\n2. The traveler 2 moves from the island 3 to the island 7 by passing through the bridge 6.\n3. The traveler 2 visits the sightseeing spot 6 in the island 7.\n4. The traveler 2 moves from the island 7 to the island 3 by passing through the bridge 6.\n5. The traveler 2 moves from the island 3 to the island 1 by passing through the bridge 2.\n6. The traveler 2 moves from the island 1 to the island 2 by passing through the bridge 1.\n7. The traveler 2 moves from the island 2 to the island 4 by passing through the bridge 3.\n8. The traveler 2 visits the sightseeing spot 4 in the island 4.\n9. The traveler 2 moves from the island 4 to the island 2 by passing through the bridge 3.\n10. The traveler 2 moves from the island 2 to the island 5 by passing through the bridge 4.\n11. The traveler 2 visits the sightseeing spot 5 in the island 5.\n12. The traveler 2 departs from the island 5 and leaves JOI Kingdom.\n\nThe islands 1, 2, 3, 4, 5, 7 are the six islands where the traveler 2 visits at least once. If the number of islands\ntraveler 2 visits at least once is less than or equal to 5, it is impossible to visit all of the sightseeing spots 4, 5, 6.\nTherefore, output 6 in the second line.\nThis sample input satisfies the constraints of Subtasks 1, 2, 4, 5, 6.\n\nThe islands 1, 2, 3, 4, 5, 7 are the six islands where the traveler 2 visits at least once. If the number of islands\ntraveler 2 visits at least once is less than or equal to 5, it is impossible to visit all of the sightseeing spots 4, 5, 6.\nTherefore, output 6 in the second line.\n\nThis sample input satisfies the constraints of Subtasks 1, 2, 4, 5, 6.\n\n**【样例解释 #2】**\n\nThis sample input satisfies the constraints of Subtasks 1, 2, 3, 6.\n\n**【样例解释 #3】**\n\nThis sample input satisfies the constraints of Subtasks 1, 2, 6.\n\n**【数据范围】**\n\n- $1 ≤ N ≤ 100 000$.\n- $1 ≤ M ≤ 100 000$.\n- $1 ≤ Q ≤ 100 000$.\n- $1 ≤ A_i ≤ N\\ (1 ≤ i ≤ N − 1)$.\n- $1 ≤ B_i ≤ N\\ (1 ≤ i ≤ N − 1)$.\n- It is possible to travel from any island to any other island by passing through a number of bridges.\n- $1 ≤ C_j ≤ N\\ (1 ≤ j ≤ M)$.\n- $1 ≤ L_k ≤ R_k ≤ M\\ (1 ≤ k ≤ Q)$.\n- Given values are all integers.\n\n**【子任务】**\n\n1. (5 points) $N ≤ 300, M ≤ 300, Q ≤ 300$.\n2. (5 points) $N ≤ 2 000, M ≤ 2 000, Q ≤ 2 000$.\n3. (7 points) $A_i = i, B_i = i + 1\\ (1 ≤ i ≤ N − 1)$.\n4. (18 points) $L_1 = 1, R_{k} + 1 = L_{k+1}\\ (1 ≤ k ≤ Q − 1), R_Q = M$.\n5. (24 points) $A_i = \\lfloor\\frac{i+1}2\\rfloor, B_i = i + 1\\ (1 ≤ i ≤ N−1)$. Here, $⌊x⌋$ is the largest integer not exceeding x.\n6. (41 points) No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] 旅行 / Tourism", "background": null, "description": "JOI 王国是一个由 $N$ 个岛屿组成的岛国，编号从 $1$ 到 $N$。这些岛屿通过 $N - 1$ 座桥相连，编号从 $1$ 到 $N - 1$。桥 $i\\ (1 \\leq i \\leq N - 1)$ 双向连接岛屿 $A_i$ 和岛屿 $B_i$。可以通过若干座桥从任意一个岛屿到达另一个岛屿。在 JOI 王国，有 $M$ 个观光景点，编号从 $1$ 到 $M$。观光景点 $j\\ (1 \\leq j \\leq M)$ 位于岛屿 $C_j$。有 $Q$ 位旅行者，他们计划参观 JOI 王国的观光景点。旅行者编号从 $1$ 到 $Q$。每位旅行者按以下方式旅行。\n\n1. 旅行者选择一个岛屿 $x\\ (1 \\leq x \\leq N)$。乘坐飞机，旅行者到达岛屿 $x$。\n2. 旅行者进行若干次以下动作。动作的顺序和种类是任意的。\n\n    - 旅行者选择当前岛屿上的一个观光景点，并参观。\n    - 旅行者通过桥梁移动到另一个岛屿。\n\n3. 乘坐飞机，旅行者离开 JOI 王国。旅行者 $k\\ (1 \\leq k \\leq Q)$ 想要参观所有的观光景点 $L_k, L_k+1, \\ldots, R_k$。然而，由于预算有限，旅行者 $k$ 希望最小化至少访问一次的岛屿数量。", "inputFormat": "从标准输入读取以下数据。\n\n> $N\\ M\\ Q$\n\n> \n\n> $A_1\\ B_1$\n\n> \n\n> $A_2\\ B_2$\n\n> \n\n> $\\vdots$\n\n> \n\n> $A_{N-1}\\ B_{N-1}$\n\n> \n\n> $C_1\\ C_2\\ \\cdots\\ C_M$\n\n> \n\n> $L_1\\ R_1$\n\n> \n\n> $L_2\\ R_2$\n\n> \n\n> $\\vdots$\n\n> \n\n> $L_Q\\ R_Q$", "outputFormat": "向标准输出写入 $Q$ 行。输出的第 $k$ 行 $(1 \\leq k \\leq Q)$ 应包含旅行者 $k$ 至少访问一次的岛屿的最小可能数量。", "hint": "**【样例解释 #1】**\n\n旅行者 1 按以下方式旅行，并参观所有的观光景点 1, 2, 3。\n1. 旅行者 1 到达岛屿 2。\n2. 旅行者 1 参观岛屿 2 上的观光景点 1。\n3. 旅行者 1 通过桥梁 1 从岛屿 2 移动到岛屿 1。\n4. 旅行者 1 通过桥梁 2 从岛屿 1 移动到岛屿 3。\n5. 旅行者 1 参观岛屿 3 上的观光景点 2。\n6. 旅行者 1 通过桥梁 5 从岛屿 3 移动到岛屿 6。\n7. 旅行者 1 参观岛屿 6 上的观光景点 3。\n8. 旅行者 1 从岛屿 6 出发，离开 JOI 王国。\n\n岛屿 1, 2, 3, 6 是旅行者 1 至少访问一次的四个岛屿。如果旅行者 1 至少访问一次的岛屿数量小于或等于 3，则不可能参观所有的观光景点 1, 2, 3。因此，第一行输出 4。旅行者 2 按以下方式旅行，并参观所有的观光景点 4, 5, 6。\n1. 旅行者 2 到达岛屿 3。\n2. 旅行者 2 通过桥梁 6 从岛屿 3 移动到岛屿 7。\n3. 旅行者 2 参观岛屿 7 上的观光景点 6。\n4. 旅行者 2 通过桥梁 6 从岛屿 7 移动到岛屿 3。\n5. 旅行者 2 通过桥梁 2 从岛屿 3 移动到岛屿 1。\n6. 旅行者 2 通过桥梁 1 从岛屿 1 移动到岛屿 2。\n7. 旅行者 2 通过桥梁 3 从岛屿 2 移动到岛屿 4。\n8. 旅行者 2 参观岛屿 4 上的观光景点 4。\n9. 旅行者 2 通过桥梁 3 从岛屿 4 移动到岛屿 2。\n10. 旅行者 2 通过桥梁 4 从岛屿 2 移动到岛屿 5。\n11. 旅行者 2 参观岛屿 5 上的观光景点 5。\n12. 旅行者 2 从岛屿 5 出发，离开 JOI 王国。\n\n岛屿 1, 2, 3, 4, 5, 7 是旅行者 2 至少访问一次的六个岛屿。如果旅行者 2 至少访问一次的岛屿数量小于或等于 5，则不可能参观所有的观光景点 4, 5, 6。因此，第二行输出 6。此样例输入满足子任务 1, 2, 4, 5, 6 的约束。\n\n岛屿 1, 2, 3, 4, 5, 7 是旅行者 2 至少访问一次的六个岛屿。如果旅行者 2 至少访问一次的岛屿数量小于或等于 5，则不可能参观所有的观光景点 4, 5, 6。因此，第二行输出 6。\n\n此样例输入满足子任务 1, 2, 4, 5, 6 的约束。\n\n**【样例解释 #2】**\n\n此样例输入满足子任务 1, 2, 3, 6 的约束。\n\n**【样例解释 #3】**\n\n此样例输入满足子任务 1, 2, 6 的约束。\n\n**【数据范围】**\n\n- $1 \\leq N \\leq 100 000$。\n- $1 \\leq M \\leq 100 000$。\n- $1 \\leq Q \\leq 100 000$。\n- $1 \\leq A_i \\leq N\\ (1 \\leq i \\leq N - 1)$。\n- $1 \\leq B_i \\leq N\\ (1 \\leq i \\leq N - 1)$。\n- 可以通过若干座桥从任意一个岛屿到达另一个岛屿。\n- $1 \\leq C_j \\leq N\\ (1 \\leq j \\leq M)$。\n- $1 \\leq L_k \\leq R_k \\leq M\\ (1 \\leq k \\leq Q)$。\n- 给定的值都是整数。\n\n**【子任务】**\n\n1. (5 分) $N \\leq 300, M \\leq 300, Q \\leq 300$。\n2. (5 分) $N \\leq 2 000, M \\leq 2 000, Q \\leq 2 000$。\n3. (7 分) $A_i = i, B_i = i + 1\\ (1 \\leq i \\leq N - 1)$。\n4. (18 分) $L_1 = 1, R_{k} + 1 = L_{k+1}\\ (1 \\leq k \\leq Q - 1), R_Q = M$。\n5. (24 分) $A_i = \\lfloor\\frac{i+1}2\\rfloor, B_i = i + 1\\ (1 \\leq i \\leq N-1)$。这里，$\\lfloor x\\rfloor$ 是不超过 x 的最大整数。\n6. (41 分) 无额外约束。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9341", "type": "P", "difficulty": 7, "samples": [["4 3 0\n2 1 3 2\n1 2\n2 3\n3 4\n", "7\n"], ["4 3 1\n2 1 3 2\n1 2\n2 3\n3 4\n", "7\n5\n"], ["3 3 0\n1 1 1\n1 2\n1 3\n2 3\n", "2\n"], ["8 7 0\n2 2 2 2 2 2 2 2\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n", "14"], ["8 7 0\n16 39 36 23 15 48 23 56\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n7 8\n", "245"], ["10 13 4\n314 159 265 358 979 323 846 264 338 327\n1 2\n1 4\n2 3\n2 5\n3 6\n4 5\n4 7\n5 6\n5 8\n6 9\n7 8\n8 9\n9 10\n", "3139\n2901\n2722\n2567\n2461\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] 警卫 / Security Guard", "background": "", "description": "在 JOI 王国，有 $N$ 个岛屿，编号从 $1$ 到 $N$。每个岛屿都有一个不安全等级。岛屿 $i\\ (1 \\le i \\le N)$ 的不安全等级是 $S_i$。\n\n在 JOI 王国，岛屿之间的船只是主要的交通方式。有 $M$ 艘船，编号从 $1$ 到 $M$。船 $j\\ (1 \\le j \\le M)$ 连接岛屿 $A_j$ 和岛屿 $B_j$。我们可以在需要时运行船只。可以通过多次乘船从任何岛屿到达其他岛屿。\n\n在 JOI 王国，有计划引入新的船只。我们可以选择任何一对岛屿来连接新引入的船只。\n\n有一天，发生了一起事件。一艘停泊的船遭到了攻击。JOI 王国的总理 K 决定引入新的船只。他还要求 JOI 王国的船只满足以下**安全条件**。\n\n- 当船停泊在岛屿 $i\\ (1 \\le i \\le N)$ 时，船上的保安人数必须大于或等于 $S_i$。\n\n然而，由于雇佣保安很昂贵，我们希望最小化雇佣保安的人数。只要满足“可以通过多次乘船从任何岛屿到达其他岛屿”的条件，就可以废除当前运行的船只。\n\n因此，我们将按如下方式运行船只。这里，$k$ 是新引入的船只数量。\n\n1. 对于每艘新引入的船，我们选择它连接的两个岛屿。\n2. 我们选择若干（大于或等于 $0$）船只，并废除它们。允许废除新引入的船只。\n3. 对于每艘船，我们将其停泊在它连接的两个岛屿之一。我们让若干保安登船。此外，必须满足以下条件。\n\n*条件* 对于每对岛屿 $u, v\\ (1 \\le u \\le N, 1 \\le v \\le N)$，可以通过多次重复以下操作将乘客从岛屿 $u$ 运输到岛屿 $v$。在此过程中，安全条件必须始终得到满足。\n\n- 我们让乘客或保安登上停泊在乘客或保安所在岛屿的船。\n- 我们让乘客或保安在船当前停泊的岛屿下船。\n- 我们将船从当前停泊的岛屿移动到船连接的另一个岛屿。\n\n由于预算有限，我们最多可以引入 $Q$ 艘新船。对于每个 $k\\ (0 \\le k \\le Q)$，总理 K 想知道如果新引入的船只数量为 $k$ 时，雇佣保安的最小可能人数。\n\n编写一个程序，给定岛屿的信息、船只的航线以及我们可以引入的新船数量，计算每个 $k$ 的雇佣保安的最小可能人数。", "inputFormat": "从标准输入读取以下数据。\n\n> $N\\ M\\ Q$\n>\n> $S_1\\ S_2\\ \\cdots\\ S_N$\n>\n> $A_1\\ B_1$\n>\n> $A_2\\ B_2$\n>\n> $\\vdots$\n>\n> $A_M\\ B_M$", "outputFormat": "向标准输出写入 $Q+1$ 行。输出的第 $(k+1)$ 行 $(0 \\le k \\le Q)$ 应包含如果新引入的船只数量为 $k$ 时雇佣保安的最小可能人数。", "hint": "#### 【样例解释 #1】\n\n如果新引入的船只数量为 $0$，我们需要 $7$ 名保安。例如，如果我们按如下方式分配船只和 $7$ 名保安，则条件得到满足。\n\n- 船 $1$ 最初停泊在岛屿 $2$，并有两名保安登上船 $1$。\n- 船 $2$ 最初停泊在岛屿 $2$，并有两名保安登上船 $2$。\n- 船 $3$ 最初停泊在岛屿 $4$，并有三名保安登上船 $3$。\n\n让我们解释如何在以下两种情况下运输乘客。\n\n- 我们将乘客从岛屿 $1$ 运输到岛屿 $4$。\n- 我们将乘客从岛屿 $3$ 运输到岛屿 $2$。\n\n我们可以按如下方式将乘客从岛屿 $1$ 运输到岛屿 $4$。船 $1, 2, 3$ 停泊的岛屿，以及船 $1, 2, 3$ 上的保安人数按此顺序写出。岛屿 $1, 2, 3, 4$ 上的保安人数按此顺序写出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/itac2gkr.png)\n\n我们可以按如下方式将乘客从岛屿 $3$ 运输到岛屿 $2$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cooaz7e1.png)\n\n由于如果保安人数小于或等于 $6$，则无法满足条件，因此输出 $7$。\n\n此样例输入满足子任务 $2, 3, 4, 5, 6, 7$ 的约束。\n\n#### 【样例解释 #2】\n\n如果新引入的船只数量为 $0$，与样例输入 $1$ 类似，我们需要 $7$ 名保安。\n\n如果新引入的船只数量为 $1$，我们需要 $5$ 名保安。例如，如果我们按如下方式分配船只和 $5$ 名保安，则条件得到满足。\n\n- 我们引入一艘连接岛屿 $2$ 和岛屿 $4$ 的新船。（在下文中，我们称之为船 $4$。）\n- 我们废除船 $3$。\n- 我们最初将船 $1$ 停泊在岛屿 $2$，并让两名保安登上船 $1$。\n- 我们最初将船 $2$ 停泊在岛屿 $2$，并让一名保安登上船 $2$。\n- 我们最初将船 $4$ 停泊在岛屿 $2$，并让两名保安登上船 $4$。\n\n此样例输入满足子任务 $5, 6, 7$ 的约束。\n\n#### 【样例解释 #3】\n\n如果新引入的船只数量为 $0$，我们需要 $2$ 名保安。例如，如果我们按如下方式分配船只和 $2$ 名保安，则条件得到满足。\n\n- 我们废除船 $3$。\n- 我们最初将船 $1$ 停泊在岛屿 $1$，并让一名保安登上船 $1$。\n- 我们最初将船 $2$ 停泊在岛屿 $1$，并让一名保安登上船 $2$。\n\n此样例输入满足子任务 $4, 5, 6, 7$ 的约束。\n\n#### 【样例解释 #4】\n\n此样例输入满足所有子任务的约束。\n\n#### 【样例解释 #5】\n\n此样例输入满足子任务 $3, 4, 5, 6, 7$ 的约束。\n\n#### 【样例解释 #6】\n\n此样例输入满足子任务 $5, 6, 7$ 的约束。\n\n#### 【数据范围】\n\n对于所有测试数据，满足：\n\n- $2 \\le N \\le 2\\times 10 ^ 5$；\n- $N - 1 \\le M \\le 4\\times 10 ^ 5$；\n- $0 \\le Q \\le 2\\times 10 ^ 5$；\n- $1 \\le S_i \\le 10 ^ 9\\ (1 \\le i \\le N)$；\n- $1 \\le A_j < B_j \\le N\\ (1 \\le j \\le M)$；\n- $(A_x, B_x) \neq (A_y, B_y)\\ (1 \\le x < y \\le M)$；\n- 可以通过多次乘船从任何岛屿到达其他岛屿；\n- 给定值均为整数。\n\n| 子任务编号 | 分值 | 特殊限制 |\n| :----------: | :----------: | :----------: |\n| $1$ | $12$ | $M = N - 1$，$Q = 0$，$S_i \\le 2\\ (1 \\le i \\le N)$，$A_j = j$，$B_j = j + 1\\ (1 \\le j \\le M)$ |\n| $2$ | $13$ | $M = N - 1$，$Q = 0$，$A_j = j$，$B_j = j + 1\\ (1 \\le j \\le M)$ |\n| $3$ | $12$ | $M = N - 1$，$Q = 0$ |\n| $4$ | $13$ | $Q = 0$ |\n| $5$ | $8$ | $N \\le 16$ |\n| $6$ | $18$ | $N \\le 3 000$ |\n| $7$ | $24$ | 无 |\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2023] Security Guard", "background": null, "description": "In JOI Kingdom, there are $N$ islands, numbered from $1$ to $N$. Each island has the insecurity level. The insecurity level of the island $i\\ (1 \\le i \\le N)$ is $S_i$.\n\nIn JOI Kingdom, ships between pairs of islands are mostly used as the methods of transportations. There are $M$ ships, numbered from $1$ to $M$. The ship $j\\ (1 \\le j \\le M)$ connects the island $A_j$ and the island $B_j$. We can run ships when necessary. It is possible to travel from any island to any other island by taking a number of ships.\n\nIn JOI Kingdom, there is a plan to introduce new ships. We can choose any pairs of islands where newly introduced ships connect.\n\nOne day, an incident occurred. A ship at anchor was attacked. Prime minister K of JOI Kingdom decided to introduce new ships. He also demands that ships in JOI Kingdom should satisfy the following **Security\nCondition**.\n\n- When a ship is anchored at the island $i\\ (1 \\le i \\le N)$, the number of security guards on the ship is greater than or equal to $S_i$.\n\nHowever, since it is expensive to hire security guards, we want to minimize the number of hired security guards. As long as the condition “it is possible to travel from any island to any other island by taking a number of ships” is satisfied, it is possible to abolish ships which are currently running.\n\nTherefore, we will run ships as follows. Here, $k$ is the number of newly introduced ships.\n\n1. For each of the $k$ newly introduced ships, we choose two islands where it connects.\n2. We choose a number of (more than or equal to $0$) ships, and we abolish them. It is allowed to abolish newly introduced ships.\n3. For each of the ships, we anchor it at one of the two islands where it connects. We make a number of security guards get on it. Moreover, the following conditions should be satisfied.\n\n*Condition* &nbsp; &nbsp; For every pair $u, v\\ (1 \\le u \\le N, 1 \\le v \\le N)$ of islands, it is possible to transport a passenger from the island $u$ to the island $v$ by repeating the following operations a number of times. In the process, Security Condition should be satisfied all the time.\n\n -  We make a passenger or security guards get on a ship which is anchored at the island where the passenger or security guards are staying.\n- We make a passenger or security guards get off a ship at the island where the ship is currently anchored.\n- We move a ship from the island where the ship is currently anchored to the other island where the ship connects.\n\nSince the budget is limited, we can introduce at most $Q$ new ships. For each $k\\ (0 \\le k \\le Q)$, Prime minister K wants to know the minimum possible number of hired security guards if the number of newly introduced ships is $k$.\nWrite a program which, given the information of islands and the routes of the ships and the number of new ships we can introduce, calculates the minimum possible number of hired security guards for each $k$.", "inputFormat": "Read the following data from the standard input.\n\n> $N\\ M\\ Q$\n>\n> $S_1\\ S_2\\ \\cdots\\ S_N$\n>\n> $A_1\\ B_1$\n>\n> $A_2\\ B_2$\n>\n> $\\vdots$\n>\n> $A_M\\ B_M$", "outputFormat": "Write $Q+1$ lines to the standard output. The $(k+1)$-th line $(0 \\le k \\le Q)$ of output should contain the minimum possible number of hired security guards if the number of newly introduced ships is $k$.\n", "hint": "#### 【样例解释 #1】\n\nIf the number of newly introduced ships is $0$, we need $7$ security guards. For example, the conditions are satisfied if we allocate the ships and $7$ security guards as follows.\n\n- The ship $1$ is initially anchored at the island $2$, and two security guards get on the ship $1$.\n- The ship $2$ is initially anchored at the island $2$, and two security guards get on the ship $2$.\n- The ship $3$ is initially anchored at the island $4$, and three security guards get on the ship $3$.\n\nLet us explain how to transport a passenger in the following two cases.\n\n- We transport a passenger from the island $1$ to the island $4$.\n- We transport a passenger from the island $3$ to the island $2$.\n\nWe can transport a passenger from the island $1$ to the island $4$ as follows. The islands where the ships $1, 2, 3$ are anchored, and the numbers of security guards on the ships $1, 2, 3$ are written in this order. The numbers of security guards on the islands $1, 2, 3, 4$ are written in this order.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/itac2gkr.png)\n\nWe can transport a passenger from the island $3$ to the island $2$ as follows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cooaz7e1.png)\n\nSince it is impossible to satisfy the conditions if the number of security guards is less than or equal to $6$, output $7$.\n\nThis sample input satisfies the constraints of Subtasks $2, 3, 4, 5, 6, 7$.\n\n#### 【样例解释 #2】\n\nIf the number of newly introduced ships is $0$, similarly as Sample Input $1$, we need $7$ security guards.\n\nIf the number of newly introduced ships is $1$, we need $5$ security guards. For example, the conditions are satisfied if we allocate the ships and $5$ security guards as follows.\n\n- We introduce a new ship connecting the island $2$ and the island $4$. (In the following, we call it the ship $4$.)\n- We abolish the ship $3$.\n- We initially anchor the ship $1$ at the island $2$, and make two security guards get on the ship $1$.\n- We initially anchor the ship $2$ at the island $2$, and make one security guard get on the ship $2$.\n- We initially anchor the ship $4$ at the island $2$, and make two security guards get on the ship $4$.\n\nThis sample input satisfies the constraints of Subtasks $5, 6, 7$.\n\n#### 【样例解释 #3】\n\nIf the number of newly introduced ships is $0$, we need $2$ security guards. For example, the conditions are satisfied if we allocate the ships and $2$ security guards as follows.\n\n- We abolish the ship $3$.\n- We initially anchor the ship $1$ at the island $1$, and make one security guard get on the ship $1$.\n- We initially anchor the ship $2$ at the island $1$, and make one security guard get on the ship $2$.\n\nThis sample input satisfies the constraints of Subtasks $4, 5, 6, 7$.\n\n#### 【样例解释 #4】\n\nThis sample input satisfies the constraints of all the subtasks.\n\n#### 【样例解释 #5】\n\nThis sample input satisfies the constraints of Subtasks $3, 4, 5, 6, 7$.\n\n#### 【样例解释 #6】\n\nThis sample input satisfies the constraints of Subtasks $5, 6, 7$.\n\n#### 【数据范围】\n\n对于所有测试数据，满足：\n\n- $2 \\le N \\le 2\\times 10 ^ 5$;\n- $N - 1 \\le M \\le 4\\times 10 ^ 5$;\n- $0 \\le Q \\le 2\\times 10 ^ 5$;\n- $1 \\le S_i \\le 10 ^ 9\\ (1 \\le i \\le N)$;\n- $1 \\le A_j < B_j \\le N\\ (1 \\le j \\le M)$;\n- $(A_x, B_x) \\neq (A_y, B_y)\\ (1 \\le x < y \\le M)$;\n- It is possible to travel from any island to any other island by taking a number of ships;\n- Given values are all integers.\n\n| 子任务编号 | 分值 | 特殊限制 |\n| :----------: | :----------: | :----------: |\n| $1$ | $12$ | $M = N - 1$，$Q = 0$，$S_i \\le 2\\ (1 \\le i \\le N)$，$A_j = j$，$B_j = j + 1\\ (1 \\le j \\le M)$ |\n| $2$ | $13$ | $M = N - 1$，$Q = 0$，$A_j = j$，$B_j = j + 1\\ (1 \\le j \\le M)$ |\n| $3$ | $12$ | $M = N - 1$，$Q = 0$ |\n| $4$ | $13$ | $Q = 0$ |\n| $5$ | $8$ | $N \\le 16$ |\n| $6$ | $18$ | $N \\le 3 000$ |\n| $7$ | $24$ | 无 |\n\n", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] 警卫 / Security Guard", "background": "", "description": "在 JOI 王国，有 $N$ 个岛屿，编号从 $1$ 到 $N$。每个岛屿都有一个不安全等级。岛屿 $i\\ (1 \\le i \\le N)$ 的不安全等级是 $S_i$。\n\n在 JOI 王国，岛屿之间的船只是主要的交通方式。有 $M$ 艘船，编号从 $1$ 到 $M$。船 $j\\ (1 \\le j \\le M)$ 连接岛屿 $A_j$ 和岛屿 $B_j$。我们可以在需要时运行船只。可以通过多次乘船从任何岛屿到达其他岛屿。\n\n在 JOI 王国，有计划引入新的船只。我们可以选择任何一对岛屿来连接新引入的船只。\n\n有一天，发生了一起事件。一艘停泊的船遭到了攻击。JOI 王国的总理 K 决定引入新的船只。他还要求 JOI 王国的船只满足以下**安全条件**。\n\n- 当船停泊在岛屿 $i\\ (1 \\le i \\le N)$ 时，船上的保安人数必须大于或等于 $S_i$。\n\n然而，由于雇佣保安很昂贵，我们希望最小化雇佣保安的人数。只要满足“可以通过多次乘船从任何岛屿到达其他岛屿”的条件，就可以废除当前运行的船只。\n\n因此，我们将按如下方式运行船只。这里，$k$ 是新引入的船只数量。\n\n1. 对于每艘新引入的船，我们选择它连接的两个岛屿。\n2. 我们选择若干（大于或等于 $0$）船只，并废除它们。允许废除新引入的船只。\n3. 对于每艘船，我们将其停泊在它连接的两个岛屿之一。我们让若干保安登船。此外，必须满足以下条件。\n\n*条件* 对于每对岛屿 $u, v\\ (1 \\le u \\le N, 1 \\le v \\le N)$，可以通过多次重复以下操作将乘客从岛屿 $u$ 运输到岛屿 $v$。在此过程中，安全条件必须始终得到满足。\n\n- 我们让乘客或保安登上停泊在乘客或保安所在岛屿的船。\n- 我们让乘客或保安在船当前停泊的岛屿下船。\n- 我们将船从当前停泊的岛屿移动到船连接的另一个岛屿。\n\n由于预算有限，我们最多可以引入 $Q$ 艘新船。对于每个 $k\\ (0 \\le k \\le Q)$，总理 K 想知道如果新引入的船只数量为 $k$ 时，雇佣保安的最小可能人数。\n\n编写一个程序，给定岛屿的信息、船只的航线以及我们可以引入的新船数量，计算每个 $k$ 的雇佣保安的最小可能人数。", "inputFormat": "从标准输入读取以下数据。\n\n> $N\\ M\\ Q$\n>\n> $S_1\\ S_2\\ \\cdots\\ S_N$\n>\n> $A_1\\ B_1$\n>\n> $A_2\\ B_2$\n>\n> $\\vdots$\n>\n> $A_M\\ B_M$", "outputFormat": "向标准输出写入 $Q+1$ 行。输出的第 $(k+1)$ 行 $(0 \\le k \\le Q)$ 应包含如果新引入的船只数量为 $k$ 时雇佣保安的最小可能人数。", "hint": "#### 【样例解释 #1】\n\n如果新引入的船只数量为 $0$，我们需要 $7$ 名保安。例如，如果我们按如下方式分配船只和 $7$ 名保安，则条件得到满足。\n\n- 船 $1$ 最初停泊在岛屿 $2$，并有两名保安登上船 $1$。\n- 船 $2$ 最初停泊在岛屿 $2$，并有两名保安登上船 $2$。\n- 船 $3$ 最初停泊在岛屿 $4$，并有三名保安登上船 $3$。\n\n让我们解释如何在以下两种情况下运输乘客。\n\n- 我们将乘客从岛屿 $1$ 运输到岛屿 $4$。\n- 我们将乘客从岛屿 $3$ 运输到岛屿 $2$。\n\n我们可以按如下方式将乘客从岛屿 $1$ 运输到岛屿 $4$。船 $1, 2, 3$ 停泊的岛屿，以及船 $1, 2, 3$ 上的保安人数按此顺序写出。岛屿 $1, 2, 3, 4$ 上的保安人数按此顺序写出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/itac2gkr.png)\n\n我们可以按如下方式将乘客从岛屿 $3$ 运输到岛屿 $2$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cooaz7e1.png)\n\n由于如果保安人数小于或等于 $6$，则无法满足条件，因此输出 $7$。\n\n此样例输入满足子任务 $2, 3, 4, 5, 6, 7$ 的约束。\n\n#### 【样例解释 #2】\n\n如果新引入的船只数量为 $0$，与样例输入 $1$ 类似，我们需要 $7$ 名保安。\n\n如果新引入的船只数量为 $1$，我们需要 $5$ 名保安。例如，如果我们按如下方式分配船只和 $5$ 名保安，则条件得到满足。\n\n- 我们引入一艘连接岛屿 $2$ 和岛屿 $4$ 的新船。（在下文中，我们称之为船 $4$。）\n- 我们废除船 $3$。\n- 我们最初将船 $1$ 停泊在岛屿 $2$，并让两名保安登上船 $1$。\n- 我们最初将船 $2$ 停泊在岛屿 $2$，并让一名保安登上船 $2$。\n- 我们最初将船 $4$ 停泊在岛屿 $2$，并让两名保安登上船 $4$。\n\n此样例输入满足子任务 $5, 6, 7$ 的约束。\n\n#### 【样例解释 #3】\n\n如果新引入的船只数量为 $0$，我们需要 $2$ 名保安。例如，如果我们按如下方式分配船只和 $2$ 名保安，则条件得到满足。\n\n- 我们废除船 $3$。\n- 我们最初将船 $1$ 停泊在岛屿 $1$，并让一名保安登上船 $1$。\n- 我们最初将船 $2$ 停泊在岛屿 $1$，并让一名保安登上船 $2$。\n\n此样例输入满足子任务 $4, 5, 6, 7$ 的约束。\n\n#### 【样例解释 #4】\n\n此样例输入满足所有子任务的约束。\n\n#### 【样例解释 #5】\n\n此样例输入满足子任务 $3, 4, 5, 6, 7$ 的约束。\n\n#### 【样例解释 #6】\n\n此样例输入满足子任务 $5, 6, 7$ 的约束。\n\n#### 【数据范围】\n\n对于所有测试数据，满足：\n\n- $2 \\le N \\le 2\\times 10 ^ 5$；\n- $N - 1 \\le M \\le 4\\times 10 ^ 5$；\n- $0 \\le Q \\le 2\\times 10 ^ 5$；\n- $1 \\le S_i \\le 10 ^ 9\\ (1 \\le i \\le N)$；\n- $1 \\le A_j < B_j \\le N\\ (1 \\le j \\le M)$；\n- $(A_x, B_x) \neq (A_y, B_y)\\ (1 \\le x < y \\le M)$；\n- 可以通过多次乘船从任何岛屿到达其他岛屿；\n- 给定值均为整数。\n\n| 子任务编号 | 分值 | 特殊限制 |\n| :----------: | :----------: | :----------: |\n| $1$ | $12$ | $M = N - 1$，$Q = 0$，$S_i \\le 2\\ (1 \\le i \\le N)$，$A_j = j$，$B_j = j + 1\\ (1 \\le j \\le M)$ |\n| $2$ | $13$ | $M = N - 1$，$Q = 0$，$A_j = j$，$B_j = j + 1\\ (1 \\le j \\le M)$ |\n| $3$ | $12$ | $M = N - 1$，$Q = 0$ |\n| $4$ | $13$ | $Q = 0$ |\n| $5$ | $8$ | $N \\le 16$ |\n| $6$ | $18$ | $N \\le 3 000$ |\n| $7$ | $24$ | 无 |\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9342", "type": "P", "difficulty": 5, "samples": [["5\n0 5 6 7 9\n1\n7\n", "15"], ["10\n1 2 3 4 5 6 7 8 9 10\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n", "9\n10\n11\n12\n13\n14\n15\n16\n17\n9\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] 比太郎之旅 / Bitaro's Travel", "background": "", "description": "在 JOI 市有一条很长的道路，可以看作是实数轴。道路上的一个位置由一个实数坐标表示。在 JOI 市，沿着这条道路有 $N$ 个观光景点，按坐标递增的顺序编号为 $1$ 到 $N$。第 $i$ 个观光景点 $(1 \\le i \\le N)$ 的坐标为 $X_i$。\n\nBitaro 将参观 JOI 市的所有观光景点。由于“贪婪”是他生活的口号，他将重复以下步骤，直到参观完所有的观光景点。\n\n- 设 $x$ 为 Bitaro 当前的坐标。在他尚未参观的观光景点中，选择一个景点 $i$，使得从 Bitaro 当前坐标到该景点的距离 $|x - X_i|$ 最小。然后 Bitaro 移动到景点 $i$ 的位置，并参观它。如果有多个这样的观光景点，他会移动到坐标较小的那个景点。这里，$|t|$ 是 $t$ 的绝对值。\n\n然而，由于多年的经验，Bitaro 知道如果他通过重复上述步骤来移动，总旅行距离可能会比他预期的要长。由于总旅行距离会根据起始坐标的不同而变化，他想知道如果从 $Q$ 个起始坐标候选 $S_1, S_2, \\dots, S_Q$ 中的每一个开始，直到参观完所有观光景点的总旅行距离。\n\n为了帮助 Bitaro，编写一个程序，计算如果他从每个起始坐标候选开始的总旅行距离，给定 JOI 市的信息和起始坐标候选。", "inputFormat": "从标准输入读取以下数据。\n\n> $N$\n> \n> $X_1\\ X_2\\cdots X_N$\n> \n> $Q$\n> \n> $S_1$\n> \n> $S_2$\n> \n> $\\vdots$\n> \n> $S_Q$", "outputFormat": "向标准输出写入 $Q$ 行。输出的第 $j$ 行 $(1 \\le j \\le Q)$ 应包含如果 Bitaro 从坐标 $S_j$ 开始的总旅行距离。", "hint": "**【样例解释 #1】**\n\n如果 Bitaro 从坐标 $7$ 开始，他将按如下方式参观所有观光景点。\n1. 他尚未参观的观光景点有 $1, 2, 3, 4, 5$，从 Bitaro 当前坐标到这些景点的距离分别为 $7, 2, 1, 0, 2$。由于观光景点 $4$ 是离 Bitaro 最近的景点，他停留在坐标 $7$ 并参观观光景点 $4$。\n2. 他尚未参观的观光景点有 $1, 2, 3, 5$，从 Bitaro 当前坐标到这些景点的距离分别为 $7, 2, 1, 2$。由于观光景点 $3$ 是离 Bitaro 最近的景点，他从坐标 $7$ 移动到坐标 $6$ 并参观观光景点 $3$。\n3. 他尚未参观的观光景点有 $1, 2, 5$，从 Bitaro 当前坐标到这些景点的距离分别为 $6, 1, 3$。由于观光景点 $2$ 是离 Bitaro 最近的景点，他从坐标 $6$ 移动到坐标 $5$ 并参观观光景点 $2$。\n4. 他尚未参观的观光景点有 $1, 5$，从 Bitaro 当前坐标到这些景点的距离分别为 $5, 4$。由于观光景点 $5$ 是离 Bitaro 最近的景点，他从坐标 $5$ 移动到坐标 $9$ 并参观观光景点 $5$。\n5. 他尚未参观的观光景点有 $1$。由于观光景点 $1$ 是离 Bitaro 最近的景点，他从坐标 $9$ 移动到坐标 $0$ 并参观观光景点 $1$。\n\n由于 Bitaro 的总旅行距离是 $15$，输出 $15$。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n该样例满足子任务 $3, 4$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\le N, Q \\le 2 \\times 10^5$，$0 \\le X_i \\le 10^9$，$X_i < X_{i+1}$，$0 \\le S_j \\le 10^9$，保证所有输入均为整数。\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$5$|$Q=1, N \\le 2 \\times 10^3$|\n|$2$|$10$|$Q=1$|\n|$3$|$30$|$X_{i+1} - X_i \\le 100$|\n|$4$|$55$|无|\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2023] Bitaro's Travel", "background": null, "description": "There is a very long road in JOI City, which can be considered as the real number line. A position on the road is represented by a real number coordinate. In JOI City, there are $N$ sightseeing spots along the road, numbered from $1$ to $N$ in ascending order of the coordinates. The coordinate of the $i$-th sightseeing spot $(1\\le i\\le N)$ is $X_i$.\n\nBitaro will visit all the sightseeing spots in JOI City. Since \"greedy\" is the slogan of his life, he will repeat the following procedures until he visits all the sightseeing spots.\n\n- Let $x$ be Bitaro’s current coordinate. Among the sightseeing spots he has not yet visited, take the sightseeing spot $i$ where the distance $|x − X_i|$ from Bitaro's current position takes a minimum value. Then Bitaro moves to the position of the sightseeing spot $i$, and visits it. If there are more than one such sightseeing spots, he moves to the sightseeing spot whose coordinate is smaller than the others. Here, $|t|$ is the absolute value of $t$.\n\nHowever, thanks to long years of experience, Bitaro knows that if he moves by repeating the above procedures, the total traveling distance may be longer than he expected. Since the total traveling distance varies according to the starting coordinate, he wants to know the total traveling distance until he visits all the sightseeing spots if he starts from each of $Q$ candidates of starting coordinates $S_1, S_2,\\dots, S_Q$.\n\nTo help Bitaro, write a program which calculates the total traveling distance if he starts from each of the candidates of starting coordinates, given information of JOI City and candidates of starting coordinates.", "inputFormat": "Read the following data from the standard input.\n\n> $N$\n>\n> $X_1\\ X_2\\cdots X_N$\n>\n> $Q$\n>\n> $S_1$\n>\n> $S_2$\n>\n> $\\vdots$\n>\n> $S_Q$", "outputFormat": "Write $Q$ lines to the standard output. The $j$-th line $(1 \\le j \\le Q)$ of output should contain the total traveling distance if Bitaro starts from the coordinate $S_j$.", "hint": "**【样例解释 #1】**\n\nIf Bitaro starts from the coordinate $7$, he visits all the sightseeing spots as follows.\n1. He has not yet visited the sightseeing spots $1, 2, 3, 4, 5$, and the distances from Bitaro’s current position are $7, 2, 1, 0, 2$, respectively. Since the sightseeing spot $4$ is the nearest sightseeing spot from Bitaro, he stays at the coordinate $7$ and visits the sightseeing spot $4$.\n2. He has not yet visited the sightseeing spots $1, 2, 3, 5$, and the distances from Bitaro’s current position are $7, 2, 1, 2$, respectively. Since the sightseeing spot $3$ is the nearest sightseeing spot from Bitaro, he moves from the coordinate $7$ to the coordinate $6$ and visits the sightseeing spot $3$.\n3. He has not yet visited the sightseeing spots $1, 2, 5$, and the distances from Bitaro’s current position are $6, 1, 3$, respectively. Since the sightseeing spot $2$ is the nearest sightseeing spot from Bitaro, he moves from the coordinate $6$ to the coordinate $5$ and visits the sightseeing spot $2$.\n4. He has not yet visited the sightseeing spots $1, 5$, and the distances from Bitaro’s current position are $5, 4$, respectively. Since the sightseeing spot $5$ is the nearest sightseeing spot from Bitaro, he moves from the coordinate $5$ to the coordinate $9$ and visits the sightseeing spot $5$.\n5. He has not yet visited the sightseeing spot $1$. Since the sightseeing spot $1$ is the nearest sightseeing spot from Bitaro, he moves from the coordinate $9$ to the coordinate $0$ and visits the sightseeing spot $1$.\n\nSince Bitaro’s total traveling distance is $15$, output $15$.\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n该样例满足子任务 $3, 4$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1\\le N,Q\\le2\\times10^5$，$0\\le X_i\\le10^9$，$X_i<X_{i+1}$，$0\\le S_j\\le10^9$，保证所有输入均为整数。\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$5$|$Q=1,N\\le2\\times10^3$|\n|$2$|$10$|$Q=1$|\n|$3$|$30$|$X_{i+1}-X_i\\le100$|\n|$4$|$55$|无|", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] 比太郎之旅 / Bitaro's Travel", "background": "", "description": "在 JOI 市有一条很长的道路，可以看作是实数轴。道路上的一个位置由一个实数坐标表示。在 JOI 市，沿着这条道路有 $N$ 个观光景点，按坐标递增的顺序编号为 $1$ 到 $N$。第 $i$ 个观光景点 $(1 \\le i \\le N)$ 的坐标为 $X_i$。\n\nBitaro 将参观 JOI 市的所有观光景点。由于“贪婪”是他生活的口号，他将重复以下步骤，直到参观完所有的观光景点。\n\n- 设 $x$ 为 Bitaro 当前的坐标。在他尚未参观的观光景点中，选择一个景点 $i$，使得从 Bitaro 当前坐标到该景点的距离 $|x - X_i|$ 最小。然后 Bitaro 移动到景点 $i$ 的位置，并参观它。如果有多个这样的观光景点，他会移动到坐标较小的那个景点。这里，$|t|$ 是 $t$ 的绝对值。\n\n然而，由于多年的经验，Bitaro 知道如果他通过重复上述步骤来移动，总旅行距离可能会比他预期的要长。由于总旅行距离会根据起始坐标的不同而变化，他想知道如果从 $Q$ 个起始坐标候选 $S_1, S_2, \\dots, S_Q$ 中的每一个开始，直到参观完所有观光景点的总旅行距离。\n\n为了帮助 Bitaro，编写一个程序，计算如果他从每个起始坐标候选开始的总旅行距离，给定 JOI 市的信息和起始坐标候选。", "inputFormat": "从标准输入读取以下数据。\n\n> $N$\n> \n> $X_1\\ X_2\\cdots X_N$\n> \n> $Q$\n> \n> $S_1$\n> \n> $S_2$\n> \n> $\\vdots$\n> \n> $S_Q$", "outputFormat": "向标准输出写入 $Q$ 行。输出的第 $j$ 行 $(1 \\le j \\le Q)$ 应包含如果 Bitaro 从坐标 $S_j$ 开始的总旅行距离。", "hint": "**【样例解释 #1】**\n\n如果 Bitaro 从坐标 $7$ 开始，他将按如下方式参观所有观光景点。\n1. 他尚未参观的观光景点有 $1, 2, 3, 4, 5$，从 Bitaro 当前坐标到这些景点的距离分别为 $7, 2, 1, 0, 2$。由于观光景点 $4$ 是离 Bitaro 最近的景点，他停留在坐标 $7$ 并参观观光景点 $4$。\n2. 他尚未参观的观光景点有 $1, 2, 3, 5$，从 Bitaro 当前坐标到这些景点的距离分别为 $7, 2, 1, 2$。由于观光景点 $3$ 是离 Bitaro 最近的景点，他从坐标 $7$ 移动到坐标 $6$ 并参观观光景点 $3$。\n3. 他尚未参观的观光景点有 $1, 2, 5$，从 Bitaro 当前坐标到这些景点的距离分别为 $6, 1, 3$。由于观光景点 $2$ 是离 Bitaro 最近的景点，他从坐标 $6$ 移动到坐标 $5$ 并参观观光景点 $2$。\n4. 他尚未参观的观光景点有 $1, 5$，从 Bitaro 当前坐标到这些景点的距离分别为 $5, 4$。由于观光景点 $5$ 是离 Bitaro 最近的景点，他从坐标 $5$ 移动到坐标 $9$ 并参观观光景点 $5$。\n5. 他尚未参观的观光景点有 $1$。由于观光景点 $1$ 是离 Bitaro 最近的景点，他从坐标 $9$ 移动到坐标 $0$ 并参观观光景点 $1$。\n\n由于 Bitaro 的总旅行距离是 $15$，输出 $15$。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n该样例满足子任务 $3, 4$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\le N, Q \\le 2 \\times 10^5$，$0 \\le X_i \\le 10^9$，$X_i < X_{i+1}$，$0 \\le S_j \\le 10^9$，保证所有输入均为整数。\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$5$|$Q=1, N \\le 2 \\times 10^3$|\n|$2$|$10$|$Q=1$|\n|$3$|$30$|$X_{i+1} - X_i \\le 100$|\n|$4$|$55$|无|\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9343", "type": "P", "difficulty": 2, "samples": [["2\n3 3\n1 1\n1 2\n1 3\n3 2\n1 1\n2 2", "3\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "洛谷原创", "O2优化", "洛谷月赛"], "title": "一曲新词酒一杯", "background": "昨夜勾栏听曲，一壶浊酒，与明月凭栏相望，想起如今的处境，却没有怅然若失，仍然醉心于宴饮涵咏之乐，把酒临风之际，想起一种酒桌上的游戏，便和好友玩起来。", "description": "酒桌上共有 $n$ 杯酒，标号为 $1\\sim n$。桌旁有许多写有“酒”字的红色纸片。\n\n接下来对这 $n$ 杯酒**依次**进行 $m$ 次操作。\n\n操作共分为 $2$ 种：\n\n- `1 x`：给 $x$ 号酒贴上 $1$ 张红纸。\n- `2 x`：给除了 $x$ 号酒的其它 $n-1$ 杯酒分别贴上 $1$ 张红纸。\n\n问在**至少**几次操作后，每杯酒上至少有一张红纸？\n", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示测试数据组数。\n\n对于每组测试数据：\n\n- 第一行两个整数 $n,m$。\n- 后 $m$ 行每行两个整数 $o_i,x_i$，表示第 $i$ 次操作。", "outputFormat": "对于每组测试数据：\n\n- 若在 $m$ 次操作后至少有一杯酒没有红纸，输出一行 `-1`；\n- 否则输出一行一个整数表示答案。", "hint": "**【样例 1 解释】**\n\n对于第一组数据：\n\n- 第 $1$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $0$ 张红纸，$3$ 号酒有 $0$ 张红纸。\n- 第 $2$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $1$ 张红纸，$3$ 号酒有 $0$ 张红纸。\n- 第 $3$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $1$ 张红纸，$3$ 号酒有 $1$ 张红纸。\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试。**\n\n-  Subtask 1（20 points）：$o_i=1$。\n-  Subtask 2（20 points）：$o_i=2$。\n-  Subtask 3（20 points）：所有 $x_i$ 均相等。\n-  Subtask 4（20 points）：$\\sum n,\\sum m\\le 3\\times 10^3$。\n-  Subtask 5（20 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le T,n,m,\\sum n,\\sum m\\le 2\\times 10^5$，$o_i\\in \\{1,2\\}$，$1\\le x_i\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "一曲新词酒一杯", "background": "昨夜勾栏听曲，一壶浊酒，与明月凭栏相望，想起如今的处境，却没有怅然若失，仍然醉心于宴饮涵咏之乐，把酒临风之际，想起一种酒桌上的游戏，便和好友玩起来。", "description": "酒桌上共有 $n$ 杯酒，标号为 $1\\sim n$。桌旁有许多写有“酒”字的红色纸片。\n\n接下来对这 $n$ 杯酒**依次**进行 $m$ 次操作。\n\n操作共分为 $2$ 种：\n\n- `1 x`：给 $x$ 号酒贴上 $1$ 张红纸。\n- `2 x`：给除了 $x$ 号酒的其它 $n-1$ 杯酒分别贴上 $1$ 张红纸。\n\n问在**至少**几次操作后，每杯酒上至少有一张红纸？\n", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示测试数据组数。\n\n对于每组测试数据：\n\n- 第一行两个整数 $n,m$。\n- 后 $m$ 行每行两个整数 $o_i,x_i$，表示第 $i$ 次操作。", "outputFormat": "对于每组测试数据：\n\n- 若在 $m$ 次操作后至少有一杯酒没有红纸，输出一行 `-1`；\n- 否则输出一行一个整数表示答案。", "hint": "**【样例 1 解释】**\n\n对于第一组数据：\n\n- 第 $1$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $0$ 张红纸，$3$ 号酒有 $0$ 张红纸。\n- 第 $2$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $1$ 张红纸，$3$ 号酒有 $0$ 张红纸。\n- 第 $3$ 次操作后，$1$ 号酒有 $1$ 张红纸，$2$ 号酒有 $1$ 张红纸，$3$ 号酒有 $1$ 张红纸。\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试。**\n\n-  Subtask 1（20 points）：$o_i=1$。\n-  Subtask 2（20 points）：$o_i=2$。\n-  Subtask 3（20 points）：所有 $x_i$ 均相等。\n-  Subtask 4（20 points）：$\\sum n,\\sum m\\le 3\\times 10^3$。\n-  Subtask 5（20 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le T,n,m,\\sum n,\\sum m\\le 2\\times 10^5$，$o_i\\in \\{1,2\\}$，$1\\le x_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P9344", "type": "P", "difficulty": 3, "samples": [["2\n6\n1 1 4 5 1 4\n1 0 0 1 0 1\n8\n3 1 4 1 5 9 2 6\n1 0 1 0 1 0 1 0", "5\n13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "贪心", "2023", "洛谷原创", "O2优化", "洛谷月赛"], "title": "去年天气旧亭台", "background": "依旧是过往的天气，过往的楼台烟雨。时间悄悄流逝着，山河仍在，人却已不是过去的人……", "description": "登上楼台，旧时满面沉灰的地板映入眼帘。\n\n共有 $n$ 块地板，地板分为两类，第 $i$ 块地板的类别用 $c_i$ 表示，积灰程度用 $a_i$ 表示。**注意 $c_i$ 为 $0$ 或 $1$。**\n\n现在要清理这些地板上的灰尘。每次操作中，你可以：\n\n+ 选择两个下标 $i,j$，满足 $1\\leq i\\leq j\\leq n$， $c_i=c_j$，**且第 $i$ 块和第 $j$ 块地板上的灰尘均未被清理过**；\n+ 花费 $a_i+a_j$ 的能量清理**第 $i$ 块到第 $j$ 块所有地板**上的灰尘。\n\n求清理完所有地板上的灰尘至少要多少能量。", "inputFormat": "**本题有多组测试数据**。\n\n第一行一个整数 $T$，表示测试数据组数。\n\n对于每组测试数据：\n\n- 第一行一个整数 $n$。\n- 第二行 $n$ 个整数 $a_1,a_2,\\dots,a_n$。\n- 第三行 $n$ 个整数 $c_1,c_2,\\dots,c_n$。", "outputFormat": "对于每组测试数据，一行一个整数表示最小能量。", "hint": "**【样例 1 解释】**\n\n- 对于第一组数据，直接花费 $a_1+a_6=5$ 的能量清理所有灰尘。\n- 对于第二组数据，先花费 $a_1+a_1=6$ 的能量清理第一个地板上的灰尘，再花费 $a_2+a_8=7$ 的能量清理剩余灰尘。\n\n**【数据规模与约定】**\n\n对于 $10\\%$ 的数据，保证 $T\\le 10$，$n\\le 10$；\n\n对于 $40\\%$ 的数据，保证 $T\\le 20$，$n\\le 10^3$；\n\n另有 $10\\%$ 的数据，保证 $c_i=1$；\n\n对于 $100\\%$ 的数据，保证 $1 \\le T \\le 10^5$，$1 \\le n,\\sum n\\le 2 \\times 10^6$，$c_i \\in \\{0,1\\}$，$1 \\le a_i \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "去年天气旧亭台", "background": "依旧是过往的天气，过往的楼台烟雨。时间悄悄流逝着，山河仍在，人却已不是过去的人……", "description": "登上楼台，旧时满面沉灰的地板映入眼帘。\n\n共有 $n$ 块地板，地板分为两类，第 $i$ 块地板的类别用 $c_i$ 表示，积灰程度用 $a_i$ 表示。**注意 $c_i$ 为 $0$ 或 $1$。**\n\n现在要清理这些地板上的灰尘。每次操作中，你可以：\n\n+ 选择两个下标 $i,j$，满足 $1\\leq i\\leq j\\leq n$， $c_i=c_j$，**且第 $i$ 块和第 $j$ 块地板上的灰尘均未被清理过**；\n+ 花费 $a_i+a_j$ 的能量清理**第 $i$ 块到第 $j$ 块所有地板**上的灰尘。\n\n求清理完所有地板上的灰尘至少要多少能量。", "inputFormat": "**本题有多组测试数据**。\n\n第一行一个整数 $T$，表示测试数据组数。\n\n对于每组测试数据：\n\n- 第一行一个整数 $n$。\n- 第二行 $n$ 个整数 $a_1,a_2,\\dots,a_n$。\n- 第三行 $n$ 个整数 $c_1,c_2,\\dots,c_n$。", "outputFormat": "对于每组测试数据，一行一个整数表示最小能量。", "hint": "**【样例 1 解释】**\n\n- 对于第一组数据，直接花费 $a_1+a_6=5$ 的能量清理所有灰尘。\n- 对于第二组数据，先花费 $a_1+a_1=6$ 的能量清理第一个地板上的灰尘，再花费 $a_2+a_8=7$ 的能量清理剩余灰尘。\n\n**【数据规模与约定】**\n\n对于 $10\\%$ 的数据，保证 $T\\le 10$，$n\\le 10$；\n\n对于 $40\\%$ 的数据，保证 $T\\le 20$，$n\\le 10^3$；\n\n另有 $10\\%$ 的数据，保证 $c_i=1$；\n\n对于 $100\\%$ 的数据，保证 $1 \\le T \\le 10^5$，$1 \\le n,\\sum n\\le 2 \\times 10^6$，$c_i \\in \\{0,1\\}$，$1 \\le a_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9345", "type": "P", "difficulty": 4, "samples": [["3\n7 1\n6 5\n11 4\n", "Yes\n1 2 3 4 5 6 7\nNo\nYes\n1 11 9 3 6 7 8 2 5 10 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "洛谷原创", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "夕阳西下几时回", "background": "随着夕阳从山间落下，最后一丝余晖逐渐暗淡；美丽的晚霞，终究还是化作一片黑夜。在这番景象中，一阵又一阵的乡愁涌上心头；远离家乡的游子，就算不是病死他乡，又何时能回还？", "description": "夕阳可以被视作由 $n$ 种不同颜色组成的一副图，其中第 $i$ 种的颜色为 $a_i$，满足 $a$ 是长度为 $n$ 的排列。\n\n定义一个排列的乡愁度为：\n\n+ 对于所有 $1\\le i\\le n$，记 $b_i=\\gcd(a_i,a_{i+1})$。特别地，我们认为 $a_{n+1}=a_1$。\n+ 排列 $a$ 的乡愁度为序列 $b$ 中**不同**元素的个数。\n\n求是否有一个长度为 $n$，乡愁度为 $k$ 的排列 $p$。若有解，请输出任意一个排列。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，一行两个整数 $n,k$。", "outputFormat": "对于每组测试数据：\n\n- 如果不存在这样的排列，输出一行一个字符串 `No`；\n- 否则，输出一行一个字符串 `Yes`，然后输出一行 $n$ 个正整数 $p_1,p_2,\\dots,p_n$，表示你找到的排列。\n\n校验器忽略字符串大小写，例如，`YES`，`yEs`，`yes` 都会被视作答案存在。", "hint": "**【提示】**\n\n一个长度为 $n$ 的排列是一个满足 $1$ 到 $n$ 中的所有正整数恰好出现 $1$ 次的数组。例如，$[3,1,2]$ 是一个长度为 $3$ 的排列，而 $[5,5,1,2,3]$ 不是一个排列。\n\n**【样例 1 解释】**\n\n- 对于第一组数据，$b=[1,1,1,1,1,1,1]$，故 $p$ 的乡愁度为 $1$。\n- 对于第二组数据，可以证明不存在这样的序列。\n- 对于第三组数据，$b=[1,1,3,3,1,1,2,1,5,2,1]$，包含 $4$ 个不同的元素 — $1,2,3$ 和 $5$，故 $p$ 的乡愁度为 $4$。\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试。**\n\n-  Subtask 1（4 points）：$n\\le 9$，$\\sum n\\le 100$。\n-  Subtask 2（5 points）：$k=1$。\n-  Subtask 3（13 points）：$\\sum n\\le 200$。\n-  Subtask 4（30 points）：对于所有测试数据，保证有解。\n-  Subtask 5（48 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$3\\le n\\le 3\\times 10^5$，$1\\le k\\le n$，$\\sum n \\le 6\\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "夕阳西下几时回", "background": "随着夕阳从山间落下，最后一丝余晖逐渐暗淡；美丽的晚霞，终究还是化作一片黑夜。在这番景象中，一阵又一阵的乡愁涌上心头；远离家乡的游子，就算不是病死他乡，又何时能回还？", "description": "夕阳可以被视作由 $n$ 种不同颜色组成的一副图，其中第 $i$ 种的颜色为 $a_i$，满足 $a$ 是长度为 $n$ 的排列。\n\n定义一个排列的乡愁度为：\n\n+ 对于所有 $1\\le i\\le n$，记 $b_i=\\gcd(a_i,a_{i+1})$。特别地，我们认为 $a_{n+1}=a_1$。\n+ 排列 $a$ 的乡愁度为序列 $b$ 中**不同**元素的个数。\n\n求是否有一个长度为 $n$，乡愁度为 $k$ 的排列 $p$。若有解，请输出任意一个排列。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，一行两个整数 $n,k$。", "outputFormat": "对于每组测试数据：\n\n- 如果不存在这样的排列，输出一行一个字符串 `No`；\n- 否则，输出一行一个字符串 `Yes`，然后输出一行 $n$ 个正整数 $p_1,p_2,\\dots,p_n$，表示你找到的排列。\n\n校验器忽略字符串大小写，例如，`YES`，`yEs`，`yes` 都会被视作答案存在。", "hint": "**【提示】**\n\n一个长度为 $n$ 的排列是一个满足 $1$ 到 $n$ 中的所有正整数恰好出现 $1$ 次的数组。例如，$[3,1,2]$ 是一个长度为 $3$ 的排列，而 $[5,5,1,2,3]$ 不是一个排列。\n\n**【样例 1 解释】**\n\n- 对于第一组数据，$b=[1,1,1,1,1,1,1]$，故 $p$ 的乡愁度为 $1$。\n- 对于第二组数据，可以证明不存在这样的序列。\n- 对于第三组数据，$b=[1,1,3,3,1,1,2,1,5,2,1]$，包含 $4$ 个不同的元素 — $1,2,3$ 和 $5$，故 $p$ 的乡愁度为 $4$。\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试。**\n\n-  Subtask 1（4 points）：$n\\le 9$，$\\sum n\\le 100$。\n-  Subtask 2（5 points）：$k=1$。\n-  Subtask 3（13 points）：$\\sum n\\le 200$。\n-  Subtask 4（30 points）：对于所有测试数据，保证有解。\n-  Subtask 5（48 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$3\\le n\\le 3\\times 10^5$，$1\\le k\\le n$，$\\sum n \\le 6\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P9346", "type": "P", "difficulty": 5, "samples": [["4\n1 2 2", "1"], ["5\n1 1 2 2", "739246082"], ["19\n1 2 3 4 5 6 1 8 9 10 11 12 1 14 15 16 17 18", "246415365"], ["49\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 3 11 13 13 15 1 21 7 20 16 4 3 11 11 24 24 31 33 29 24 21 22 12 27 18 37 25 28 26 22 36 38 29", "587033383"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "背包 DP", "树形 DP", "组合数学", "洛谷月赛"], "title": "无可奈何花落去", "background": "天上下起了蒙蒙小雨，回家已是傍晚，推开院门，一地花瓣映入眼帘，随着最近几天花瓣的凋落，树上的花瓣已所剩无几。从地上捡起一片花瓣，干涩的双眼立刻充满了泪水，它顺着脸颊滑下。落到花上的，不知是雨还是泪......", "description": "望向树上的花朵：一朵花有 $n$ 瓣花瓣，花瓣之间有 $n-1$ 条边连接，所有的花瓣都是连通的。\n\n树上的花瓣随着春天的离开而凋落。具体地，每一天，都会在未断开的边中均匀随机地选择一条边断开。\n\n当每个花瓣的度数均不超过 $2$ 时，我们称这朵花凋零了。\n\n一朵花期望会在几天后凋零呢？", "inputFormat": "第一行一个正整数 $n$，表示花瓣的数量。\n\n第二行 $n-1$ 个正整数 $f_2,\\dots,f_n$，表示花瓣 $f_i$ 与花瓣 $i$ 之间有一条边。", "outputFormat": "一行，一个正整数，表示一朵花的期望凋零时间，对 $985661441$（是个质数捏）取模。\n\n如果你不会分数取模，请参考[此题](https://www.luogu.com.cn/problem/P2613)。", "hint": "**【样例 1 解释】**\n\n可以发现第一次不管断开哪条边，均会使这朵花凋零，故期望凋零时间为 $1$。\n\n**【样例 2 解释】**\n\n第一次断开 $(1,2)$ 或 $(2,4)$ 或 $(2,5)$，凋零时间为 $1$；第一次断开 $(1,3)$，凋零时间为 $2$。故期望凋零时间为 $\\frac{3}{4}\\times 1+\\frac{1}{4}\\times 2=\\frac{5}{4}$。\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试。**\n\n-  Subtask 1（1 point）：$f_i=i-1$。\n-  Subtask 2（12 points）：$n\\leq 8$。\n-  Subtask 3（12 points）：$n\\leq 18$。\n-  Subtask 4（8 points）：$f_i=1$。\n-  Subtask 5（16 points）：有且仅有 $1$ 号点度数大于 $2$。\n-  Subtask 6（13 points）：$n\\leq 50$。\n-  Subtask 7（13 points）：$n\\leq 100$。\n-  Subtask 8（13 points）：$n\\leq 500$。\n-  Subtask 9（12 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le n\\leq 5\\times 10^3$，$f_i<i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "无可奈何花落去", "background": "天上下起了蒙蒙小雨，回家已是傍晚，推开院门，一地花瓣映入眼帘，随着最近几天花瓣的凋落，树上的花瓣已所剩无几。从地上捡起一片花瓣，干涩的双眼立刻充满了泪水，它顺着脸颊滑下。落到花上的，不知是雨还是泪......", "description": "望向树上的花朵：一朵花有 $n$ 瓣花瓣，花瓣之间有 $n-1$ 条边连接，所有的花瓣都是连通的。\n\n树上的花瓣随着春天的离开而凋落。具体地，每一天，都会在未断开的边中均匀随机地选择一条边断开。\n\n当每个花瓣的度数均不超过 $2$ 时，我们称这朵花凋零了。\n\n一朵花期望会在几天后凋零呢？", "inputFormat": "第一行一个正整数 $n$，表示花瓣的数量。\n\n第二行 $n-1$ 个正整数 $f_2,\\dots,f_n$，表示花瓣 $f_i$ 与花瓣 $i$ 之间有一条边。", "outputFormat": "一行，一个正整数，表示一朵花的期望凋零时间，对 $985661441$（是个质数捏）取模。\n\n如果你不会分数取模，请参考[此题](https://www.luogu.com.cn/problem/P2613)。", "hint": "**【样例 1 解释】**\n\n可以发现第一次不管断开哪条边，均会使这朵花凋零，故期望凋零时间为 $1$。\n\n**【样例 2 解释】**\n\n第一次断开 $(1,2)$ 或 $(2,4)$ 或 $(2,5)$，凋零时间为 $1$；第一次断开 $(1,3)$，凋零时间为 $2$。故期望凋零时间为 $\\frac{3}{4}\\times 1+\\frac{1}{4}\\times 2=\\frac{5}{4}$。\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试。**\n\n-  Subtask 1（1 point）：$f_i=i-1$。\n-  Subtask 2（12 points）：$n\\leq 8$。\n-  Subtask 3（12 points）：$n\\leq 18$。\n-  Subtask 4（8 points）：$f_i=1$。\n-  Subtask 5（16 points）：有且仅有 $1$ 号点度数大于 $2$。\n-  Subtask 6（13 points）：$n\\leq 50$。\n-  Subtask 7（13 points）：$n\\leq 100$。\n-  Subtask 8（13 points）：$n\\leq 500$。\n-  Subtask 9（12 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le n\\leq 5\\times 10^3$，$f_i<i$。", "locale": "zh-CN"}}}
{"pid": "P9347", "type": "P", "difficulty": 6, "samples": [["1\n4 4\n4 2 1 3", "2\n1 3 4\n2 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创", "Special Judge", "O2优化", "排序", "构造", "洛谷月赛", "分类讨论"], "title": "似曾相识燕归来", "background": "春雨将过，忽而燕鸣轻唤，唤起春波荡漾。春波荡漾，漾起去年的回忆。回忆生香，香满檐下。檐下燕巢残旧，不禁落泪，抬头望归来之燕，心中一动，却是旧时相识……", "description": "$n$ 只燕在夕阳中飞过。按从前到后的顺序，第 $i$ 只燕的大小为 $p_i$，且 $p$ 是一个长度为 $n$ 的排列。\n\n现在可以进行**至多 $L$ 次**如下操作：\n\n- 选定三个整数 $i,j,k$ 满足 $1\\le i<j<k\\le n$，如果 $p_i>p_k$，交换第 $i,j$ 只燕；否则交换第 $j,k$ 只燕。\n\n为了使队形整齐，我们希望燕是从前到后升序排列的，即 $\\forall 1\\le i\\le n$ 都有 $p_i=i$。\n\n问是否可以达成目标。若可以，请构造一组符合要求的操作。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示测试数据组数。\n\n对于每组测试数据：\n\n- 第一行两个整数 $n,L$。\n- 第二行 $n$ 个整数 $p_1,p_2,\\ldots,p_n$。", "outputFormat": "对于每组测试数据：\n\n- 若无法用至多 $L$ 次操作使得 $p$ 升序排列，仅输出一行 `-1`；\n- 否则第一行输出一个整数表示操作次数 $x$，后 $x$ 行每行输出三个整数 $i,j,k$ 表示进行的操作。你需要保证 $0\\le x\\le L$，$1\\le i<j<k\\le n$。", "hint": "**【提示】**\n\n一个长度为 $n$ 的排列是一个满足 $1$ 到 $n$ 中的所有正整数恰好出现 $1$ 次的数组。例如，$[3,1,2]$ 是一个长度为 $3$ 的排列，而 $[5,5,1,2,3]$ 不是一个排列。\n\n**【样例 1 解释】**\n\n- 第一次操作中，$i=1,j=3,k=4$，由于 $p_1>p_4$，我们交换 $p_1,p_3$，此时 $p=[1,2,4,3]$；\n- 第二次操作中，$i=2,j=3,k=4$，由于 $p_2<p_4$，我们交换 $p_3,p_4$，此时 $p=[1,2,3,4]$。\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试。**\n\n-  Subtask 1（5 points）：$n\\le 3$。\n-  Subtask 2（5 points）：$n\\le 4$。\n-  Subtask 3（5 points）：$T\\le 50$，$n\\le 8$。\n-  Subtask 4（10 points）：$n\\le 8$。\n-  Subtask 5（25 points）：$L=n+2$。\n-  Subtask 6（25 points）：$L=n+1$。\n-  Subtask 7（25 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$1\\le n,\\sum n\\le 2\\times 10^6$，$n\\le L\\le n+2$，$p$ 为一个 $1\\sim n$ 的排列。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "似曾相识燕归来", "background": "春雨将过，忽而燕鸣轻唤，唤起春波荡漾。春波荡漾，漾起去年的回忆。回忆生香，香满檐下。檐下燕巢残旧，不禁落泪，抬头望归来之燕，心中一动，却是旧时相识……", "description": "$n$ 只燕在夕阳中飞过。按从前到后的顺序，第 $i$ 只燕的大小为 $p_i$，且 $p$ 是一个长度为 $n$ 的排列。\n\n现在可以进行**至多 $L$ 次**如下操作：\n\n- 选定三个整数 $i,j,k$ 满足 $1\\le i<j<k\\le n$，如果 $p_i>p_k$，交换第 $i,j$ 只燕；否则交换第 $j,k$ 只燕。\n\n为了使队形整齐，我们希望燕是从前到后升序排列的，即 $\\forall 1\\le i\\le n$ 都有 $p_i=i$。\n\n问是否可以达成目标。若可以，请构造一组符合要求的操作。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示测试数据组数。\n\n对于每组测试数据：\n\n- 第一行两个整数 $n,L$。\n- 第二行 $n$ 个整数 $p_1,p_2,\\ldots,p_n$。", "outputFormat": "对于每组测试数据：\n\n- 若无法用至多 $L$ 次操作使得 $p$ 升序排列，仅输出一行 `-1`；\n- 否则第一行输出一个整数表示操作次数 $x$，后 $x$ 行每行输出三个整数 $i,j,k$ 表示进行的操作。你需要保证 $0\\le x\\le L$，$1\\le i<j<k\\le n$。", "hint": "**【提示】**\n\n一个长度为 $n$ 的排列是一个满足 $1$ 到 $n$ 中的所有正整数恰好出现 $1$ 次的数组。例如，$[3,1,2]$ 是一个长度为 $3$ 的排列，而 $[5,5,1,2,3]$ 不是一个排列。\n\n**【样例 1 解释】**\n\n- 第一次操作中，$i=1,j=3,k=4$，由于 $p_1>p_4$，我们交换 $p_1,p_3$，此时 $p=[1,2,4,3]$；\n- 第二次操作中，$i=2,j=3,k=4$，由于 $p_2<p_4$，我们交换 $p_3,p_4$，此时 $p=[1,2,3,4]$。\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试。**\n\n-  Subtask 1（5 points）：$n\\le 3$。\n-  Subtask 2（5 points）：$n\\le 4$。\n-  Subtask 3（5 points）：$T\\le 50$，$n\\le 8$。\n-  Subtask 4（10 points）：$n\\le 8$。\n-  Subtask 5（25 points）：$L=n+2$。\n-  Subtask 6（25 points）：$L=n+1$。\n-  Subtask 7（25 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$1\\le n,\\sum n\\le 2\\times 10^6$，$n\\le L\\le n+2$，$p$ 为一个 $1\\sim n$ 的排列。", "locale": "zh-CN"}}}
{"pid": "P9348", "type": "P", "difficulty": 7, "samples": [["2\nababdca\ndcbcadb", "aaabbdc\nabbcdcd"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "贪心", "洛谷原创", "后缀自动机 SAM", "O2优化", "后缀数组 SA", "洛谷月赛"], "title": "小园香径独徘徊", "background": "徘徊在一条幽深的小径上，拾起记忆的碎片，将它们放入两个长长的口袋中。\n\n将它们收集完倒出来后，会拼成什么样的故事呢？", "description": "有两个字符串 $S,T$，一开始给定 $S$，$T$ 为空串。每次你可以执行以下三种操作，直到 $S$ 变为空串：\n\n1. 删去 $S$ 的第一个字符，并将这个字符插入 $T$ 的开头；\n1. 删去 $S$ 的第一个字符，并将这个字符插入 $T$ 的末尾；\n1. 删去 $S$ 的最后一个字符，并将这个字符插入 $T$ 的开头。\n\na3 想知道，$S$ 变为空串后，可以构成的字典序最小的 $T$。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $Q$，表示测试数据组数。\n\n对于每组测试数据，一行一个字符串 $S$。", "outputFormat": "对于每组测试数据，一行一个字符串，表示可以构成的字典序最小的 $T$。", "hint": "**【样例 1 解释】**\n\n- 对于 $\\texttt{ababdca}$，依次进行第 $1,2,1,2,2,2,1$ 种操作，即可得到 $\\texttt{aaabbdc}$。\n- 对于 $\\texttt{dcbcadb}$，依次进行第 $1,1,1,2,3,1,2$ 种操作，即可得到 $\\texttt{abbcdcd}$。\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试。**\n\n-  Subtask 1（5 points）：$S$ 由至多两种字符构成。\n-  Subtask 2（10 points）：$\\sum |S|\\le 12$。\n-  Subtask 3（15 points）：$\\sum |S|\\le 100$。\n-  Subtask 4（25 points）：$\\sum |S|\\le 3\\times 10^3$。\n-  Subtask 5（20 points）：$\\sum |S|\\le 2\\times 10^5$。\n-  Subtask 6（25 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le Q\\le 3\\times 10^5$，$1\\le |S|\\le 10^6$，$1\\le \\sum |S|\\le 2\\times 10^6$，$S$ 仅由小写字母构成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "小园香径独徘徊", "background": "徘徊在一条幽深的小径上，拾起记忆的碎片，将它们放入两个长长的口袋中。\n\n将它们收集完倒出来后，会拼成什么样的故事呢？", "description": "有两个字符串 $S,T$，一开始给定 $S$，$T$ 为空串。每次你可以执行以下三种操作，直到 $S$ 变为空串：\n\n1. 删去 $S$ 的第一个字符，并将这个字符插入 $T$ 的开头；\n1. 删去 $S$ 的第一个字符，并将这个字符插入 $T$ 的末尾；\n1. 删去 $S$ 的最后一个字符，并将这个字符插入 $T$ 的开头。\n\na3 想知道，$S$ 变为空串后，可以构成的字典序最小的 $T$。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $Q$，表示测试数据组数。\n\n对于每组测试数据，一行一个字符串 $S$。", "outputFormat": "对于每组测试数据，一行一个字符串，表示可以构成的字典序最小的 $T$。", "hint": "**【样例 1 解释】**\n\n- 对于 $\\texttt{ababdca}$，依次进行第 $1,2,1,2,2,2,1$ 种操作，即可得到 $\\texttt{aaabbdc}$。\n- 对于 $\\texttt{dcbcadb}$，依次进行第 $1,1,1,2,3,1,2$ 种操作，即可得到 $\\texttt{abbcdcd}$。\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试。**\n\n-  Subtask 1（5 points）：$S$ 由至多两种字符构成。\n-  Subtask 2（10 points）：$\\sum |S|\\le 12$。\n-  Subtask 3（15 points）：$\\sum |S|\\le 100$。\n-  Subtask 4（25 points）：$\\sum |S|\\le 3\\times 10^3$。\n-  Subtask 5（20 points）：$\\sum |S|\\le 2\\times 10^5$。\n-  Subtask 6（25 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le Q\\le 3\\times 10^5$，$1\\le |S|\\le 10^6$，$1\\le \\sum |S|\\le 2\\times 10^6$，$S$ 仅由小写字母构成。", "locale": "zh-CN"}}}
{"pid": "P9349", "type": "P", "difficulty": 4, "samples": [["6\n1\n2\n1\n2\n3\n2\n", "1\n1\n1\n2\n2\n2\n"], ["10\n1\n1\n2\n2\n1\n2\n2\n1\n1\n2\n", "1\n1\n1\n1\n1\n1\n1\n1\n1\n2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "线段树", "2023", "JOI（日本）"], "title": "[JOI 2023 Final] 石子排列 2 / Stone Arranging 2", "background": "", "description": "JOI-kun has $N$ go stones. The stones are numbered from $1$ to $N$. The color of each stone is an integer between $1$ and $10^9$, inclusive. In the beginning, the color of Stone $i$ ($1 \\le i \\le N$) is $A_i$.\n\nFrom now, JOI-kun will perform $N$ operations. He will put the stones on the table in a line. The operation $i$ ($1 \\le i \\le N$) will be performed as follows:\n\n1. JOI-kun will put Stone $i$ on the immediate right of Stone $i - 1$. However, when $i = 1$, JOI-kun will put Stone 1 on the table.\n2. If there is a stone among Stones $1,2,\\cdots,i-1$ whose current color is the same as Stone $i$, let $j$ be the maximum index of such stones, and JOI-kun will paint all of Stones $j+1,j+2,\\cdots,i-1$ with the color $A_i$.\n\nIn order to confirm whether the operations are correctly performed, JOI-kun wants to know in advance the colors of the stones after all the operations are performed.\n\nGiven information of the go stones, write a program which determines the colors of the stones after the $N$ operations are performed.", "inputFormat": "Read the following data from the standard input.\n\n> $N$  \n> $A_1$  \n> $A_2$  \n> $\\vdots$  \n> $A_N$", "outputFormat": "Write $N$ lines to the standard output. The $i$-th line ($1 \\le i \\le N$) should contain the color of Stone $i$ after the $N$ operations are performed.", "hint": "## Samples\n\n### Sample 1\n\nThe operations are performed as in the following table.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0newqhzt.png)\n\nFinally, the colors of Stones 1, 2, 3, 4, 5, 6 will be 1, 1, 1, 2, 2, 2, respectively.\n\nThis sample input satisfies the constraints of Subtasks 1, 3.\n\n### Sample 2\n\nThis sample input satisfies the constraints of all the subtasks.\n\n## Constraints\n\n- $1 \\le N \\le 2\\times 10^5$.\n- $1 \\le A_i \\le 10^9$ ($1 \\le i \\le N$).\n- Given values are all integers.\n\n## Subtasks\n\n1. (25 points) $N \\le 2 000$.\n2. (35 points) $A_i \\le 2$ ($1 \\le i \\le N$).\n3. (40 points) No additional constraints.", "locale": "en", "translations": {"en": {"title": "[JOI 2023 Final] 石子排列 2 / Stone Arranging 2", "background": "", "description": "JOI-kun has $N$ go stones. The stones are numbered from $1$ to $N$. The color of each stone is an integer between $1$ and $10^9$, inclusive. In the beginning, the color of Stone $i$ ($1 \\le i \\le N$) is $A_i$.\n\nFrom now, JOI-kun will perform $N$ operations. He will put the stones on the table in a line. The operation $i$ ($1 \\le i \\le N$) will be performed as follows:\n\n1. JOI-kun will put Stone $i$ on the immediate right of Stone $i - 1$. However, when $i = 1$, JOI-kun will put Stone 1 on the table.\n2. If there is a stone among Stones $1,2,\\cdots,i-1$ whose current color is the same as Stone $i$, let $j$ be the maximum index of such stones, and JOI-kun will paint all of Stones $j+1,j+2,\\cdots,i-1$ with the color $A_i$.\n\nIn order to confirm whether the operations are correctly performed, JOI-kun wants to know in advance the colors of the stones after all the operations are performed.\n\nGiven information of the go stones, write a program which determines the colors of the stones after the $N$ operations are performed.", "inputFormat": "Read the following data from the standard input.\n\n> $N$  \n> $A_1$  \n> $A_2$  \n> $\\vdots$  \n> $A_N$", "outputFormat": "Write $N$ lines to the standard output. The $i$-th line ($1 \\le i \\le N$) should contain the color of Stone $i$ after the $N$ operations are performed.", "hint": "## Samples\n\n### Sample 1\n\nThe operations are performed as in the following table.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0newqhzt.png)\n\nFinally, the colors of Stones 1, 2, 3, 4, 5, 6 will be 1, 1, 1, 2, 2, 2, respectively.\n\nThis sample input satisfies the constraints of Subtasks 1, 3.\n\n### Sample 2\n\nThis sample input satisfies the constraints of all the subtasks.\n\n## Constraints\n\n- $1 \\le N \\le 2\\times 10^5$.\n- $1 \\le A_i \\le 10^9$ ($1 \\le i \\le N$).\n- Given values are all integers.\n\n## Subtasks\n\n1. (25 points) $N \\le 2 000$.\n2. (35 points) $A_i \\le 2$ ($1 \\le i \\le N$).\n3. (40 points) No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[JOI 2023 Final] 石子排列 2 / Stone Arranging 2", "background": "", "description": "JOI 君有 $N$ 颗围棋子。这些棋子从 $1$ 到 $N$ 编号。每颗棋子的颜色是一个介于 $1$ 和 $10^9$ 之间的整数（包含 $1$ 和 $10^9$）。一开始，第 $i$ 颗棋子（$1 \\le i \\le N$）的颜色是 $A_i$。\n\n接下来，JOI 君将进行 $N$ 次操作。他会将棋子排成一行放在桌子上。第 $i$ 次操作（$1 \\le i \\le N$）将按如下方式进行：\n\n1. JOI 君将第 $i$ 颗棋子放在第 $i-1$ 颗棋子的右边。但是，当 $i = 1$ 时，JOI 君会将第 1 颗棋子放在桌子上。\n2. 如果在第 $1, 2, \\cdots, i-1$ 颗棋子中有一颗棋子的当前颜色与第 $i$ 颗棋子的颜色相同，设 $j$ 为此类棋子的最大索引，JOI 君将用颜色 $A_i$ 涂色第 $j+1, j+2, \\cdots, i-1$ 颗棋子。\n\n为了确认操作是否正确执行，JOI 君想提前知道所有操作执行后棋子的颜色。\n\n给定围棋子的相关信息，编写一个程序来确定 $N$ 次操作后棋子的颜色。", "inputFormat": "从标准输入读取以下数据。\n\n> $N$  \n> $A_1$  \n> $A_2$  \n> $\\vdots$  \n> $A_N$", "outputFormat": "向标准输出写入 $N$ 行。第 $i$ 行（$1 \\le i \\le N$）应包含第 $i$ 颗棋子在 $N$ 次操作后颜色。", "hint": "## 样例\n\n### 样例 1\n\n操作按下表执行。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0newqhzt.png)\n\n最终，第 1, 2, 3, 4, 5, 6 颗棋子的颜色分别为 1, 1, 1, 2, 2, 2。\n\n此样例输入满足子任务 1, 3 的约束。\n\n### 样例 2\n\n此样例输入满足所有子任务的约束。\n\n## 约束\n\n- $1 \\le N \\le 2 \\times 10^5$。\n- $1 \\le A_i \\le 10^9$ ($1 \\le i \\le N$)。\n- 给定的值都是整数。\n\n## 子任务\n\n1. (25 分) $N \\le 2 000$。\n2. (35 分) $A_i \\le 2$ ($1 \\le i \\le N$)。\n3. (40 分) 无额外约束。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9350", "type": "P", "difficulty": 4, "samples": [["4\n4 2\n2 3\n3 4\n6 5\n", "2\n"], ["3\n7 10\n10 10\n7 10\n", "2\n"], ["10\n31447678 204745778\n430226982 292647686\n327782937 367372305\n843320852 822224390\n687565054 738216211\n970840050 766211141\n563662348 742939240\n103739645 854320982\n294864525 601612333\n375952316 469655019\n", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2023", "离散化", "扫描线", "JOI（日本）"], "title": "[JOI 2023 Final] 宣传 2 / Advertisement 2", "background": "", "description": "There are $N$ residents in JOI Kingdom, numbered from $1$ to $N$. Resident $i$ ($1\\le i\\le N$) lives at the coordinate $X_i$ on the real line, and its **power of influence** is $E_i$. It may be the case that more than one residents live at the same coordinate. A resident with a large power of influence has a high advertising potential. But such a resident is careful in buying books.\n\nRie published a book on informatics. In order to encourage many people to buy copies of the book, she can donate copies of the book to some residents. If she donates a copy of the book to Resident $i$ ($1\\le i\\le N$), Resident $i$ will get a copy of Rie’s book. Moreover, among the residents who did not yet get copies of the book, every resident $j$ ($1\\le j\\le N$) satisfying the following condition will buy a copy of the book and get it.\n\n-  The distance between Resident $i$ and Resident $j$ on the real line is less than or equal to $E_i - E_j$. In other words, $|X_i − X_j| \\le E_i − E_j$ is satisfied.\n\nIf all the residents read Rie’s book, the Olympiads in Informatics will be greatly recognized. Write a program which calculates the minimum number of residents who will be donated copies of Rie’s book so that all the residents in JOI Kingdom will get copies of Rie’s book.", "inputFormat": "Read the following data from the standard input.\n\n> $N$  \n> $X_1$ $E_1$  \n> $X_2$ $E_2$  \n> $\\vdots$  \n> $X_N$ $E_N$", "outputFormat": "Write one line to the standard output. The output should contain the minimum number of residents who will be donated copies of Rie’s book.", "hint": "## Samples\n\n### Sample 1\n\nFor example, if Rie donates copies of the book in the following way, all the residents in JOI Kingdom will get copies of Rie’s book.\n\n- Rie donates a copy of the book to Resident 3.\n  - Since $|X_3 - X_1| = 1$ and $E_3 - E_1 = 2$, Resident 1 will buy a copy of Rie’s book and get it.\n  - Since $|X_3 - X_2| = 1$ and $E_3 - E_2 = 1$, Resident 2 will buy a copy of Rie’s book and get it.\n  - Since $|X_3 - X_4| = 3$ and $E_3 - E_4 = -1$, Resident 4 will not buy a copy of Rie’s book.\n  Therefore, Residents 1, 2, 3 will get copies of Rie’s book.\n- Rie donates a copy of the book to Resident 4. Since all the residents except Resident 4 already got copies of Rie’s book, all the residents in JOI Kingdom finally get copies of Rie’s book.\n\nSince it is impossible to donate copies of the book to less than two residents so that all the residents in JOI Kingdom will get copies of Rie’s book, output 2.\n\nThis sample input satisfies the constraints of Subtasks 2, 3, 4.\n\n### Sample 2\n\nThis sample input satisfies the constraints of all the subtasks.\n\n### Sample 3\n\nThis sample input satisfies the constraints of Subtasks 2, 3, 4.\n\n## Constraints\n\n- $1\\le N\\le 5\\times 10^5$.\n- $1\\le X_i\\le 10^9$ ($1\\le i\\le N$).\n- $1\\le E_i\\le 10^9$ ($1\\le i\\le N$).\n- Given values are all integers.\n\n## Subtasks\n\n1. (10 points) $E_1=E_2=\\cdots=E_N$.\n2. (23 points) $N\\le 16$.\n3. (36 points) $N\\le 10^3$.\n4. (31 points) No additional constraints.\n", "locale": "en", "translations": {"en": {"title": "[JOI 2023 Final] 宣传 2 / Advertisement 2", "background": "", "description": "There are $N$ residents in JOI Kingdom, numbered from $1$ to $N$. Resident $i$ ($1\\le i\\le N$) lives at the coordinate $X_i$ on the real line, and its **power of influence** is $E_i$. It may be the case that more than one residents live at the same coordinate. A resident with a large power of influence has a high advertising potential. But such a resident is careful in buying books.\n\nRie published a book on informatics. In order to encourage many people to buy copies of the book, she can donate copies of the book to some residents. If she donates a copy of the book to Resident $i$ ($1\\le i\\le N$), Resident $i$ will get a copy of Rie’s book. Moreover, among the residents who did not yet get copies of the book, every resident $j$ ($1\\le j\\le N$) satisfying the following condition will buy a copy of the book and get it.\n\n-  The distance between Resident $i$ and Resident $j$ on the real line is less than or equal to $E_i - E_j$. In other words, $|X_i − X_j| \\le E_i − E_j$ is satisfied.\n\nIf all the residents read Rie’s book, the Olympiads in Informatics will be greatly recognized. Write a program which calculates the minimum number of residents who will be donated copies of Rie’s book so that all the residents in JOI Kingdom will get copies of Rie’s book.", "inputFormat": "Read the following data from the standard input.\n\n> $N$  \n> $X_1$ $E_1$  \n> $X_2$ $E_2$  \n> $\\vdots$  \n> $X_N$ $E_N$", "outputFormat": "Write one line to the standard output. The output should contain the minimum number of residents who will be donated copies of Rie’s book.", "hint": "## Samples\n\n### Sample 1\n\nFor example, if Rie donates copies of the book in the following way, all the residents in JOI Kingdom will get copies of Rie’s book.\n\n- Rie donates a copy of the book to Resident 3.\n  - Since $|X_3 - X_1| = 1$ and $E_3 - E_1 = 2$, Resident 1 will buy a copy of Rie’s book and get it.\n  - Since $|X_3 - X_2| = 1$ and $E_3 - E_2 = 1$, Resident 2 will buy a copy of Rie’s book and get it.\n  - Since $|X_3 - X_4| = 3$ and $E_3 - E_4 = -1$, Resident 4 will not buy a copy of Rie’s book.\n  Therefore, Residents 1, 2, 3 will get copies of Rie’s book.\n- Rie donates a copy of the book to Resident 4. Since all the residents except Resident 4 already got copies of Rie’s book, all the residents in JOI Kingdom finally get copies of Rie’s book.\n\nSince it is impossible to donate copies of the book to less than two residents so that all the residents in JOI Kingdom will get copies of Rie’s book, output 2.\n\nThis sample input satisfies the constraints of Subtasks 2, 3, 4.\n\n### Sample 2\n\nThis sample input satisfies the constraints of all the subtasks.\n\n### Sample 3\n\nThis sample input satisfies the constraints of Subtasks 2, 3, 4.\n\n## Constraints\n\n- $1\\le N\\le 5\\times 10^5$.\n- $1\\le X_i\\le 10^9$ ($1\\le i\\le N$).\n- $1\\le E_i\\le 10^9$ ($1\\le i\\le N$).\n- Given values are all integers.\n\n## Subtasks\n\n1. (10 points) $E_1=E_2=\\cdots=E_N$.\n2. (23 points) $N\\le 16$.\n3. (36 points) $N\\le 10^3$.\n4. (31 points) No additional constraints.\n", "locale": "en"}, "zh-CN": {"title": "[JOI 2023 Final] 宣传 2 / Advertisement 2", "background": "", "description": "JOI 王国有 $N$ 位居民，编号从 $1$ 到 $N$。居民 $i$ ($1 \\le i \\le N$) 住在实数轴上的坐标 $X_i$ 处，其**影响力**为 $E_i$。可能有多个居民住在同一坐标处。拥有较大影响力的居民具有较高的广告潜力，但这样的居民在购买书籍时很谨慎。\n\nRie 出版了一本信息学的书。为了鼓励更多人购买这本书，她可以向一些居民赠送这本书的副本。如果她向居民 $i$ ($1 \\le i \\le N$) 赠送了一本书，居民 $i$ 将获得 Rie 的书。此外，在尚未获得书的居民中，满足以下条件的每位居民 $j$ ($1 \\le j \\le N$) 都会购买一本书并获得它。\n\n- 居民 $i$ 和居民 $j$ 在实数轴上的距离小于或等于 $E_i - E_j$。换句话说，满足 $|X_i - X_j| \\le E_i - E_j$。\n\n如果所有居民都阅读了 Rie 的书，信息学奥林匹克将得到极大的认可。编写一个程序，计算需要向多少位居民赠送 Rie 的书，才能使 JOI 王国的所有居民都获得 Rie 的书。", "inputFormat": "从标准输入读取以下数据。\n\n> $N$  \n> $X_1$ $E_1$  \n> $X_2$ $E_2$  \n> $\\vdots$  \n> $X_N$ $E_N$", "outputFormat": "向标准输出写入一行。输出应包含需要赠送 Rie 的书的最少居民数量，以便 JOI 王国的所有居民都获得 Rie 的书。", "hint": "## 样例\n\n### 样例 1\n\n例如，如果 Rie 按以下方式赠送书，JOI 王国的所有居民将获得 Rie 的书。\n\n- Rie 向居民 3 赠送了一本书。\n  - 因为 $|X_3 - X_1| = 1$ 且 $E_3 - E_1 = 2$，居民 1 会购买一本 Rie 的书并获得它。\n  - 因为 $|X_3 - X_2| = 1$ 且 $E_3 - E_2 = 1$，居民 2 会购买一本 Rie 的书并获得它。\n  - 因为 $|X_3 - X_4| = 3$ 且 $E_3 - E_4 = -1$，居民 4 不会购买 Rie 的书。\n  因此，居民 1、2、3 将获得 Rie 的书。\n- Rie 向居民 4 赠送了一本书。由于除了居民 4 之外的所有居民都已经获得了 Rie 的书，最终 JOI 王国的所有居民都获得了 Rie 的书。\n\n由于不可能向少于两位居民赠送书以使 JOI 王国的所有居民都获得 Rie 的书，因此输出 2。\n\n此样例输入满足子任务 2、3、4 的约束。\n\n### 样例 2\n\n此样例输入满足所有子任务的约束。\n\n### 样例 3\n\n此样例输入满足子任务 2、3、4 的约束。\n\n## 约束\n\n- $1 \\le N \\le 5 \\times 10^5$。\n- $1 \\le X_i \\le 10^9$ ($1 \\le i \\le N$)。\n- $1 \\le E_i \\le 10^9$ ($1 \\le i \\le N$)。\n- 给定值均为整数。\n\n## 子任务\n\n1. (10 分) $E_1=E_2=\\cdots=E_N$。\n2. (23 分) $N \\le 16$。\n3. (36 分) $N \\le 10^3$。\n4. (31 分) 无额外约束。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9351", "type": "P", "difficulty": 6, "samples": [["2 4 2\n1 1\n2 4\n.###\n###.\n", "1\n"], ["6 6 1\n1 6\n6 1\n..#.#.\n##.###\n####.#\n...###\n##.##.\n.#.###\n", "4\n"], ["6 7 6\n6 4\n3 1\n..#.#.#\n##.##..\n.######\n#..#.#.\n.######\n..#.##.\n", "1\n"], ["1 15 1\n1 15\n1 1\n...............\n", "0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2023", "O2优化", "JOI（日本）"], "title": "[JOI 2023 Final] 迷宫 / Maze", "background": "", "description": "President K loves solving mazes. He found cells from which he may create a maze. The cells are rectangular grid with $R$ horizontal rows and $C$ vertical columns. Each cell is colored either white or black. The cell in the $i$-th row ($1 \\leqslant i \\leqslant R$) from the top and the $j$-th column ($1 \\leqslant j \\leqslant C$) from the left is called Cell $(i, j)$.\n\nPresident K will solve the maze under the condition that he can pass the white cells, but he cannot pass the black cells. More precisely, he will solve the maze in the following way.\n\n1. Among the white cells, he will choose Cell $(S_r, S_c)$, which is the starting cell of the maze, and Cell $(G_r, G_c)$, which is the goal cell of the maze.\n2. It is possible to move from one cell to another white cell which is adjacent to the current cell in one of the four directions (top, bottom, left, or right). By repeating this, he will find a path from the starting cell to the goal cell.\n\nPresident K already fixed the starting cell and the goal cell. However, he noticed that in some situations of the colors of the cells, there might not be a path from the starting cell to the goal cell consisting of white cells only. He has a stamp of size $N \\times N$. He will perform the following **Operations** several times so that there will be a path from the starting cell to the goal cell consisting of white cells only.\n\n**Operation.** He chooses a square region of $N \\times N$ cells, and paint the cells in the region white. More precisely, he chooses integers $a, b$ satisfying $1 \\leqslant a \\leqslant R - N + 1$ and $1 \\leqslant b \\leqslant C − N + 1$, and for every pair $(i, j)$ of integers satisfying $a \\leqslant i \\leqslant a + N − 1$ and $b \\leqslant j \\leqslant b + N − 1$, he paints Cell $(i, j)$ white.\n\nSince his hands becomes dirty if he uses the stamp, he wants to minimize the number of operations. Given\ninformation of the colors of the cells, the size of the stamp, and the locations of the starting cell and the goal cell, write a program which calculates the minimum number of operations he has to perform so that there will be a path from the starting cell to the goal cell consisting of white cells only.", "inputFormat": "Read the following data from the standard input.\n\n> $R$ $C$ $N$  \n$S_r$ $S_c$  \n$G_r$ $G_c$  \n$A_1$  \n$A_2$  \n$.$  \n$.$  \n$.$  \n$A_R$\n\n$A_i (1 \\leqslant i \\leqslant R)$ is a string of length $C$ consisting of `.` or `#`. The $j$-th character ($1 \\leqslant j \\leqslant C$) of $A_i$ represents the color of Cell $(i, j)$. Its color is white if the character is `.`, and its color is black if the character is `#`.", "outputFormat": "Write one line to the standard output. The output should contain the minimum number of operations President\nK has to perform so that there will be a path from the starting cell to the goal cell consisting of white cells only.", "hint": "#### 【样例解释 #1】\n\nIf he chooses $(a, b) = (1, 2)$ and perform an operation, Cells $(1, 2), (1, 3), (2, 2), (2, 3)$ become white. Then there will be a path from the starting cell to the goal cell consisting of white cells only. For example, the path $(1, 1) → (1, 2) → (1, 3) → (2, 3) → (2, 4)$ satisfies the condition.\n\nIf he does not perform an operation, there is no path from the starting cell to the goal cell consisting of white cells only. Therefore, output $1$.\n\n该样例满足子任务 $2, 3, 4, 5, 6, 7, 8$ 的限制。\n\n#### 【样例解释 #2】\n\n该样例满足所有子任务的限制。\n\n#### 【样例解释 #3】\n\n该样例满足子任务 $2, 3, 4, 5, 6, 7, 8$ 的限制。\n\n#### 【样例解释 #4】\n\nEven if he does not perform an operation, there might be a path from the starting cell to the goal cell consisting of white cells only.\n\n该样例满足所有子任务的限制。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 ≤ N ≤ R ≤ C$, $R × C ≤ 6 \\times 10^6$, $1 ≤ S_r ≤ R$, $1 ≤ S_c ≤ C$, $1 ≤ G_r ≤ R$, $1 ≤ G_c ≤ C$, $(S_r, S_c) \\neq (G_r, G_c)$.\n\n保证 $A_i (1 ≤ i ≤ R)$ 是一个长为 $C$ 且只由 `.` 或 `#` 构成的字符串。保证格子 $(S_r, S_c)$ 与格子 $(G_r, G_c)$ 均为白色。\n\n保证 $R, C, N, S_r, S_c, G_r, G_c$ 均为整数。\n\n| 子任务编号 | 分值 | 限制 |\n| :-: | :-: | :-: |\n| $1$ | $8$ | $N = 1, R × C ≤ 1.5 \\times 10^6$ |\n| $2$ | $19$ | $R × C ≤ 10^3$ |\n| $3$ | $16$ | 答案不超过 $10$, $R × C ≤ 1.5 \\times 10^6$ |\n| $4$ | $19$ | $R × C ≤ 6 \\times 10^4$ |\n| $5$ | $5$ | $R × C ≤ 1.5 \\times 10^5$ |\n| $6$ | $19$ | $R × C ≤ 1.5 \\times 10^6$ |\n| $7$ | $8$ | $R × C ≤ 3 \\times 10^6$ |\n| $8$ | $6$ | 无 |", "locale": "en", "translations": {"en": {"title": "[JOI 2023 Final] 迷宫 / Maze", "background": "", "description": "President K loves solving mazes. He found cells from which he may create a maze. The cells are rectangular grid with $R$ horizontal rows and $C$ vertical columns. Each cell is colored either white or black. The cell in the $i$-th row ($1 \\leqslant i \\leqslant R$) from the top and the $j$-th column ($1 \\leqslant j \\leqslant C$) from the left is called Cell $(i, j)$.\n\nPresident K will solve the maze under the condition that he can pass the white cells, but he cannot pass the black cells. More precisely, he will solve the maze in the following way.\n\n1. Among the white cells, he will choose Cell $(S_r, S_c)$, which is the starting cell of the maze, and Cell $(G_r, G_c)$, which is the goal cell of the maze.\n2. It is possible to move from one cell to another white cell which is adjacent to the current cell in one of the four directions (top, bottom, left, or right). By repeating this, he will find a path from the starting cell to the goal cell.\n\nPresident K already fixed the starting cell and the goal cell. However, he noticed that in some situations of the colors of the cells, there might not be a path from the starting cell to the goal cell consisting of white cells only. He has a stamp of size $N \\times N$. He will perform the following **Operations** several times so that there will be a path from the starting cell to the goal cell consisting of white cells only.\n\n**Operation.** He chooses a square region of $N \\times N$ cells, and paint the cells in the region white. More precisely, he chooses integers $a, b$ satisfying $1 \\leqslant a \\leqslant R - N + 1$ and $1 \\leqslant b \\leqslant C − N + 1$, and for every pair $(i, j)$ of integers satisfying $a \\leqslant i \\leqslant a + N − 1$ and $b \\leqslant j \\leqslant b + N − 1$, he paints Cell $(i, j)$ white.\n\nSince his hands becomes dirty if he uses the stamp, he wants to minimize the number of operations. Given\ninformation of the colors of the cells, the size of the stamp, and the locations of the starting cell and the goal cell, write a program which calculates the minimum number of operations he has to perform so that there will be a path from the starting cell to the goal cell consisting of white cells only.", "inputFormat": "Read the following data from the standard input.\n\n> $R$ $C$ $N$  \n$S_r$ $S_c$  \n$G_r$ $G_c$  \n$A_1$  \n$A_2$  \n$.$  \n$.$  \n$.$  \n$A_R$\n\n$A_i (1 \\leqslant i \\leqslant R)$ is a string of length $C$ consisting of `.` or `#`. The $j$-th character ($1 \\leqslant j \\leqslant C$) of $A_i$ represents the color of Cell $(i, j)$. Its color is white if the character is `.`, and its color is black if the character is `#`.", "outputFormat": "Write one line to the standard output. The output should contain the minimum number of operations President\nK has to perform so that there will be a path from the starting cell to the goal cell consisting of white cells only.", "hint": "#### 【样例解释 #1】\n\nIf he chooses $(a, b) = (1, 2)$ and perform an operation, Cells $(1, 2), (1, 3), (2, 2), (2, 3)$ become white. Then there will be a path from the starting cell to the goal cell consisting of white cells only. For example, the path $(1, 1) → (1, 2) → (1, 3) → (2, 3) → (2, 4)$ satisfies the condition.\n\nIf he does not perform an operation, there is no path from the starting cell to the goal cell consisting of white cells only. Therefore, output $1$.\n\n该样例满足子任务 $2, 3, 4, 5, 6, 7, 8$ 的限制。\n\n#### 【样例解释 #2】\n\n该样例满足所有子任务的限制。\n\n#### 【样例解释 #3】\n\n该样例满足子任务 $2, 3, 4, 5, 6, 7, 8$ 的限制。\n\n#### 【样例解释 #4】\n\nEven if he does not perform an operation, there might be a path from the starting cell to the goal cell consisting of white cells only.\n\n该样例满足所有子任务的限制。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 ≤ N ≤ R ≤ C$, $R × C ≤ 6 \\times 10^6$, $1 ≤ S_r ≤ R$, $1 ≤ S_c ≤ C$, $1 ≤ G_r ≤ R$, $1 ≤ G_c ≤ C$, $(S_r, S_c) \\neq (G_r, G_c)$.\n\n保证 $A_i (1 ≤ i ≤ R)$ 是一个长为 $C$ 且只由 `.` 或 `#` 构成的字符串。保证格子 $(S_r, S_c)$ 与格子 $(G_r, G_c)$ 均为白色。\n\n保证 $R, C, N, S_r, S_c, G_r, G_c$ 均为整数。\n\n| 子任务编号 | 分值 | 限制 |\n| :-: | :-: | :-: |\n| $1$ | $8$ | $N = 1, R × C ≤ 1.5 \\times 10^6$ |\n| $2$ | $19$ | $R × C ≤ 10^3$ |\n| $3$ | $16$ | 答案不超过 $10$, $R × C ≤ 1.5 \\times 10^6$ |\n| $4$ | $19$ | $R × C ≤ 6 \\times 10^4$ |\n| $5$ | $5$ | $R × C ≤ 1.5 \\times 10^5$ |\n| $6$ | $19$ | $R × C ≤ 1.5 \\times 10^6$ |\n| $7$ | $8$ | $R × C ≤ 3 \\times 10^6$ |\n| $8$ | $6$ | 无 |", "locale": "en"}, "zh-CN": {"title": "[JOI 2023 Final] 迷宫 / Maze", "background": "", "description": "总统 K 喜欢解迷宫。他找到了可以用来创建迷宫的格子。这些格子是一个有 $R$ 行和 $C$ 列的矩形网格。每个格子要么是白色，要么是黑色。位于从上到下第 $i$ 行（$1 \\leqslant i \\leqslant R$）和从左到右第 $j$ 列（$1 \\leqslant j \\leqslant C$）的格子称为格子 $(i, j)$。\n\n总统 K 将在可以通过白色格子而不能通过黑色格子的条件下解迷宫。更具体地，他将按以下方式解迷宫。\n\n1. 在白色格子中，他将选择格子 $(S_r, S_c)$ 作为迷宫的起始格子，以及格子 $(G_r, G_c)$ 作为迷宫的目标格子。\n2. 可以从一个格子移动到相邻的白色格子，方向可以是四个方向之一（上、下、左或右）。通过重复这个过程，他将找到从起始格子到目标格子的路径。\n\n总统 K 已经固定了起始格子和目标格子。然而，他注意到在某些格子的颜色情况下，可能不存在一条仅由白色格子组成的从起始格子到目标格子的路径。他有一个大小为 $N \\times N$ 的印章。他将多次执行以下**操作**，以便存在一条仅由白色格子组成的从起始格子到目标格子的路径。\n\n**操作。** 他选择一个 $N \\times N$ 的正方形区域，并将该区域内的格子涂成白色。更具体地，他选择整数 $a, b$ 满足 $1 \\leqslant a \\leqslant R - N + 1$ 和 $1 \\leqslant b \\leqslant C - N + 1$，对于每对整数 $(i, j)$ 满足 $a \\leqslant i \\leqslant a + N - 1$ 和 $b \\leqslant j \\leqslant b + N - 1$，他将格子 $(i, j)$ 涂成白色。\n\n由于使用印章会弄脏他的手，他希望最小化操作次数。给定格子的颜色信息、印章的大小以及起始格子和目标格子的位置，编写一个程序计算他必须执行的最小操作次数，以便存在一条仅由白色格子组成的从起始格子到目标格子的路径。", "inputFormat": "从标准输入读取以下数据。\n\n> $R$ $C$ $N$  \n$S_r$ $S_c$  \n$G_r$ $G_c$  \n$A_1$  \n$A_2$  \n$.$  \n$.$  \n$.$  \n$A_R$\n\n$A_i (1 \\leqslant i \\leqslant R)$ 是一个长度为 $C$ 的字符串，由 `.` 或 `#` 组成。$A_i$ 的第 $j$ 个字符（$1 \\leqslant j \\leqslant C$）表示格子 $(i, j)$ 的颜色。如果字符是 `.`，则颜色为白色；如果字符是 `#`，则颜色为黑色。", "outputFormat": "向标准输出写入一行。输出应包含总统 K 必须执行的最小操作次数，以便存在一条仅由白色格子组成的从起始格子到目标格子的路径。", "hint": "#### 【样例解释 #1】\n\n如果他选择 $(a, b) = (1, 2)$ 并执行一次操作，格子 $(1, 2), (1, 3), (2, 2), (2, 3)$ 变成白色。然后将存在一条仅由白色格子组成的从起始格子到目标格子的路径。例如，路径 $(1, 1) \\to (1, 2) \\to (1, 3) \\to (2, 3) \\to (2, 4)$ 满足条件。\n\n如果他不执行任何操作，则不存在一条仅由白色格子组成的从起始格子到目标格子的路径。因此，输出 $1$。\n\n该样例满足子任务 $2, 3, 4, 5, 6, 7, 8$ 的限制。\n\n#### 【样例解释 #2】\n\n该样例满足所有子任务的限制。\n\n#### 【样例解释 #3】\n\n该样例满足子任务 $2, 3, 4, 5, 6, 7, 8$ 的限制。\n\n#### 【样例解释 #4】\n\n即使他不执行任何操作，也可能存在一条仅由白色格子组成的从起始格子到目标格子的路径。\n\n该样例满足所有子任务的限制。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\leqslant N \\leqslant R \\leqslant C$，$R \\times C \\leqslant 6 \\times 10^6$，$1 \\leqslant S_r \\leqslant R$，$1 \\leqslant S_c \\leqslant C$，$1 \\leqslant G_r \\leqslant R$，$1 \\leqslant G_c \\leqslant C$，$(S_r, S_c) \neq (G_r, G_c)$。\n\n保证 $A_i (1 \\leqslant i \\leqslant R)$ 是一个长度为 $C$ 且只由 `.` 或 `#` 构成的字符串。保证格子 $(S_r, S_c)$ 和格子 $(G_r, G_c)$ 均为白色。\n\n保证 $R, C, N, S_r, S_c, G_r, G_c$ 均为整数。\n\n| 子任务编号 | 分值 | 限制 |\n| :-: | :-: | :-: |\n| $1$ | $8$ | $N = 1, R \\times C \\leqslant 1.5 \\times 10^6$ |\n| $2$ | $19$ | $R \\times C \\leqslant 10^3$ |\n| $3$ | $16$ | 答案不超过 $10$，$R \\times C \\leqslant 1.5 \\times 10^6$ |\n| $4$ | $19$ | $R \\times C \\leqslant 6 \\times 10^4$ |\n| $5$ | $5$ | $R \\times C \\leqslant 1.5 \\times 10^5$ |\n| $6$ | $19$ | $R \\times C \\leqslant 1.5 \\times 10^6$ |\n| $7$ | $8$ | $R \\times C \\leqslant 3 \\times 10^6$ |\n| $8$ | $6$ | 无 |\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9352", "type": "P", "difficulty": 5, "samples": [["4\n3 4 1 2\n1 2\n2 3\n3 4\n", "3\n"], ["7\n3 2 7 1 5 4 6\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n", "7\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "并查集", "2023", "最近公共祖先 LCA", "JOI（日本）", "笛卡尔树"], "title": "[JOI 2023 Final] 训猫 / Cat Exercise", "background": null, "description": "There are $N$ cat towers, numbered from $1$ to $N$. The height of Tower $i$ ($1 \\le i \\le N$) is $P_i$. The heights of the towers are distinct integers between $1$ and $N$, inclusive. There are $N - 1$ adjacent pairs of towers. For each $j$ ($1 \\le j \\le N - 1$), Tower $A_j$ and Tower $B_j$ are adjacent to each other. In the beginning, it is possible to travel from a tower to any other tower by repeating moves from towers to adjacent towers.\n\nIn the beginning, a cat stays in a tower of height $N$.\n\nThen we perform **cat exercises**. In cat exercises, we repeatedly choose a tower and put an obstacle on it. However, we cannot put an obstacle on a tower where we already put an obstacle on it. During the process, the following will happen.\n\n- If the cat does not stay in the chosen tower, nothing will happen.\n- If the cat stays in the chosen tower and there is an obstacle on every tower which is adjacent to the chosen tower, the cat exercises will finish.\n- Otherwise, among the towers where the cat can arrive by repeating moves from towers to adjacent towers without obstacles, the cat will move to the highest tower except for the current tower by repeating moves from towers to adjacent towers. In this process, the cat takes the route where the number of moves from towers to adjacent towers becomes minimum.\n\nGiven information of the heights of the towers and pairs of adjacent towers, write a program which calculates the maximum possible sum of the number of moves of the cat from towers to adjacent towers if we put obstacles suitably.", "inputFormat": "Read the following data from the standard input.\n\n> $N$  \n> $P_1$ $P_2$ $\\cdots$ $P_N$  \n> $A_1$ $B_1$  \n> $A_2$ $B_2$  \n> $\\vdots$    \n> $A_{N-1}$ $B_{N-1}$", "outputFormat": "Write one line to the standard output. The output should contain the maximum possible sum of the number of moves of the cat from towers to adjacent towers.", "hint": "## Samples\n\n### Sample 1\n\nIf we perform the cat exercises in the following way, the cat moves 3 times in total.\n\n- We put an obstacle on Tower 1. The cat does not move.\n- We put an obstacle on Tower 2. The cat moves from Tower 2 to Tower 3. Then, the cat moves from Tower 3 to Tower 4.\n- We put an obstacle on Tower 4. The cat moves from Tower 4 to Tower 3.\n- We put an obstacle on Tower 3. Then the cat exercises finish.\n\nSince there is no way to perform cat exercises where the cat moves more than or equal to 4 times from towers to adjacent towers, output 3.\n\nThis sample input satisfies the constraints of Subtasks 1, 2, 3, 4, 5, 7.\n\n### Sample 2\n\nThis sample input satisfies the constraints of Subtasks 4, 6, 7.\n\n## Constraints\n\n- $2 \\le N \\le 2\\times 10^5$.\n- $1 \\le P_i \\le N$ ($1 \\le i \\le N$).\n- $P_i \\neq P_j$ ($1 \\le i < j \\le N$).\n- $1 \\le A_j < B_j \\le N$ ($1 \\le j \\le N - 1$).\n- In the beginning, it is possible to travel from a tower to any other tower by repeating moves from towers to adjacent towers.\n- Given values are all integers.\n\n## Subtasks\n\n1. (7 points) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$), $N \\le 16$．\n2. (7 points) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$), $N \\le 300$．\n3. (7 points) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$), $N \\le 5 000$．\n4. (10 points) $N \\le 5 000$．\n5. (20 points) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$)．\n6. (23 points) $A_i =\\left\\lfloor\\frac{i+1}2\\right\\rfloor, B_i = i + 1$ ($1 \\le i \\le N - 1$). Here $\\lfloor x \\rfloor$ is the largest integer which is smaller than or equal to $x$.\n7. (26 points) No additional constraints.", "locale": "en", "translations": {"en": {"title": "[JOI 2023 Final] 训猫 / Cat Exercise", "background": null, "description": "There are $N$ cat towers, numbered from $1$ to $N$. The height of Tower $i$ ($1 \\le i \\le N$) is $P_i$. The heights of the towers are distinct integers between $1$ and $N$, inclusive. There are $N - 1$ adjacent pairs of towers. For each $j$ ($1 \\le j \\le N - 1$), Tower $A_j$ and Tower $B_j$ are adjacent to each other. In the beginning, it is possible to travel from a tower to any other tower by repeating moves from towers to adjacent towers.\n\nIn the beginning, a cat stays in a tower of height $N$.\n\nThen we perform **cat exercises**. In cat exercises, we repeatedly choose a tower and put an obstacle on it. However, we cannot put an obstacle on a tower where we already put an obstacle on it. During the process, the following will happen.\n\n- If the cat does not stay in the chosen tower, nothing will happen.\n- If the cat stays in the chosen tower and there is an obstacle on every tower which is adjacent to the chosen tower, the cat exercises will finish.\n- Otherwise, among the towers where the cat can arrive by repeating moves from towers to adjacent towers without obstacles, the cat will move to the highest tower except for the current tower by repeating moves from towers to adjacent towers. In this process, the cat takes the route where the number of moves from towers to adjacent towers becomes minimum.\n\nGiven information of the heights of the towers and pairs of adjacent towers, write a program which calculates the maximum possible sum of the number of moves of the cat from towers to adjacent towers if we put obstacles suitably.", "inputFormat": "Read the following data from the standard input.\n\n> $N$  \n> $P_1$ $P_2$ $\\cdots$ $P_N$  \n> $A_1$ $B_1$  \n> $A_2$ $B_2$  \n> $\\vdots$    \n> $A_{N-1}$ $B_{N-1}$", "outputFormat": "Write one line to the standard output. The output should contain the maximum possible sum of the number of moves of the cat from towers to adjacent towers.", "hint": "## Samples\n\n### Sample 1\n\nIf we perform the cat exercises in the following way, the cat moves 3 times in total.\n\n- We put an obstacle on Tower 1. The cat does not move.\n- We put an obstacle on Tower 2. The cat moves from Tower 2 to Tower 3. Then, the cat moves from Tower 3 to Tower 4.\n- We put an obstacle on Tower 4. The cat moves from Tower 4 to Tower 3.\n- We put an obstacle on Tower 3. Then the cat exercises finish.\n\nSince there is no way to perform cat exercises where the cat moves more than or equal to 4 times from towers to adjacent towers, output 3.\n\nThis sample input satisfies the constraints of Subtasks 1, 2, 3, 4, 5, 7.\n\n### Sample 2\n\nThis sample input satisfies the constraints of Subtasks 4, 6, 7.\n\n## Constraints\n\n- $2 \\le N \\le 2\\times 10^5$.\n- $1 \\le P_i \\le N$ ($1 \\le i \\le N$).\n- $P_i \\neq P_j$ ($1 \\le i < j \\le N$).\n- $1 \\le A_j < B_j \\le N$ ($1 \\le j \\le N - 1$).\n- In the beginning, it is possible to travel from a tower to any other tower by repeating moves from towers to adjacent towers.\n- Given values are all integers.\n\n## Subtasks\n\n1. (7 points) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$), $N \\le 16$．\n2. (7 points) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$), $N \\le 300$．\n3. (7 points) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$), $N \\le 5 000$．\n4. (10 points) $N \\le 5 000$．\n5. (20 points) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$)．\n6. (23 points) $A_i =\\left\\lfloor\\frac{i+1}2\\right\\rfloor, B_i = i + 1$ ($1 \\le i \\le N - 1$). Here $\\lfloor x \\rfloor$ is the largest integer which is smaller than or equal to $x$.\n7. (26 points) No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[JOI 2023 Final] 训猫 / Cat Exercise", "background": null, "description": "有 $N$ 个猫塔，编号从 $1$ 到 $N$。塔 $i$ 的高度为 $P_i$（$1 \\le i \\le N$）。这些塔的高度是 $1$ 到 $N$ 之间的不同整数。共有 $N - 1$ 对相邻的塔。对于每个 $j$（$1 \\le j \\le N - 1$），塔 $A_j$ 和塔 $B_j$ 是相邻的。最开始，可以通过从一个塔移动到相邻的塔，来从一个塔到达任何其他塔。\n\n最开始，一只猫待在高度为 $N$ 的塔上。\n\n然后我们进行**猫运动**。在猫运动中，我们反复选择一个塔并在其上放置一个障碍。然而，我们不能在已经放置障碍的塔上再放置障碍。在这个过程中，将发生以下情况：\n\n- 如果猫不在所选的塔上，什么也不会发生。\n- 如果猫在所选的塔上，并且所选塔的每个相邻塔上都有障碍，猫运动将结束。\n- 否则，在猫可以通过从塔移动到相邻塔而不受障碍影响到达的塔中，猫将移动到除当前塔外最高的塔。过程中，猫会选择从塔移动到相邻塔的步数最少的路线。\n\n给定塔的高度信息和相邻塔的对，编写程序计算在适当放置障碍的情况下，猫从塔移动到相邻塔的最大可能移动次数之和。", "inputFormat": "从标准输入读取以下数据。\n\n> $N$  \n> $P_1$ $P_2$ $\\cdots$ $P_N$  \n> $A_1$ $B_1$  \n> $A_2$ $B_2$  \n> $\\vdots$  \n> $A_{N-1}$ $B_{N-1}$", "outputFormat": "向标准输出写入一行。输出应包含猫从塔移动到相邻塔的最大可能移动次数之和。", "hint": "## 样例\n\n### 样例 1\n\n如果我们按以下方式进行猫运动，猫总共移动 3 次。\n\n- 我们在塔 1 上放置一个障碍。猫不移动。\n- 我们在塔 2 上放置一个障碍。猫从塔 2 移动到塔 3。然后，猫从塔 3 移动到塔 4。\n- 我们在塔 4 上放置一个障碍。猫从塔 4 移动到塔 3。\n- 我们在塔 3 上放置一个障碍。然后猫运动结束。\n\n由于没有办法进行猫运动，使得猫从塔移动到相邻塔的次数大于或等于 4，因此输出 3。\n\n此样例输入满足子任务 1、2、3、4、5、7 的约束。\n\n### 样例 2\n\n此样例输入满足子任务 4、6、7 的约束。\n\n## 约束\n\n- $2 \\le N \\le 2\\times 10^5$。\n- $1 \\le P_i \\le N$ ($1 \\le i \\le N$)。\n- $P_i \\neq P_j$ ($1 \\le i < j \\le N$)。\n- $1 \\le A_j < B_j \\le N$ ($1 \\le j \\le N - 1$)。\n- 最开始，可以通过从一个塔移动到相邻塔，来从一个塔到达任何其他塔。\n- 给定的值都是整数。\n\n## 子任务\n\n1. (7 分) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$)，$N \\le 16$。\n2. (7 分) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$)，$N \\le 300$。\n3. (7 分) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$)，$N \\le 5 000$。\n4. (10 分) $N \\le 5 000$。\n5. (20 分) $A_i = i, B_i = i + 1$ ($1 \\le i \\le N - 1$)。\n6. (23 分) $A_i =\\left\\lfloor\\frac{i+1}2\\right\\rfloor, B_i = i + 1$ ($1 \\le i \\le N - 1$)。这里 $\\lfloor x \\rfloor$ 是小于或等于 $x$ 的最大整数。\n7. (26 分) 无额外约束。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9353", "type": "P", "difficulty": 7, "samples": [["5 1\nRBRRB\n4\n1\n1 1", "1"], ["5 3\nRBRBR\n1 3 4\n2\n2 3\n1 3", "5\n0"], ["10 3\nBBRRBRBRRB\n2 10 5\n1\n1 3", "2"], ["10 10\nRRRRRRRRRR\n3 1 4 1 5 9 2 6 5 3\n5\n1 7\n2 8\n3 9\n4 10\n1 10", "4\n8\n10\n0\n9"], ["10 10\nRRRBBBBBBB\n3 1 4 1 5 9 2 6 5 3\n5\n1 10\n2 9\n3 8\n4 7\n5 6", "2\n6\n0\n10\n7"], ["30 10\nRRRBBRBBBRBBBRBRBRRRRRBBBBRBRR\n3 28 2 29 1 30 6 14 7 7\n10\n1 10\n2 3\n2 5\n2 8\n3 3\n3 6\n4 5\n4 7\n5 9\n10 10", "21\n15\n15\n4\n17\n16\n14\n20\n12\n23"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2023", "JOI（日本）"], "title": "[JOI 2023 Final] 现代机器 / Modern Machine", "background": null, "description": "Bitaro is given JOI machine as a birthday present. JOI machine consists of one ball, $N$ light tiles, and $M$\nbuttons. The light tiles are numbered from $1$ to $N$. When Bitaro turns the power on, Light tile $i$ ($1 \\leq i \\leq N$) emit light of color $C_i$ (blue ($\\texttt B$) or red ($\\texttt R$)). The buttons are numbered from $1$ to $M$. If Bitaro pushes Button $j$ ($1 \\leq j \\leq M$), the following happen.\n1. The ball is placed on Light tile $A_j$.\n2. Light tile $A_j$ becomes red (regardless of its original color).\n3. The following operations are performed until the ball is removed.  \n    Let $p$ be the index of the light tile where the ball is currently placed.    \n    - If Light tile $p$ is blue,  \n    Light tile $p$ becomes red. After that, if $p = 1$, the ball is removed. Otherwise, the ball moves to\nLight tile $p − 1$.  \n    - If Light tile $p$ is red,  \n    Light tile $p$ becomes blue. After that, if $p = N$, the ball is removed. Otherwise, the ball moves\nto Light tile $p + 1$.\n\nBitaro is interested in JOI machine. He plans to perform $Q$ experiments. In the $k$-th experiment ($1 \\leq k \\leq Q$),\nafter Bitaro turns the power on, Bitaro pushes Buttons $L_k, L_{k}+1,\\dots , R_k$ in this order. After Bitaro pushes a button, he will not push the next button and wait until the ball is removed.\n\nGiven information of JOI machine and the experiments, write a program which calculates, for each experi-\nment, the number of light tiles whose colors are red when the experiment finishes.", "inputFormat": "Read the following data from the standard input.\n> $N$ $M$  \n> $C_1\\ C_2 \\dots C_N$  \n> $A_1\\ A_2 \\dots A_M$  \n> $Q$  \n> $L_1\\ R_1$  \n> $L_2\\ R_2$  \n> $\\dots$  \n> $L_Q\\ R_Q$", "outputFormat": "Write $Q$ lines to the standard output. In the $k$-th line ($1 \\leq k \\leq Q$), the output should contain the number of light tiles whose colors are red when the $k$-th experiment finishes.", "hint": "**【Sample Explanation #1】**\n\nThe first experiment proceeds as follows.\n1. Bitaro pushes Button 1, and ball is placed on Light tile 4.\n2. Light tile 4 becomes red. Since the original color of Light tile 4 is red, the color of Light tile 4 does not\nchange.\n3. After that, the following operations are performed.  \n（1）Since the current color of Light tile 4 is red, Light tile 4 becomes blue, and the ball moves to Light\ntile 5.  \n（2）Since the current color of Light tile 5 is blue, Light tile 5 becomes red, and the ball moves to Light\ntile 4.  \n（3）Since the current color of Light tile 4 is blue, Light tile 4 becomes red, and the ball moves to Light\ntile 3.  \n（4）Since the current color of Light tile 3 is red, Light tile 3 becomes blue, and the ball moves to Light\ntile 4.  \n（5）Since the current color of Light tile 4 is red, the color of Light tile 4 becomes blue, and the ball\nmoves to Light tile 5.  \n（6）Since the current color of Light tile 5 is red, the color of Light tile 5 becomes blue, and the ball is\nremoved.\n\nAfter the experiment, Light tile 1 is the only light tile whose current color is red. Therefore, output 1.\n\nThis sample satisfies the constraints of subtasks 1, 2, 3, 6, and 7.\n\n**【Sample Explanation #2】**\n\nFor the first experiment, Light tiles 1, 2, 3, 4, 5 are the light tiles whose current colors are red after the experiment. Since there are five such light tiles, output 5.\n\nFor the second experiment, there is no light tile whose current color is red after the experiment. Therefore,\noutput 0.\n\nThis sample satisfies the constraints of subtasks 3, 6, and 7.\n\n**【Sample Explanation #3】**  \n\nThis sample satisfies the constraints of subtasks 1, 2, 3, 6, and 7.  \n\n**【Sample Explanation #4】**  \n\nThis sample satisfies the constraints of subtasks 3, 4, 5, 6, and 7.  \n\n**【Sample Explanation #5】**  \n\nThis sample satisfies the constraints of subtasks 3, 5, 6, and 7.  \n\n**【Sample Explanation #6】**  \n\nThis sample satisfies the constraints of subtasks 6 and 7.\n\n**【Constraints】**\n\nFor all test cases, it is guaranteed that:\n\n- $3 \\leq N \\leq 1.2 \\times 10^5$；\n- $1 \\leq M \\leq 1.2 \\times 10^5$；\n- $C_i \\in \\{\\texttt{B},\\texttt{R}\\}$；\n- $1 \\leq A_j \\leq N$；\n- $1 \\leq Q \\leq 1.2 \\times 10^5$；\n- $1 \\leq L_k \\leq R_k \\leq M$；\n- $N, M, A_j, Q, L_k, R_k$ are all integers。\n\n**【Subtasks】**\n\n**Subtasks are used in this problem**。\n\n1. (3 points) $N,M \\leq 300$，$Q = 1$。\n2. (12 points) $N, M \\leq 7000$，$Q = 1$。\n3. (10 points) $Q \\leq 5$。\n4. (11 points) $N = 10$，$C_i = \\texttt R$。\n5. (26 points) There exists a positive integer $t \\in [0, N]$，is guaranteed that $1 \\leq i \\leq t$，$C_i = \\texttt R$；And $\\forall t < i \\leq N$，$C_i = \\texttt B$。\n6. (17 points) $A_j \\leq 20$ or $A_j > N - 20$。\n7. (21 points) No more constraints。", "locale": "en", "translations": {"en": {"title": "[JOI 2023 Final] 现代机器 / Modern Machine", "background": null, "description": "Bitaro is given JOI machine as a birthday present. JOI machine consists of one ball, $N$ light tiles, and $M$\nbuttons. The light tiles are numbered from $1$ to $N$. When Bitaro turns the power on, Light tile $i$ ($1 \\leq i \\leq N$) emit light of color $C_i$ (blue ($\\texttt B$) or red ($\\texttt R$)). The buttons are numbered from $1$ to $M$. If Bitaro pushes Button $j$ ($1 \\leq j \\leq M$), the following happen.\n1. The ball is placed on Light tile $A_j$.\n2. Light tile $A_j$ becomes red (regardless of its original color).\n3. The following operations are performed until the ball is removed.  \n    Let $p$ be the index of the light tile where the ball is currently placed.    \n    - If Light tile $p$ is blue,  \n    Light tile $p$ becomes red. After that, if $p = 1$, the ball is removed. Otherwise, the ball moves to\nLight tile $p − 1$.  \n    - If Light tile $p$ is red,  \n    Light tile $p$ becomes blue. After that, if $p = N$, the ball is removed. Otherwise, the ball moves\nto Light tile $p + 1$.\n\nBitaro is interested in JOI machine. He plans to perform $Q$ experiments. In the $k$-th experiment ($1 \\leq k \\leq Q$),\nafter Bitaro turns the power on, Bitaro pushes Buttons $L_k, L_{k}+1,\\dots , R_k$ in this order. After Bitaro pushes a button, he will not push the next button and wait until the ball is removed.\n\nGiven information of JOI machine and the experiments, write a program which calculates, for each experi-\nment, the number of light tiles whose colors are red when the experiment finishes.", "inputFormat": "Read the following data from the standard input.\n> $N$ $M$  \n> $C_1\\ C_2 \\dots C_N$  \n> $A_1\\ A_2 \\dots A_M$  \n> $Q$  \n> $L_1\\ R_1$  \n> $L_2\\ R_2$  \n> $\\dots$  \n> $L_Q\\ R_Q$", "outputFormat": "Write $Q$ lines to the standard output. In the $k$-th line ($1 \\leq k \\leq Q$), the output should contain the number of light tiles whose colors are red when the $k$-th experiment finishes.", "hint": "**【Sample Explanation #1】**\n\nThe first experiment proceeds as follows.\n1. Bitaro pushes Button 1, and ball is placed on Light tile 4.\n2. Light tile 4 becomes red. Since the original color of Light tile 4 is red, the color of Light tile 4 does not\nchange.\n3. After that, the following operations are performed.  \n（1）Since the current color of Light tile 4 is red, Light tile 4 becomes blue, and the ball moves to Light\ntile 5.  \n（2）Since the current color of Light tile 5 is blue, Light tile 5 becomes red, and the ball moves to Light\ntile 4.  \n（3）Since the current color of Light tile 4 is blue, Light tile 4 becomes red, and the ball moves to Light\ntile 3.  \n（4）Since the current color of Light tile 3 is red, Light tile 3 becomes blue, and the ball moves to Light\ntile 4.  \n（5）Since the current color of Light tile 4 is red, the color of Light tile 4 becomes blue, and the ball\nmoves to Light tile 5.  \n（6）Since the current color of Light tile 5 is red, the color of Light tile 5 becomes blue, and the ball is\nremoved.\n\nAfter the experiment, Light tile 1 is the only light tile whose current color is red. Therefore, output 1.\n\nThis sample satisfies the constraints of subtasks 1, 2, 3, 6, and 7.\n\n**【Sample Explanation #2】**\n\nFor the first experiment, Light tiles 1, 2, 3, 4, 5 are the light tiles whose current colors are red after the experiment. Since there are five such light tiles, output 5.\n\nFor the second experiment, there is no light tile whose current color is red after the experiment. Therefore,\noutput 0.\n\nThis sample satisfies the constraints of subtasks 3, 6, and 7.\n\n**【Sample Explanation #3】**  \n\nThis sample satisfies the constraints of subtasks 1, 2, 3, 6, and 7.  \n\n**【Sample Explanation #4】**  \n\nThis sample satisfies the constraints of subtasks 3, 4, 5, 6, and 7.  \n\n**【Sample Explanation #5】**  \n\nThis sample satisfies the constraints of subtasks 3, 5, 6, and 7.  \n\n**【Sample Explanation #6】**  \n\nThis sample satisfies the constraints of subtasks 6 and 7.\n\n**【Constraints】**\n\nFor all test cases, it is guaranteed that:\n\n- $3 \\leq N \\leq 1.2 \\times 10^5$；\n- $1 \\leq M \\leq 1.2 \\times 10^5$；\n- $C_i \\in \\{\\texttt{B},\\texttt{R}\\}$；\n- $1 \\leq A_j \\leq N$；\n- $1 \\leq Q \\leq 1.2 \\times 10^5$；\n- $1 \\leq L_k \\leq R_k \\leq M$；\n- $N, M, A_j, Q, L_k, R_k$ are all integers。\n\n**【Subtasks】**\n\n**Subtasks are used in this problem**。\n\n1. (3 points) $N,M \\leq 300$，$Q = 1$。\n2. (12 points) $N, M \\leq 7000$，$Q = 1$。\n3. (10 points) $Q \\leq 5$。\n4. (11 points) $N = 10$，$C_i = \\texttt R$。\n5. (26 points) There exists a positive integer $t \\in [0, N]$，is guaranteed that $1 \\leq i \\leq t$，$C_i = \\texttt R$；And $\\forall t < i \\leq N$，$C_i = \\texttt B$。\n6. (17 points) $A_j \\leq 20$ or $A_j > N - 20$。\n7. (21 points) No more constraints。", "locale": "en"}, "zh-CN": {"title": "[JOI 2023 Final] 现代机器 / Modern Machine", "background": null, "description": "Bitaro 收到了一个 JOI 机器作为生日礼物。\n\nJOI 机器由一个球、$N$ 个灯光瓷砖和 $M$ 个按钮组成。灯光瓷砖从 $1$ 到 $N$ 编号。当 Bitaro 打开电源时，灯光瓷砖 $i$ ($1 \\leq i \\leq N$) 会发出颜色为 $C_i$（蓝色（$\\texttt B$）或红色（$\\texttt R$））的光。按钮从 $1$ 到 $M$ 编号。\n\n如果 Bitaro 按下按钮 $j$ ($1 \\leq j \\leq M$)，会发生以下情况。 \n\n1. 球被放置在灯光瓷砖 $A_j$ 上。\n2. 灯光瓷砖 $A_j$ 变为红色（无论其原始颜色如何）。\n3. 在球被移除之前，执行以下操作。 设 $p$ 为球当前所在的灯光瓷砖的索引。\n   - 如果灯光瓷砖 $p$ 是蓝色的，灯光瓷砖 $p$ 变为红色。之后，如果 $p = 1$，球被移除。否则，球移动到灯光瓷砖 $p - 1$。\n   - 如果灯光瓷砖 $p$ 是红色的，灯光瓷砖 $p$ 变为蓝色。之后，如果 $p = N$，球被移除。否则，球移动到灯光瓷砖 $p + 1$。\n\nBitaro 对 JOI 机器很感兴趣。他计划进行 $Q$ 次实验。在第 $k$ 次实验中（$1 \\leq k \\leq Q$），在 Bitaro 打开电源后，Bitaro 按顺序按下按钮 $L_k, L_{k} + 1, \\dots , R_k$。在 Bitaro 按下一个按钮后，他不会按下下一个按钮，并等待球被移除。\n\n给定 JOI 机器的信息和实验，编写一个程序来计算每次实验结束时颜色为红色的灯光瓷砖的数量。", "inputFormat": "从标准输入读取以下数据。 \n\n> $N$ $M$  \n> $C_1\\ C_2 \\dots C_N$  \n> $A_1\\ A_2 \\dots A_M$  \n> $Q$  \n> $L_1\\ R_1$  \n> $L_2\\ R_2$  \n> $\\dots$  \n> $L_Q\\ R_Q$", "outputFormat": "向标准输出写入 $Q$ 行。在第 $k$ 行（$1 \\leq k \\leq Q$），输出应包含第 $k$ 次实验结束时颜色为红色的灯光瓷砖的数量。", "hint": "**【样例解释 #1】**\n\n第一次实验如下进行。 \n1. Bitaro 按下按钮 1，球被放置在灯光瓷砖 4 上。 \n2. 灯光瓷砖 4 变为红色。由于灯光瓷砖 4 的原始颜色是红色，灯光瓷砖 4 的颜色没有改变。 \n3. 之后，执行以下操作。  \n（1）由于灯光瓷砖 4 的当前颜色是红色，灯光瓷砖 4 变为蓝色，球移动到灯光瓷砖 5。  \n（2）由于灯光瓷砖 5 的当前颜色是蓝色，灯光瓷砖 5 变为红色，球移动到灯光瓷砖 4。  \n（3）由于灯光瓷砖 4 的当前颜色是蓝色，灯光瓷砖 4 变为红色，球移动到灯光瓷砖 3。  \n（4）由于灯光瓷砖 3 的当前颜色是红色，灯光瓷砖 3 变为蓝色，球移动到灯光瓷砖 4。  \n（5）由于灯光瓷砖 4 的当前颜色是红色，灯光瓷砖 4 的颜色变为蓝色，球移动到灯光瓷砖 5。  \n（6）由于灯光瓷砖 5 的当前颜色是红色，灯光瓷砖 5 的颜色变为蓝色，球被移除。\n\n实验结束后，灯光瓷砖 1 是唯一一个当前颜色为红色的灯光瓷砖。因此，输出 1。\n\n本样例满足子任务 1,2,3,6,7 的限制。\n\n**【样例解释 #2】**\n\n对于第一次实验，灯光瓷砖 1, 2, 3, 4, 5 是实验结束后当前颜色为红色的灯光瓷砖。由于有五个这样的灯光瓷砖，输出 5。\n\n对于第二次实验，没有灯光瓷砖在实验结束后颜色为红色。因此，输出 0。\n\n本样例满足子任务 3,6,7 的限制。\n\n**【样例解释 #3】**\n\n本样例满足子任务 1,2,3,6,7 的限制。\n\n**【样例解释 #4】**\n\n本样例满足子任务 3,4,5,6,7 的限制。\n\n**【样例解释 #5】**\n\n本样例满足子任务 3,5,6,7 的限制。\n\n**【样例解释 #6】**\n\n本样例满足子任务 6,7 的限制。\n\n**【数据规模】**\n\n对全部的测试点，保证： \n- $3 \\leq N \\leq 1.2 \\times 10^5$；\n- $1 \\leq M \\leq 1.2 \\times 10^5$；\n- $C_i \\in \\{\\texttt{B},\\texttt{R}\\}$； \n- $1 \\leq A_j \\leq N$；\n- $1 \\leq Q \\leq 1.2 \\times 10^5$； \n- $1 \\leq L_k \\leq R_k \\leq M$； \n- $N, M, A_j, Q, L_k, R_k$ 均为整数。\n\n**【子任务】**\n\n**本题采用捆绑测试**。\n\n1. (3 分) $N,M \\leq 300$，$Q = 1$。 \n2. (12 分) $N, M \\leq 7000$，$Q = 1$。 \n3. (10 分) $Q \\leq 5$。 \n4. (11 分) $N = 10$，$C_i = \\texttt R$。 \n5. (26 分) 存在一个整数 $t \\in [0, N]$，满足对 $1 \\leq i \\leq t$，$C_i = \\texttt R$；且对 $t < i \\leq N$，$C_i = \\texttt B$。 \n6. (17 分) $A_j \\leq 20$ 或 $A_j > N - 20$。\n7. (21 分) 无特殊约定。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9354", "type": "P", "difficulty": 1, "samples": [["2\n1100\n11332132121", "11\n28"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「SiR-1」Popsicle", "background": "然而如何优雅地摆烂？", "description": "猫猫有若干个雪糕棒排成一排，每个雪糕棒上有一个 $0\\sim 9$ 的数字，并且满足最左边的雪糕棒上写的数字不为 $0$。猫猫认为这一排雪糕棒从左到右依次构成了十进制正整数 $n$。\n\n猫猫认为 $0$ 是美好的，所以她会尽可能把 $n$ 变成 $0$，也就是把所有雪糕棒都拿走。\n\n猫猫每次会进行一次操作。每次操作选择一个数字非 $0$ 的雪糕棒，并将其减 $1$。这之后，如果最左边有连续的一些数字为 $0$ 的雪糕棒（也即 $n$ 出现了前导 $0$），猫猫会把这些雪糕棒拿走。\n\n小老鼠会来捣乱，它会在某个时刻（可能是所有操作开始之前，也可能是猫猫任意一次操作之后）改变某个雪糕棒上的一个数字。小老鼠**总共只能改变一个数字**。\n\n小老鼠希望操作次数尽量多，猫猫希望操作次数尽量少，所以她想知道二者都使用最优策略时，她的操作次数。", "inputFormat": "**本题单个测试点内有多组数据。**\n\n第一行，一个正整数 $T$ 表示数据组数。对于每组数据：\n\n- 仅一行，一个正整数 $n$。", "outputFormat": "共 $T$ 行，每行一个整数，表示答案。", "hint": "### 样例解释 1\n\n对于第一组数据，小老鼠可以一开始就将 $1100$ 变为 $1109$，这样猫猫共需要 $1 + 1 + 9$ 次操作把 $n$ 变为 $0$。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n+ Subtask 0（13 pts）：$n \\leq 99$。\n+ Subtask 1（13 pts）：$n = 10^k$，$k$ 为自然数。\n+ Subtask 2（13 pts）：$n = 10^k - 1$，$k$ 为正整数。\n+ Subtask 3（13 pts）：$n \\leq 999\\ 999$。\n+ Subtask 4（48 pts）：无特殊限制。\n\n对于所有数据，$1 \\leq T \\leq 3333$，$1 \\leq n \\leq 9\\ 999\\ 999\\ 999\\ 999(=10^{13} - 1)$，毕竟猫猫最多一捆只有 $13$ 根雪糕嘛。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SiR-1」Popsicle", "background": "然而如何优雅地摆烂？", "description": "猫猫有若干个雪糕棒排成一排，每个雪糕棒上有一个 $0\\sim 9$ 的数字，并且满足最左边的雪糕棒上写的数字不为 $0$。猫猫认为这一排雪糕棒从左到右依次构成了十进制正整数 $n$。\n\n猫猫认为 $0$ 是美好的，所以她会尽可能把 $n$ 变成 $0$，也就是把所有雪糕棒都拿走。\n\n猫猫每次会进行一次操作。每次操作选择一个数字非 $0$ 的雪糕棒，并将其减 $1$。这之后，如果最左边有连续的一些数字为 $0$ 的雪糕棒（也即 $n$ 出现了前导 $0$），猫猫会把这些雪糕棒拿走。\n\n小老鼠会来捣乱，它会在某个时刻（可能是所有操作开始之前，也可能是猫猫任意一次操作之后）改变某个雪糕棒上的一个数字。小老鼠**总共只能改变一个数字**。\n\n小老鼠希望操作次数尽量多，猫猫希望操作次数尽量少，所以她想知道二者都使用最优策略时，她的操作次数。", "inputFormat": "**本题单个测试点内有多组数据。**\n\n第一行，一个正整数 $T$ 表示数据组数。对于每组数据：\n\n- 仅一行，一个正整数 $n$。", "outputFormat": "共 $T$ 行，每行一个整数，表示答案。", "hint": "### 样例解释 1\n\n对于第一组数据，小老鼠可以一开始就将 $1100$ 变为 $1109$，这样猫猫共需要 $1 + 1 + 9$ 次操作把 $n$ 变为 $0$。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n+ Subtask 0（13 pts）：$n \\leq 99$。\n+ Subtask 1（13 pts）：$n = 10^k$，$k$ 为自然数。\n+ Subtask 2（13 pts）：$n = 10^k - 1$，$k$ 为正整数。\n+ Subtask 3（13 pts）：$n \\leq 999\\ 999$。\n+ Subtask 4（48 pts）：无特殊限制。\n\n对于所有数据，$1 \\leq T \\leq 3333$，$1 \\leq n \\leq 9\\ 999\\ 999\\ 999\\ 999(=10^{13} - 1)$，毕竟猫猫最多一捆只有 $13$ 根雪糕嘛。", "locale": "zh-CN"}}}
{"pid": "P9355", "type": "P", "difficulty": 2, "samples": [["4\n1 3\n2 2\n3 4\n7 13", "2\n4\n17\n162"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「SiR-1」Checkmate", "background": "这里本来有一串很长的背景，但是出题人觉得它实在太长了，所以就把它删掉了。\n\n「来吧，游戏开始了。」", "description": "有一个 $n$ 行 $m$ 列的棋盘。你要在这个棋盘上的所有格子**依次**放置一个棋子。\n\n每当你放置一个棋子，你将会获得一定的分数，获得的分数为**放置时**你放置的这个棋子旁边的格子中没有放置棋子的格子的个数。这里「旁边」指的是上、下、左、右的相邻格子。\n\n你想知道，在**按照最优策略决策放置棋子的顺序的情况下**，你最终得分总和的最大值。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，包含由空格隔开的两个正整数 $n,m$。", "outputFormat": "对于每组测试数据，输出一行，代表最大的分数。", "hint": "**本题采用捆绑测试。**\n\n- Subtask 1（20 points）：$n, m \\leq 3$，$T \\leq 5$。\n- Subtask 2（20 points）：$n, m \\leq 4$，$T \\leq 10$。\n- Subtask 3（20 points）：$n=1$。\n- Subtask 4（20 points）：$n=m$。\n- Subtask 5（20 points）：无特殊限制。\n\n对于所有测试数据，$1 \\leq n, m \\leq 10^8$，$1 \\leq T \\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SiR-1」Checkmate", "background": "这里本来有一串很长的背景，但是出题人觉得它实在太长了，所以就把它删掉了。\n\n「来吧，游戏开始了。」", "description": "有一个 $n$ 行 $m$ 列的棋盘。你要在这个棋盘上的所有格子**依次**放置一个棋子。\n\n每当你放置一个棋子，你将会获得一定的分数，获得的分数为**放置时**你放置的这个棋子旁边的格子中没有放置棋子的格子的个数。这里「旁边」指的是上、下、左、右的相邻格子。\n\n你想知道，在**按照最优策略决策放置棋子的顺序的情况下**，你最终得分总和的最大值。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，包含由空格隔开的两个正整数 $n,m$。", "outputFormat": "对于每组测试数据，输出一行，代表最大的分数。", "hint": "**本题采用捆绑测试。**\n\n- Subtask 1（20 points）：$n, m \\leq 3$，$T \\leq 5$。\n- Subtask 2（20 points）：$n, m \\leq 4$，$T \\leq 10$。\n- Subtask 3（20 points）：$n=1$。\n- Subtask 4（20 points）：$n=m$。\n- Subtask 5（20 points）：无特殊限制。\n\n对于所有测试数据，$1 \\leq n, m \\leq 10^8$，$1 \\leq T \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P9356", "type": "P", "difficulty": 6, "samples": [["5\n2\n((\n4\n())(\n5\n()(()\n5\n()()(\n15\n()())(())))()()", "4\n11\n16\n12\n241"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "「SiR-1」Bracket", "background": "> Everything that kills me makes me feel alive.", "description": "Mirika 有一个长度为 $n$ 的括号序列 $s$。\n\n对于一个括号序列 $S$，Mirika 可以执行两种操作：\n\n- 变换：选择一个位置 $i$ 满足 $1 \\leq i \\leq \\lvert S \\rvert$，使得 $S$ 变为 $S_iS_{i+1}\\cdots S_{\\lvert S\\rvert}S_1S_2\\cdots S_{i-2}S_{i-1}$。\n- 插入：在这个序列的 **任意位置** 插入一个括号（左右括号均可）。\n\nMirika 定义括号序列 $S$ 的权值 $f(S)$ 为能将这个括号序列变成一个合法括号序列所需的最小操作数。\n\n其中，合法括号序列的定义为：\n\n+ 空串为 合法括号序列。\n+ 若 $\\texttt A$ 为 合法括号序列，则 $\\texttt{(A)}$ 为 合法括号序列。\n+ 若 $\\texttt A, \\texttt B$ 均为 合法括号序列，则 $\\texttt{AB}$ 也为 合法括号序列。\n\n现在 Mirika 想要求出：\n\n$\\sum_{l=1}^n \\sum_{r=l}^n f(s[l,r])$\n\n其中 $s[l,r]$ 表示由 $s_l,s_{l+1},\\cdots,s_r$ 形成的连续子序列。\n\n但是 Mirika 太菜了不会算，于是只好求助于你。", "inputFormat": "**本题每个测试点内有多组数据。**\n\n第一行一个正整数 $T$ 表示测试数据组数。\n\n对于每组数据，第一行一个正整数 $n$。\n\n第二行一个长度为 $n$ 的括号序列 $s$。", "outputFormat": "输出共 $T$ 行，第 $i$ 行一个整数表示第 $i$ 组测试数据的答案。", "hint": "### 样例解释\n\n对于 $s = \\texttt{())(}$：\n\n+ 考虑 $s[1,4]=\\texttt{())(}$。执行变换操作 $i=4$，有 $\\texttt{())(} \\Rightarrow \\texttt{(())}$，其中 $\\texttt{(())}$ 是合法括号序列，故 $f(s[1, 4]) = 1$。可以证明不存在更优的策略。\n+ 考虑 $s[2,4]=\\texttt{))(}$。执行变换操作 $i=2$，再在序列开头插入一个左括号，有 $\\texttt{))(} \\Rightarrow \\texttt{)()} \\Rightarrow \\texttt{()()}$，其中 $\\texttt{()()}$ 是合法括号序列，故 $f(s[2, 4]) = 2$。可以证明不存在更优的策略。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n+ Subtask 0（15 pts）：$n \\leq 400$，$\\sum n \\leq 800$。\n+ Subtask 1（20 pts）：$n \\leq 2\\times 10^3$，$\\sum n \\leq 4\\times 10^3$。\n+ Subtask 2（5 pts）：$s$ 内不含有右括号。\n+ Subtask 3（10 pts）：对于所有整数 $1\\le i < n$，有 $s_i \\neq s_{i+1}$。\n+ Subtask 4（30 pts）：$n \\leq 2\\times 10^5$，$\\sum n \\leq 5\\times 10^5$。\n+ Subtask 5（20 pts）：无特殊限制。\n\n对于所有数据，$1 \\leq T \\leq 10000$，$1 \\leq n \\leq 2 \\times 10^6$，$1 \\leq \\sum n \\leq 2 \\times 10^7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SiR-1」Bracket", "background": "> Everything that kills me makes me feel alive.", "description": "Mirika 有一个长度为 $n$ 的括号序列 $s$。\n\n对于一个括号序列 $S$，Mirika 可以执行两种操作：\n\n- 变换：选择一个位置 $i$ 满足 $1 \\leq i \\leq \\lvert S \\rvert$，使得 $S$ 变为 $S_iS_{i+1}\\cdots S_{\\lvert S\\rvert}S_1S_2\\cdots S_{i-2}S_{i-1}$。\n- 插入：在这个序列的 **任意位置** 插入一个括号（左右括号均可）。\n\nMirika 定义括号序列 $S$ 的权值 $f(S)$ 为能将这个括号序列变成一个合法括号序列所需的最小操作数。\n\n其中，合法括号序列的定义为：\n\n+ 空串为 合法括号序列。\n+ 若 $\\texttt A$ 为 合法括号序列，则 $\\texttt{(A)}$ 为 合法括号序列。\n+ 若 $\\texttt A, \\texttt B$ 均为 合法括号序列，则 $\\texttt{AB}$ 也为 合法括号序列。\n\n现在 Mirika 想要求出：\n\n$\\sum_{l=1}^n \\sum_{r=l}^n f(s[l,r])$\n\n其中 $s[l,r]$ 表示由 $s_l,s_{l+1},\\cdots,s_r$ 形成的连续子序列。\n\n但是 Mirika 太菜了不会算，于是只好求助于你。", "inputFormat": "**本题每个测试点内有多组数据。**\n\n第一行一个正整数 $T$ 表示测试数据组数。\n\n对于每组数据，第一行一个正整数 $n$。\n\n第二行一个长度为 $n$ 的括号序列 $s$。", "outputFormat": "输出共 $T$ 行，第 $i$ 行一个整数表示第 $i$ 组测试数据的答案。", "hint": "### 样例解释\n\n对于 $s = \\texttt{())(}$：\n\n+ 考虑 $s[1,4]=\\texttt{())(}$。执行变换操作 $i=4$，有 $\\texttt{())(} \\Rightarrow \\texttt{(())}$，其中 $\\texttt{(())}$ 是合法括号序列，故 $f(s[1, 4]) = 1$。可以证明不存在更优的策略。\n+ 考虑 $s[2,4]=\\texttt{))(}$。执行变换操作 $i=2$，再在序列开头插入一个左括号，有 $\\texttt{))(} \\Rightarrow \\texttt{)()} \\Rightarrow \\texttt{()()}$，其中 $\\texttt{()()}$ 是合法括号序列，故 $f(s[2, 4]) = 2$。可以证明不存在更优的策略。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n+ Subtask 0（15 pts）：$n \\leq 400$，$\\sum n \\leq 800$。\n+ Subtask 1（20 pts）：$n \\leq 2\\times 10^3$，$\\sum n \\leq 4\\times 10^3$。\n+ Subtask 2（5 pts）：$s$ 内不含有右括号。\n+ Subtask 3（10 pts）：对于所有整数 $1\\le i < n$，有 $s_i \\neq s_{i+1}$。\n+ Subtask 4（30 pts）：$n \\leq 2\\times 10^5$，$\\sum n \\leq 5\\times 10^5$。\n+ Subtask 5（20 pts）：无特殊限制。\n\n对于所有数据，$1 \\leq T \\leq 10000$，$1 \\leq n \\leq 2 \\times 10^6$，$1 \\leq \\sum n \\leq 2 \\times 10^7$。", "locale": "zh-CN"}}}
