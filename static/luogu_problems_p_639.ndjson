{"pid": "P13956", "type": "P", "difficulty": 4, "samples": [["3\n3 6\n3 3 1 5\n2 5 3\n2 2 6\n2 3\n3 1 3 2\n2 3 1\n1 3\n2 2 1", "Yes\n3 1 2\nNo\nNo"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2023", "Special Judge", "拓扑排序", "ICPC", "南京"], "title": "[ICPC 2023 Nanjing R] 等价重写", "background": "", "description": "有一个长度为 $m$ 的序列 $A$，所有元素均为 $0$。接下来我们将依次对 $A$ 执行 $n$ 个操作。第 $i$ 个操作可记为 $p_i$ 个不同的整数 $b_{i, 1}, b_{i, 2}, \\cdots, b_{i, p_i}$，表示对于所有 $1 \\le j \\le p_i$，我们将把序列中第 $b_{i, j}$ 个元素的值改为 $i$。令 $R$ 表示所有操作后的结果序列。\n\n我们现在要求您重新排列这些操作，但保持最终的结果不变。更正式地，令 $q_1, q_2, \\cdots, q_n$ 表示一个 $n$ 的排列，且与 $1, 2, \\cdots, n$ 不同。您将会依次对序列 $A$ 执行第 $q_1$，$q_2$，...，$q_n$ 个操作，最终的结果序列必须和 $R$ 相同。您的任务就是找到这样的排列，或表明其不存在。\n\n请回忆：一个 $n$ 的排列是一个长度为 $n$ 的序列，每个从 $1$ 到 $n$（含两端）的整数在其中都恰好出现一次。令 $x_1, x_2, \\cdots, x_n$ 和 $y_1, y_2, \\cdots, y_n$ 为两个 $n$ 的排列，我们称它们是不同的，若存在整数 $k$ 满足 $1 \\le k \\le n$ 且 $x_k \\ne y_k$。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 10^5$）表示操作的数量和序列的长度。\n\n对于接下来 $n$ 行，第 $i$ 行首先输入一个整数 $p_i$（$1 \\le p_i \\le m$）表示第 $i$ 个操作修改的元素数量。接下来输入 $p_i$ 个不同的整数 $b_{i,1}, b_{i,2}, \\cdots, b_{i,p_i}$（$1 \\le b_{i,j} \\le m$）表示被修改的元素下标。\n\n保证所有数据 $(n + m)$ 之和不超过 $2 \\times 10^6$，且所有数据 $p_i$ 之和不超过 $10^6$。", "outputFormat": "对于每组测试数据：\n\n如果存在所求的排列，首先输出一行 $\\texttt{Yes}$。接下来在第二行输出 $n$ 个由单个空格分隔的整数 $q_1, q_2, \\cdots, q_n$ 表示答案。如果有多种合法答案，您可以输出任意一种。\n\n如果不存在所求的排列，仅需输出一行 $\\texttt{No}$。\n\n请不要在行末输出多余空格，否则您的答案可能会被认为是错误的！", "hint": "对于第一组样例数据，按 $\\{1, 2, 3\\}$ 或 $\\{3, 1, 2\\}$ 的顺序执行操作，结果序列均为 $\\{1, 3, 2, 0, 2, 3\\}$。", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Equivalent Rewriting", "background": "", "description": "There is a sequence $A$ of length $m$ where all elements equal to $0$. We will then execute $n$ operations on $A$ in order. The $i$-th operation can be denoted as $p_i$ distinct integers $b_{i, 1}, b_{i, 2}, \\cdots, b_{i, p_i}$, indicating that we'll change the value of the $b_{i, j}$-th element in the sequence to $i$ for all $1 \\le j \\le p_i$. Let $R$ be the resulting sequence after all operations.\n\nWe now require you to rearrange the operations but still produce the same result. More formally, let $q_1, q_2, \\cdots, q_n$ be a permutation of $n$ that differs from $1, 2, \\cdots, n$. You'll execute the $q_1$-th, $q_2$-th, ..., $q_n$-th operation on sequence $A$ in order, and the final resulting sequence must equal to $R$. Your task is to find such permutation or state that it does not exist.\n\nRecall that a permutation of $n$ is a sequence of length $n$ in which each integer from $1$ to $n$ (both inclusive) appears exactly once. Let $x_1, x_2, \\cdots, x_n$ and $y_1, y_2, \\cdots, y_n$ be two permutations of $n$. We say they're different if there exists an integer $k$ such that $1 \\le k \\le n$ and $x_k \\ne y_k$.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of\ntest cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 10^5$) indicating the number of operations and the length of the sequence.\n\nFor the following $n$ lines, the $i$-th line first contains an integer $p_i$ ($1 \\le p_i \\le m$) indicating the number of elements changed by the $i$-th operation. Then $p_i$ distinct integers $b_{i,1}, b_{i,2}, \\cdots, b_{i,p_i}$ follow ($1 \\le b_{i,j} \\le m$) indicating the index of the elements to be changed.\n\nIt is guaranteed that the sum of $(n + m)$ of all test cases will not exceed $2 \\times 10^6$, and the sum of $p_i$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case, if such permutation exists, first output $\\texttt{Yes}$ in one line. Then output $n$ integers $q_1, q_2, \\cdots, q_n$ separated by a space in the second line indicating the answer. If there are multiple valid answers, you can output any of them.\n\nIf there is no such permutation, simply output $\\texttt{No}$ in one line.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": "For the first sample test case, by executing the operations in either order of $\\{1, 2, 3\\}$ or $\\{3, 1, 2\\}$ yields the same resulting sequence $\\{1, 3, 2, 0, 2, 3\\}$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 等价重写", "background": "", "description": "有一个长度为 $m$ 的序列 $A$，所有元素均为 $0$。接下来我们将依次对 $A$ 执行 $n$ 个操作。第 $i$ 个操作可记为 $p_i$ 个不同的整数 $b_{i, 1}, b_{i, 2}, \\cdots, b_{i, p_i}$，表示对于所有 $1 \\le j \\le p_i$，我们将把序列中第 $b_{i, j}$ 个元素的值改为 $i$。令 $R$ 表示所有操作后的结果序列。\n\n我们现在要求您重新排列这些操作，但保持最终的结果不变。更正式地，令 $q_1, q_2, \\cdots, q_n$ 表示一个 $n$ 的排列，且与 $1, 2, \\cdots, n$ 不同。您将会依次对序列 $A$ 执行第 $q_1$，$q_2$，...，$q_n$ 个操作，最终的结果序列必须和 $R$ 相同。您的任务就是找到这样的排列，或表明其不存在。\n\n请回忆：一个 $n$ 的排列是一个长度为 $n$ 的序列，每个从 $1$ 到 $n$（含两端）的整数在其中都恰好出现一次。令 $x_1, x_2, \\cdots, x_n$ 和 $y_1, y_2, \\cdots, y_n$ 为两个 $n$ 的排列，我们称它们是不同的，若存在整数 $k$ 满足 $1 \\le k \\le n$ 且 $x_k \\ne y_k$。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 10^5$）表示操作的数量和序列的长度。\n\n对于接下来 $n$ 行，第 $i$ 行首先输入一个整数 $p_i$（$1 \\le p_i \\le m$）表示第 $i$ 个操作修改的元素数量。接下来输入 $p_i$ 个不同的整数 $b_{i,1}, b_{i,2}, \\cdots, b_{i,p_i}$（$1 \\le b_{i,j} \\le m$）表示被修改的元素下标。\n\n保证所有数据 $(n + m)$ 之和不超过 $2 \\times 10^6$，且所有数据 $p_i$ 之和不超过 $10^6$。", "outputFormat": "对于每组测试数据：\n\n如果存在所求的排列，首先输出一行 $\\texttt{Yes}$。接下来在第二行输出 $n$ 个由单个空格分隔的整数 $q_1, q_2, \\cdots, q_n$ 表示答案。如果有多种合法答案，您可以输出任意一种。\n\n如果不存在所求的排列，仅需输出一行 $\\texttt{No}$。\n\n请不要在行末输出多余空格，否则您的答案可能会被认为是错误的！", "hint": "对于第一组样例数据，按 $\\{1, 2, 3\\}$ 或 $\\{3, 1, 2\\}$ 的顺序执行操作，结果序列均为 $\\{1, 3, 2, 0, 2, 3\\}$。", "locale": "zh-CN"}}}
{"pid": "P13957", "type": "P", "difficulty": 4, "samples": [["4 10 1\n9 10\n10 1\n3 5\n5 20", "35"], ["5 13 2\n5 16\n5 28\n7 44\n8 15\n8 41", "129"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2023", "背包 DP", "ICPC", "南京"], "title": "[ICPC 2023 Nanjing R] 背包", "background": "", "description": "小青鱼，一位没有经验的商人，最近开了一家名叫“皇后有机珠宝”（QOJ）的店。这家珠宝店共有 $n$ 枚宝石，其中第 $i$ 枚售价为 $w_i$ 元，美丽度为 $v_i$。进入商店之前，您准备了 $W$ 元用来买下美丽度总和尽量高的宝石。\n\n有趣的是，小青鱼的店今天正在促销。任何顾客都可以任选 $k$ 枚宝石并免费获得它们。有了这样的机会，您很想知道，如果您使用最佳策略，用 $W$ 元到底能获得美丽度总和多高的宝石。\n\n请注意，每枚宝石独此一份，您不能多次获取同一枚宝石。另外，您无需花完所有的钱。", "inputFormat": "每个测试文件仅有一组测试数据。\n\n第一行输入三个整数 $n$，$W$ 和 $k$（$1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq W \\leq 10^4$，$0 \\leq k \\leq n$），表示商店中宝石的总数，您拥有的金钱数以及您可以免费获得的宝石数量。\n\n对于接下来 $n$ 行，第 $i$ 行输入两个整数 $w_i$ 和 $v_i$（$1 \\leq w_i \\leq W$，$1 \\leq v_i \\leq 10^9$），表示第 $i$ 枚宝石的售价和美丽度。", "outputFormat": "输出一行一个整数表示答案。", "hint": "对于第一组样例数据，小青鱼的商店有 $4$ 枚宝石，您可以免费获得其中 $1$ 枚。一种最优策略是免费获取第一枚宝石，并购买第三和第四枚宝石。\n\n$$\\begin{array}{ | c | c | c | c | } \\hline\n    \\bf{宝石} &\n    \\bf{售价 w_i} &\n    \\bf{美丽度 v_i} &\n    \\bf{操作} \\\\ \\hline\n    1 & 9 & 10 & 免费获取 \\\\ \\hline\n    2 & 10 & 1 & / \\\\ \\hline\n    3 & 3 & 5 & 购买 \\\\ \\hline\n    4 & 5 & 20 & 购买 \\\\ \\hline\n  \\end{array}$$\n  \n所以答案是 $10 + 5 + 20 = 35$。", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Knapsack", "background": "", "description": "Little Cyan Fish, an inexperienced businessman, recently launched a store named $\\textit{Queen's Organic Jewelry}$. This jewelry store houses $n$ gemstones, where the $i$-th gemstone is priced at $w_i$ dollar and has a beauty of $v_i$. Prior to visiting the store, you have $W$ dollars in hand, which you plan to use to purchase gemstones of the greatest possible total beauty.\n\nInterestingly, Little Cyan Fish's store is running a promotion today. Any visitor to the store can select any $k$ gemstones and take them home absolutely free of charge! With this opportunity at hand, you're keen to know the maximum total beauty of gemstones you could obtain with your $W$ dollars, assuming you adopt the optimal strategy.\n\nPlease bear in mind that the store stocks only one unit of each gemstone, so you cannot obtain the same gemstone more than once. Also note that you don't have to spend all the money.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains three integers $n$, $W$ and $k$ ($1 \\leq n \\leq 5 \\times 10^3$, $1 \\leq W \\leq 10^4$, $0 \\leq k \\leq n$), indicating the total number of gemstones in the store, the amount of money you have and the number of gemstones you can take for free.\n\nFor the following $n$ lines, the $i$-th line contains two integers $w_i$ and $v_i$ ($1 \\leq w_i \\leq W$, $1 \\leq v_i \\leq 10^9$), indicating the price and the beauty of the $i$-th gemstone.", "outputFormat": "Output one line containing one integer indicating the answer.", "hint": "In the first example, Little Cyan Fish's shop holds $4$ gemstones and you are permitted to take $1$ gemstone for free. One optimal strategy involves taking the first gemstone for free, and purchasing the third and fourth gemstones.\n\n$$\\begin{array}{ | c | c | c | c | } \\hline\n    \\bf{Gemstone} &\n    \\bf{Price\\ w_i} &\n    \\bf{Beauty\\ v_i} &\n    \\bf{Action} \\\\ \\hline\n    1 & 9 & 10 & \\text{Take for free} \\\\ \\hline\n    2 & 10 & 1 & / \\\\ \\hline\n    3 & 3 & 5 & \\text{Purchase} \\\\ \\hline\n    4 & 5 & 20 & \\text{Purchase} \\\\ \\hline\n  \\end{array}$$", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 背包", "background": "", "description": "小青鱼，一位没有经验的商人，最近开了一家名叫“皇后有机珠宝”（QOJ）的店。这家珠宝店共有 $n$ 枚宝石，其中第 $i$ 枚售价为 $w_i$ 元，美丽度为 $v_i$。进入商店之前，您准备了 $W$ 元用来买下美丽度总和尽量高的宝石。\n\n有趣的是，小青鱼的店今天正在促销。任何顾客都可以任选 $k$ 枚宝石并免费获得它们。有了这样的机会，您很想知道，如果您使用最佳策略，用 $W$ 元到底能获得美丽度总和多高的宝石。\n\n请注意，每枚宝石独此一份，您不能多次获取同一枚宝石。另外，您无需花完所有的钱。", "inputFormat": "每个测试文件仅有一组测试数据。\n\n第一行输入三个整数 $n$，$W$ 和 $k$（$1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq W \\leq 10^4$，$0 \\leq k \\leq n$），表示商店中宝石的总数，您拥有的金钱数以及您可以免费获得的宝石数量。\n\n对于接下来 $n$ 行，第 $i$ 行输入两个整数 $w_i$ 和 $v_i$（$1 \\leq w_i \\leq W$，$1 \\leq v_i \\leq 10^9$），表示第 $i$ 枚宝石的售价和美丽度。", "outputFormat": "输出一行一个整数表示答案。", "hint": "对于第一组样例数据，小青鱼的商店有 $4$ 枚宝石，您可以免费获得其中 $1$ 枚。一种最优策略是免费获取第一枚宝石，并购买第三和第四枚宝石。\n\n$$\\begin{array}{ | c | c | c | c | } \\hline\n    \\bf{宝石} &\n    \\bf{售价 w_i} &\n    \\bf{美丽度 v_i} &\n    \\bf{操作} \\\\ \\hline\n    1 & 9 & 10 & 免费获取 \\\\ \\hline\n    2 & 10 & 1 & / \\\\ \\hline\n    3 & 3 & 5 & 购买 \\\\ \\hline\n    4 & 5 & 20 & 购买 \\\\ \\hline\n  \\end{array}$$\n  \n所以答案是 $10 + 5 + 20 = 35$。", "locale": "zh-CN"}}}
{"pid": "P13958", "type": "P", "difficulty": 7, "samples": [["2\n3\n4", "2\n0 1 1\n2 2 1\n2 1 2\n4\n1 1 2 2\n1 2 3 2\n4 1 4 3\n4 4 3 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "构造", "ICPC", "南京"], "title": "[ICPC 2023 Nanjing R] 谜题：问号", "background": "", "description": "星绘是一位谜题大师。今天，她正在玩一款名叫“问号填充”的谜题。谜题由一个 $n$ 行 $n$ 列的网格，以及许多问号拼图（QM 拼图）组成。一片 QM 拼图占据 $4$ 个格子，如下图所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/vh1gvat2.png)\n\n一片 QM 拼图（它看起来像一个问号，应该吧？）\n:::\n\n整片 QM 拼图必须全部位于网格内部，拼图可以旋转 $90$ 度的倍数或翻面。更精确地，共有 $8$ 种 QM 拼图，如下图所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/if4bnscx.png)\n:::\n\n任意两片 QM 拼图不能占据同一个格子。谜题的目标是在 $n \\times n$ 的网格中放入尽可能多的 QM 拼图。\n\n星绘想知道您能否成功解开谜题。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\leq n \\leq 2 \\times 10^3$）表示网格的大小。\n\n保证所有数据 $n^2$ 之和不超过 $5 \\times 10^6$。", "outputFormat": "对于每组数据：\n\n首先输出一行一个整数表示最多能在网格中放入几片 QM 拼图。\n\n接下来输出 $n$ 行。每一行包含由单个空格分隔的 $n$ 个整数。第 $i$ 行的第 $j$ 个整数 $a_{i,j}$ 表示位于第 $i$ 行第 $j$ 列的格子属于第 $a_{i,j}$ 片 QM 拼图。如果 $a_{i,j}$ 为 $0$，则这个格子是空的，不属于任何 QM 拼图。\n\n如果有多种合法答案，输出任意一种。\n\n请不要在行末输出多余空格，否则您的答案可能会被认为是错误的！", "hint": "样例数据解释如下。\n\n:::align{center}\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/al14eixb.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aee8unei.png)\n:::", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Puzzle: Question Mark", "background": "", "description": "XingHui is a puzzle master. Today, she is playing a puzzle called $\\textit{Filling with Question Marks}$. The puzzle contains a grid of $n$ rows and $n$ columns, and a handful of $\\textit{question mark}$ pieces (QM pieces). A QM piece occupies $4$ cells, as shown in the following figure.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/vh1gvat2.png)\n\nA QM piece (It looks like a question mark, I suppose?)\n:::\n\nQM pieces must be placed entirely inside the grid and pieces can be rotated by a multiple of $90$ degrees and/or flipped. More precisely, there are $8$ types of QM pieces, as shown below.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/if4bnscx.png)\n:::\n\nAny two QM pieces cannot occupy the same cell. The goal of the puzzle is to find a way to place the maximum number of QM pieces on the $n \\times n$ grid.\n\nXingHui wonders if you could solve the puzzle successfully.", "inputFormat": "There are multiple test cases. The first line of the input contains a single integer $T$ indicating the number of test cases. For each test case:\n\nThe first and only line contains one integer $n$ ($1 \\leq n \\leq 2 \\times 10^3$) indicating the size of the grid.\n\nIt is guaranteed that the sum of $n^2$ of all test cases will not exceed $5 \\times 10^6$.", "outputFormat": "For each test case:\n\nFirst output one line containing one integer indicating the maximum number of QM pieces placed on the grid.\n\nThen output $n$ lines. Each of these lines contains $n$ integers separated by a space. The $j$-th integer of the $i$-th line $a_{i,j}$ indicates that the cell on the $i$-th row and $j$-th column belongs to the $a_{i,j}$-th QM piece. If $a_{i,j}$ is $0$, it indicates that the corresponding cell is empty and does not belong to any QM piece.\n\nIf there are multiple solutions, output any of them.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": "The sample test cases are shown below.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/al14eixb.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aee8unei.png)\n:::", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 谜题：问号", "background": "", "description": "星绘是一位谜题大师。今天，她正在玩一款名叫“问号填充”的谜题。谜题由一个 $n$ 行 $n$ 列的网格，以及许多问号拼图（QM 拼图）组成。一片 QM 拼图占据 $4$ 个格子，如下图所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/vh1gvat2.png)\n\n一片 QM 拼图（它看起来像一个问号，应该吧？）\n:::\n\n整片 QM 拼图必须全部位于网格内部，拼图可以旋转 $90$ 度的倍数或翻面。更精确地，共有 $8$ 种 QM 拼图，如下图所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/if4bnscx.png)\n:::\n\n任意两片 QM 拼图不能占据同一个格子。谜题的目标是在 $n \\times n$ 的网格中放入尽可能多的 QM 拼图。\n\n星绘想知道您能否成功解开谜题。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\leq n \\leq 2 \\times 10^3$）表示网格的大小。\n\n保证所有数据 $n^2$ 之和不超过 $5 \\times 10^6$。", "outputFormat": "对于每组数据：\n\n首先输出一行一个整数表示最多能在网格中放入几片 QM 拼图。\n\n接下来输出 $n$ 行。每一行包含由单个空格分隔的 $n$ 个整数。第 $i$ 行的第 $j$ 个整数 $a_{i,j}$ 表示位于第 $i$ 行第 $j$ 列的格子属于第 $a_{i,j}$ 片 QM 拼图。如果 $a_{i,j}$ 为 $0$，则这个格子是空的，不属于任何 QM 拼图。\n\n如果有多种合法答案，输出任意一种。\n\n请不要在行末输出多余空格，否则您的答案可能会被认为是错误的！", "hint": "样例数据解释如下。\n\n:::align{center}\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/al14eixb.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aee8unei.png)\n:::", "locale": "zh-CN"}}}
{"pid": "P13959", "type": "P", "difficulty": 2, "samples": [["3\n7 4\n4 0\n2 2\n7 1\n5 1\n3 2\n2 2\n3 1\n3 1\n3 100", "Yes\nNo\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2023", "排序", "ICPC", "南京"], "title": "[ICPC 2023 Nanjing R] 计数器", "background": "", "description": "有一个计数器上有两个按钮，按下 `+` 按钮会让计数器的值增加 $1$，按下 `c` 按钮会让计数器的值变成 $0$。计数器一开始的值为 $0$。\n\n某人对计数器进行了 $n$ 次操作，每次操作是按下两个按钮中的某一个。给定 $m$ 条已知信息，其中第 $i$ 条已知信息可以用两个整数 $a_i$ 和 $b_i$ 描述，表示第 $a_i$ 次操作后，计数器的值为 $b_i$。\n\n问是否存在一种操作方式满足所有已知条件。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\le n \\le 10^9$，$1 \\le m \\le 10^5$）表示操作总数和已知信息总数。\n\n对于接下来 $m$ 行，第 $i$ 行输入两个整数 $a_i$ 和 $b_i$（$1 \\le a_i \\le n$，$0 \\le b_i \\le 10^9$）表示已知第 $a_i$ 次操作后，计数器的值为 $b_i$。\n\n保证所有数据 $m$ 之和不超过 $5 \\times 10^5$。", "outputFormat": "每组数据输出一行。若存在一种操作方式满足所有已知条件输出 $\\texttt{Yes}$，否则输出 $\\texttt{No}$。", "hint": "对于第一组样例数据，按 `++cc+c+` 的顺序按下按钮即可满足所有已知条件。\n\n对于第二组样例数据，按下 $3$ 次按钮共有 $8$ 种方式，如下表所述。\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|}\n\\hline\n\\textbf{操作方式} & \\textbf{第 2 次操作结果} & \\textbf{第 3 次操作结果} & & \\textbf{操作方式} & \\textbf{第 2 次操作结果} & \\textbf{第 3 次操作结果} \\\\\n\\hline\nccc & 0 & 0 & & +cc & 0 & 0 \\\\\n\\hline\ncc+ & 0 & 1 & & +c+ & 0 & 1 \\\\\n\\hline\nc+c & 1 & 0 & & ++c & 2 & 0 \\\\\n\\hline\nc++ & 1 & 2 & & +++ & 2 & 3 \\\\\n\\hline\n\\end{array}$$\n\n没有任何操作方式满足所有已知条件。\n\n对于第三组样例数据，按下 $3$ 次按钮最多让计数器的值变成 $3$，不可能变成 $100$。", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Counter", "background": "", "description": "There is a counter with two buttons. Pressing the ``+`` button will increase the value on the counter by $1$ and pressing the ``c`` button will set the value on the counter to $0$. The initial value on the counter is $0$.\n\nSomeone has performed $n$ operations on the counter. Each operation is to press one of the two buttons. There are $m$ known conditions where the $i$-th condition can be described as two integers $a_i$ and $b_i$, indicating that after the $a_i$-th operation the value on the counter is $b_i$.\n\nIs there a way to press the buttons so that all known conditions are satisfied?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 10^9$, $1 \\le m \\le 10^5$) indicating the number of operations and the number of known conditions.\n\nFor the following $m$ lines, the $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i \\le n$, $0 \\le b_i \\le 10^9$) indicating that after the $a_i$-th operation the value on the counter is $b_i$.\n\nIt's guaranteed that the sum of $m$ of all test cases will not exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line. If there exists a way to press the buttons so that all known conditions are satisfied, output $\\texttt{Yes}$. Otherwise output $\\texttt{No}$.", "hint": "For the first sample test case, pressing buttons in the order of ``++cc+c+`` can satisfy all known conditions.\n\nFor the second sample test case, there are $8$ ways to press the buttons $3$ times.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|}\n\\hline\n\\textbf{Presses} & \\textbf{$2$-nd Op. Result} & \\textbf{$3$-rd Op. Result} & & \\textbf{Presses} & \\textbf{$2$-nd Op. Result} & \\textbf{$3$-rd Op. Result} \\\\\n\\hline\nccc & 0 & 0 & & +cc & 0 & 0 \\\\\n\\hline\ncc+ & 0 & 1 & & +c+ & 0 & 1 \\\\\n\\hline\nc+c & 1 & 0 & & ++c & 2 & 0 \\\\\n\\hline\nc++ & 1 & 2 & & +++ & 2 & 3 \\\\\n\\hline\n\\end{array}$$\n\nThere is no way to satisfy all known conditions.\n\nFor the third sample test case, pressing the buttons $3$ times can only make the value on the counter at most $3$. It can't be $100$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 计数器", "background": "", "description": "有一个计数器上有两个按钮，按下 `+` 按钮会让计数器的值增加 $1$，按下 `c` 按钮会让计数器的值变成 $0$。计数器一开始的值为 $0$。\n\n某人对计数器进行了 $n$ 次操作，每次操作是按下两个按钮中的某一个。给定 $m$ 条已知信息，其中第 $i$ 条已知信息可以用两个整数 $a_i$ 和 $b_i$ 描述，表示第 $a_i$ 次操作后，计数器的值为 $b_i$。\n\n问是否存在一种操作方式满足所有已知条件。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\le n \\le 10^9$，$1 \\le m \\le 10^5$）表示操作总数和已知信息总数。\n\n对于接下来 $m$ 行，第 $i$ 行输入两个整数 $a_i$ 和 $b_i$（$1 \\le a_i \\le n$，$0 \\le b_i \\le 10^9$）表示已知第 $a_i$ 次操作后，计数器的值为 $b_i$。\n\n保证所有数据 $m$ 之和不超过 $5 \\times 10^5$。", "outputFormat": "每组数据输出一行。若存在一种操作方式满足所有已知条件输出 $\\texttt{Yes}$，否则输出 $\\texttt{No}$。", "hint": "对于第一组样例数据，按 `++cc+c+` 的顺序按下按钮即可满足所有已知条件。\n\n对于第二组样例数据，按下 $3$ 次按钮共有 $8$ 种方式，如下表所述。\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|}\n\\hline\n\\textbf{操作方式} & \\textbf{第 2 次操作结果} & \\textbf{第 3 次操作结果} & & \\textbf{操作方式} & \\textbf{第 2 次操作结果} & \\textbf{第 3 次操作结果} \\\\\n\\hline\nccc & 0 & 0 & & +cc & 0 & 0 \\\\\n\\hline\ncc+ & 0 & 1 & & +c+ & 0 & 1 \\\\\n\\hline\nc+c & 1 & 0 & & ++c & 2 & 0 \\\\\n\\hline\nc++ & 1 & 2 & & +++ & 2 & 3 \\\\\n\\hline\n\\end{array}$$\n\n没有任何操作方式满足所有已知条件。\n\n对于第三组样例数据，按下 $3$ 次按钮最多让计数器的值变成 $3$，不可能变成 $100$。", "locale": "zh-CN"}}}
{"pid": "P13960", "type": "P", "difficulty": 7, "samples": [["2\n11 3\n0 1 2 0 4 5 4 6 0 9 10\n1 3 2 2 1 3 4 1 3 2 1\n3 2 4\n5 16\n0 0 0 1 4\n1 2 3 2 2\n2 1 3 3 2 1 3 2 1 3 2 2 1 1 2 1", "17 26 22\n8 5 5 5 5 5 5 5 5 5 5 5 5 5 10 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC", "南京"], "title": "[ICPC 2023 Nanjing R] 后缀结构", "background": "", "description": "给定字符串 $u = u_1 \\dots u_n$，令 $\\mathrm{pre}(u, i)$ 表示前缀 $u_1 \\dots u_i$。特别地，$\\mathrm{pre}(u, 0)$ 是空字符串。\n\n对于两个字符串 $u = u_1 \\dots u_n$ 与 $v = v_1 \\dots v_m$，令 $u+v$ 表示连接后的字符串 $u_1 \\dots u_n v_1 \\dots v_m$。\n\n给定长度为 $m$ 的字符串 $t=t_1 \\dots t_m$ 和一棵有 $(n + 1)$ 个节点的树 $T$，节点编号为 $0, 1, \\dots, n$，其中节点 $0$ 是根。每条边上都有一个字符。请注意，在本题中，字母表中可能会有多于 $26$ 个字符。\n\n考虑如下函数 $$f(i,j) = \\max\\{d(x) \\mid s_x\\text{ 是 }s_i+ \\mathrm{pre}(t,j)\\text{ 的后缀}\\}$$ 其中 $s_i$ 是从根到节点 $i$ 的最短路径上所有字符连接而成的字符串，$d(i)$ 是从根到节点 $i$ 的最短路径经过的边数。\n\n您需要计算 $g_1, g_2, \\dots, g_m$，其中 $g_j=\\sum\\limits_{i=1}^{n} f(i,j)$。\n\n请注意，$s_0$ 是空字符串，空字符串是任何字符串的后缀。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\le n, m \\le 2 \\times 10^5$）。\n\n第二行输入 $n$ 个整数 $p_1, p_2, \\dots, p_n$（$0 \\le p_i < i$），其中 $p_i$ 表示节点 $i$ 的父节点。\n\n第三行输入 $n$ 个整数 $c_1, c_2, \\dots, c_n$（$1 \\le c_i \\le n$），其中 $c_i$ 表示从节点 $p_i$ 到节点 $i$ 的边上的字符是字母表中第 $c_i$ 个字符。保证对于所有 $i \\ne j$，有 $p_i \\ne p_j$ 或 $c_i \\ne c_j$。\n\n第四行输入 $m$ 个整数 $t_1, t_2, \\dots, t_m$（$1 \\le t_i \\le n$），其中 $t_i$ 是字符串 $t$ 中的第 $i$ 个字符。\n\n保证所有数据 $n$ 之和与 $m$ 之和均不超过 $2 \\times 10^5$。", "outputFormat": "每组数据输出一行 $m$ 个由单个空格分隔的整数 $g_1, g_2, \\dots, g_m$。\n\n请不要在行末输出多余空格，否则您的答案可能会被认为是错误的！", "hint": "我们来计算第一组样例数据中的 $f(11, 1)$ 和 $f(11, 2)$ 以便您更好地理解。有 $s_{11} = \\{3, 2, 1\\}$，所以 $s_{11} + \\text{pre}(t, 1) = \\{3, 2, 1, 3\\}$。因为 $s_6 = \\{2, 1, 3\\}$ 是该字符串存在于树中的最长后缀，所以 $f(11, 1) = d(6) = 3$。另外 $s_{11} + \\text{pre}(t, 2) = \\{3, 2, 1, 3, 2\\}$，那么 $s_3 = \\{1, 3, 2\\}$ 是该字符串存在于树中的最长后缀，所以 $f(11, 2) = d(3) = 3$。", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Suffix Structure", "background": "", "description": "For a string $u = u_1 \\dots u_n$, let $\\mathrm{pre}(u, i)$ be the prefix $u_1 \\dots u_i$. In particular, $\\mathrm{pre}(u, 0)$ is empty string.\n\nFor two strings $u = u_1 \\dots u_n$ and $v = v_1 \\dots v_m$, let $u+v$ be the concatenation $u_1 \\dots u_n v_1 \\dots v_m$.\n\nYou are given a string $t=t_1 \\dots t_m$ of length $m$ and a tree $T$ with $(n + 1)$ vertices labeled with $0, 1, \\dots, n$ rooted at vertex $0$. Each edge is associated with a character. Please note that in this problem, the alphabet may contain more than $26$ characters.\n\nConsider the following function $$f(i,j) = \\max\\{d(x) \\mid s_x\\text{ is a suffix of }s_i+ \\mathrm{pre}(t,j)\\}$$ where $s_i$ be the concatenation of characters on the shortest path from root to vertex $i$ and $d(i)$ be the number of edges on the shortest path from the root to vertex $i$.\n\nYour task is to compute the values of $g_1, g_2, \\dots, g_m$ where $g_j=\\sum\\limits_{i=1}^{n} f(i,j)$.\n\nNote that $s_0$ is the empty string and empty string is a suffix of any string.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of\ntest cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 2 \\times 10^5$).\n\nThe second line contains $n$ integers $p_1, p_2, \\dots, p_n$ ($0 \\le p_i < i$) where $p_i$ indicates the parent of vertex $i$.\n\nThe third line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le n$) where $c_i$ indicates that the edge from vertex $p_i$ to vertex $i$ is associated with the $c_i$-th character from the alphabet. It is guaranteed that $p_i \\ne p_j$ or $c_i \\ne c_j$ for all $i \\ne j$.\n\nThe fourth line contains $m$ integers $t_1, t_2, \\dots, t_m$ ($1 \\le t_i \\le n$) where $t_i$ is the $i$-th character of string $t$.\n\nIt is guaranteed that neither the sum of $n$ nor the sum of $m$ will exceed $2 \\times 10^5$.", "outputFormat": "For each test case output one line containing $m$ integers $g_1, g_2, \\dots, g_m$ separated by a space.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": "Let's calculate $f(11, 1)$ and $f(11, 2)$ in the first sample test case to help you further understand. We have $s_{11} = \\{3, 2, 1\\}$ so $s_{11} + \\text{pre}(t, 1) = \\{3, 2, 1, 3\\}$. As $s_6 = \\{2, 1, 3\\}$ is its longest suffix existing in the tree, $f(11, 1) = d(6) = 3$. Also $s_{11} + \\text{pre}(t, 2) = \\{3, 2, 1, 3, 2\\}$ and $s_3 = \\{1, 3, 2\\}$ is its longest suffix existing in the tree, so $f(11, 2) = d(3) = 3$.\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 后缀结构", "background": "", "description": "给定字符串 $u = u_1 \\dots u_n$，令 $\\mathrm{pre}(u, i)$ 表示前缀 $u_1 \\dots u_i$。特别地，$\\mathrm{pre}(u, 0)$ 是空字符串。\n\n对于两个字符串 $u = u_1 \\dots u_n$ 与 $v = v_1 \\dots v_m$，令 $u+v$ 表示连接后的字符串 $u_1 \\dots u_n v_1 \\dots v_m$。\n\n给定长度为 $m$ 的字符串 $t=t_1 \\dots t_m$ 和一棵有 $(n + 1)$ 个节点的树 $T$，节点编号为 $0, 1, \\dots, n$，其中节点 $0$ 是根。每条边上都有一个字符。请注意，在本题中，字母表中可能会有多于 $26$ 个字符。\n\n考虑如下函数 $$f(i,j) = \\max\\{d(x) \\mid s_x\\text{ 是 }s_i+ \\mathrm{pre}(t,j)\\text{ 的后缀}\\}$$ 其中 $s_i$ 是从根到节点 $i$ 的最短路径上所有字符连接而成的字符串，$d(i)$ 是从根到节点 $i$ 的最短路径经过的边数。\n\n您需要计算 $g_1, g_2, \\dots, g_m$，其中 $g_j=\\sum\\limits_{i=1}^{n} f(i,j)$。\n\n请注意，$s_0$ 是空字符串，空字符串是任何字符串的后缀。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\le n, m \\le 2 \\times 10^5$）。\n\n第二行输入 $n$ 个整数 $p_1, p_2, \\dots, p_n$（$0 \\le p_i < i$），其中 $p_i$ 表示节点 $i$ 的父节点。\n\n第三行输入 $n$ 个整数 $c_1, c_2, \\dots, c_n$（$1 \\le c_i \\le n$），其中 $c_i$ 表示从节点 $p_i$ 到节点 $i$ 的边上的字符是字母表中第 $c_i$ 个字符。保证对于所有 $i \\ne j$，有 $p_i \\ne p_j$ 或 $c_i \\ne c_j$。\n\n第四行输入 $m$ 个整数 $t_1, t_2, \\dots, t_m$（$1 \\le t_i \\le n$），其中 $t_i$ 是字符串 $t$ 中的第 $i$ 个字符。\n\n保证所有数据 $n$ 之和与 $m$ 之和均不超过 $2 \\times 10^5$。", "outputFormat": "每组数据输出一行 $m$ 个由单个空格分隔的整数 $g_1, g_2, \\dots, g_m$。\n\n请不要在行末输出多余空格，否则您的答案可能会被认为是错误的！", "hint": "我们来计算第一组样例数据中的 $f(11, 1)$ 和 $f(11, 2)$ 以便您更好地理解。有 $s_{11} = \\{3, 2, 1\\}$，所以 $s_{11} + \\text{pre}(t, 1) = \\{3, 2, 1, 3\\}$。因为 $s_6 = \\{2, 1, 3\\}$ 是该字符串存在于树中的最长后缀，所以 $f(11, 1) = d(6) = 3$。另外 $s_{11} + \\text{pre}(t, 2) = \\{3, 2, 1, 3, 2\\}$，那么 $s_3 = \\{1, 3, 2\\}$ 是该字符串存在于树中的最长后缀，所以 $f(11, 2) = d(3) = 3$。", "locale": "zh-CN"}}}
{"pid": "P13961", "type": "P", "difficulty": 6, "samples": [["2\n2 6\nBG\nBQWBWW\n4 6\nGQBW\nWWWWQB", "3\nIMPOSSIBLE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC", "南京"], "title": "[ICPC 2023 Nanjing R] 华丽收场", "background": "", "description": "在猪之国，《Slay the Pig》是当下最流行的肉鸽游戏。在游戏中，玩家们通过使用卡牌来对抗邪恶的土豆大魔王（Evil Potato Lord）。\n\n游戏的主要规则如下：\n\n- 游戏开始时，玩家有一个起始手牌集合和一个自顶向下排列好的抽牌堆。 \n- 在游戏的任意时刻，卡牌只会存在于玩家的手牌中或者抽牌堆里。\n- 玩家可以使用手牌中的卡牌，使用卡牌会先让该卡牌被丢弃，然后触发该卡牌的效果。\n- 玩家只有在上一张卡牌的所有效果都被触发完毕后，才可以使用下一张卡牌。\n\n本题中，简单起见，我们只考虑抽牌这一种效果。\n抽牌的规则如下：\n\n- 当使用可以抽牌的卡牌时，会按自顶向下的顺序将若干张卡牌从抽牌堆依次加入到手牌中。\n- 玩家有一个手牌数量上限 $k$，任意时刻玩家的手牌数量不能超过 $k$。 \n- 当玩家试图抽牌时，如果玩家此时的手牌数量已经为 $k$，则不会将这张卡牌加入到手牌，而是将它直接从抽牌堆中丢弃，且不触发这张卡牌的任何效果。\n- 当玩家试图抽牌时，如果此时抽牌堆为空，则什么都不会发生。\n\n在这个游戏中，以“华丽收场”这张卡牌为核心的卡组是最为强大的。因为一旦这张牌被使用，它会对所有敌人造成大量的伤害从而轻易地赢得游戏胜利。然而华丽收场也有着苛刻的使用条件，即使用时玩家的抽牌堆必须是空。也就是说，此时所有卡牌必须已经被使用，或被丢弃，或在玩家的手牌中。\n\n鳖皇（Bie-Bot）是猪之国中仅次于 Mysterious Oscar 的最聪明的猪，他也在使用基于华丽收场的卡组。卡组由以下四种卡牌组成：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mqom89yi.png)\n:::\n\n- 华丽收场（Grand Finale）：游戏中最强大的卡牌, 保证有且仅有一张华丽收场在鳖皇的卡组中。这张卡仅能在抽牌堆为空时被打出。\n- 快斩（Quick Slash）：使用这张卡之后可以从抽牌堆抽一张牌。\n- 后空翻（Backflip）：使用这张卡之后可以从抽牌堆抽两张牌。\n- 伤口（Wound）：一张状态牌，一旦这张牌在玩家的手牌中，就不能被使用。\n\n在游戏开始时，鳖皇幸运地在他的起始手牌中获得了唯一一张华丽收场，并且鳖皇提前得知了他的抽牌堆自顶向下每一张牌分别是什么。现在，他的目标是成功使用华丽收场。\n鳖皇想要知道，在最优策略下，达成目标所需的最小手牌数量上限 $k$。\n作为猪之国第三聪明的玩家，您能帮帮鳖皇吗？\n\n更正式地，给定一个长度为 $n$ 的字符串 $S_{H}$ 表示鳖皇的起始手牌，和一个长度为 $m$ 的字符串 $S_{P}$ 自顶向下地表示鳖皇的抽牌堆。\n这两个字符串均由大写字母 `G`, `Q`, `B` 和 `W` 组成，分别表示起始手牌或抽牌堆对应位置的卡牌为华丽收场，快斩，后空翻和伤口。\n鳖皇可以根据前文提到的规则使用这些卡牌。\n请输出鳖皇最终能成功使用华丽收场所需的最小手牌数量上限 $k$（$k \\geq n$），或者声明不存在这样的 $k$。\n", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 2500$）表示鳖皇的起始手牌数量以及抽牌堆的卡牌的数量。\n\n第二行输入一个长度为 $n$ 的字符串 $S_{H}$ 表示鳖皇的起始手牌。字符串由大写字母 `G`，`Q`，`B`，`W` 组成。保证字符 `G` 仅在字符串  $S_{H}$ 中出现一次。\n\n第三行输入一个长度为 $m$ 的字符串 $S_{P}$ 自顶向下地表示鳖皇抽牌堆。字符串由大写字母 `Q`，`B`，`W` 组成。\n\n保证所有数据 $(n + m)$ 之和不超过 $5 \\times 10^4$。", "outputFormat": "每组数据输出一行一个整数，表示成功使用华丽收场需要的最小手牌数量上限 $k$（$k \\geq n$）。如果无法使用华丽收场，输出 $\\texttt{IMPOSSIBLE}$。", "hint": "以下使用“手牌/抽牌堆”字符串表示当前状况。对于第一组测试数据，一种可行的最优策略是：\n- BG/BQWBWW $\\overset{B}{\\longrightarrow}$ BQG/WBWW \n- BQG/WBWW $\\overset{Q}{\\longrightarrow}$ BWG/BWW\n- BWG/BWW $\\overset{B}{\\longrightarrow}$ BWG/W（抽牌过程中会移除一个 `W'，因为此时手牌上限已满）\n- BWG/W $\\overset{B}{\\longrightarrow}$ WWG/$\\emptyset$（只会抽取一个 `W' 因为抽取第二张牌时抽牌堆为空）\n- WWG/$\\emptyset$ $\\overset{G}{\\longrightarrow}$ 成功使用华丽收场！", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Grand Finale", "background": "", "description": "In Pigeland, $\\textit{Slay the Pig}$ is the most popular roguelike game where players use card decks to challenge a boss called Evil Potato Lord.\n\nThe general game rules are as follows:\n\n- Players start with a set of initial cards in their hand and a draw pile arranged from top to bottom. \n- At any given time, the player's hand and the draw pile are the only places where cards are present. \n- Players can play cards from their hands, and each played card will lead to this card being discarded first, and then triggering certain effects.\n- The player can only use the next card after all the effects of the previously played card have been triggered.\n\nIn this problem, for simplicity, we will only consider the effect of drawing cards. \nThe rules for drawing cards are as follows:\n\n- When using cards that can draw some other cards, players will draw a certain number of cards from the top of the draw pile into their hands in sequential order. \n- Players have a hand size limit of $k$, and at any given moment, the number of cards in a player's hand cannot exceed the limitation $k$. \n- When a player attempts to draw a card from the top of the draw pile and their hand already contains $k$ cards, the drawn card will be discarded from the draw pile without triggering any effects and not added to the hand. \n- When a player attempts to draw a card but the draw pile is empty, nothing will happen.\n\nDecks based on the key card $\\textit{Grand Finale}$ are the most powerful deck in the game. Once this card is played, it will cause massive damage to all enemies and often leads to victory in the game. However, to play the Grand Finale card, there are strict conditions. That is, the player's draw pile must be empty, which means that all cards must either be played, discarded, or in the player's hand.\n\nBie-Bot is the smartest pig in Pigeland only after the Mysterious Oscar, and he is also playing a $\\textit{Grand Finale}$-based deck, which can contain the following four types of cards:\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mqom89yi.png)\n:::\n\n- $\\textit{Grand Finale}$: The most powerful card in the game, playing it will lead to an easy victory, and there is exactly one $\\textit{Grand Finale}$ in Bie-Bot's deck. This card can only be played if there are no cards in the draw pile.\n- $\\textit{Quick Slash}$: Using this card, you will draw one card from the draw pile.\n- $\\textit{Backflip}$: Using this card, you will draw two cards from the draw pile.\n- $\\textit{Wound}$: A status card that, once it is in your hand, can not be played.\n\nAt the beginning of the game, Bie-Bot was lucky to have drawn the only one $\\textit{Grand Finale}$ in his starting hand, and he also knows that each card in the draw pile from top to bottom. Now, his goal is to successfully play the $\\textit{Grand Finale}$ card. Bie-Bot wants to know, under his optimal strategy, what is the minimum hand size limit $k$ required for him to achieve his goal. As the third smartest player in Pigeland, can you help him out?\n\nMore formally, you are given a string $S_{H}$ of length $n$ representing Bie-Bot's starting hand and a string $S_{P}$ of length $m$ representing the draw pile from top to bottom. Both strings consist of uppercase letters `G`, `Q`, `B` and `W`, indicating that the card at the corresponding position in the starting hand or draw pile is $\\textit{Grand Finale}$, $\\textit{Quick Slash}$, $\\textit{Backflip}$, or $\\textit{Wound}$, respectively. Bie-Bot can use the cards in his hand according to the rules mentioned above. Please output the minimum hand size limit $k$ ($k \\geq n$) such that Bie-Bot can finally play the $\\textit{Grand Finale}$ or state that there is no such $k$.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of\ntest cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 2500$) indicating the number of cards in Bie-Bot's starting hand and draw pile.\n\nThe second line contains a string $S_{H}$ of length $n$ to represent Bie-Bot's starting hand, consisting of uppercase letters `G`, `Q`, `B`, and `W`. It's guaranteed that there is exactly one `G` in $S_{H}$.\n\nThe third line of the input contains a string $S_{P}$ of length $m$ to represent Bie-Bot's draw pile from top to bottom, consisting of uppercase letters `Q`, `B`, and `W`.\n\nIt is guaranteed that the sum of $(n + m)$ of all test cases will not exceed $5 \\times 10^4$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum hand size $k$ ($k \\geq n$) that can lead to successfully playing $\\textit{Grand Finale}$, or $\\texttt{IMPOSSIBLE}$ if it can't be played.", "hint": "We express the situation with \"hand/deck\" string. For the first sample test case, one optimal strategy is:\n- BG/BQWBWW $\\overset{B}{\\longrightarrow}$ BQG/WBWW \n- BQG/WBWW $\\overset{Q}{\\longrightarrow}$ BWG/BWW\n- BWG/BWW $\\overset{B}{\\longrightarrow}$ BWG/W (Discard one \"W\" here due to hand size limit) \n- BWG/W $\\overset{B}{\\longrightarrow}$ WWG/$\\emptyset$ (Only draw one card here because there is no more card in the draw pile)\n- WWG/$\\emptyset$ $\\overset{G}{\\longrightarrow}$ Successfully playing $\\textit{Grand Finale}$!", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 华丽收场", "background": "", "description": "在猪之国，《Slay the Pig》是当下最流行的肉鸽游戏。在游戏中，玩家们通过使用卡牌来对抗邪恶的土豆大魔王（Evil Potato Lord）。\n\n游戏的主要规则如下：\n\n- 游戏开始时，玩家有一个起始手牌集合和一个自顶向下排列好的抽牌堆。 \n- 在游戏的任意时刻，卡牌只会存在于玩家的手牌中或者抽牌堆里。\n- 玩家可以使用手牌中的卡牌，使用卡牌会先让该卡牌被丢弃，然后触发该卡牌的效果。\n- 玩家只有在上一张卡牌的所有效果都被触发完毕后，才可以使用下一张卡牌。\n\n本题中，简单起见，我们只考虑抽牌这一种效果。\n抽牌的规则如下：\n\n- 当使用可以抽牌的卡牌时，会按自顶向下的顺序将若干张卡牌从抽牌堆依次加入到手牌中。\n- 玩家有一个手牌数量上限 $k$，任意时刻玩家的手牌数量不能超过 $k$。 \n- 当玩家试图抽牌时，如果玩家此时的手牌数量已经为 $k$，则不会将这张卡牌加入到手牌，而是将它直接从抽牌堆中丢弃，且不触发这张卡牌的任何效果。\n- 当玩家试图抽牌时，如果此时抽牌堆为空，则什么都不会发生。\n\n在这个游戏中，以“华丽收场”这张卡牌为核心的卡组是最为强大的。因为一旦这张牌被使用，它会对所有敌人造成大量的伤害从而轻易地赢得游戏胜利。然而华丽收场也有着苛刻的使用条件，即使用时玩家的抽牌堆必须是空。也就是说，此时所有卡牌必须已经被使用，或被丢弃，或在玩家的手牌中。\n\n鳖皇（Bie-Bot）是猪之国中仅次于 Mysterious Oscar 的最聪明的猪，他也在使用基于华丽收场的卡组。卡组由以下四种卡牌组成：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mqom89yi.png)\n:::\n\n- 华丽收场（Grand Finale）：游戏中最强大的卡牌, 保证有且仅有一张华丽收场在鳖皇的卡组中。这张卡仅能在抽牌堆为空时被打出。\n- 快斩（Quick Slash）：使用这张卡之后可以从抽牌堆抽一张牌。\n- 后空翻（Backflip）：使用这张卡之后可以从抽牌堆抽两张牌。\n- 伤口（Wound）：一张状态牌，一旦这张牌在玩家的手牌中，就不能被使用。\n\n在游戏开始时，鳖皇幸运地在他的起始手牌中获得了唯一一张华丽收场，并且鳖皇提前得知了他的抽牌堆自顶向下每一张牌分别是什么。现在，他的目标是成功使用华丽收场。\n鳖皇想要知道，在最优策略下，达成目标所需的最小手牌数量上限 $k$。\n作为猪之国第三聪明的玩家，您能帮帮鳖皇吗？\n\n更正式地，给定一个长度为 $n$ 的字符串 $S_{H}$ 表示鳖皇的起始手牌，和一个长度为 $m$ 的字符串 $S_{P}$ 自顶向下地表示鳖皇的抽牌堆。\n这两个字符串均由大写字母 `G`, `Q`, `B` 和 `W` 组成，分别表示起始手牌或抽牌堆对应位置的卡牌为华丽收场，快斩，后空翻和伤口。\n鳖皇可以根据前文提到的规则使用这些卡牌。\n请输出鳖皇最终能成功使用华丽收场所需的最小手牌数量上限 $k$（$k \\geq n$），或者声明不存在这样的 $k$。\n", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 2500$）表示鳖皇的起始手牌数量以及抽牌堆的卡牌的数量。\n\n第二行输入一个长度为 $n$ 的字符串 $S_{H}$ 表示鳖皇的起始手牌。字符串由大写字母 `G`，`Q`，`B`，`W` 组成。保证字符 `G` 仅在字符串  $S_{H}$ 中出现一次。\n\n第三行输入一个长度为 $m$ 的字符串 $S_{P}$ 自顶向下地表示鳖皇抽牌堆。字符串由大写字母 `Q`，`B`，`W` 组成。\n\n保证所有数据 $(n + m)$ 之和不超过 $5 \\times 10^4$。", "outputFormat": "每组数据输出一行一个整数，表示成功使用华丽收场需要的最小手牌数量上限 $k$（$k \\geq n$）。如果无法使用华丽收场，输出 $\\texttt{IMPOSSIBLE}$。", "hint": "以下使用“手牌/抽牌堆”字符串表示当前状况。对于第一组测试数据，一种可行的最优策略是：\n- BG/BQWBWW $\\overset{B}{\\longrightarrow}$ BQG/WBWW \n- BQG/WBWW $\\overset{Q}{\\longrightarrow}$ BWG/BWW\n- BWG/BWW $\\overset{B}{\\longrightarrow}$ BWG/W（抽牌过程中会移除一个 `W'，因为此时手牌上限已满）\n- BWG/W $\\overset{B}{\\longrightarrow}$ WWG/$\\emptyset$（只会抽取一个 `W' 因为抽取第二张牌时抽牌堆为空）\n- WWG/$\\emptyset$ $\\overset{G}{\\longrightarrow}$ 成功使用华丽收场！", "locale": "zh-CN"}}}
{"pid": "P13962", "type": "P", "difficulty": 4, "samples": [["2\n4 6\n1 1 8\n7 2 5\n1 1 7\n3 2 6\n8 1200000\n100000 1 100000\n100000 1 12345\n100000 2 100000\n100000 2 12345\n100000 1 100000\n100000 1 12345\n100000 2 100000\n100000 2 12345", "24\n100000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2023", "ICPC", "南京"], "title": "[ICPC 2023 Nanjing R] 电梯", "background": "", "description": "有 $n$ 组包裹需要被配送。第 $i$ 组共有 $c_i$ 个包裹，每个包裹的重量为 $w_i$（$w_i$ 等于 $1$ 或 $2$），并且需要被送到第 $f_i$ 层。\n\n有一台电梯，每趟能运送总重量不超过 $k$（$k$ 是偶数）的包裹。电梯会从地面层出发，渐渐移动到这一趟所有包裹的目标楼层的最高层 $h$，最后返回地面层。这一趟运送将消耗 $h$ 单位的电能。\n\n更正式地，令 $(w, f)$ 表示一个重量为 $w$，且目的地为第 $f$ 层的包裹。一个由包裹组成的多重集合（一种可能含有重复元素的集合）$\\mathbb{P}$ 能在同一趟被运送，若 $\\sum\\limits_{(w, f) \\in \\mathbb{P}} w \\le k$。这一趟运送将消耗 $\\max\\limits_{(w, f) \\in \\mathbb{P}} f$ 单位的电能。\n\n求将所有包裹运送到目的地最少一共需要多少单位的电能？\n\n请注意，每一趟运送的包裹可以来自不同组，每一组包裹也可以分成多趟运送。您可以认为一共有 $\\sum\\limits_{i=1}^n c_i$ 个包裹需要被运送，只不过一些包裹可能有相同的重量以及相同的目的地。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 与 $k$（$1 \\le n \\le 10^5$，$2 \\le k \\le 2 \\times 10^{10}$，$k$ 是偶数）表示组数以及电梯的最大载重。\n\n对于接下来 $n$ 行，第 $i$ 行输入三个整数 $c_i$，$w_i$ 与 $f_i$（$1 \\le c_i \\le 10^5$，$w_i \\in \\{1, 2\\}$，$1 \\le f_i \\le 10^5$）表示第 $i$ 组包裹的数量，每个包裹的重量以及目的地。\n\n保证所有数据中 $n$ 之和不超过 $3 \\times 10^5$。", "outputFormat": "每组数据输出一行一个整数，表示将所有包裹运送到目的地最少一共需要多少单位的电能。", "hint": "对于第一组样例数据，我们可以遵循以下策略：\n\n- 第一趟运送包裹 $(2, 6)$，$(2, 6)$ 与 $(2, 5)$。这一趟消耗 $6$ 单位的电能。\n- 第二趟运送包裹 $(1, 8)$，$(1, 7)$，$(2, 6)$ 与 $(2, 5)$。这一趟消耗 $8$ 单位的电能。\n- 第三趟运送包裹 $(2, 5)$，$(2, 5)$ 与 $(2, 5)$。这一趟消耗 $5$ 单位的电能。\n- 第四趟运送包裹 $(2, 5)$ 与 $(2, 5)$。这一趟消耗 $5$ 单位的电能。\n\n一共需要 $6 + 8 + 5 + 5 = 24$ 单位的电能。可以证明这是最少一共需要的电能。\n\n对于第二组样例数据，所有包裹可以在同一趟被运送。", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Elevator", "background": "", "description": "There are $n$ groups of parcels waiting to be delivered. There are $c_i$ parcels in the $i$-th group, where each parcel has the same weight of $w_i$ ($w_i$ is either $1$ or $2$) and should be delivered to the $f_i$-th floor.\n\nThere is an elevator which can carry parcels with a maximum total weight of $k$ ($k$ is even) for each ride. The elevator will start from the ground floor and move gradually towards the hightest floor $h$ where a parcel in the elevator should be delivered and finally move back to the ground floor, costing $h$ units of electric power for that ride.\n\nMore formally, let $(w, f)$ be a parcel whose weight is $w$ and should be delivered to the $f$-th floor. A multiset (a set which allows duplicated elements) of parcels $\\mathbb{P}$ can be delivered in the same ride if $\\sum\\limits_{(w, f) \\in \\mathbb{P}} w \\le k$. This ride will cost $\\max\\limits_{(w, f) \\in \\mathbb{P}} f$ units of electric power.\n\nWhat's the minimum total units of electric power needed to deliver all parcels?\n\nNote that each ride can contain parcels from different groups and each group of parcels can be delivered through multiple rides. You can treat this problem as if there are a total of $\\sum\\limits_{i=1}^n c_i$ parcels to be delivered, just that some parcels may have the same weight and the same destination.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($1 \\le n \\le 10^5$, $2 \\le k \\le 2 \\times 10^{10}$, $k$ is even) indicating the number of groups and the capacity of the elevator.\n\nFor the following $n$ lines, the $i$-th line contains three integers $c_i$, $w_i$ and $f_i$ ($1 \\le c_i \\le 10^5$, $w_i \\in \\{1, 2\\}$, $1 \\le f_i \\le 10^5$) indicating the number of parcels in the $i$-th group, the weight of each parcel and the destination of the parcels.\n\nIt's guaranteed that the sum of $n$ over all test cases does not exceed $3 \\times 10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum total units of electric power needed to deliver all parcels.", "hint": "For the first sample test case we can follow this strategy:\n\n- In the first ride, deliver parcel $(2, 6)$, $(2, 6)$ and $(2, 5)$. This ride costs $6$ units of electric power.\n- In the second ride, deliver parcel $(1, 8)$, $(1, 7)$, $(2, 6)$ and $(2, 5)$. This ride costs $8$ units of electric power.\n- In the third ride, deliver parcel $(2, 5)$, $(2, 5)$ and $(2, 5)$. This ride costs $5$ units of electric power.\n- In the fourth ride, deliver parcel $(2, 5)$ and $(2, 5)$. This ride costs $5$ units of electric power.\n\nThe total units of electric power is $6 + 8 + 5 + 5 = 24$. It can be proven that this is the minimum total units of electric power needed.\n\nFor the second sample test case, all parcels can be delivered in the same ride.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 电梯", "background": "", "description": "有 $n$ 组包裹需要被配送。第 $i$ 组共有 $c_i$ 个包裹，每个包裹的重量为 $w_i$（$w_i$ 等于 $1$ 或 $2$），并且需要被送到第 $f_i$ 层。\n\n有一台电梯，每趟能运送总重量不超过 $k$（$k$ 是偶数）的包裹。电梯会从地面层出发，渐渐移动到这一趟所有包裹的目标楼层的最高层 $h$，最后返回地面层。这一趟运送将消耗 $h$ 单位的电能。\n\n更正式地，令 $(w, f)$ 表示一个重量为 $w$，且目的地为第 $f$ 层的包裹。一个由包裹组成的多重集合（一种可能含有重复元素的集合）$\\mathbb{P}$ 能在同一趟被运送，若 $\\sum\\limits_{(w, f) \\in \\mathbb{P}} w \\le k$。这一趟运送将消耗 $\\max\\limits_{(w, f) \\in \\mathbb{P}} f$ 单位的电能。\n\n求将所有包裹运送到目的地最少一共需要多少单位的电能？\n\n请注意，每一趟运送的包裹可以来自不同组，每一组包裹也可以分成多趟运送。您可以认为一共有 $\\sum\\limits_{i=1}^n c_i$ 个包裹需要被运送，只不过一些包裹可能有相同的重量以及相同的目的地。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 与 $k$（$1 \\le n \\le 10^5$，$2 \\le k \\le 2 \\times 10^{10}$，$k$ 是偶数）表示组数以及电梯的最大载重。\n\n对于接下来 $n$ 行，第 $i$ 行输入三个整数 $c_i$，$w_i$ 与 $f_i$（$1 \\le c_i \\le 10^5$，$w_i \\in \\{1, 2\\}$，$1 \\le f_i \\le 10^5$）表示第 $i$ 组包裹的数量，每个包裹的重量以及目的地。\n\n保证所有数据中 $n$ 之和不超过 $3 \\times 10^5$。", "outputFormat": "每组数据输出一行一个整数，表示将所有包裹运送到目的地最少一共需要多少单位的电能。", "hint": "对于第一组样例数据，我们可以遵循以下策略：\n\n- 第一趟运送包裹 $(2, 6)$，$(2, 6)$ 与 $(2, 5)$。这一趟消耗 $6$ 单位的电能。\n- 第二趟运送包裹 $(1, 8)$，$(1, 7)$，$(2, 6)$ 与 $(2, 5)$。这一趟消耗 $8$ 单位的电能。\n- 第三趟运送包裹 $(2, 5)$，$(2, 5)$ 与 $(2, 5)$。这一趟消耗 $5$ 单位的电能。\n- 第四趟运送包裹 $(2, 5)$ 与 $(2, 5)$。这一趟消耗 $5$ 单位的电能。\n\n一共需要 $6 + 8 + 5 + 5 = 24$ 单位的电能。可以证明这是最少一共需要的电能。\n\n对于第二组样例数据，所有包裹可以在同一趟被运送。", "locale": "zh-CN"}}}
{"pid": "P13963", "type": "P", "difficulty": 5, "samples": [["2\n6\n1 2 3 4 5 6\n2\n1 2\n3 3\n5\n100 10 1 10 100\n1\n3 100", "1\n4\n180"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2023", "颜色段均摊（珂朵莉树 ODT）", "分块", "ICPC", "吉司机线段树 segment tree beats", "单调栈", "南京"], "title": "[ICPC 2023 Nanjing R] 接雨水", "background": "", "description": "有一张由长度为 $n$ 的序列 $a_1, a_2, \\cdots, a_n$ 表示的柱状图。柱状图上从左到右第 $i$ 根柱子的高度为 $a_i$，宽度为 $1$。\n\n我们会对该柱状图进行 $q$ 次修改。第 $i$ 次修改可以记为一对整数 $(x_i, v_i)$，表示我们会将第 $x_i$ 根柱子的高度增加 $v_i$。\n\n在每次修改之后，回答以下询问：如果下了一场大雨，雨水填满了柱状图上的每个坑洼，求这张柱状图中可以留存多少雨水。\n\n更正式地，给定长度为 $n$ 的整数序列 $a_1, a_2, \\cdots, a_n$，第 $i$ 次修改会将 $a_{x_i}$ 的值增加 $v_i$。在每次修改之后，回答以下询问：令 $f_i = \\max(a_1, a_2, \\cdots, a_i)$ 以及 $g_i = \\max(a_i, a_{i + 1}, \\cdots, a_n)$，计算\n\n$$\n\\sum\\limits_{i = 1}^n \\left( \\min(f_i, g_i) - a_i \\right)\n$$", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 10^5$）表示柱状图中柱子的数量。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$1 \\le a_i \\le 10^6$），其中 $a_i$ 表示第 $i$ 根柱子的初始高度。\n\n第三行输入一个整数 $q$（$1 \\le q \\le 10^5$）表示修改的次数。\n\n对于接下来 $q$ 行，第 $i$ 行输入两个整数 $x_i$ 和 $v_i$（$1 \\le x_i \\le n$，$1 \\le v_i \\le 10^6$）表示第 $i$ 次修改将第 $x_i$ 根柱子的高度增加了 $v_i$。\n\n保证所有数据 $n$ 之和与 $q$ 之和均不超过 $10^6$。", "outputFormat": "每次修改输出一行一个整数表示柱状图中可以留存多少雨水。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Trapping Rain Water", "background": "", "description": "There is a histogram represented by an integer sequence $a_1, a_2, \\cdots, a_n$ of length $n$. For the $i$-th bar from left to right, its height is $a_i$ and its width is $1$.\n\nWe'll perform $q$ modifications to the histogram. The $i$-th modification can be represented by a pair of integers $(x_i, v_i)$ indicating that we'll increase the height of the $x_i$-th bar by $v_i$.\n\nAfter each modification, answer the following query: Calculate how much water this histogram can trap if a heavy rain pours onto it and fills all the pits as much as possible.\n\nMore formally, given an integer sequence $a_1, a_2, \\cdots, a_n$ of length $n$, the $i$-th modification will increase $a_{x_i}$ by $v_i$. After each modification, answer the following query: Let $f_i = \\max(a_1, a_2, \\cdots, a_i)$ and $g_i = \\max(a_i, a_{i + 1}, \\cdots, a_n)$, calculate\n\n$$\n\\sum\\limits_{i = 1}^n \\left( \\min(f_i, g_i) - a_i \\right)\n$$", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the number of bars in the histogram.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^6$) where $a_i$ indicates the initial height of the $i$-th bar.\n\nThe third line contains an integer $q$ ($1 \\le q \\le 10^5$) indicating the number of modifications.\n\nFor the following $q$ lines, the $i$-th line contains two integers $x_i$ and $v_i$ ($1 \\le x_i \\le n$, $1 \\le v_i \\le 10^6$) indicating that the $i$-th modification increases the height of the $x_i$-th bar by $v_i$.\n\nIt is guaranteed that neither the sum of $n$ nor the sum of $q$ of all test cases will exceed $10^6$.\n", "outputFormat": "For each modification output one line containing one integer indicating how much rain water this histogram can trap.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 接雨水", "background": "", "description": "有一张由长度为 $n$ 的序列 $a_1, a_2, \\cdots, a_n$ 表示的柱状图。柱状图上从左到右第 $i$ 根柱子的高度为 $a_i$，宽度为 $1$。\n\n我们会对该柱状图进行 $q$ 次修改。第 $i$ 次修改可以记为一对整数 $(x_i, v_i)$，表示我们会将第 $x_i$ 根柱子的高度增加 $v_i$。\n\n在每次修改之后，回答以下询问：如果下了一场大雨，雨水填满了柱状图上的每个坑洼，求这张柱状图中可以留存多少雨水。\n\n更正式地，给定长度为 $n$ 的整数序列 $a_1, a_2, \\cdots, a_n$，第 $i$ 次修改会将 $a_{x_i}$ 的值增加 $v_i$。在每次修改之后，回答以下询问：令 $f_i = \\max(a_1, a_2, \\cdots, a_i)$ 以及 $g_i = \\max(a_i, a_{i + 1}, \\cdots, a_n)$，计算\n\n$$\n\\sum\\limits_{i = 1}^n \\left( \\min(f_i, g_i) - a_i \\right)\n$$", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 10^5$）表示柱状图中柱子的数量。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$1 \\le a_i \\le 10^6$），其中 $a_i$ 表示第 $i$ 根柱子的初始高度。\n\n第三行输入一个整数 $q$（$1 \\le q \\le 10^5$）表示修改的次数。\n\n对于接下来 $q$ 行，第 $i$ 行输入两个整数 $x_i$ 和 $v_i$（$1 \\le x_i \\le n$，$1 \\le v_i \\le 10^6$）表示第 $i$ 次修改将第 $x_i$ 根柱子的高度增加了 $v_i$。\n\n保证所有数据 $n$ 之和与 $q$ 之和均不超过 $10^6$。", "outputFormat": "每次修改输出一行一个整数表示柱状图中可以留存多少雨水。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P13964", "type": "P", "difficulty": 2, "samples": [["1", "1"], ["2", "9"], ["3", "21"], ["4", "45"], ["5", "69"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2024"], "title": "[VKOSHP 2024] Colony of Bacteria", "background": "", "description": "Scientists have discovered a new species of bacteria and have begun conducting experiments to study it.\n\nIn one of the experiments, they placed a colony of bacteria on an infinite grid, and it turned out that it expands every second. In every even second, the colony expands in eight directions, meaning it occupies cells adjacent to the occupied ones both orthogonally and diagonally, if they are not already occupied. In odd seconds, it only expands in four directions, occupying cells adjacent to the occupied ones orthogonally.\n\nHelp the scientists determine how many cells are occupied by the colony of bacteria at the $k$-th second of the experiment, given that it was placed on the grid in the first second.", "inputFormat": "The first line contains an integer $k$ --- the time in seconds when the scientists want to know how many cells are occupied by the colony of bacteria ($1 \\le k \\le 10^8$).", "outputFormat": "Output a single number -- the number of cells occupied by the colony of bacteria at the $k$-th second of the experiment.", "hint": "The filling of the grid for the first five seconds, with the cell indicating the second when this cell will first be occupied by the colony of bacteria.\n\n$$\\begin{array}{ |c|c|c|c|c|c|c|c|c| }\n\\hline\n      &   & 5 & 5 & 5 & 5 & 5 &   &   \\\\\n\\hline\n\n      & 5 & 4 & 4 & 4 & 4 & 4 & 5 &  \\\\\n\\hline\n    5 & 4 & 4 & 3 & 3 & 3 & 4 & 4 & 5 \\\\\n\\hline\n    5 & 4 & 3 & 2 & 2 & 2 & 3 & 4 & 5 \\\\\n\\hline\n    5 & 4 & 3 & 2 & 1 & 2 & 3 & 4 & 5 \\\\\n\\hline\n    5 & 4 & 3 & 2 & 2 & 2 & 3 & 4 & 5 \\\\\n\\hline\n    5 & 4 & 4 & 3 & 3 & 3 & 4 & 4 & 5 \\\\\n\\hline\n      & 5 & 4 & 4 & 4 & 4 & 4 & 5 &   \\\\\n\\hline\n      &   & 5 & 5 & 5 & 5 & 5 &   &   \\\\\n\\hline\n\\end{array}$$", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] Colony of Bacteria", "background": "", "description": "Scientists have discovered a new species of bacteria and have begun conducting experiments to study it.\n\nIn one of the experiments, they placed a colony of bacteria on an infinite grid, and it turned out that it expands every second. In every even second, the colony expands in eight directions, meaning it occupies cells adjacent to the occupied ones both orthogonally and diagonally, if they are not already occupied. In odd seconds, it only expands in four directions, occupying cells adjacent to the occupied ones orthogonally.\n\nHelp the scientists determine how many cells are occupied by the colony of bacteria at the $k$-th second of the experiment, given that it was placed on the grid in the first second.", "inputFormat": "The first line contains an integer $k$ --- the time in seconds when the scientists want to know how many cells are occupied by the colony of bacteria ($1 \\le k \\le 10^8$).", "outputFormat": "Output a single number -- the number of cells occupied by the colony of bacteria at the $k$-th second of the experiment.", "hint": "The filling of the grid for the first five seconds, with the cell indicating the second when this cell will first be occupied by the colony of bacteria.\n\n$$\\begin{array}{ |c|c|c|c|c|c|c|c|c| }\n\\hline\n      &   & 5 & 5 & 5 & 5 & 5 &   &   \\\\\n\\hline\n\n      & 5 & 4 & 4 & 4 & 4 & 4 & 5 &  \\\\\n\\hline\n    5 & 4 & 4 & 3 & 3 & 3 & 4 & 4 & 5 \\\\\n\\hline\n    5 & 4 & 3 & 2 & 2 & 2 & 3 & 4 & 5 \\\\\n\\hline\n    5 & 4 & 3 & 2 & 1 & 2 & 3 & 4 & 5 \\\\\n\\hline\n    5 & 4 & 3 & 2 & 2 & 2 & 3 & 4 & 5 \\\\\n\\hline\n    5 & 4 & 4 & 3 & 3 & 3 & 4 & 4 & 5 \\\\\n\\hline\n      & 5 & 4 & 4 & 4 & 4 & 4 & 5 &   \\\\\n\\hline\n      &   & 5 & 5 & 5 & 5 & 5 &   &   \\\\\n\\hline\n\\end{array}$$", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] Colony of Bacteria", "background": "", "description": "科学家发现了一种新的细菌种类，并开始进行实验研究。\n\n在一次实验中，他们将一个细菌群落放置在一个无限网格上，发现该群落每秒都会扩张。在偶数秒时，菌落会向八个方向扩张，即占据与已占据单元格正交和对角相邻的所有未占据单元格；在奇数秒时，菌落仅向四个正交方向扩张。\n\n已知细菌在第一秒被放置于网格上，请帮助科学家计算在第 $k$ 秒时被细菌占据的单元格数量。第 $1$ 秒细菌不扩张。", "inputFormat": "第一行包含一个整数 $k$，表示科学家想知道细菌占据单元格数量的时间点（$1 \\le k \\le 10^8$）。", "outputFormat": "输出一个数字，表示第 $k$ 秒时被细菌群落占据的单元格数量。", "hint": "前五秒的网格填充情况（单元格数字表示该单元格首次被细菌占据的秒数）：  \n$$\\begin{array}{ |c|c|c|c|c|c|c|c|c| } \\hline  \n      &   & 5 & 5 & 5 & 5 & 5 &   &   \\\\ \\hline  \n       & 5 & 4 & 4 & 4 & 4 & 4 & 5 &  \\\\ \\hline  \n    5 & 4 & 4 & 3 & 3 & 3 & 4 & 4 & 5 \\\\ \\hline  \n    5 & 4 & 3 & 2 & 2 & 2 & 3 & 4 & 5 \\\\ \\hline  \n    5 & 4 & 3 & 2 & 1 & 2 & 3 & 4 & 5 \\\\ \\hline  \n    5 & 4 & 3 & 2 & 2 & 2 & 3 & 4 & 5 \\\\ \\hline  \n    5 & 4 & 4 & 3 & 3 & 3 & 4 & 4 & 5 \\\\ \\hline  \n       & 5 & 4 & 4 & 4 & 4 & 4 & 5 &   \\\\ \\hline  \n       &   & 5 & 5 & 5 & 5 & 5 &   &   \\\\ \\hline  \n\\end{array}$$", "locale": "zh-CN"}}}
{"pid": "P13965", "type": "P", "difficulty": 0, "samples": [["3\n1 1\n1 2\n1 3\n3\n1 4\n1 5\n1 6", "0"], ["3\n4 1\n3 8\n3 6\n5\n2 2\n3 3\n1 5\n2 7\n2 4", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024"], "title": "[VKOSHP 2024] Two-Story Advent Calendar", "background": "", "description": "The \"General Passenger Company\" is launching New Year's train excursions from Saint Petersburg to Veliky Ustyug. For all purchasers of this trip, a special gift has been developed---an advent calendar.\n\nThe advent calendar is a box shaped like the main carrier of the \"General Passenger Company\" --- a two-story train car. Inside the box, there are small boxes arranged in two levels, with each small box containing a candy. The upper level contains $n$ small boxes, while the lower level contains $m$ small boxes. Each small box is labeled with a natural number from $1$ to $n+m$, inclusive. The numbers on the boxes do not repeat.\n\nFor each small box, its length is known. The boxes can differ in length. It is guaranteed that the sums of the lengths of the boxes on the first and second levels of the advent calendar are equal.\n\nTo properly open the advent calendar, on the first day, you must take and open the box numbered $1$, on the second day ---the box numbered $2$, and so on, finishing the calendar with the box numbered $n+m$, which should be taken and opened on the $(n+m)$-th day. An example of the advent calendar is shown in the figure.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8ztfrcyc.png)\n\nAdvent calendar with $8$ cells. To properly open it and create a New Year's mood, you need to open cell $1$ $8$ days before New Year, cell $2$ $7$ days before, and so on. On the last day ---December 31 ---you need to open cell $8$.\n:::\n\nDesigner and perfectionist Maya decided to take a train ride for the New Year and received a two-story advent calendar as a gift. Maya finds it inconvenient when she opens a candy box on the lower level and there is at least one unopened box on top of it on the upper level.\n\nMaya became curious about how many boxes she needs to remove from the calendar in advance to make it convenient. At the same time, Maya wants to leave as many boxes as possible in the advent calendar. Help her determine the minimum number of boxes that need to be removed from the calendar in advance so that when opening a box on the lower level, there are no unopened boxes from the upper level on top of it. Boxes can be removed in advance from both the upper and lower levels.", "inputFormat": "The first line of input contains an integer $n$ ($1 \\le n \\le 10^{5}$) --- the number of boxes on the upper level of the calendar.\n\nIn the next $n$ lines, there are two numbers $a_i$ and $x_i$ ($1 \\le a_i \\le 10^{9}$, $1 \\le x_i \\le n + m$) --- the length of the $i$-th box on the upper level of the calendar and the number written on it, respectively.\n\nOn the $(n+1)$-th line of input, there is an integer $m$ ($1 \\le m \\le 10^{5}$) --- the number of boxes on the lower level of the calendar.\n\nIn the next $m$ lines, there are two numbers $b_j$ and $y_j$ ($1 \\le b_j \\le 10^{9}$, $1 \\le y_j \\le n + m$) --- the length of the $j$-th box on the lower level of the calendar and the number written on it, respectively.\n\nIt is guaranteed that $a_1 + a_2 + \\ldots + a_n = b_1 + b_2 + \\ldots + b_m$.\nIt is guaranteed that all numbers in the set $\\{x_1, x_2, \\ldots, x_n, y_1, y_2, \\ldots, y_m\\}$ are distinct.", "outputFormat": "Output a single integer $k$---the minimum number of boxes that need to be removed from the calendar to make it convenient.", "hint": "In the second example, you can remove the boxes numbered $4$ and $8$. After this, the calendar will look like the one shown below and will become convenient.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0bmtdodl.png)\n:::", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] Two-Story Advent Calendar", "background": "", "description": "The \"General Passenger Company\" is launching New Year's train excursions from Saint Petersburg to Veliky Ustyug. For all purchasers of this trip, a special gift has been developed---an advent calendar.\n\nThe advent calendar is a box shaped like the main carrier of the \"General Passenger Company\" --- a two-story train car. Inside the box, there are small boxes arranged in two levels, with each small box containing a candy. The upper level contains $n$ small boxes, while the lower level contains $m$ small boxes. Each small box is labeled with a natural number from $1$ to $n+m$, inclusive. The numbers on the boxes do not repeat.\n\nFor each small box, its length is known. The boxes can differ in length. It is guaranteed that the sums of the lengths of the boxes on the first and second levels of the advent calendar are equal.\n\nTo properly open the advent calendar, on the first day, you must take and open the box numbered $1$, on the second day ---the box numbered $2$, and so on, finishing the calendar with the box numbered $n+m$, which should be taken and opened on the $(n+m)$-th day. An example of the advent calendar is shown in the figure.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8ztfrcyc.png)\n\nAdvent calendar with $8$ cells. To properly open it and create a New Year's mood, you need to open cell $1$ $8$ days before New Year, cell $2$ $7$ days before, and so on. On the last day ---December 31 ---you need to open cell $8$.\n:::\n\nDesigner and perfectionist Maya decided to take a train ride for the New Year and received a two-story advent calendar as a gift. Maya finds it inconvenient when she opens a candy box on the lower level and there is at least one unopened box on top of it on the upper level.\n\nMaya became curious about how many boxes she needs to remove from the calendar in advance to make it convenient. At the same time, Maya wants to leave as many boxes as possible in the advent calendar. Help her determine the minimum number of boxes that need to be removed from the calendar in advance so that when opening a box on the lower level, there are no unopened boxes from the upper level on top of it. Boxes can be removed in advance from both the upper and lower levels.", "inputFormat": "The first line of input contains an integer $n$ ($1 \\le n \\le 10^{5}$) --- the number of boxes on the upper level of the calendar.\n\nIn the next $n$ lines, there are two numbers $a_i$ and $x_i$ ($1 \\le a_i \\le 10^{9}$, $1 \\le x_i \\le n + m$) --- the length of the $i$-th box on the upper level of the calendar and the number written on it, respectively.\n\nOn the $(n+1)$-th line of input, there is an integer $m$ ($1 \\le m \\le 10^{5}$) --- the number of boxes on the lower level of the calendar.\n\nIn the next $m$ lines, there are two numbers $b_j$ and $y_j$ ($1 \\le b_j \\le 10^{9}$, $1 \\le y_j \\le n + m$) --- the length of the $j$-th box on the lower level of the calendar and the number written on it, respectively.\n\nIt is guaranteed that $a_1 + a_2 + \\ldots + a_n = b_1 + b_2 + \\ldots + b_m$.\nIt is guaranteed that all numbers in the set $\\{x_1, x_2, \\ldots, x_n, y_1, y_2, \\ldots, y_m\\}$ are distinct.", "outputFormat": "Output a single integer $k$---the minimum number of boxes that need to be removed from the calendar to make it convenient.", "hint": "In the second example, you can remove the boxes numbered $4$ and $8$. After this, the calendar will look like the one shown below and will become convenient.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0bmtdodl.png)\n:::", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] Two-Story Advent Calendar", "background": null, "description": "“General Passenger Company”正在推出从圣彼得堡到大乌斯秋格的新年列车游。为所有购买此行程的旅客，特别准备了一份礼物——一个降临节日历。\n\n这个降临节日历的盒子形状像“General Passenger Company”的主力车型——一节双层火车车厢。盒子内部分为上下两层，每层都排列着若干小盒子，每个小盒子里都装有一颗糖果。上层有 $n$ 个小盒子，下层有 $m$ 个小盒子。每个小盒子上都标有一个从 $1$ 到 $n+m$ 的自然数，且这些数字互不重复。\n\n每个小盒子的长度已知，不同盒子的长度可能不同。保证上下两层所有盒子的长度之和相等。\n\n正确开启降临节日历的方法是：第 $1$ 天取出并打开编号为 $1$ 的盒子，第 $2$ 天取出并打开编号为 $2$ 的盒子，依此类推，最后一天取出并打开编号为 $n+m$ 的盒子。下图展示了一个降临节日历的示例。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8ztfrcyc.png)\n\n有 $8$ 个格子的降临节日历。为了正确开启并营造新年氛围，你需要在新年前第 $8$ 天打开第 $1$ 个格子，在新年前第 $7$ 天打开第 $2$ 个格子，依此类推。最后一天——12 月 31 日——你需要打开第 $8$ 个格子。\n:::\n\n设计师兼完美主义者 Maya 决定乘坐新年列车，并收到了一个双层降临节日历作为礼物。Maya 觉得，如果她在下层打开一个糖果盒时，上面正好还有未打开的上层盒子，这样很不方便。\n\nMaya 很好奇，想知道她需要提前从日历中移除多少个盒子，才能让开启过程变得方便。同时，Maya 希望尽可能多地保留盒子。请你帮她计算，为了让每次打开下层盒子时，上面没有未打开的上层盒子，最少需要提前移除多少个盒子。可以从上层和下层任意移除盒子。", "inputFormat": "第一行输入一个整数 $n$（$1 \\le n \\le 10^{5}$），表示日历上层的盒子数量。\n\n接下来 $n$ 行，每行包含两个整数 $a_i$ 和 $x_i$（$1 \\le a_i \\le 10^{9}$，$1 \\le x_i \\le n + m$），分别表示上层第 $i$ 个盒子的长度和编号。\n\n第 $n+1$ 行输入一个整数 $m$（$1 \\le m \\le 10^{5}$），表示日历下层的盒子数量。\n\n接下来 $m$ 行，每行包含两个整数 $b_j$ 和 $y_j$（$1 \\le b_j \\le 10^{9}$，$1 \\le y_j \\le n + m$），分别表示下层第 $j$ 个盒子的长度和编号。\n\n保证 $a_1 + a_2 + \\ldots + a_n = b_1 + b_2 + \\ldots + b_m$。\n\n保证集合 $\\{x_1, x_2, \\ldots, x_n, y_1, y_2, \\ldots, y_m\\}$ 中的所有数字互不相同。", "outputFormat": "输出一个整数 $k$，表示为使日历开启过程方便，最少需要提前移除的盒子数量。", "hint": "在第二个样例中，你可以移除编号为 $4$ 和 $8$ 的盒子。此后，日历将如下面所示，并变得方便。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0bmtdodl.png)\n:::\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13966", "type": "P", "difficulty": 0, "samples": [["4\n5 7 2 0\n1 2\n2 3\n3 4\n4 1\n3 5\n5 4\n1 5\n5 7 2 1\n1 2\n2 3\n3 4\n4 1\n3 5\n5 4\n1 5\n5 7 2 2\n1 2\n2 3\n3 4\n4 1\n3 5\n5 4\n1 5\n5 7 2 3\n1 2\n2 3\n3 4\n4 1\n3 5\n5 4\n1 5", "2 1 2 3 3\n2 1 4 1 1\n2 1 5 5 1\n2 1 4 1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge"], "title": "[VKOSHP 2024] Intermediate Verticality", "background": "", "description": "Two classical graph algorithms --- depth-first search and breadth-first search --- construct two spanning trees in a graph. The depth-first search is known for producing a tree that has no $\\textit{horizontal}$ edges, which are edges connecting vertices that are not ancestors of each other, while breadth-first search is known for producing a tree that has no $\\textit{vertical}$ edges --- edges connecting a vertex to its ancestor in the tree. In this problem, you will need to construct an intermediate spanning tree that has a specified number of horizontal and vertical edges.\n\nRecall that an undirected graph consists of a set of vertices $V$ and a set of edges $E$, where each edge connects two vertices. We will consider connected graphs, where it is possible to reach any vertex from any other vertex via edges. A tree is a connected undirected graph that contains no cycles, and a spanning tree in a graph is a subset of its edges that forms a tree, allowing one to reach any vertex of the graph from any other. Recall two fundamental properties of a tree: in a tree with $n$ vertices, there are exactly $n-1$ edges, and there is exactly one path between any two vertices in a tree.\n\nWe will designate a vertex $r$ in the graph, which we will call the $\\textit{root}$ of the tree. The vertices that lie on the unique path from vertex $x$ to vertex $r$ are called the $\\textit{ancestors}$ of vertex $x$, and the first vertex on this path is called the $\\textit{parent}$ of vertex $x$ and is denoted as $p_x$. The root has no parent.\n\nIf a root and a spanning tree are fixed in the graph, then all edges of the graph can be divided into three types:\n\n- $\\textit{tree edges}$ --- the edges of the chosen spanning tree;\n- $\\textit{vertical edges}$ --- the edges not belonging to the tree that connect a vertex to its ancestor;\n- $\\textit{horizontal edges}$ --- the remaining edges of the graph.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/f1t3rreq.png)\n:::\n\nThe $\\textit{verticality}$ of the spanning tree in the graph is defined as the number of vertical edges.\n\nYou are given a graph with $n$ vertices and $m$ edges, the root of the tree $r$, and a number $h$, $0 \\le h \\le m-n+1$. You need to construct a spanning tree of the given graph with root at $r$, having a verticality equal to $h$, or report that such a tree does not exist.", "inputFormat": "Each test consists of several sets of input data. The first line contains one integer $t$ --- the number of sets of input data ($1 \\le t \\le 10^5$). Following this are descriptions of $t$ sets of input data.\n\nIn the first line of each set of input data, there are four integers $n$, $m$, $r$, and $h$ --- the number of vertices and edges in the graph, respectively, the index of the root vertex, and the required verticality of the future spanning tree ($2 \\le n \\le 3 \\cdot 10^5$; $n - 1 \\le m \\le 3 \\cdot 10^5$; $1 \\le r \\le n$; $0 \\le h \\le m - n + 1$).\n\nIn each of the following $m$ lines, there are two integers $u_i$, $v_i$ --- the indices of the vertices connected by an edge in the graph ($1 \\le u_i, v_i \\le n$; $u_i \\ne v_i$).\n\nIt is guaranteed that all graphs are connected, contain no loops or multiple edges. It is guaranteed that the sum of $n$ across all input data sets does not exceed $3 \\cdot 10^5$. It is guaranteed that the sum of $m$ across all input data sets does not exceed $3 \\cdot 10^5$.", "outputFormat": "For each test case, find the required spanning tree $T$ and output in a separate line $n$ integers $p_1, p_2, \\ldots, p_n$, where $p_i$ is the index of the parent of the $i$-th vertex in the tree $T$ ($1 \\le p_i \\le n$). For $p_r$, you can output any number from $1$ to $n$. If a tree $T$ with the desired properties does not exist, output $n$ numbers $-1$ instead.", "hint": "", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] Intermediate Verticality", "background": "", "description": "Two classical graph algorithms --- depth-first search and breadth-first search --- construct two spanning trees in a graph. The depth-first search is known for producing a tree that has no $\\textit{horizontal}$ edges, which are edges connecting vertices that are not ancestors of each other, while breadth-first search is known for producing a tree that has no $\\textit{vertical}$ edges --- edges connecting a vertex to its ancestor in the tree. In this problem, you will need to construct an intermediate spanning tree that has a specified number of horizontal and vertical edges.\n\nRecall that an undirected graph consists of a set of vertices $V$ and a set of edges $E$, where each edge connects two vertices. We will consider connected graphs, where it is possible to reach any vertex from any other vertex via edges. A tree is a connected undirected graph that contains no cycles, and a spanning tree in a graph is a subset of its edges that forms a tree, allowing one to reach any vertex of the graph from any other. Recall two fundamental properties of a tree: in a tree with $n$ vertices, there are exactly $n-1$ edges, and there is exactly one path between any two vertices in a tree.\n\nWe will designate a vertex $r$ in the graph, which we will call the $\\textit{root}$ of the tree. The vertices that lie on the unique path from vertex $x$ to vertex $r$ are called the $\\textit{ancestors}$ of vertex $x$, and the first vertex on this path is called the $\\textit{parent}$ of vertex $x$ and is denoted as $p_x$. The root has no parent.\n\nIf a root and a spanning tree are fixed in the graph, then all edges of the graph can be divided into three types:\n\n- $\\textit{tree edges}$ --- the edges of the chosen spanning tree;\n- $\\textit{vertical edges}$ --- the edges not belonging to the tree that connect a vertex to its ancestor;\n- $\\textit{horizontal edges}$ --- the remaining edges of the graph.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/f1t3rreq.png)\n:::\n\nThe $\\textit{verticality}$ of the spanning tree in the graph is defined as the number of vertical edges.\n\nYou are given a graph with $n$ vertices and $m$ edges, the root of the tree $r$, and a number $h$, $0 \\le h \\le m-n+1$. You need to construct a spanning tree of the given graph with root at $r$, having a verticality equal to $h$, or report that such a tree does not exist.", "inputFormat": "Each test consists of several sets of input data. The first line contains one integer $t$ --- the number of sets of input data ($1 \\le t \\le 10^5$). Following this are descriptions of $t$ sets of input data.\n\nIn the first line of each set of input data, there are four integers $n$, $m$, $r$, and $h$ --- the number of vertices and edges in the graph, respectively, the index of the root vertex, and the required verticality of the future spanning tree ($2 \\le n \\le 3 \\cdot 10^5$; $n - 1 \\le m \\le 3 \\cdot 10^5$; $1 \\le r \\le n$; $0 \\le h \\le m - n + 1$).\n\nIn each of the following $m$ lines, there are two integers $u_i$, $v_i$ --- the indices of the vertices connected by an edge in the graph ($1 \\le u_i, v_i \\le n$; $u_i \\ne v_i$).\n\nIt is guaranteed that all graphs are connected, contain no loops or multiple edges. It is guaranteed that the sum of $n$ across all input data sets does not exceed $3 \\cdot 10^5$. It is guaranteed that the sum of $m$ across all input data sets does not exceed $3 \\cdot 10^5$.", "outputFormat": "For each test case, find the required spanning tree $T$ and output in a separate line $n$ integers $p_1, p_2, \\ldots, p_n$, where $p_i$ is the index of the parent of the $i$-th vertex in the tree $T$ ($1 \\le p_i \\le n$). For $p_r$, you can output any number from $1$ to $n$. If a tree $T$ with the desired properties does not exist, output $n$ numbers $-1$ instead.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] Intermediate Verticality", "background": null, "description": "两个经典的图算法——深度优先搜索和广度优先搜索——在图中分别构造出两棵生成树。深度优先搜索生成的树没有“水平”边，即连接两个互为非祖先关系顶点的边；而广度优先搜索生成的树没有“垂直”边，即连接某个顶点与其祖先的边。在本题中，你需要构造一棵具有指定数量水平边和垂直边的中间生成树。\n\n回顾一下，无向图由顶点集 $V$ 和边集 $E$ 组成，每条边连接两个顶点。我们只考虑连通图，即任意两个顶点之间都可以通过边到达。树是一个连通且无环的无向图，图中的生成树是其边的一个子集，能够构成一棵树，使得任意两个顶点之间都可以互达。树有两个基本性质：一棵有 $n$ 个顶点的树恰好有 $n-1$ 条边，并且任意两点之间有且仅有一条简单路径。\n\n我们指定图中的一个顶点 $r$ 作为树的“根”。在从顶点 $x$ 到根 $r$ 的唯一路径上的所有顶点，称为 $x$ 的“祖先”；路径上的第一个顶点称为 $x$ 的“父亲”，记作 $p_x$。根没有父亲。\n\n如果在图中固定了根和生成树，则所有边可以分为三类：\n\n- “树边”——所选生成树中的边；\n- “垂直边”——不属于树的边，连接某个顶点与其祖先；\n- “水平边”——其余的边。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/f1t3rreq.png)\n:::\n\n生成树的“垂直度”定义为图中垂直边的数量。\n\n给定一个有 $n$ 个顶点和 $m$ 条边的图，树的根 $r$，以及一个整数 $h$，$0 \\le h \\le m-n+1$。你需要构造一棵以 $r$ 为根、垂直度为 $h$ 的生成树，或者报告不存在这样的树。", "inputFormat": "每组测试数据包含若干组输入。第一行包含一个整数 $t$，表示测试数据组数（$1 \\le t \\le 10^5$）。接下来是 $t$ 组测试数据的描述。\n\n每组测试数据的第一行包含四个整数 $n$、$m$、$r$ 和 $h$，分别表示图的顶点数、边数、根的编号和所需生成树的垂直度（$2 \\le n \\le 3 \\cdot 10^5$；$n-1 \\le m \\le 3 \\cdot 10^5$；$1 \\le r \\le n$；$0 \\le h \\le m-n+1$）。\n\n接下来的 $m$ 行，每行包含两个整数 $u_i$、$v_i$，表示一条连接顶点 $u_i$ 和 $v_i$ 的边（$1 \\le u_i, v_i \\le n$；$u_i \\ne v_i$）。\n\n保证所有图都是连通的，没有自环和重边。保证所有测试数据中 $n$ 的总和不超过 $3 \\cdot 10^5$，$m$ 的总和不超过 $3 \\cdot 10^5$。", "outputFormat": "对于每组测试数据，找到所需的生成树 $T$，并在单独一行输出 $n$ 个整数 $p_1, p_2, \\ldots, p_n$，其中 $p_i$ 表示第 $i$ 个顶点在树 $T$ 中的父亲编号（$1 \\le p_i \\le n$）。对于 $p_r$，你可以输出 $1$ 到 $n$ 之间的任意数。如果不存在满足条件的树 $T$，则输出 $n$ 个 $-1$。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13967", "type": "P", "difficulty": 4, "samples": [["5\n4 2 3\n-1 -2 -3 -4\n-1 -2 -3 -4\n3 3 2\n1 6 4\n1 4 1\n4 0 3\n0 2 1 2\n0 2 3 3\n5 2 1\n-1 0 1 2 3\n2 2 2 2 2\n3 66 77\n235 -111 9\n100 -200 -100", "1\n3\n3\n-1\n440"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "二分", "2024"], "title": "[VKOSHP 2024] Two Arrays", "background": "", "description": "Let the maximum in the array $d$ be denoted as $\\max(d)$ and the minimum as $\\min(d)$.\n\nTwo arrays $a$ and $b$ of length $n$ are given. In one operation, you can choose an index $1 \\leq i \\leq n$ and simultaneously increase the elements $a_i$ and $b_i$ by one: $a_i = a_i + 1$, $b_i = b_i + 1$. It is necessary to use these operations to achieve the simultaneous fulfillment of two conditions:\n\n- $\\max(a) - \\min(a) \\leq x$,\n- $\\max(b) - \\min(b) \\leq y$.\n\nDetermine the minimum number of operations required to achieve the simultaneous fulfillment of the specified conditions, or find out that it is impossible.", "inputFormat": "Each test consists of several test cases. The first line contains one integer $t$ --- the number of test cases ($1 \\leq t \\leq 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains three integers: $n$, $x$, $y$ ($1 \\leq n \\leq 10^5$, $0 \\leq x, y \\leq 10^9$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots a_n$ --- the elements of array $a$ ($-10^9 \\leq a_i \\leq 10^9$).\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\dots b_n$ --- the elements of array $b$ ($-10^9 \\leq b_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $10^5$.", "outputFormat": "For each test case, output one integer --- the minimum possible number of operations required to satisfy both conditions. If it is impossible to satisfy both conditions simultaneously, output $-1$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] Two Arrays", "background": "", "description": "Let the maximum in the array $d$ be denoted as $\\max(d)$ and the minimum as $\\min(d)$.\n\nTwo arrays $a$ and $b$ of length $n$ are given. In one operation, you can choose an index $1 \\leq i \\leq n$ and simultaneously increase the elements $a_i$ and $b_i$ by one: $a_i = a_i + 1$, $b_i = b_i + 1$. It is necessary to use these operations to achieve the simultaneous fulfillment of two conditions:\n\n- $\\max(a) - \\min(a) \\leq x$,\n- $\\max(b) - \\min(b) \\leq y$.\n\nDetermine the minimum number of operations required to achieve the simultaneous fulfillment of the specified conditions, or find out that it is impossible.", "inputFormat": "Each test consists of several test cases. The first line contains one integer $t$ --- the number of test cases ($1 \\leq t \\leq 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains three integers: $n$, $x$, $y$ ($1 \\leq n \\leq 10^5$, $0 \\leq x, y \\leq 10^9$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots a_n$ --- the elements of array $a$ ($-10^9 \\leq a_i \\leq 10^9$).\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\dots b_n$ --- the elements of array $b$ ($-10^9 \\leq b_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $10^5$.", "outputFormat": "For each test case, output one integer --- the minimum possible number of operations required to satisfy both conditions. If it is impossible to satisfy both conditions simultaneously, output $-1$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] Two Arrays", "background": null, "description": "设数组 $d$ 的最大值为 $\\max(d)$，最小值为 $\\min(d)$。\n\n给定两个长度为 $n$ 的数组 $a$ 和 $b$。每次操作，你可以选择一个下标 $1 \\leq i \\leq n$，同时将 $a_i$ 和 $b_i$ 增加 $1$：即 $a_i = a_i + 1$，$b_i = b_i + 1$。你需要通过若干次操作，使得同时满足以下两个条件：\n\n- $\\max(a) - \\min(a) \\leq x$；\n- $\\max(b) - \\min(b) \\leq y$。\n\n请你求出最少需要多少次操作才能同时满足上述条件，或者判断是否无法满足。", "inputFormat": "每组测试数据包含若干组测试用例。第一行包含一个整数 $t$，表示测试用例的组数（$1 \\leq t \\leq 10^5$）。接下来是每组测试用例的描述。\n\n每组测试用例的第一行包含三个整数：$n$、$x$、$y$（$1 \\leq n \\leq 10^5$，$0 \\leq x, y \\leq 10^9$）。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n$，表示数组 $a$ 的元素（$-10^9 \\leq a_i \\leq 10^9$）。\n\n第三行包含 $n$ 个整数 $b_1, b_2, \\dots, b_n$，表示数组 $b$ 的元素（$-10^9 \\leq b_i \\leq 10^9$）。\n\n保证所有测试用例中 $n$ 的总和不超过 $10^5$。", "outputFormat": "对于每组测试用例，输出一个整数，表示满足条件所需的最小操作次数。如果无法同时满足条件，输出 $-1$。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13968", "type": "P", "difficulty": 5, "samples": [["5\n1 2 1 3 4", "1\n2\n2\n2\n3"], ["1\n1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "平衡树", "树状数组", "2024"], "title": "[VKOSHP 2024] Classics", "background": "", "description": "You are probably familiar with the classic problem of finding the longest increasing subsequence in an array. Let $a$ be an array consisting of $n$ integers. A subsequence $i_1 < i_2 < \\ldots < i_k$ is called $\\textit{increasing}$ if $a_{i_1} < a_{i_2} < \\ldots < a_{i_k}$. The longest increasing subsequence is the increasing subsequence of maximum length. Of course, we will not ask you to solve the classic problem; you will have to solve its more complicated version...\n\nInitially, there is an empty array $a$. Then, the numbers $1, 2, \\ldots, n$ are added to the array in this order. The number $i$ is added to the array at position $p_i$. Positions in the array are numbered with integers from $1$ to $k$, where $k$ is the current size of the array. When adding an element at position $p$ in an array of size $k$, all elements that previously had positions from $p$ to $k$ are shifted one position to the right, and the current element is added to the freed space.\n\nYour task is to determine the length of the longest increasing subsequence in the array after each addition of a new element.", "inputFormat": "The first line contains one integer $n$ ($1 \\le n \\le 200\\,000$) --- the number of added elements.\n\nThe second line contains $n$ integers $p_1, p_2, \\ldots, p_n$ ($1 \\le p_i \\le i$) --- $p_i$ denotes the position where element $i$ is added.", "outputFormat": "Output $n$ integers --- the length of the longest increasing subsequence of the array after each addition of a new element.", "hint": "The array in the first example changed as follows: $[] \\to [1] \\to [1, 2] \\to [3, 1, 2] \\to [3, 1, 4, 2] \\to [3, 1, 4, 5, 2]$.", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] Classics", "background": "", "description": "You are probably familiar with the classic problem of finding the longest increasing subsequence in an array. Let $a$ be an array consisting of $n$ integers. A subsequence $i_1 < i_2 < \\ldots < i_k$ is called $\\textit{increasing}$ if $a_{i_1} < a_{i_2} < \\ldots < a_{i_k}$. The longest increasing subsequence is the increasing subsequence of maximum length. Of course, we will not ask you to solve the classic problem; you will have to solve its more complicated version...\n\nInitially, there is an empty array $a$. Then, the numbers $1, 2, \\ldots, n$ are added to the array in this order. The number $i$ is added to the array at position $p_i$. Positions in the array are numbered with integers from $1$ to $k$, where $k$ is the current size of the array. When adding an element at position $p$ in an array of size $k$, all elements that previously had positions from $p$ to $k$ are shifted one position to the right, and the current element is added to the freed space.\n\nYour task is to determine the length of the longest increasing subsequence in the array after each addition of a new element.", "inputFormat": "The first line contains one integer $n$ ($1 \\le n \\le 200\\,000$) --- the number of added elements.\n\nThe second line contains $n$ integers $p_1, p_2, \\ldots, p_n$ ($1 \\le p_i \\le i$) --- $p_i$ denotes the position where element $i$ is added.", "outputFormat": "Output $n$ integers --- the length of the longest increasing subsequence of the array after each addition of a new element.", "hint": "The array in the first example changed as follows: $[] \\to [1] \\to [1, 2] \\to [3, 1, 2] \\to [3, 1, 4, 2] \\to [3, 1, 4, 5, 2]$.", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] Classics", "background": null, "description": "你可能已经熟悉了在一个数组中寻找最长上升子序列的经典问题。设 $a$ 是一个包含 $n$ 个整数的数组。一个子序列 $i_1 < i_2 < \\ldots < i_k$ 被称为“上升”的，如果 $a_{i_1} < a_{i_2} < \\ldots < a_{i_k}$。最长上升子序列即为长度最大的上升子序列。当然，我们不会让你解决这个经典问题；你需要解决一个更复杂的版本……\n\n一开始，数组 $a$ 为空。然后，数字 $1, 2, \\ldots, n$ 依次被加入到数组中。数字 $i$ 被插入到数组的第 $p_i$ 个位置。数组中的位置编号为 $1$ 到 $k$，其中 $k$ 是当前数组的大小。当在一个大小为 $k$ 的数组的第 $p$ 个位置插入一个元素时，原本处于第 $p$ 到第 $k$ 个位置的所有元素都会向右移动一位，当前元素被放入空出的位置。\n\n你的任务是在每次插入新元素后，输出当前数组中最长上升子序列的长度。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 200\\,000$）——表示要插入的元素个数。\n\n第二行包含 $n$ 个整数 $p_1, p_2, \\ldots, p_n$（$1 \\le p_i \\le i$）——$p_i$ 表示第 $i$ 个元素插入的位置。", "outputFormat": "输出 $n$ 个整数，依次表示每次插入新元素后，当前数组中最长上升子序列的长度。", "hint": "第一个样例中的数组变化如下：$[] \\to [1] \\to [1, 2] \\to [3, 1, 2] \\to [3, 1, 4, 2] \\to [3, 1, 4, 5, 2]$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13969", "type": "P", "difficulty": 6, "samples": [["5\n1 0\n1 1\n2 2\n3 1\n4 2", "1\n1\n2\n2\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024"], "title": "[VKOSHP 2024] Exchange and Deletion", "background": "", "description": "There is a classic way to remove an element from an array: swap the values of the element to be removed and the last element of the array, and then delete the last element. \nUnfortunately, it turned out that this method does not always preserve the order of the elements in the array. Your task is to count the number of sequences of $k$ deletions after which the initially sorted array in ascending order will remain sorted.\n\nYou are given an array $a$ of length $n$, initially filled with numbers from $1$ to $n$ in ascending order, that is, $a_i=i$, and an array $b$ of length $k$, whose elements are pairwise distinct numbers from $1$ to $n$.\n\nThere are $k$ steps performed, at the $j$-th step the following occurs: an index $i$ is chosen from $1$ to $n-j+1$ such that $a_i=b_j$, after which $a_i$ and $a_{n-j+1}$ are swapped (if $i=n-j+1$, nothing happens). Then the last element of the array at this step, which has the index $n - j + 1$, is removed from the array.\n\nThe array $[b_1,b_2,\\ldots,b_k]$ is called $\\textit{good}$ if after performing $k$ steps the array $[a_1,a_2,\\ldots,a_{n-k}]$ is strictly increasing. \n\nYou are given the numbers $n$ and $k$, count the number of good arrays $[b_1,b_2,\\ldots,b_k]$. The answer may be too large, so output the remainder of the answer when divided by $10^9+7$.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 10^4$) --- the number of test cases.\nIn the following $t$ lines, the test cases are provided.\n\nIn the first line of each test case, the integers $n$ and $k$ are given ($1 \\le n \\le 5\\cdot 10^5$, $0 \\le k \\le n$).\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $5\\cdot 10^5$.", "outputFormat": "For each test case, output a single integer --- the number of good arrays $b$, taken modulo $10^9+7$.", "hint": "Let's analyze the fourth test from the example. In it, $n=3$ and $k=1$. Initially, $a=[1,2,3]$.\nLet's see how $a$ changes after the first step for all possible arrays $b$. \n\n- $b=[1]$. Then $a$ changes as follows: $[1, 2, 3]\\to[3,2,1]\\to[3,2]$. The array $[3,2]$ is not increasing.\n- $b=[2]$. Then $a$ changes as follows: $[1, 2, 3]\\to[1,3,2]\\to[1,3]$. The array $[1,3]$ is increasing.\n- $b=[3]$. Then $a$ changes as follows: $[1, 2, 3]\\to[1,2,3]\\to[1,2]$. The array $[1,2]$ is increasing.\n\nWe find that there are two good arrays $b=[2]$ and $b=[3]$, so the answer to the fourth test from the example is $2$.", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] Exchange and Deletion", "background": "", "description": "There is a classic way to remove an element from an array: swap the values of the element to be removed and the last element of the array, and then delete the last element. \nUnfortunately, it turned out that this method does not always preserve the order of the elements in the array. Your task is to count the number of sequences of $k$ deletions after which the initially sorted array in ascending order will remain sorted.\n\nYou are given an array $a$ of length $n$, initially filled with numbers from $1$ to $n$ in ascending order, that is, $a_i=i$, and an array $b$ of length $k$, whose elements are pairwise distinct numbers from $1$ to $n$.\n\nThere are $k$ steps performed, at the $j$-th step the following occurs: an index $i$ is chosen from $1$ to $n-j+1$ such that $a_i=b_j$, after which $a_i$ and $a_{n-j+1}$ are swapped (if $i=n-j+1$, nothing happens). Then the last element of the array at this step, which has the index $n - j + 1$, is removed from the array.\n\nThe array $[b_1,b_2,\\ldots,b_k]$ is called $\\textit{good}$ if after performing $k$ steps the array $[a_1,a_2,\\ldots,a_{n-k}]$ is strictly increasing. \n\nYou are given the numbers $n$ and $k$, count the number of good arrays $[b_1,b_2,\\ldots,b_k]$. The answer may be too large, so output the remainder of the answer when divided by $10^9+7$.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 10^4$) --- the number of test cases.\nIn the following $t$ lines, the test cases are provided.\n\nIn the first line of each test case, the integers $n$ and $k$ are given ($1 \\le n \\le 5\\cdot 10^5$, $0 \\le k \\le n$).\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $5\\cdot 10^5$.", "outputFormat": "For each test case, output a single integer --- the number of good arrays $b$, taken modulo $10^9+7$.", "hint": "Let's analyze the fourth test from the example. In it, $n=3$ and $k=1$. Initially, $a=[1,2,3]$.\nLet's see how $a$ changes after the first step for all possible arrays $b$. \n\n- $b=[1]$. Then $a$ changes as follows: $[1, 2, 3]\\to[3,2,1]\\to[3,2]$. The array $[3,2]$ is not increasing.\n- $b=[2]$. Then $a$ changes as follows: $[1, 2, 3]\\to[1,3,2]\\to[1,3]$. The array $[1,3]$ is increasing.\n- $b=[3]$. Then $a$ changes as follows: $[1, 2, 3]\\to[1,2,3]\\to[1,2]$. The array $[1,2]$ is increasing.\n\nWe find that there are two good arrays $b=[2]$ and $b=[3]$, so the answer to the fourth test from the example is $2$.", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] Exchange and Deletion", "background": null, "description": "有一种经典的方法可以从数组中删除一个元素：将要删除的元素与数组的最后一个元素交换，然后删除最后一个元素。\n不幸的是，这种方法并不总是能保持数组元素的顺序。你的任务是统计有多少种长度为 $k$ 的删除序列，使得初始为升序排列的数组在经过这些删除操作后仍然保持升序。\n\n给定一个长度为 $n$ 的数组 $a$，初始时 $a_i=i$，即 $a$ 按升序排列。还给定一个长度为 $k$ 的数组 $b$，其中元素是 $1$ 到 $n$ 的两两不同的数。\n\n进行 $k$ 步操作，在第 $j$ 步时，选择一个下标 $i$，满足 $1 \\leq i \\leq n-j+1$ 且 $a_i = b_j$，然后交换 $a_i$ 和 $a_{n-j+1}$（如果 $i = n-j+1$，则不做任何操作）。接着删除当前数组的最后一个元素（即下标为 $n-j+1$ 的元素）。\n\n如果在 $k$ 步操作后，数组 $[a_1,a_2,\\ldots,a_{n-k}]$ 仍然严格递增，则称数组 $[b_1,b_2,\\ldots,b_k]$ 是“好”的。\n\n给定 $n$ 和 $k$，请你计算有多少个“好”的数组 $[b_1,b_2,\\ldots,b_k]$。答案可能很大，请输出对 $10^9+7$ 取模后的结果。", "inputFormat": "第一行包含一个整数 $t$（$1 \\leq t \\leq 10^4$），表示测试用例的数量。\n接下来的 $t$ 行，每行描述一个测试用例。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $k$（$1 \\leq n \\leq 5 \\cdot 10^5$，$0 \\leq k \\leq n$）。\n\n保证所有测试用例中 $n$ 的总和不超过 $5 \\cdot 10^5$。", "outputFormat": "对于每个测试用例，输出一个整数，表示“好”的数组 $b$ 的数量，对 $10^9+7$ 取模。", "hint": "我们来分析样例中的第四个测试用例，其中 $n=3$，$k=1$。初始时 $a=[1,2,3]$。\n我们来看所有可能的 $b$ 数组，经过第一步操作后 $a$ 的变化。\n\n- $b=[1]$。则 $a$ 变化为：$[1,2,3]\\to[3,2,1]\\to[3,2]$。数组 $[3,2]$ 不是递增的。\n- $b=[2]$。则 $a$ 变化为：$[1,2,3]\\to[1,3,2]\\to[1,3]$。数组 $[1,3]$ 是递增的。\n- $b=[3]$。则 $a$ 变化为：$[1,2,3]\\to[1,2,3]\\to[1,2]$。数组 $[1,2]$ 是递增的。\n\n可以发现有两种“好”的数组 $b=[2]$ 和 $b=[3]$，所以该测试用例的答案是 $2$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13970", "type": "P", "difficulty": 3, "samples": [["8 5\n1 1\n2 0\n3 1\n6 0\n7 0\n8 1\n15 1\n19 1", "3"], ["10 6\n0 1\n1 0\n3 1\n4 0\n5 1\n8 1\n10 0\n11 0\n14 1\n18 1", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024"], "title": "[VKOSHP 2024] M-11 Highway", "background": "", "description": "The new high-speed highway M-11 is an infinite straight line.\n\nOn the highway, there are $n$ stopping points, each of which is a rest area or a gas station. Each stopping point is defined by its coordinate $x_i$, and no two stopping points are located at the same place. A triplet of stopping points $(i, j, k)$ is called $\\textit{convenient}$ if $x_{i} < x_{j} < x_{k}$, there are gas stations at points $x_{i}$ and $x_{k}$, a rest area at point $x_{j}$, and the distance between the gas stations does not exceed $d$.\n\nA team from Moscow is planning to travel to the contest along the M-11 highway, and its leader became curious about how many convenient triplets of stopping points exist along the way.", "inputFormat": "The first line contains two natural numbers $n$ and $d$ --- the number of stopping points and the maximum distance between gas stations ($3 \\leq n \\leq 5 \\cdot 10^{5}$, $2 \\leq d \\leq 10^{9}$).\n\nIn the following $n$ lines, the stopping points are given. Each stopping point is defined by two integers $x_i$ and $t_i$ --- the coordinate of the point and its type. Type $0$ denotes a rest area, and type $1$ denotes a gas station ($-10^{18} \\leq x_i \\leq 10^{18}$; $t_{i} \\in \\{0, 1\\}$). It is guaranteed that the coordinates of the stopping points are in increasing order.", "outputFormat": "Output a single number --- the number of convenient triplets.", "hint": "In the first input set, the convenient triplets are $(1, 2, 3)$, $(3, 4, 6)$, and $(3, 5, 6)$.", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] M-11 Highway", "background": "", "description": "The new high-speed highway M-11 is an infinite straight line.\n\nOn the highway, there are $n$ stopping points, each of which is a rest area or a gas station. Each stopping point is defined by its coordinate $x_i$, and no two stopping points are located at the same place. A triplet of stopping points $(i, j, k)$ is called $\\textit{convenient}$ if $x_{i} < x_{j} < x_{k}$, there are gas stations at points $x_{i}$ and $x_{k}$, a rest area at point $x_{j}$, and the distance between the gas stations does not exceed $d$.\n\nA team from Moscow is planning to travel to the contest along the M-11 highway, and its leader became curious about how many convenient triplets of stopping points exist along the way.", "inputFormat": "The first line contains two natural numbers $n$ and $d$ --- the number of stopping points and the maximum distance between gas stations ($3 \\leq n \\leq 5 \\cdot 10^{5}$, $2 \\leq d \\leq 10^{9}$).\n\nIn the following $n$ lines, the stopping points are given. Each stopping point is defined by two integers $x_i$ and $t_i$ --- the coordinate of the point and its type. Type $0$ denotes a rest area, and type $1$ denotes a gas station ($-10^{18} \\leq x_i \\leq 10^{18}$; $t_{i} \\in \\{0, 1\\}$). It is guaranteed that the coordinates of the stopping points are in increasing order.", "outputFormat": "Output a single number --- the number of convenient triplets.", "hint": "In the first input set, the convenient triplets are $(1, 2, 3)$, $(3, 4, 6)$, and $(3, 5, 6)$.", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] M-11 Highway", "background": null, "description": "新建的高速公路 M-11 是一条无限长的直线。\n\n在这条公路上有 $n$ 个停车点，每个停车点要么是休息区，要么是加油站。每个停车点由其坐标 $x_i$ 定义，且没有两个停车点位于同一位置。一个停车点三元组 $(i, j, k)$ 被称为“方便的”，如果满足 $x_{i} < x_{j} < x_{k}$，且 $x_{i}$ 和 $x_{k}$ 处都是加油站，$x_{j}$ 处是休息区，并且两个加油站之间的距离不超过 $d$。\n\n一支来自莫斯科的队伍计划沿 M-11 高速公路前往比赛，其领队对沿途有多少个方便的停车点三元组产生了兴趣。", "inputFormat": "第一行包含两个正整数 $n$ 和 $d$ —— 停车点的数量和加油站之间的最大距离（$3 \\leq n \\leq 5 \\cdot 10^{5}$，$2 \\leq d \\leq 10^{9}$）。\n\n接下来的 $n$ 行，每行描述一个停车点。每个停车点由两个整数 $x_i$ 和 $t_i$ 构成 —— $x_i$ 表示该点的坐标，$t_i$ 表示该点的类型。类型 $0$ 表示休息区，类型 $1$ 表示加油站（$-10^{18} \\leq x_i \\leq 10^{18}$，$t_{i} \\in \\{0, 1\\}$）。保证所有停车点的坐标严格递增。", "outputFormat": "输出一个整数，表示方便的三元组的数量。", "hint": "在第一个输入样例中，方便的三元组有 $(1, 2, 3)$、$(3, 4, 6)$ 和 $(3, 5, 6)$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13971", "type": "P", "difficulty": 5, "samples": [["10 4\naabaabbaab\n4 5\n8 5\n2 3\n1 1", "3\n10\n3\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024"], "title": "[VKOSHP 2024] Exploration Robots", "background": "", "description": "The field for testing the robots consists of $n$ cells numbered by integers $1$ to $n$ from left to right. Each cell contains a letter of the English alphabet; reading the letters from the first to the $n$-th cell forms the string $s$.\n\nThere are two robots that can move across the field, with the following conditions:\n\n- The robots know the string $s$;\n- The robots can freely exchange information;\n- The robots always know the distance between them, as well as which robot is to the left and which is to the right;\n- Each of the two robots can read the letter that is directly below it;\n\nIn one step, a robot can, after exchanging information with the other robot, move to an adjacent cell to the left or to an adjacent cell to the right. If a robot attempts to move left of the first cell or right of the $n$-th cell, it is destroyed.\n\nThe scientists want to conduct $q$ experiments, in the $i$-th of which the first robot is placed at position $x_i$, and the second at position $y_i$. The goal of the robots in each experiment is to visit as many different cells as possible. For each experiment, it is necessary to determine the maximum number of cells that the robots can visit without risking destruction.", "inputFormat": "The first line contains a pair of numbers $n$ and $q$ ($1 \\le n,q \\le 300\\,000$) --- the number of cells and the number of experiments.\n\nThe second line contains the string $s$ of length $n$, consisting of $n$ lowercase Latin letters.\n\nIn the following $q$ lines, pairs of numbers $x_i$, $y_i$ are given ($1 \\le x_i , y_i \\le n$).", "outputFormat": "For each experiment, output the maximum number of different cells that the robots can visit.", "hint": "Consider the last experiment in the example. The robots start at the same point and see the letter $\\texttt{a}$. They understand that moving left is dangerous, as it may lead to the destruction of the robot. However, moving right is safe, as the last letter of the string is $\\texttt{b}$. One or both robots move to the right until they reach the letter $\\texttt{b}$. Upon reaching the letter $\\texttt{b}$, the robots know that the string before it was $\\texttt{aab}$, which could be either the beginning or the end of the string; they cannot go beyond its limits without risking destruction, so they managed to visit a total of $3$ cells.", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] Exploration Robots", "background": "", "description": "The field for testing the robots consists of $n$ cells numbered by integers $1$ to $n$ from left to right. Each cell contains a letter of the English alphabet; reading the letters from the first to the $n$-th cell forms the string $s$.\n\nThere are two robots that can move across the field, with the following conditions:\n\n- The robots know the string $s$;\n- The robots can freely exchange information;\n- The robots always know the distance between them, as well as which robot is to the left and which is to the right;\n- Each of the two robots can read the letter that is directly below it;\n\nIn one step, a robot can, after exchanging information with the other robot, move to an adjacent cell to the left or to an adjacent cell to the right. If a robot attempts to move left of the first cell or right of the $n$-th cell, it is destroyed.\n\nThe scientists want to conduct $q$ experiments, in the $i$-th of which the first robot is placed at position $x_i$, and the second at position $y_i$. The goal of the robots in each experiment is to visit as many different cells as possible. For each experiment, it is necessary to determine the maximum number of cells that the robots can visit without risking destruction.", "inputFormat": "The first line contains a pair of numbers $n$ and $q$ ($1 \\le n,q \\le 300\\,000$) --- the number of cells and the number of experiments.\n\nThe second line contains the string $s$ of length $n$, consisting of $n$ lowercase Latin letters.\n\nIn the following $q$ lines, pairs of numbers $x_i$, $y_i$ are given ($1 \\le x_i , y_i \\le n$).", "outputFormat": "For each experiment, output the maximum number of different cells that the robots can visit.", "hint": "Consider the last experiment in the example. The robots start at the same point and see the letter $\\texttt{a}$. They understand that moving left is dangerous, as it may lead to the destruction of the robot. However, moving right is safe, as the last letter of the string is $\\texttt{b}$. One or both robots move to the right until they reach the letter $\\texttt{b}$. Upon reaching the letter $\\texttt{b}$, the robots know that the string before it was $\\texttt{aab}$, which could be either the beginning or the end of the string; they cannot go beyond its limits without risking destruction, so they managed to visit a total of $3$ cells.", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] Exploration Robots", "background": null, "description": "用于测试机器人的场地由 $n$ 个格子组成，这些格子从左到右依次编号为 $1$ 到 $n$。每个格子中包含一个英文字母，从第一个格子到第 $n$ 个格子依次读出这些字母可以得到字符串 $s$。\n\n有两个机器人可以在场地上移动，具体规则如下：\n\n- 机器人知道字符串 $s$；\n- 机器人可以自由交换信息；\n- 机器人始终知道它们之间的距离，以及哪一个在左、哪一个在右；\n- 每个机器人可以读取正下方格子的字母；\n\n每一步，机器人可以在与另一个机器人交换信息后，移动到相邻的左侧或右侧格子。如果机器人试图移动到第一个格子左侧或第 $n$ 个格子的右侧，则会被销毁。\n\n科学家们要进行 $q$ 次实验，在第 $i$ 次实验中，第一个机器人被放置在位置 $x_i$，第二个机器人被放置在位置 $y_i$。每次实验中，机器人的目标是尽可能多地访问不同的格子。对于每次实验，需要确定机器人在不冒被销毁风险的情况下，最多能访问多少个不同的格子。", "inputFormat": "第一行包含两个整数 $n$ 和 $q$（$1 \\le n, q \\le 300\\,000$），分别表示格子的数量和实验的次数。\n\n第二行包含长度为 $n$ 的字符串 $s$，由 $n$ 个小写拉丁字母组成。\n\n接下来的 $q$ 行，每行包含一对整数 $x_i, y_i$（$1 \\le x_i, y_i \\le n$）。", "outputFormat": "对于每次实验，输出机器人能够访问的不同格子的最大数量。", "hint": "考虑示例中的最后一次实验。两个机器人从同一个位置出发，看到的字母是 $\\texttt{a}$。它们明白向左移动是危险的，因为可能导致机器人被销毁。然而，向右移动是安全的，因为字符串的最后一个字母是 $\\texttt{b}$。一个或两个机器人向右移动，直到到达字母 $\\texttt{b}$。到达 $\\texttt{b}$ 时，机器人知道之前的字符串是 $\\texttt{aab}$，这可能是字符串的开头或结尾；它们无法越界，否则会被销毁，因此它们总共访问了 $3$ 个格子。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13972", "type": "P", "difficulty": 0, "samples": [["2\nhello\nhavvaeeello\ntest\ntesssst", "YES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024"], "title": "[VKOSHP 2024] Prank", "background": "", "description": "Katya formed the word $s_1$ from blocks, but when she returned to the room, she saw her brother Andrey running out. Now the word made from the blocks looked different --- $s_2$. Andrey admitted that he played a little $\\textit{prank}$. His prank consisted of the following: Andrey would choose a position and then insert two blocks with the same letter next to it. He could place these two blocks at the beginning of the string, at the end of the string, or between two neighboring blocks.\n\nHelp Katya determine whether Andrey told the truth, that is, whether the string $s_2$ could have been obtained from the string $s_1$ by possibly applying several $\\textit{pranks}$.", "inputFormat": "One test contains several sets of input data.\n\nThe first line contains one integer $t$ --- the number of sets of input data ($1 \\le t \\le 500\\,000$).\n\nIn the first line of each set description, there is one string $s_1$ --- the word from the blocks that Katya originally had.\n\nIn the second line of each set description, there is one string $s_2$ --- the word from the blocks that Andrey obtained.\n\nIt is guaranteed that all words consist of lowercase Latin letters. The total length of all words does not exceed $1\\,000\\,000$.\n", "outputFormat": "For each set of input data, output $\\texttt{YES}$, if Andrey could be telling the truth, and $\\texttt{NO}$ otherwise.", "hint": "", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] Prank", "background": "", "description": "Katya formed the word $s_1$ from blocks, but when she returned to the room, she saw her brother Andrey running out. Now the word made from the blocks looked different --- $s_2$. Andrey admitted that he played a little $\\textit{prank}$. His prank consisted of the following: Andrey would choose a position and then insert two blocks with the same letter next to it. He could place these two blocks at the beginning of the string, at the end of the string, or between two neighboring blocks.\n\nHelp Katya determine whether Andrey told the truth, that is, whether the string $s_2$ could have been obtained from the string $s_1$ by possibly applying several $\\textit{pranks}$.", "inputFormat": "One test contains several sets of input data.\n\nThe first line contains one integer $t$ --- the number of sets of input data ($1 \\le t \\le 500\\,000$).\n\nIn the first line of each set description, there is one string $s_1$ --- the word from the blocks that Katya originally had.\n\nIn the second line of each set description, there is one string $s_2$ --- the word from the blocks that Andrey obtained.\n\nIt is guaranteed that all words consist of lowercase Latin letters. The total length of all words does not exceed $1\\,000\\,000$.\n", "outputFormat": "For each set of input data, output $\\texttt{YES}$, if Andrey could be telling the truth, and $\\texttt{NO}$ otherwise.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] Prank", "background": null, "description": "Katya 用积木拼出了单词 $s_1$，但当她回到房间时，看到她的弟弟 Andrey 正跑出去。现在用积木拼出的单词变成了另一个样子——$s_2$。Andrey 承认他搞了个小“恶作剧”。他的恶作剧是这样的：Andrey 会选择一个位置，然后在该位置旁边插入两个相同字母的积木。他可以把这两个积木放在字符串的开头、结尾，或者两个相邻积木之间。\n\n请帮助 Katya 判断 Andrey 说的是否属实，也就是说，字符串 $s_2$ 是否可以通过对字符串 $s_1$ 进行若干次上述“恶作剧”操作得到。", "inputFormat": "一个测试包含多组输入数据。\n\n第一行包含一个整数 $t$，表示数据组数（$1 \\le t \\le 500\\,000$）。\n\n每组数据的第一行包含一个字符串 $s_1$，表示 Katya 最初用积木拼出的单词。\n\n每组数据的第二行包含一个字符串 $s_2$，表示 Andrey 最终拼出的单词。\n\n保证所有单词均由小写拉丁字母组成。所有单词的总长度不超过 $1\\,000\\,000$。", "outputFormat": "对于每组输入数据，如果 Andrey 可能说的是真话，则输出 $\\texttt{YES}$，否则输出 $\\texttt{NO}$。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13973", "type": "P", "difficulty": 5, "samples": [["6\n1 3 6 4 2 5", "56"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024"], "title": "[VKOSHP 2024] Nightmare Sum", "background": "", "description": "Given an array $a$ of length $n$, consisting of distinct positive integers. Compute\n\n$$\\sum\\limits_{l=1}^{n} \\sum\\limits_{r=l}^{n} \\left\\lfloor\\frac{\\max(a_{l},a_{l+1},\\ldots,a_{r})}{\\min(a_{l},a_{l+1},\\ldots,a_{r})}\\right\\rfloor$$\n\nHere, $\\lfloor x \\rfloor$ denotes $x$ rounded down to the nearest integer.\n\nThus, it is necessary to compute the sum of the results of integer division of the maximum by the minimum over all subarrays of the array $a$.", "inputFormat": "The first line of input contains a single integer $n$~--- the length of the array $(1 \\leq n \\leq 300\\,000)$.\n\nThe second line of input contains $n$ integers~--- the array $a$ $(1 \\leq a_{i} \\leq 300\\,000)$.\n\nIt is guaranteed that all numbers in the array $a$ are distinct.", "outputFormat": "Output a single number --- the desired sum.", "hint": "Let's consider the example in more detail:\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/1l5bm6h7.png)\n:::", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] Nightmare Sum", "background": "", "description": "Given an array $a$ of length $n$, consisting of distinct positive integers. Compute\n\n$$\\sum\\limits_{l=1}^{n} \\sum\\limits_{r=l}^{n} \\left\\lfloor\\frac{\\max(a_{l},a_{l+1},\\ldots,a_{r})}{\\min(a_{l},a_{l+1},\\ldots,a_{r})}\\right\\rfloor$$\n\nHere, $\\lfloor x \\rfloor$ denotes $x$ rounded down to the nearest integer.\n\nThus, it is necessary to compute the sum of the results of integer division of the maximum by the minimum over all subarrays of the array $a$.", "inputFormat": "The first line of input contains a single integer $n$~--- the length of the array $(1 \\leq n \\leq 300\\,000)$.\n\nThe second line of input contains $n$ integers~--- the array $a$ $(1 \\leq a_{i} \\leq 300\\,000)$.\n\nIt is guaranteed that all numbers in the array $a$ are distinct.", "outputFormat": "Output a single number --- the desired sum.", "hint": "Let's consider the example in more detail:\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/1l5bm6h7.png)\n:::", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] Nightmare Sum", "background": null, "description": "给定一个长度为 $n$ 的数组 $a$，数组中的元素均为互不相同的正整数。计算\n\n$$\\sum\\limits_{l=1}^{n} \\sum\\limits_{r=l}^{n} \\left\\lfloor\\frac{\\max(a_{l},a_{l+1},\\ldots,a_{r})}{\\min(a_{l},a_{l+1},\\ldots,a_{r})}\\right\\rfloor$$\n\n其中，$\\lfloor x \\rfloor$ 表示对 $x$ 向下取整。\n\n也就是说，需要计算数组 $a$ 的所有子数组中，最大值除以最小值的整数部分之和。", "inputFormat": "输入的第一行包含一个整数 $n$，表示数组的长度（$1 \\leq n \\leq 300\\,000$）。\n\n输入的第二行包含 $n$ 个整数，表示数组 $a$（$1 \\leq a_{i} \\leq 300\\,000$）。\n\n保证数组 $a$ 中所有的数互不相同。", "outputFormat": "输出一个整数，表示所求的和。", "hint": "让我们更详细地考虑这个例子：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/1l5bm6h7.png)\n:::\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13974", "type": "P", "difficulty": 0, "samples": [["7 11", "Yes\n1 2\n2 3\n3 4\n3 5\n3 6\n3 7"], ["5 5", "No"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge"], "title": "[VKOSHP 2024] Petya's Cryptography", "background": "", "description": "Petya received a failing grade in cryptography, but it was the teachers who did not understand his genius, not him being lazy. To convince the entire world community of his genius, Petya created a new public key encryption system --- $\\textit{PSA}$. Any self-respecting public key cryptosystem has a public key and a private key.\n\nAs a private key, Petya chose a tree $T$, and as a public key --- two numbers $(n, p)$, where $n$ is the number of vertices in the tree $T$, and $p$ is the number of paths of length 2 in $T$. Recall that a tree is an undirected connected graph that does not contain cycles.\n\nThe peculiarity of Petya's cryptosystem is that any private key corresponding to the public key will suffice to break it. But that's not a problem; Petya chose quite a complex task, right? Restore any private key of the cryptosystem $PSA$ or state that such a public key could not have been produced.", "inputFormat": "The input consists of a single line containing two numbers $n$ and $p$ ($1 \\leq n \\leq 1000$, $0 \\leq p \\leq 10^9$).", "outputFormat": "If a solution exists, output $\\texttt{Yes}$ in the first line. In the next $n - 1$ lines, output two distinct integers from 1 to $n$ --- the edges of the tree.\n\nIf no solution exists, output $\\texttt{No}$ in a single line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] Petya's Cryptography", "background": "", "description": "Petya received a failing grade in cryptography, but it was the teachers who did not understand his genius, not him being lazy. To convince the entire world community of his genius, Petya created a new public key encryption system --- $\\textit{PSA}$. Any self-respecting public key cryptosystem has a public key and a private key.\n\nAs a private key, Petya chose a tree $T$, and as a public key --- two numbers $(n, p)$, where $n$ is the number of vertices in the tree $T$, and $p$ is the number of paths of length 2 in $T$. Recall that a tree is an undirected connected graph that does not contain cycles.\n\nThe peculiarity of Petya's cryptosystem is that any private key corresponding to the public key will suffice to break it. But that's not a problem; Petya chose quite a complex task, right? Restore any private key of the cryptosystem $PSA$ or state that such a public key could not have been produced.", "inputFormat": "The input consists of a single line containing two numbers $n$ and $p$ ($1 \\leq n \\leq 1000$, $0 \\leq p \\leq 10^9$).", "outputFormat": "If a solution exists, output $\\texttt{Yes}$ in the first line. In the next $n - 1$ lines, output two distinct integers from 1 to $n$ --- the edges of the tree.\n\nIf no solution exists, output $\\texttt{No}$ in a single line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] Petya's Cryptography", "background": null, "description": "Petya 在密码学考试中得了不及格的分数，但他认为是老师们没有理解他的天才，而不是他自己懒惰。为了向全世界证明自己的天才，Petya 创造了一种新的公钥加密系统——$\\textit{PSA}$。任何自尊的公钥密码系统都应该有公钥和私钥。\n\nPetya 选择一棵树 $T$ 作为私钥，公钥则是两个数 $(n, p)$，其中 $n$ 是树 $T$ 的顶点数，$p$ 是树中长度为 $2$ 的路径的数量。回忆一下，树是一个无环连通无向图。\n\nPetya 的加密系统的特殊之处在于，任何与公钥对应的私钥都可以破解它。但这不是问题，毕竟 Petya 选择了一个相当复杂的任务，对吧？请你还原出该加密系统 PSA 的任意一个私钥，或者说明这样的公钥不可能被产生。", "inputFormat": "输入包含一行，包含两个整数 $n$ 和 $p$，其中 $1 \\leq n \\leq 1000$，$0 \\leq p \\leq 10^9$。", "outputFormat": "如果存在解，第一行输出 $\\texttt{Yes}$。接下来的 $n-1$ 行，每行输出两个 $1$ 到 $n$ 之间的不同整数，表示树中的一条边。\n\n如果不存在解，输出一行 $\\texttt{No}$。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13975", "type": "P", "difficulty": 2, "samples": [["473 10 11", "4200"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2024"], "title": "[VKOSHP 2024] Two Scooters", "background": "", "description": "Katya knows that the travel time from home to the metro on a scooter is $t$ seconds.\n\nThe cost of the ride on the scooter from company $\\texttt{W}$ is calculated as follows: first, the number of full minutes spent on the trip is determined, then this time is multiplied by 60 and used to calculate the cost at the rate of $c_1$ cents per second.\n\nThe cost of the ride on the scooter from company $\\texttt{Y}$ is calculated differently: first, the cost of the trip is calculated at the rate of $c_2$ cents per second, and then this amount is rounded up to the nearest whole euro.\n\nHelp Katya understand what is the minimum cost she can get to the metro on a scooter from one of these companies.\n\nRecall that there are 100 cents in one euro.", "inputFormat": "The first line contains three integers $t$, $c_1$, and $c_2$ --- the travel time in seconds, the fare in cents per second on the scooter from company $\\texttt{W}$, and the fare in cents per second on the scooter from company $\\texttt{Y}$ ($1 \\le t \\le 1000$, $10 \\le c_1, c_2 \\le 20$).", "outputFormat": "Output the minimum cost of the ride in cents.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[VKOSHP 2024] Two Scooters", "background": "", "description": "Katya knows that the travel time from home to the metro on a scooter is $t$ seconds.\n\nThe cost of the ride on the scooter from company $\\texttt{W}$ is calculated as follows: first, the number of full minutes spent on the trip is determined, then this time is multiplied by 60 and used to calculate the cost at the rate of $c_1$ cents per second.\n\nThe cost of the ride on the scooter from company $\\texttt{Y}$ is calculated differently: first, the cost of the trip is calculated at the rate of $c_2$ cents per second, and then this amount is rounded up to the nearest whole euro.\n\nHelp Katya understand what is the minimum cost she can get to the metro on a scooter from one of these companies.\n\nRecall that there are 100 cents in one euro.", "inputFormat": "The first line contains three integers $t$, $c_1$, and $c_2$ --- the travel time in seconds, the fare in cents per second on the scooter from company $\\texttt{W}$, and the fare in cents per second on the scooter from company $\\texttt{Y}$ ($1 \\le t \\le 1000$, $10 \\le c_1, c_2 \\le 20$).", "outputFormat": "Output the minimum cost of the ride in cents.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[VKOSHP 2024] Two Scooters", "background": null, "description": "Katya 知道从家到地铁站骑滑板车需要 $t$ 秒。\n\n公司 $\\texttt{W}$ 的滑板车费用计算方式如下：首先确定本次行程所用的完整分钟数，然后将该分钟数乘以 60，按每秒 $c_1$ 分的费率计算费用。\n\n公司 $\\texttt{Y}$ 的滑板车费用计算方式不同：首先按每秒 $c_2$ 分的费率计算本次行程的费用，然后将该金额向上取整到最接近的整欧元。\n\n请帮助 Katya 计算，她选择这两家公司中哪一家，能以最低的费用骑滑板车到地铁站。\n\n注意：1 欧元等于 100 分。", "inputFormat": "第一行包含三个整数 $t$、$c_1$ 和 $c_2$，分别表示骑行时间（秒）、公司 $\\texttt{W}$ 的每秒费用（分）、公司 $\\texttt{Y}$ 的每秒费用（分）$(1 \\le t \\le 1000, 10 \\le c_1, c_2 \\le 20)$。", "outputFormat": "输出骑行所需的最小费用（单位：分）。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
