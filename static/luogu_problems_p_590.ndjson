{"pid": "P12975", "type": "P", "difficulty": 5, "samples": [["1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "数学", "O2优化"], "title": "疯狂星期四", "background": "Source：TYCPC 4th，Check：not_clever_syl。\n\nAlice 想要训练 Bob 的树穴能力！", "description": "Alice 说，Bob 每天只要填一个表格，是一个 $1\\times n$ 的矩阵，每一格可以填一个数 $x(0 \\leq x \\leq 7)$。\n\nAlice 会检查这个表格，如果每一格的数之和可以被 $7$ 整除，Alice 就会带 Bob 去吃疯狂星期四。\n\nBob 很喜欢去吃疯狂星期四，但 Alice 为了防止 Bob 填重复的表格，增加了每天的填法不能相同的设定。\n\nBob 想知道他最多能吃多少次疯狂星期四。\n\n由于 Bob 觉得这个数可能很大，所以你只需要输出这个数对 $101$ 取余的结果。", "inputFormat": "输入一个整数 $n$。", "outputFormat": "一行，一个整数表示答案对 $101$ 取余的结果。", "hint": "对于所有数据，$1\\leq n\\leq 10^{10000000}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "疯狂星期四", "background": "Source：TYCPC 4th，Check：not_clever_syl。\n\nAlice 想要训练 Bob 的树穴能力！", "description": "Alice 说，Bob 每天只要填一个表格，是一个 $1\\times n$ 的矩阵，每一格可以填一个数 $x(0 \\leq x \\leq 7)$。\n\nAlice 会检查这个表格，如果每一格的数之和可以被 $7$ 整除，Alice 就会带 Bob 去吃疯狂星期四。\n\nBob 很喜欢去吃疯狂星期四，但 Alice 为了防止 Bob 填重复的表格，增加了每天的填法不能相同的设定。\n\nBob 想知道他最多能吃多少次疯狂星期四。\n\n由于 Bob 觉得这个数可能很大，所以你只需要输出这个数对 $101$ 取余的结果。", "inputFormat": "输入一个整数 $n$。", "outputFormat": "一行，一个整数表示答案对 $101$ 取余的结果。", "hint": "对于所有数据，$1\\leq n\\leq 10^{10000000}$。", "locale": "zh-CN"}}}
{"pid": "P12976", "type": "P", "difficulty": 5, "samples": [["2\n2 4\n1 5\n3 5\n2 7", "0 0 \n2 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["O2优化", "差分约束"], "title": "受力分析 Force", "background": "还在写题的 Comentropy 突然收到了挑战，竟然是一道力学题！他感到震惊，一看到数据范围就知道该怎么写了，但是过程冗长，于是找到你帮他精简一下。\n\n注：本题没有严格的物理理论基础，且本题并不要求物理基础。\n\n**建议阅读形式化题意。**", "description": "现在有 $n\\times n$ 个正方体物块摆成一个方阵，物块有自己的重量，你现在需要控制它们平衡不动。这就要求对于第 $i$ 行第 $j$ 列的物块，它底面受到的支持力在区间 $[l_{i,j},r_{i,j}]$ 中。\n\n出题人们给出横纵方向各 $n$ 根钢丝用以给底面支持力，并把物块放置在钢丝交点处。现在你可以给这 $2n$ 根钢丝分别施加力。（注意同一根钢丝处处的力是相同的）\n\n规定：在数值上，物块受到的支持力就是你施加给其下的两根钢丝的力的和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/shg5p17w.png)\n\n如图，有两组钢丝一组横着放，施加给它们的力分别是：$[x_1,x_2,\\dots,x_n]$；一组竖着放，施加给它们的力分别是：$[y_1,y_2,\\dots,y_n]$，交点 $(i,j)$ 处的合力即为：$x_i+y_j$。\n\n请你求出每根钢丝的使用力的情况。出题人们为了难倒 Comentropy，还要求序列 $[x_1,x_2,\\dots,x_n,y_1,y_2\\dots,y_n]$ 的字典序最小。你能帮他处理这个问题吗？\n\n**每个力都应当是非负整数，方向向上。**\n\n**形式化地**：\n给出两个 $n\\times n$ 的矩阵 $l,r$，要求 $l_{i,j}\\leq x_i+y_j \\leq r_{i,j}$，求一个字典序最小的非负整数解的序列 $\\{x\\}$, $\\{y\\}$（把 $x$ 和 $y$ 的序列并起来 $[x_1,x_2,\\dots,x_n,y_1,y_2,\\dots,y_n]$ 的字典序最小）。", "inputFormat": "第一行，一个正整数 $n(1\\leq n \\leq 500)$ 表示这是一个 $n \\times n$ 的矩阵。\n\n第 $2$ 到 $n+1$ 行，一个矩阵表示受力下界 $l$。\n\n第 $n+2$ 到第 $2n+1$ 行，又一个矩阵表示受力上界 $r$。", "outputFormat": "如果无解，直接输出 ```-1```。\n\n否则：\n\n第一行 $n$ 个数，表示横排钢丝的受力 $x_1,...,x_n$。\n\n第二行 $n$ 个数，表示竖排钢丝的受力 $y_1,...,y_n$。\n\n**注意如有多组答案，请输出字典序最小的一组。**", "hint": "**样例 1 解释：** 可能有另一组解 $x_1=2,x_2=2,y_1=0,y_2=3$，但是 $\\{0,0\\},\\{2,5\\}$ 是一组字典序更小的解，且能证明字典序最小。\n\n对于 $10\\%$ 的数据，保证 $1\\leq n\\leq 7,0 \\leq r_{i,j}\\leq 7$。\n\n对于 $20\\%$ 的数据，保证 $1\\leq n\\leq 50$，$1 \\leq l_{i,j}\\leq r_{i,j} \\leq 200$。\n\n对于 $40\\%$ 的数据，保证 $1\\leq n\\leq 200$。\n\n对于另外 $20\\%$ 的数据，保证 $l_{i,j}=r_{i,j}$。\n\n对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 500$，$0 \\leq l_{i,j} \\leq r_{i,j} \\leq 10^9$。\n\n**请注意常数给程序带来的运行效率影响。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "受力分析 Force", "background": "还在写题的 Comentropy 突然收到了挑战，竟然是一道力学题！他感到震惊，一看到数据范围就知道该怎么写了，但是过程冗长，于是找到你帮他精简一下。\n\n注：本题没有严格的物理理论基础，且本题并不要求物理基础。\n\n**建议阅读形式化题意。**", "description": "现在有 $n\\times n$ 个正方体物块摆成一个方阵，物块有自己的重量，你现在需要控制它们平衡不动。这就要求对于第 $i$ 行第 $j$ 列的物块，它底面受到的支持力在区间 $[l_{i,j},r_{i,j}]$ 中。\n\n出题人们给出横纵方向各 $n$ 根钢丝用以给底面支持力，并把物块放置在钢丝交点处。现在你可以给这 $2n$ 根钢丝分别施加力。（注意同一根钢丝处处的力是相同的）\n\n规定：在数值上，物块受到的支持力就是你施加给其下的两根钢丝的力的和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/shg5p17w.png)\n\n如图，有两组钢丝一组横着放，施加给它们的力分别是：$[x_1,x_2,\\dots,x_n]$；一组竖着放，施加给它们的力分别是：$[y_1,y_2,\\dots,y_n]$，交点 $(i,j)$ 处的合力即为：$x_i+y_j$。\n\n请你求出每根钢丝的使用力的情况。出题人们为了难倒 Comentropy，还要求序列 $[x_1,x_2,\\dots,x_n,y_1,y_2\\dots,y_n]$ 的字典序最小。你能帮他处理这个问题吗？\n\n**每个力都应当是非负整数，方向向上。**\n\n**形式化地**：\n给出两个 $n\\times n$ 的矩阵 $l,r$，要求 $l_{i,j}\\leq x_i+y_j \\leq r_{i,j}$，求一个字典序最小的非负整数解的序列 $\\{x\\}$, $\\{y\\}$（把 $x$ 和 $y$ 的序列并起来 $[x_1,x_2,\\dots,x_n,y_1,y_2,\\dots,y_n]$ 的字典序最小）。", "inputFormat": "第一行，一个正整数 $n(1\\leq n \\leq 500)$ 表示这是一个 $n \\times n$ 的矩阵。\n\n第 $2$ 到 $n+1$ 行，一个矩阵表示受力下界 $l$。\n\n第 $n+2$ 到第 $2n+1$ 行，又一个矩阵表示受力上界 $r$。", "outputFormat": "如果无解，直接输出 ```-1```。\n\n否则：\n\n第一行 $n$ 个数，表示横排钢丝的受力 $x_1,...,x_n$。\n\n第二行 $n$ 个数，表示竖排钢丝的受力 $y_1,...,y_n$。\n\n**注意如有多组答案，请输出字典序最小的一组。**", "hint": "**样例 1 解释：** 可能有另一组解 $x_1=2,x_2=2,y_1=0,y_2=3$，但是 $\\{0,0\\},\\{2,5\\}$ 是一组字典序更小的解，且能证明字典序最小。\n\n对于 $10\\%$ 的数据，保证 $1\\leq n\\leq 7,0 \\leq r_{i,j}\\leq 7$。\n\n对于 $20\\%$ 的数据，保证 $1\\leq n\\leq 50$，$1 \\leq l_{i,j}\\leq r_{i,j} \\leq 200$。\n\n对于 $40\\%$ 的数据，保证 $1\\leq n\\leq 200$。\n\n对于另外 $20\\%$ 的数据，保证 $l_{i,j}=r_{i,j}$。\n\n对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 500$，$0 \\leq l_{i,j} \\leq r_{i,j} \\leq 10^9$。\n\n**请注意常数给程序带来的运行效率影响。**", "locale": "zh-CN"}}}
{"pid": "P12977", "type": "P", "difficulty": 5, "samples": [["4\na??a", "15\n"], ["10\n?a?aa?a?a?", "115"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "Manacher 算法"], "title": "泪雨 Namid[A]me", "background": "> 涙目 変わらずの雨模様\\\n泪眼不变的烟雨迷蒙\\\nその夢の淵ギリギリで\\\n在那梦的深渊倾盆而下\\\n—— ヒトリエ《Namid[A]me》\n\n最终，只剩我一人了。", "description": "给定小写英文字母和 ```?``` 组成的字符串 $s$。\n\n“泪雨”定义为这样的串：这是一个回文串，并且 ```?``` 的个数大于等于小写英文字符的个数。\n\n请对于是“泪雨”的 $s$ 的所有子串，求出它们问号位置的和之和。（位置下标从 $1$ 开始）\n\n**形式化题意**：定义：\n$$\nf(l,r)=\n\\sum_{i=l}^{r} [s_i=\\texttt{?}]\\cdot i\n\\\\\ng(l,r)=\\big[\\sum_{i=l}^r{[s_i=\\texttt{?}] \\geq} \\frac{r-l+1}{2}\\big]\\big[ s[l,r]\\text{ is a palindrome} \\big]\n$$\n\n请你求出 $\\sum_{l=1}^{n} \\sum_{r=l}^{n} g(l,r)\\cdot f(l,r)$，其中 $n=\\lvert s\\rvert$。", "inputFormat": "第一行一个正整数 $n$，表示 $s$ 的长度 $n$。\n\n第二行输入仅由小写英文字母和问号组成的字符串 $s$。", "outputFormat": "一行一个正整数，表示答案。", "hint": "**样例解释：** 样例 $1$ 中，$[2,2],[3,3],[1,4],[2,3]$ 都是符合要求的回文串，并且所求的问号位置之和为 $2+3+(2+3)+(2+3)=15$。\n\n以下是数据范围。\n\n| Subtask | $n$ | 特殊性质 | 分值 | 子任务依赖 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 500$ | 无 | $10$ | - |\n| $2$ | $\\leq 7000$ | 无 | $15$ | $1$ |\n| $3$ | $\\leq 2\\times 10^6$ | $s$ 中仅有 ```?``` | $5$ | - |\n| $4$ | $\\leq 2\\times 10^6$ | 字符串随机生成 | $10$ | $1$ |\n| $5$ | $\\leq 2\\times 10^6$ | $s$ 中有且仅有两种字符 | $10$ | - |\n| $6$ | $\\leq 3\\times 10^5$ | 无 | $15$ | $1,2$ |\n| $7$ | $\\leq2\\times 10^6$ | 无 | $15$ | $1\\sim 6$ |\n| $8$ | $\\leq 5\\times10^6$ | $\\text{timelimit}=1.5s$ | $20$ | $1\\sim 7$ |\n\n对于 $100\\%$ 的数据满足 $1\\leq n\\leq 5\\times 10^6$，且 $s$ 仅包含小写英文字母和 ```?```。\n\n除了 $\\text{subtask 8}$ 之外，时限皆为 $1s$。\n\n时间限制已开到了 std 的 2 倍以上，空间限制开到了 std 的 1.25 倍以上，但仍需 **注意程序的运行时空常数**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "泪雨 Namid[A]me", "background": "> 涙目 変わらずの雨模様\\\n泪眼不变的烟雨迷蒙\\\nその夢の淵ギリギリで\\\n在那梦的深渊倾盆而下\\\n—— ヒトリエ《Namid[A]me》\n\n最终，只剩我一人了。", "description": "给定小写英文字母和 ```?``` 组成的字符串 $s$。\n\n“泪雨”定义为这样的串：这是一个回文串，并且 ```?``` 的个数大于等于小写英文字符的个数。\n\n请对于是“泪雨”的 $s$ 的所有子串，求出它们问号位置的和之和。（位置下标从 $1$ 开始）\n\n**形式化题意**：定义：\n$$\nf(l,r)=\n\\sum_{i=l}^{r} [s_i=\\texttt{?}]\\cdot i\n\\\\\ng(l,r)=\\big[\\sum_{i=l}^r{[s_i=\\texttt{?}] \\geq} \\frac{r-l+1}{2}\\big]\\big[ s[l,r]\\text{ is a palindrome} \\big]\n$$\n\n请你求出 $\\sum_{l=1}^{n} \\sum_{r=l}^{n} g(l,r)\\cdot f(l,r)$，其中 $n=\\lvert s\\rvert$。", "inputFormat": "第一行一个正整数 $n$，表示 $s$ 的长度 $n$。\n\n第二行输入仅由小写英文字母和问号组成的字符串 $s$。", "outputFormat": "一行一个正整数，表示答案。", "hint": "**样例解释：** 样例 $1$ 中，$[2,2],[3,3],[1,4],[2,3]$ 都是符合要求的回文串，并且所求的问号位置之和为 $2+3+(2+3)+(2+3)=15$。\n\n以下是数据范围。\n\n| Subtask | $n$ | 特殊性质 | 分值 | 子任务依赖 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 500$ | 无 | $10$ | - |\n| $2$ | $\\leq 7000$ | 无 | $15$ | $1$ |\n| $3$ | $\\leq 2\\times 10^6$ | $s$ 中仅有 ```?``` | $5$ | - |\n| $4$ | $\\leq 2\\times 10^6$ | 字符串随机生成 | $10$ | $1$ |\n| $5$ | $\\leq 2\\times 10^6$ | $s$ 中有且仅有两种字符 | $10$ | - |\n| $6$ | $\\leq 3\\times 10^5$ | 无 | $15$ | $1,2$ |\n| $7$ | $\\leq2\\times 10^6$ | 无 | $15$ | $1\\sim 6$ |\n| $8$ | $\\leq 5\\times10^6$ | $\\text{timelimit}=1.5s$ | $20$ | $1\\sim 7$ |\n\n对于 $100\\%$ 的数据满足 $1\\leq n\\leq 5\\times 10^6$，且 $s$ 仅包含小写英文字母和 ```?```。\n\n除了 $\\text{subtask 8}$ 之外，时限皆为 $1s$。\n\n时间限制已开到了 std 的 2 倍以上，空间限制开到了 std 的 1.25 倍以上，但仍需 **注意程序的运行时空常数**。", "locale": "zh-CN"}}}
{"pid": "P12978", "type": "P", "difficulty": 7, "samples": [["5 5\n4 3 1 10\n4 1 1 8\n1 1 2 6\n5 0 1 8\n3 1 2 10\n2 1 3\n4 4 4\n3 1 5\n2 1 2\n1 3 4\n", "18\n0\n16\n18\n8\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["分块"], "title": "流星雨 Meteor", "background": "> 星の流れる夜に\n星光流动的夜裡\\\n北風が通りを吹き抜け\n北风穿越过街道\\\n待ち人から便りはなく\n所盼之人音讯全无\\\n明くる日を描くだけ\n单单描画翌日之像\\\n星は願いを乗せて\n繁星承载祈愿\\\nあの空を静かに散り行き\n宁静漫步夜空\\\n——じょん / 初音ミク《メテオ》\n\n题外话：现在你看到的是这个题目修改后的版本，其初始版本不太可做（各种方面），有兴趣的可以看看原先出的 [二维版本](https://www.luogu.com.cn/paste/2074cza5)。", "description": "现在你坐在观星台的监视屏幕前，这是一个 $n\\times n$ 的屏幕，这个屏幕的信号转换算法相当老旧，所以不在整像素点上的流星将被暂时忽略直到它出现在整点上。正是流星雨爆发的时候，你调整屏幕使得流星雨像是瀑布一样向正下飞去。\n\n恰好共有 $n$ 颗流星。为了方便，我们给流星依次标号，并以左下角为原点，将屏幕看作平面直角坐标系的第一象限。对第 $i$ 颗流星，有一个一开始能够被监测到的起点，$(x_i,y_i)$（是整点，此时是第 $0$ 时刻）；也有一个平行于 $y$ 轴且向下做匀速直线运动的速度，用 $(v_i,t_i)$ 表示每 $t_i$ 秒运动 $v_i$ 个像素。**此外，我们保证 $x_i=i$**。同时每个流星还有一个权值 $a_i$ 表示它的神秘学参数。\n\n繁星承载着祈愿，但同时彗星在古代被称作灾难的象征，为了提前预知，你找来了魔法师来占卜。你为他锁定了 $Q$ 次观星台的镜头，找出可能的灾厄。镜头拍出的画面是一个会调整大小的矩形。为了让他提前准备，你需要确定他至少要对屏幕上的流星施法几次，这和流星的神秘学参数相关，也就是：\n\n- 在某一时刻 $T_j$，确定当前纵坐标在某个区间内，且落在整点上的流星的权值 $a_i$ 的和；\n\n由于法师过来还需要一会儿，所以允许你把问题离线。", "inputFormat": "第一行两个整数 $n,Q$，分别表示流星数量（同时也是屏幕尺寸），和询问次数。\n\n第二行到第 $n+1$ 行，每行四个整数 $y_i,v_i,t_i,a_i$ 表示流星的起始坐标、速度，以及神秘学参数。\n\n接下来 $Q$ 行，每行三个整数 $(T_j,l_j,r_j)$ 表示询问时刻 $T_j$ 时纵坐标在 $[l_j,r_j]$ 内的流星的神秘学权值和。\n\n悬赏：如果有人能发现区间询问的非常好的做法，请告知出题人。（即查询编号在某个区间内的答案）", "outputFormat": "一共 $Q$ 行，每行一个非负整数，表示询问的答案。", "hint": "以下是数据范围。\n\n| Subtask | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n,Q\\leq 5000$ | $10$ |\n| $2$ | 均匀随机生成 $t_i$ | $20$ |\n| $3$ | 保证 $T_j$ 均匀随机生成，$a_i=1$ | $25$ |\n| $4$ | 无特殊性质；依赖前三个子任务 | $45$ |\n\n对于所有的数据，保证 $n\\leq  10^5,Q\\leq3\\times 10^5 $，且 $0\\leq v_i<n$，$1\\leq t_i,T_j,l_j,r_j\\leq n$，**以及 $v_i,t_i$ 互质**，$1\\leq a_i\\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "流星雨 Meteor", "background": "> 星の流れる夜に\n星光流动的夜裡\\\n北風が通りを吹き抜け\n北风穿越过街道\\\n待ち人から便りはなく\n所盼之人音讯全无\\\n明くる日を描くだけ\n单单描画翌日之像\\\n星は願いを乗せて\n繁星承载祈愿\\\nあの空を静かに散り行き\n宁静漫步夜空\\\n——じょん / 初音ミク《メテオ》\n\n题外话：现在你看到的是这个题目修改后的版本，其初始版本不太可做（各种方面），有兴趣的可以看看原先出的 [二维版本](https://www.luogu.com.cn/paste/2074cza5)。", "description": "现在你坐在观星台的监视屏幕前，这是一个 $n\\times n$ 的屏幕，这个屏幕的信号转换算法相当老旧，所以不在整像素点上的流星将被暂时忽略直到它出现在整点上。正是流星雨爆发的时候，你调整屏幕使得流星雨像是瀑布一样向正下飞去。\n\n恰好共有 $n$ 颗流星。为了方便，我们给流星依次标号，并以左下角为原点，将屏幕看作平面直角坐标系的第一象限。对第 $i$ 颗流星，有一个一开始能够被监测到的起点，$(x_i,y_i)$（是整点，此时是第 $0$ 时刻）；也有一个平行于 $y$ 轴且向下做匀速直线运动的速度，用 $(v_i,t_i)$ 表示每 $t_i$ 秒运动 $v_i$ 个像素。**此外，我们保证 $x_i=i$**。同时每个流星还有一个权值 $a_i$ 表示它的神秘学参数。\n\n繁星承载着祈愿，但同时彗星在古代被称作灾难的象征，为了提前预知，你找来了魔法师来占卜。你为他锁定了 $Q$ 次观星台的镜头，找出可能的灾厄。镜头拍出的画面是一个会调整大小的矩形。为了让他提前准备，你需要确定他至少要对屏幕上的流星施法几次，这和流星的神秘学参数相关，也就是：\n\n- 在某一时刻 $T_j$，确定当前纵坐标在某个区间内，且落在整点上的流星的权值 $a_i$ 的和；\n\n由于法师过来还需要一会儿，所以允许你把问题离线。", "inputFormat": "第一行两个整数 $n,Q$，分别表示流星数量（同时也是屏幕尺寸），和询问次数。\n\n第二行到第 $n+1$ 行，每行四个整数 $y_i,v_i,t_i,a_i$ 表示流星的起始坐标、速度，以及神秘学参数。\n\n接下来 $Q$ 行，每行三个整数 $(T_j,l_j,r_j)$ 表示询问时刻 $T_j$ 时纵坐标在 $[l_j,r_j]$ 内的流星的神秘学权值和。\n\n悬赏：如果有人能发现区间询问的非常好的做法，请告知出题人。（即查询编号在某个区间内的答案）", "outputFormat": "一共 $Q$ 行，每行一个非负整数，表示询问的答案。", "hint": "以下是数据范围。\n\n| Subtask | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n,Q\\leq 5000$ | $10$ |\n| $2$ | 均匀随机生成 $t_i$ | $20$ |\n| $3$ | 保证 $T_j$ 均匀随机生成，$a_i=1$ | $25$ |\n| $4$ | 无特殊性质；依赖前三个子任务 | $45$ |\n\n对于所有的数据，保证 $n\\leq  10^5,Q\\leq3\\times 10^5 $，且 $0\\leq v_i<n$，$1\\leq t_i,T_j,l_j,r_j\\leq n$，**以及 $v_i,t_i$ 互质**，$1\\leq a_i\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P12979", "type": "P", "difficulty": 2, "samples": [["3\n3 4\n2 2\n2 3", "Case #1:\n..+-+-+-+\n..|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\nCase #2:\n..+-+\n..|.|\n+-+-+\n|.|.|\n+-+-+\nCase #3:\n..+-+-+\n..|.|.|\n+-+-+-+\n|.|.|.|\n+-+-+-+"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["2022", "Google Code Jam"], "title": "[GCJ 2022 Qualification] Punched Cards", "background": "", "description": "A secret team of programmers is plotting to disrupt the programming language landscape and bring punched cards back by introducing a new language called Punched Card Python that lets people code in Python using punched cards! Like good disrupters, they are going to launch a viral campaign to promote their new language before even having the design for a prototype. For the campaign, they want to draw punched cards of different sizes in ASCII art.\n\nThe ASCII art of a punched card they want to draw is similar to an $\\mathbf{R} \\times \\mathbf{C}$ matrix without the top-left cell. That means, it has $(\\mathbf{R} \\cdot \\mathbf{C}) - 1$ cells in total. Each cell is drawn in ASCII art as a period (.) surrounded by dashes (-) above and below, pipes (|) to the left and right, and plus signs (+) for each corner. Adjacent cells share the common characters in the border. Periods (.) are used to align the cells in the top row.\n\nFor example, the following is a punched card with $\\mathbf{R} = 3$ rows and $\\mathbf{C} = 4$ columns:\n\n```\n..+-+-+-+\n..|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n```\n\nThere are more examples with other sizes in the samples below. Given the integers $\\mathbf{R}$ and $\\mathbf{C}$ describing the size of a punched card, print the ASCII art drawing of it as described above.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each describing a different test case with two integers $\\mathbf{R}$ and $\\mathbf{C}$: the number of rows and columns of the punched card that must be drawn.\n", "outputFormat": "For each test case, output one line containing `Case #x:`, where $x$ is the test case number (starting from 1). Then, output $(2 \\cdot \\mathbf{R}) + 1$ additional lines with the ASCII art drawing of a punched card with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement. Sample Cases #2 and #3 are additional examples. Notice that the output for each case contains exactly $\\mathbf{R} \\cdot \\mathbf{C} + 3$ periods.\n\n**Limits**\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 81$.\n- $2 \\leq \\mathbf{R} \\leq 10$.\n- $2 \\leq \\mathbf{C} \\leq 10$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Qualification] Punched Cards", "background": "", "description": "A secret team of programmers is plotting to disrupt the programming language landscape and bring punched cards back by introducing a new language called Punched Card Python that lets people code in Python using punched cards! Like good disrupters, they are going to launch a viral campaign to promote their new language before even having the design for a prototype. For the campaign, they want to draw punched cards of different sizes in ASCII art.\n\nThe ASCII art of a punched card they want to draw is similar to an $\\mathbf{R} \\times \\mathbf{C}$ matrix without the top-left cell. That means, it has $(\\mathbf{R} \\cdot \\mathbf{C}) - 1$ cells in total. Each cell is drawn in ASCII art as a period (.) surrounded by dashes (-) above and below, pipes (|) to the left and right, and plus signs (+) for each corner. Adjacent cells share the common characters in the border. Periods (.) are used to align the cells in the top row.\n\nFor example, the following is a punched card with $\\mathbf{R} = 3$ rows and $\\mathbf{C} = 4$ columns:\n\n```\n..+-+-+-+\n..|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n```\n\nThere are more examples with other sizes in the samples below. Given the integers $\\mathbf{R}$ and $\\mathbf{C}$ describing the size of a punched card, print the ASCII art drawing of it as described above.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each describing a different test case with two integers $\\mathbf{R}$ and $\\mathbf{C}$: the number of rows and columns of the punched card that must be drawn.\n", "outputFormat": "For each test case, output one line containing `Case #x:`, where $x$ is the test case number (starting from 1). Then, output $(2 \\cdot \\mathbf{R}) + 1$ additional lines with the ASCII art drawing of a punched card with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement. Sample Cases #2 and #3 are additional examples. Notice that the output for each case contains exactly $\\mathbf{R} \\cdot \\mathbf{C} + 3$ periods.\n\n**Limits**\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 81$.\n- $2 \\leq \\mathbf{R} \\leq 10$.\n- $2 \\leq \\mathbf{C} \\leq 10$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Qualification] Punched Cards", "background": "", "description": "一个秘密程序员团队正计划颠覆编程语言的格局，通过引入一种名为 **Punched Card Python** 的新语言让穿孔卡片重出江湖！这种语言允许人们使用穿孔卡片编写 Python 代码。像优秀的颠覆者一样，他们甚至还没有原型设计，就准备发起一场病毒式营销活动来推广这门新语言。为了这场活动，他们需要用 ASCII 艺术绘制不同尺寸的穿孔卡片。\n\n他们想要绘制的穿孔卡片的 ASCII 艺术类似于一个没有左上角单元格的 $\\mathbf{R} \\times \\mathbf{C}$ 矩阵。也就是说，总共有 $(\\mathbf{R} \\cdot \\mathbf{C}) - 1$ 个单元格。每个单元格在 ASCII 艺术中被绘制为一个由上下短横线（-）、左右竖线（|）、角落加号（+）包围的句点（.）。相邻单元格共享边框上的共同字符。句点（.）用于对齐顶行的单元格。\n\n例如，以下是一个 $\\mathbf{R} = 3$ 行、$\\mathbf{C} = 4$ 列的穿孔卡片：\n\n```\n..+-+-+-+\n..|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n```\n\n下方样例中还有其他尺寸的示例。给定描述穿孔卡片尺寸的整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，按照上述要求打印其 ASCII 艺术绘图。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行描述一个不同的测试用例，包含两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$：表示需要绘制的穿孔卡片的行数和列数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x:`，其中 $x$ 是测试用例编号（从 1 开始）。然后，额外输出 $(2 \\cdot \\mathbf{R}) + 1$ 行，包含 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列穿孔卡片的 ASCII 艺术绘图。\n", "hint": "**样例解释**\n\n样例 #1 是题目描述中的示例。样例 #2 和 #3 是额外示例。注意，每个用例的输出恰好包含 $\\mathbf{R} \\cdot \\mathbf{C} + 3$ 个句点。\n\n**限制条件**\n\n**测试集 1（11 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{T} \\leq 81$。\n- $2 \\leq \\mathbf{R} \\leq 10$。\n- $2 \\leq \\mathbf{C} \\leq 10$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12980", "type": "P", "difficulty": 2, "samples": [["3\n300000 200000 300000 500000\n300000 200000 500000 300000\n300000 500000 300000 200000\n1000000 1000000 0 0\n0 1000000 1000000 1000000\n999999 999999 999999 999999\n768763 148041 178147 984173\n699508 515362 534729 714381\n949704 625054 946212 951187", "Case #1: 300000 200000 300000 200000\nCase #2: IMPOSSIBLE\nCase #3: 400001 100002 100003 399994"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2022", "Special Judge", "Google Code Jam"], "title": "[GCJ 2022 Qualification] 3D Printing", "background": "", "description": "You are part of the executive committee of the Database Design Day festivities. You are in charge of promotions and want to print three D's to create a logo of the contest. You can choose any color you want to print them, but all three have to be printed in the same color.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n2ye797y.png)\n\nYou were given three printers and will use each one to print one of the D's. All printers use ink from 4 individual cartridges of different colors (cyan, magenta, yellow, and black) to form any color. For these printers, a color is uniquely defined by 4 non-negative integers $c$, $m$, $y$, and $k$, which indicate the number of ink units of cyan, magenta, yellow, and black ink (respectively) needed to make the color.\n\nThe total amount of ink needed to print a single D is exactly $10^6$ units. For example, printing a D in pure yellow would use $10^6$ units of yellow ink and $0$ from all others. Printing a D in the Code Jam red uses $0$ units of cyan ink, $500000$ units of magenta ink, $450000$ units of yellow ink, and $50000$ units of black ink.\n\nTo print a color, a printer must have at least the required amount of ink for each of its $4$ color cartridges. Given the number of units of ink each printer has in each cartridge, output any color, defined as $4$ non-negative integers that add up to $10^6$, such that all three printers have enough ink to print it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 3 lines. The $i$-th line of a test case contains 4 integers $\\mathbf{C}_i$, $\\mathbf{M}_i$, $\\mathbf{Y}_i$, and $\\mathbf{K}_i$, representing the number of ink units in the $i$-th printer's cartridge for the colors cyan, magenta, yellow, and black, respectively.\n", "outputFormat": "For each test case, output one line containing case #$x$: $r$, where $x$ is the test case number (starting from 1) and $r$ is IMPOSSIBLE if there is no color that can be printed by all 3 printers. Otherwise, $r$ must be equal to \"$c$ $m$ $y$ $k$\" where $c$, $m$, $y$, and $k$ are non-negative integers that add up to $10^6$ and $c \\leq \\mathbf{C}_i$, $m \\leq \\mathbf{M}_i$, $y \\leq \\mathbf{Y}_i$, and $k \\leq \\mathbf{K}_i$, for all $i$.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is the image provided above. The proposed color is using up all of the ink in the cyan, magenta, and yellow cartridges of the first printer and all of the ink in the black cartridge of the last printer. This means that no additional unit of ink could be used from any of the 4 ink colors, so the given sample output is the only possible output for this case.\n\nIn Sample Case #2, magenta is the only color that both the first and second printers have, so our only chance would be to use $10^6$ units of magenta. Unfortunately, the third printer does not have quite enough, making this case impossible.\n\nIn Sample Case #3, other correct outputs are: \"400000 100000 100000 400000\", \"300000 0 0 700000\", and \"350000 140000 160000 350000\", among lots of others. Notice that \"300000 140000 160000 700000\" would not be a valid answer because, even though there is enough ink in all printers to do that, the total number of ink units must be exactly $10^6$.\n\n**Limits**\n\n**Test Set 1 (Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{C}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{M}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{Y}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{K}_i \\leq 10^6$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Qualification] 3D Printing", "background": "", "description": "You are part of the executive committee of the Database Design Day festivities. You are in charge of promotions and want to print three D's to create a logo of the contest. You can choose any color you want to print them, but all three have to be printed in the same color.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n2ye797y.png)\n\nYou were given three printers and will use each one to print one of the D's. All printers use ink from 4 individual cartridges of different colors (cyan, magenta, yellow, and black) to form any color. For these printers, a color is uniquely defined by 4 non-negative integers $c$, $m$, $y$, and $k$, which indicate the number of ink units of cyan, magenta, yellow, and black ink (respectively) needed to make the color.\n\nThe total amount of ink needed to print a single D is exactly $10^6$ units. For example, printing a D in pure yellow would use $10^6$ units of yellow ink and $0$ from all others. Printing a D in the Code Jam red uses $0$ units of cyan ink, $500000$ units of magenta ink, $450000$ units of yellow ink, and $50000$ units of black ink.\n\nTo print a color, a printer must have at least the required amount of ink for each of its $4$ color cartridges. Given the number of units of ink each printer has in each cartridge, output any color, defined as $4$ non-negative integers that add up to $10^6$, such that all three printers have enough ink to print it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 3 lines. The $i$-th line of a test case contains 4 integers $\\mathbf{C}_i$, $\\mathbf{M}_i$, $\\mathbf{Y}_i$, and $\\mathbf{K}_i$, representing the number of ink units in the $i$-th printer's cartridge for the colors cyan, magenta, yellow, and black, respectively.\n", "outputFormat": "For each test case, output one line containing case #$x$: $r$, where $x$ is the test case number (starting from 1) and $r$ is IMPOSSIBLE if there is no color that can be printed by all 3 printers. Otherwise, $r$ must be equal to \"$c$ $m$ $y$ $k$\" where $c$, $m$, $y$, and $k$ are non-negative integers that add up to $10^6$ and $c \\leq \\mathbf{C}_i$, $m \\leq \\mathbf{M}_i$, $y \\leq \\mathbf{Y}_i$, and $k \\leq \\mathbf{K}_i$, for all $i$.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is the image provided above. The proposed color is using up all of the ink in the cyan, magenta, and yellow cartridges of the first printer and all of the ink in the black cartridge of the last printer. This means that no additional unit of ink could be used from any of the 4 ink colors, so the given sample output is the only possible output for this case.\n\nIn Sample Case #2, magenta is the only color that both the first and second printers have, so our only chance would be to use $10^6$ units of magenta. Unfortunately, the third printer does not have quite enough, making this case impossible.\n\nIn Sample Case #3, other correct outputs are: \"400000 100000 100000 400000\", \"300000 0 0 700000\", and \"350000 140000 160000 350000\", among lots of others. Notice that \"300000 140000 160000 700000\" would not be a valid answer because, even though there is enough ink in all printers to do that, the total number of ink units must be exactly $10^6$.\n\n**Limits**\n\n**Test Set 1 (Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{C}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{M}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{Y}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{K}_i \\leq 10^6$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Qualification] 3D Printing", "background": "", "description": "你是数据库设计日庆祝活动的组委会成员之一，负责宣传工作，并计划打印三个 **D** 字来设计比赛标志。你可以选择任何颜色打印它们，但所有三个 **D** 必须使用相同的颜色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n2ye797y.png)\n\n你拿到了三台打印机，每台将用于打印其中一个 **D**。所有打印机都使用 4 种不同颜色（青色、品红色、黄色和黑色）的独立墨盒来调配颜色。对于这些打印机，一种颜色由 4 个非负整数 $c$、$m$、$y$ 和 $k$ 唯一确定，分别表示调配该颜色所需的青色、品红色、黄色和黑色墨水的单位数。\n\n打印单个 **D** 所需的墨水总量恰好是 $10^6$ 单位。例如，纯黄色打印一个 **D** 需要 $10^6$ 单位黄色墨水，其余颜色为 $0$；而用 Code Jam 红色打印则需要 $0$ 单位青色墨水、$500000$ 单位品红色墨水、$450000$ 单位黄色墨水和 $50000$ 单位黑色墨水。\n\n要打印某种颜色，打印机必须在每个颜色的墨盒中至少有该颜色所需的墨水单位数。给定每台打印机各墨盒中的墨水单位数，输出任意一种满足以下条件的颜色（定义为 4 个非负整数，其和为 $10^6$）：所有三台打印机均有足够墨水打印该颜色。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含 3 行，第 $i$ 行包含 4 个整数 $\\mathbf{C}_i$、$\\mathbf{M}_i$、$\\mathbf{Y}_i$ 和 $\\mathbf{K}_i$，分别表示第 $i$ 台打印机的青色、品红色、黄色和黑色墨盒中的墨水单位数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: r`，其中 $x$ 是测试用例编号（从 1 开始），$r$ 为 `IMPOSSIBLE`（如果不存在所有三台打印机均可打印的颜色），否则 $r$ 应为 `\"c m y k\"`。这里 $c$、$m$、$y$ 和 $k$ 是非负整数，满足 $c + m + y + k = 10^6$，且对于所有 $i$ 有 $c \\leq \\mathbf{C}_i$、$m \\leq \\mathbf{M}_i$、$y \\leq \\mathbf{Y}_i$ 和 $k \\leq \\mathbf{K}_i$。\n\n若存在多组解，输出任意一组均可。", "hint": "\n## 说明/提示\n\n**样例解释**\n\n样例 #1 对应题目描述中的图片。给出的颜色方案用尽了第一台打印机的青色、品红色和黄色墨盒的所有墨水，以及最后一台打印机的黑色墨盒的所有墨水。这意味着无法再从任何颜色的墨盒中多用一单位墨水，因此该样例输出是此案例唯一可能的解。\n\n在样例 #2 中，品红色是前两台打印机唯一共有的颜色，因此唯一可能的方案是使用 $10^6$ 单位品红色墨水。但第三台打印机的品红色墨水不足，导致此案例无解。\n\n在样例 #3 中，其他正确输出包括 `\"400000 100000 100000 400000\"`、`\"300000 0 0 700000\"` 和 `\"350000 140000 160000 350000\"` 等。注意 `\"300000 140000 160000 700000\"` 不是有效答案，因为尽管所有打印机均有足够墨水，但墨水单位总数必须严格等于 $10^6$。\n\n**限制条件**\n\n**测试集 1（可见评测结果）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $0 \\leq \\mathbf{C}_i \\leq 10^6$，对所有 $i$ 成立。\n- $0 \\leq \\mathbf{M}_i \\leq 10^6$，对所有 $i$ 成立。\n- $0 \\leq \\mathbf{Y}_i \\leq 10^6$，对所有 $i$ 成立。\n- $0 \\leq \\mathbf{K}_i \\leq 10^6$，对所有 $i$ 成立。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12981", "type": "P", "difficulty": 2, "samples": [["4\n4\n6 10 12 8\n6\n5 4 5 4 4 4\n10\n10 10 7 6 7 4 4 5 7 4\n1\n10", "Case #1: 4\nCase #2: 5\nCase #3: 9\nCase #4: 1"]], "limits": {"time": [5000, 5000, 15000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2022", "排序", "Google Code Jam"], "title": "[GCJ 2022 Qualification] d1000000", "background": "", "description": "While the most typical type of dice have 6 sides, each of which shows a different integer 1 through 6, there are many games that use other types. In particular, a $d_k$ is a die with $k$ sides, each of which shows a different integer 1 through $k$. A $d6$ is a typical die, a $d4$ has four sides, and a $d1000000$ has one million sides.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b9fu60so.png)\n\nIn this problem, we start with a collection of $\\mathbf{N}$ dice. The $i$-th die is a $d\\mathbf{S}_i$, that is, it has $\\mathbf{S}_i$ sides showing integers 1 through $\\mathbf{S}_i$. A straight of length $\\ell$ starting at $x$ is the list of integers $x$, $x + 1$, $\\cdots$, $x + (\\ell - 1)$. We want to choose some of the dice (possibly all) and pick one number from each to form a straight. What is the longest straight we can form in this way?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The firstline of a test case contains a single integer $\\mathbf{N}$, the number of dice in the game. The second line contains $\\mathbf{N}$ integers $\\mathbf{S}_1$, $\\mathbf{S}_2$, $\\cdots$, $\\mathbf{S}_\\mathbf{N}$, each representing the number of sides of a different die.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of input dice that can be put in a straight.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are multiple ways to form a straight using all $4$ dice. One possible way is shown in the image above.\n\nIn Sample Case #2, since none of the dice can show an integer greater than $5$, there is no way to have a straight with more than $5$ dice. There are multiple ways to form a straight with exactly $5$ dice. For example, pick the integers $4$ and $5$ for both $d5$'s and then integers $1, 2$, and $3$ for three of the $d4$'s to form $1, 2, 3, 4, 5$.\n\nIn Sample Case #3, it is possible to form the straight $1, 2, 3, 4, 5, 6, 7, 8, 9$ by discarding one $d4$ and using the $d4$'s, $d5$, and $d6$ to get $1$ through $4$; the $d7$'s to get $5$ through $7$; and the $d10$'s to get $8$ and $9$. There is no way to form a straight of length $10$, so this is the best that can be done.\n\nIn Sample Case #4, we can only form a straight of length $1$, but we can do so by picking any integer for the $d10$ we are given.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10$.\n- $4 \\leq \\mathbf{S}_i \\leq 20$, for all $i$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^5$.\n- $4 \\leq \\mathbf{S}_i \\leq 10^6$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Qualification] d1000000", "background": "", "description": "While the most typical type of dice have 6 sides, each of which shows a different integer 1 through 6, there are many games that use other types. In particular, a $d_k$ is a die with $k$ sides, each of which shows a different integer 1 through $k$. A $d6$ is a typical die, a $d4$ has four sides, and a $d1000000$ has one million sides.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b9fu60so.png)\n\nIn this problem, we start with a collection of $\\mathbf{N}$ dice. The $i$-th die is a $d\\mathbf{S}_i$, that is, it has $\\mathbf{S}_i$ sides showing integers 1 through $\\mathbf{S}_i$. A straight of length $\\ell$ starting at $x$ is the list of integers $x$, $x + 1$, $\\cdots$, $x + (\\ell - 1)$. We want to choose some of the dice (possibly all) and pick one number from each to form a straight. What is the longest straight we can form in this way?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The firstline of a test case contains a single integer $\\mathbf{N}$, the number of dice in the game. The second line contains $\\mathbf{N}$ integers $\\mathbf{S}_1$, $\\mathbf{S}_2$, $\\cdots$, $\\mathbf{S}_\\mathbf{N}$, each representing the number of sides of a different die.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of input dice that can be put in a straight.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are multiple ways to form a straight using all $4$ dice. One possible way is shown in the image above.\n\nIn Sample Case #2, since none of the dice can show an integer greater than $5$, there is no way to have a straight with more than $5$ dice. There are multiple ways to form a straight with exactly $5$ dice. For example, pick the integers $4$ and $5$ for both $d5$'s and then integers $1, 2$, and $3$ for three of the $d4$'s to form $1, 2, 3, 4, 5$.\n\nIn Sample Case #3, it is possible to form the straight $1, 2, 3, 4, 5, 6, 7, 8, 9$ by discarding one $d4$ and using the $d4$'s, $d5$, and $d6$ to get $1$ through $4$; the $d7$'s to get $5$ through $7$; and the $d10$'s to get $8$ and $9$. There is no way to form a straight of length $10$, so this is the best that can be done.\n\nIn Sample Case #4, we can only form a straight of length $1$, but we can do so by picking any integer for the $d10$ we are given.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10$.\n- $4 \\leq \\mathbf{S}_i \\leq 20$, for all $i$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^5$.\n- $4 \\leq \\mathbf{S}_i \\leq 10^6$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Qualification] d1000000", "background": null, "description": "虽然最常见的骰子有 6 个面，每个面显示 1 到 6 的不同整数，但许多游戏会使用其他类型的骰子。特别地，$d_k$ 表示一个有 $k$ 个面的骰子，每个面显示 1 到 $k$ 的不同整数。$d_6$ 是标准骰子，$d_4$ 有四个面，而 $d_{1000000}$ 有一百万个面。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b9fu60so.png)\n\n在这个问题中，我们从一个包含 $\\mathbf{N}$ 个骰子的集合开始。第 $i$ 个骰子是 $d_{\\mathbf{S}_i}$，即它有 $\\mathbf{S}_i$ 个面，分别显示 $1$ 到 $\\mathbf{S}_i$ 的整数。从 $x$ 开始、长度为 $\\ell$ 的顺子是指整数序列 $x$, $x + 1$, $\\cdots$, $x + (\\ell - 1)$。我们需要选择部分（或全部）骰子，并从每个骰子中选取一个数字来组成一个顺子。用这种方式我们能组成的最长顺子有多长？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例由两行描述：第一行包含一个整数 $\\mathbf{N}$，表示游戏中的骰子数量；第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{S}_1$, $\\mathbf{S}_2$, $\\cdots$, $\\mathbf{S}_\\mathbf{N}$，分别表示每个骰子的面数。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是能组成顺子的最长骰子数量。", "hint": "**样例解释**\n\n在样例 #1 中，有多个方法可以用所有 $4$ 个骰子组成一个顺子。上图展示了一种可能的方式。\n\n在样例 #2 中，由于所有骰子的最大面数都不超过 $5$，因此无法组成超过 $5$ 个骰子的顺子。有多种方法可以组成恰好 $5$ 个骰子的顺子，例如：从两个 $d_5$ 中选取 $4$ 和 $5$，再从三个 $d_4$ 中选取 $1$、$2$ 和 $3$，形成顺子 $1, 2, 3, 4, 5$。\n\n在样例 #3 中，可以通过丢弃一个 $d_4$ 并使用剩余的 $d_4$、$d_5$ 和 $d_6$ 获取 $1$ 到 $4$，用 $d_7$ 获取 $5$ 到 $7$，用 $d_{10}$ 获取 $8$ 和 $9$，从而组成顺子 $1, 2, 3, 4, 5, 6, 7, 8, 9$。无法组成长度为 $10$ 的顺子，因此这是最优解。\n\n在样例 #4 中，我们只能组成长度为 $1$ 的顺子，但可以通过从给定的 $d_{10}$ 中任选一个数字来实现。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试集 1（9 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{N} \\leq 10$。\n- $4 \\leq \\mathbf{S}_i \\leq 20$，对所有 $i$ 成立。\n\n**测试集 2（11 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{N} \\leq 10^5$。\n- $4 \\leq \\mathbf{S}_i \\leq 10^6$，对所有 $i$ 成立。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12982", "type": "P", "difficulty": 3, "samples": [["3\n4\n60 20 40 50\n0 1 1 2\n5\n3 2 1 4 5\n0 1 1 1 0\n8\n100 100 100 90 80 100 90 100\n0 1 2 1 2 3 1 3", "Case #1: 110\nCase #2: 14\nCase #3: 490"]], "limits": {"time": [5000, 5000, 5000, 10000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "拓扑排序", "Google Code Jam"], "title": "[GCJ 2022 Qualification] Chain Reactions", "background": "", "description": "Wile lives alone in the desert, so he entertains himself by building complicated machines that run on chain reactions. Each machine consists of $\\mathbf{N}$ modules indexed $1, 2, \\ldots, \\mathbf{N}$. Each module may point at one other module with a lower index. If not, it points at the abyss.\n\nModules that are not pointed at by any others are called *initiators*. Wile can manually trigger initiators. When a module is triggered, it triggers the module it is pointing at (if any) which in turn may trigger a third module (if it points at one), and so on, until the chain would hit the abyss or an already triggered module. This is called a *chain reaction*.\n\nEach of the $\\mathbf{N}$ modules has a fun factor $\\mathbf{F}_i$. The fun Wile gets from a chain reaction is the largest fun factor of all modules that triggered in that chain reaction. Wile is going to trigger each initiator module once, in some order. The overall fun Wile gets from the session is the sum of the fun he gets from each chain reaction.\n\nFor example, suppose Wile has 4 modules with fun factors $\\mathbf{F}_1 = 60$, $\\mathbf{F}_2 = 20$, $\\mathbf{F}_3 = 40$, and $\\mathbf{F}_4 = 50$ and module 1 points at the abyss, modules 2 and 3 at module 1, and module 4 at module 2. There are two initiators (3 and 4) that Wile must trigger, in some order.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/v8jwu5d8)\n\nAs seen above, if Wile manually triggers module 4 first, modules 4, 2, and 1 will get triggered in the same chain reaction, for a fun of $\\max(50, 20, 60) = 60$. Then, when Wile triggers module 3, module 3 will get triggered alone (module 1 cannot get triggered again), for a fun of 40, and an overall fun for the session of $60 + 40 = 100$.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/94l7nhpi)\n\nHowever, if Wile manually triggers module 3 first, modules 3 and 1 will get triggered in the same chain reaction, for a fun of $\\max(40, 60) = 60$. Then, when Wile triggers module 4, modules 4 and 2 will get triggered in the same chain reaction, for a fun of $\\max(50, 20) = 50$, and an overall fun for the session of $60 + 50 = 110$.\n\nGiven the fun factors and the setup of the modules, compute the maximum fun Wile can get if he triggers the initiators in the best possible order.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, each described using 3 lines. Each test case starts with a line with a single integer $\\mathbf{N}$, the number of modules Wile has. The second line contains $\\mathbf{N}$ integers $\\mathbf{F}_1, \\mathbf{F}_2, \\ldots, \\mathbf{F}_\\mathbf{N}$ where $\\mathbf{F}_i$ is the fun factor of the $i$-th module. The third line contains $\\mathbf{N}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots \\mathbf{P}_\\mathbf{N}$. If $\\mathbf{P}_i = 0$, that means module $i$ points at the abyss. Otherwise, module $i$ points at module $\\mathbf{P}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum fun Wile can have by manually triggering the initiators in the best possible order.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the problem statement.\n\nIn Sample Case #2, there are $4$ initiators (modules $2$ through $5$), so there are $4$ chain reactions. Activating them in order $3, 5, 4, 2$ yields chains of fun $3, 5, 4, 2$ for an overall fun of $14$. Notice that we are summing the four highest fun numbers in the input, so there is no way to get more than that.\n\nIn Sample Case #3, an optimal activation order of the $5$ initiators is $4, 5, 7, 6, 8$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{F}_i \\leq 10^9$.\n- $0 \\leq \\mathbf{P}_i \\leq i - 1$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 10$.\n\n**Test Set 2 (12 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 3 (5 Pts, Hidden Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 100000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Qualification] Chain Reactions", "background": "", "description": "Wile lives alone in the desert, so he entertains himself by building complicated machines that run on chain reactions. Each machine consists of $\\mathbf{N}$ modules indexed $1, 2, \\ldots, \\mathbf{N}$. Each module may point at one other module with a lower index. If not, it points at the abyss.\n\nModules that are not pointed at by any others are called *initiators*. Wile can manually trigger initiators. When a module is triggered, it triggers the module it is pointing at (if any) which in turn may trigger a third module (if it points at one), and so on, until the chain would hit the abyss or an already triggered module. This is called a *chain reaction*.\n\nEach of the $\\mathbf{N}$ modules has a fun factor $\\mathbf{F}_i$. The fun Wile gets from a chain reaction is the largest fun factor of all modules that triggered in that chain reaction. Wile is going to trigger each initiator module once, in some order. The overall fun Wile gets from the session is the sum of the fun he gets from each chain reaction.\n\nFor example, suppose Wile has 4 modules with fun factors $\\mathbf{F}_1 = 60$, $\\mathbf{F}_2 = 20$, $\\mathbf{F}_3 = 40$, and $\\mathbf{F}_4 = 50$ and module 1 points at the abyss, modules 2 and 3 at module 1, and module 4 at module 2. There are two initiators (3 and 4) that Wile must trigger, in some order.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/v8jwu5d8)\n\nAs seen above, if Wile manually triggers module 4 first, modules 4, 2, and 1 will get triggered in the same chain reaction, for a fun of $\\max(50, 20, 60) = 60$. Then, when Wile triggers module 3, module 3 will get triggered alone (module 1 cannot get triggered again), for a fun of 40, and an overall fun for the session of $60 + 40 = 100$.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/94l7nhpi)\n\nHowever, if Wile manually triggers module 3 first, modules 3 and 1 will get triggered in the same chain reaction, for a fun of $\\max(40, 60) = 60$. Then, when Wile triggers module 4, modules 4 and 2 will get triggered in the same chain reaction, for a fun of $\\max(50, 20) = 50$, and an overall fun for the session of $60 + 50 = 110$.\n\nGiven the fun factors and the setup of the modules, compute the maximum fun Wile can get if he triggers the initiators in the best possible order.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, each described using 3 lines. Each test case starts with a line with a single integer $\\mathbf{N}$, the number of modules Wile has. The second line contains $\\mathbf{N}$ integers $\\mathbf{F}_1, \\mathbf{F}_2, \\ldots, \\mathbf{F}_\\mathbf{N}$ where $\\mathbf{F}_i$ is the fun factor of the $i$-th module. The third line contains $\\mathbf{N}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots \\mathbf{P}_\\mathbf{N}$. If $\\mathbf{P}_i = 0$, that means module $i$ points at the abyss. Otherwise, module $i$ points at module $\\mathbf{P}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum fun Wile can have by manually triggering the initiators in the best possible order.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the problem statement.\n\nIn Sample Case #2, there are $4$ initiators (modules $2$ through $5$), so there are $4$ chain reactions. Activating them in order $3, 5, 4, 2$ yields chains of fun $3, 5, 4, 2$ for an overall fun of $14$. Notice that we are summing the four highest fun numbers in the input, so there is no way to get more than that.\n\nIn Sample Case #3, an optimal activation order of the $5$ initiators is $4, 5, 7, 6, 8$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{F}_i \\leq 10^9$.\n- $0 \\leq \\mathbf{P}_i \\leq i - 1$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 10$.\n\n**Test Set 2 (12 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 3 (5 Pts, Hidden Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 100000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Qualification] Chain Reactions", "background": "", "description": "Wile 独自生活在沙漠中，他通过建造复杂的连锁反应机器来自娱自乐。每台机器由 $\\mathbf{N}$ 个模块组成，编号为 $1, 2, \\ldots, \\mathbf{N}$。每个模块会指向一个编号比它小的模块，如果没有可指向的模块，则指向虚空。\n\n没有被任何其他模块指向的模块称为**启动器**。Wile 可以手动触发启动器。当一个模块被触发时，它会触发它所指向的模块（如果有的话），后者可能继续触发第三个模块（如果它指向某个模块），依此类推，直到链条到达虚空或已经触发过的模块为止。这被称为**连锁反应**。\n\n每个 $\\mathbf{N}$ 个模块都有一个乐趣值 $\\mathbf{F}_i$。Wile 从一次连锁反应中获得的乐趣是该连锁反应中所有被触发模块的乐趣值的最大值。Wile 将按某种顺序依次触发每个启动器模块一次。整个过程中 Wile 获得的总乐趣是每次连锁反应所获乐趣的总和。\n\n例如，假设 Wile 有 4 个模块，乐趣值分别为 $\\mathbf{F}_1 = 60$、$\\mathbf{F}_2 = 20$、$\\mathbf{F}_3 = 40$ 和 $\\mathbf{F}_4 = 50$，模块 1 指向虚空，模块 2 和 3 指向模块 1，模块 4 指向模块 2。此时有两个启动器（3 和 4），Wile 需要按某种顺序触发它们。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/v8jwu5d8)\n\n如上图所示，如果 Wile 先手动触发模块 4，模块 4、2 和 1 会在同一次连锁反应中被触发，乐趣值为 $\\max(50, 20, 60) = 60$。接着，当 Wile 触发模块 3 时，模块 3 会单独被触发（模块 1 无法再次触发），乐趣值为 40，整个过程的总乐趣为 $60 + 40 = 100$。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/94l7nhpi)\n\n然而，如果 Wile 先手动触发模块 3，模块 3 和 1 会在同一次连锁反应中被触发，乐趣值为 $\\max(40, 60) = 60$。接着，当 Wile 触发模块 4 时，模块 4 和 2 会在同一次连锁反应中被触发，乐趣值为 $\\max(50, 20) = 50$，整个过程的总乐趣为 $60 + 50 = 110$。\n\n给定模块的乐趣值和指向关系，计算 Wile 在最优触发顺序下能获得的最大总乐趣。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例，每个测试用例由 3 行描述。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示 Wile 拥有的模块数量。第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{F}_1, \\mathbf{F}_2, \\ldots, \\mathbf{F}_\\mathbf{N}$，其中 $\\mathbf{F}_i$ 是第 $i$ 个模块的乐趣值。第三行包含 $\\mathbf{N}$ 个整数 $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots \\mathbf{P}_\\mathbf{N}$。如果 $\\mathbf{P}_i = 0$，表示模块 $i$ 指向虚空；否则，模块 $i$ 指向模块 $\\mathbf{P}_i$。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Wile 在最优触发顺序下能获得的最大总乐趣。\n", "hint": "**样例解释**\n\n样例 #1 是题目描述中解释的案例。\n\n在样例 #2 中，有 $4$ 个启动器（模块 $2$ 到 $5$），因此有 $4$ 次连锁反应。按顺序 $3, 5, 4, 2$ 触发它们，得到的连锁反应乐趣值分别为 $3, 5, 4, 2$，总乐趣为 $14$。注意我们是在对输入中的四个最大乐趣值求和，因此无法获得更大的值。\n\n在样例 #3 中，$5$ 个启动器的最优触发顺序是 $4, 5, 7, 6, 8$。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{F}_i \\leq 10^9$。\n- $0 \\leq \\mathbf{P}_i \\leq i - 1$，对所有 $i$ 成立。\n\n**测试集 1（10 分，可见评测结果）**\n\n- 时间限制：5 秒。\n- $1 \\leq \\mathbf{N} \\leq 10$。\n\n**测试集 2（12 分，可见评测结果）**\n\n- 时间限制：5 秒。\n- $1 \\leq \\mathbf{N} \\leq 1000$。\n\n**测试集 3（5 分，隐藏评测结果）**\n\n- 时间限制：10 秒。\n- $1 \\leq \\mathbf{N} \\leq 100000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12983", "type": "P", "difficulty": 6, "samples": [["1\n5 3\n4 1\n\n5 2\n\n4 1\n\n1 3", "\n\n\nT 5\n\nW\n\nT 1\n\nE 5"]], "limits": {"time": [120000], "memory": [1048576]}, "tags": ["2022", "交互题", "Special Judge", "概率论", "期望", "Google Code Jam"], "title": "[GCJ 2022 Qualification] Twisty Little Passages", "background": null, "description": "You are investigating a cave. The cave has $\\mathbf{N}$ rooms. There are underground passages that bidirectionally connect some pairs of rooms. Each room has at least one passage connected to it. No passage goes from a room to itself, and no two rooms are connected by more than one passage.\n\nWhen in a room, you can identify what room you are in and see how many passages it connects to, but you cannot distinguish the passages. You want to estimate the number of passages that exist in the cave. You are allowed to do up to $\\mathbf{K}$ operations. An operation is either:\n\n* be magically teleported to a room of your choice, or\n* walk through a random passage connected to the room you are in, taking you to the room at the other end of that passage.\n\nWhen you decide to walk through a passage, you are unable to choose which one, because they are all alike. A passage is chosen for you uniformly at random.\n\nYou begin the investigation in an arbitrary room. Estimate the number of passages between rooms in the cave with at most $\\mathbf{K}$ operations.\n\nIf $E$ is your estimate and $P$ is the actual number of passages, your solution is considered correct for a test case if and only if $P \\cdot 2/3 \\leq E \\leq P \\cdot 4/3$.\n\nTo pass a test set, your solution must be correct for at least 90% of the test cases in that set.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$: the number of rooms in the cave, and the maximum number of room operations you are allowed. Rooms are numbered between $1$ and $\\mathbf{N}$. The cave is determined at the beginning of the test case – it won't be changed while you explore it. Then, your program must process up to $\\mathbf{K} + 1$ exchanges.\n\nThe $i$-th exchange starts with you reading a line containing two integers $\\mathbf{R}_i$ and $\\mathbf{P}_i$, representing the number of the room you are currently in and the number of passages it connects to. Then, you must output a single line containing one of the following:\n\n* A single uppercase $\\mathbf{w}$: this means you want to walk through a random passage.\n* A single uppercase $\\mathbf{t}$ and an integer $S$: this means you want to teleport to room $S$.\n* A single uppercase $\\mathbf{e}$ and an integer $E$: this means you want to finish exploring and estimate that the cave contains $E$ passages.\n\nAfter an estimation operation, the judge will immediately start the next test case if there is one, regardless of the correctness of your estimation. If there is no next test case, the judge will wait for you to finish without any further output.\n\nIf the judge receives an invalidly formatted line from your program at any moment, or if your $(\\mathbf{K} + 1)$-th exchange for a test case is not an estimation operation, the judge will print a single number $-1$ and will not print any further output. If your program continues to wait for the judge after receiving a $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\n(It can be shown that the actual number of passages is either 4 or 5. The two possible graphs for this test case are shown below.)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ve57bfoy.png)\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (29 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.\n- $K = 8000$.\n- Each room has at least one passage connected to it.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Qualification] Twisty Little Passages", "background": null, "description": "You are investigating a cave. The cave has $\\mathbf{N}$ rooms. There are underground passages that bidirectionally connect some pairs of rooms. Each room has at least one passage connected to it. No passage goes from a room to itself, and no two rooms are connected by more than one passage.\n\nWhen in a room, you can identify what room you are in and see how many passages it connects to, but you cannot distinguish the passages. You want to estimate the number of passages that exist in the cave. You are allowed to do up to $\\mathbf{K}$ operations. An operation is either:\n\n* be magically teleported to a room of your choice, or\n* walk through a random passage connected to the room you are in, taking you to the room at the other end of that passage.\n\nWhen you decide to walk through a passage, you are unable to choose which one, because they are all alike. A passage is chosen for you uniformly at random.\n\nYou begin the investigation in an arbitrary room. Estimate the number of passages between rooms in the cave with at most $\\mathbf{K}$ operations.\n\nIf $E$ is your estimate and $P$ is the actual number of passages, your solution is considered correct for a test case if and only if $P \\cdot 2/3 \\leq E \\leq P \\cdot 4/3$.\n\nTo pass a test set, your solution must be correct for at least 90% of the test cases in that set.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$: the number of rooms in the cave, and the maximum number of room operations you are allowed. Rooms are numbered between $1$ and $\\mathbf{N}$. The cave is determined at the beginning of the test case – it won't be changed while you explore it. Then, your program must process up to $\\mathbf{K} + 1$ exchanges.\n\nThe $i$-th exchange starts with you reading a line containing two integers $\\mathbf{R}_i$ and $\\mathbf{P}_i$, representing the number of the room you are currently in and the number of passages it connects to. Then, you must output a single line containing one of the following:\n\n* A single uppercase $\\mathbf{w}$: this means you want to walk through a random passage.\n* A single uppercase $\\mathbf{t}$ and an integer $S$: this means you want to teleport to room $S$.\n* A single uppercase $\\mathbf{e}$ and an integer $E$: this means you want to finish exploring and estimate that the cave contains $E$ passages.\n\nAfter an estimation operation, the judge will immediately start the next test case if there is one, regardless of the correctness of your estimation. If there is no next test case, the judge will wait for you to finish without any further output.\n\nIf the judge receives an invalidly formatted line from your program at any moment, or if your $(\\mathbf{K} + 1)$-th exchange for a test case is not an estimation operation, the judge will print a single number $-1$ and will not print any further output. If your program continues to wait for the judge after receiving a $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\n(It can be shown that the actual number of passages is either 4 or 5. The two possible graphs for this test case are shown below.)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ve57bfoy.png)\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (29 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.\n- $K = 8000$.\n- Each room has at least one passage connected to it.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Qualification] Twisty Little Passages", "background": null, "description": "你正在调查一个洞穴。洞穴中有 $\\mathbf{N}$ 个房间，某些房间之间通过双向的地下通道相连。每个房间至少连接一条通道。没有通道从一个房间指向自身，且任意两个房间之间最多只有一条通道。\n\n当身处某个房间时，你可以识别当前所在的房间编号并查看它连接了多少条通道，但无法区分具体是哪条通道。你需要估算洞穴中存在的通道总数。你最多可以进行 $\\mathbf{K}$ 次操作，每次操作可以是以下两种之一：\n\n* **魔法传送**：立即传送到任意一个你选择的房间。\n* **随机行走**：从当前房间随机选择一条连接通道走过去（所有通道被选中的概率均等），到达该通道另一端的房间。\n\n你从任意一个房间开始调查。通过最多 $\\mathbf{K}$ 次操作，估算洞穴中房间之间的通道总数。\n\n设 $E$ 是你的估算值，$P$ 是实际通道数量，当且仅当满足 $P \\cdot 2/3 \\leq E \\leq P \\cdot 4/3$ 时，你的答案被视为正确。要通过一个测试集，至少需要答对该测试集中 90% 的测试用例。\n\n### 交互协议\n\n这是一个交互题。\n\n初始时，你的程序需读取一个整数 $\\mathbf{T}$，表示测试用例数量。接着处理 $\\mathbf{T}$ 个测试用例。\n\n对于每个测试用例，你的程序首先读取一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$，分别表示洞穴中的房间数量和允许的最大操作次数。房间编号为 $1$ 到 $\\mathbf{N}$。洞穴结构在测试用例开始时确定，不会在探索过程中改变。之后，程序需处理最多 $\\mathbf{K} + 1$ 次交互。\n\n第 $i$ 次交互开始时，你需要读取一行包含两个整数 $\\mathbf{R}_i$ 和 $\\mathbf{P}_i$，表示当前所在房间编号及其连接的通道数量。接着，输出以下三种指令之一：\n\n* 单个大写字母 $\\mathbf{W}$：表示选择随机行走。\n* 单个大写字母 $\\mathbf{T}$ 和一个整数 $S$：表示传送到房间 $S$。\n* 单个大写字母 $\\mathbf{E}$ 和一个整数 $E$：表示结束探索并估算通道总数为 $E$。\n\n在输出估算指令后，无论估算是否正确，裁判将立即开始下一个测试用例（如果存在）。如果没有更多测试用例，裁判将静默等待程序结束。\n\n如果裁判在任何时刻收到非法格式的输入，或某测试用例的第 $(\\mathbf{K} + 1)$ 次交互未输出估算指令，裁判将输出 $-1$ 并终止交互。若此时程序仍在等待输入，将因超时被判为 **Time Limit Exceeded**。注意：需确保程序及时退出以避免超时错误。若内存超限或程序运行时错误，将得到相应判果。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**样例解释**\n\n（可以证明，实际的通道数为 4 或 5。该测试用例的两种可能图示如下图所示。）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ve57bfoy.png)\n\n可通过本地测试工具或平台进行调试。本地测试时需同时运行交互工具（如我们提供的交互运行器）。更多说明详见工具文件内的注释。\n\n测试工具的使用说明已内嵌在注释中。建议添加自定义测试用例。请注意：该工具**并非**真实评测系统，实际行为可能存在差异。\n\n**限制条件**\n\n**测试集 1（29 分，可见判果）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{N} \\leq 10^5$。\n- $K = 8000$。\n- 每个房间至少连接一条通道。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12984", "type": "P", "difficulty": 2, "samples": [["3\nPEEL\nAAAAAAAAAA\nCODEJAMDAY", "Case #1: PEEEEL\nCase #2: AAAAAAAAAA\nCase #3: CCODDEEJAAMDAAY"]], "limits": {"time": [2000, 2000, 2000], "memory": [1048576, 1048576, 1048576]}, "tags": ["字符串", "贪心", "2022", "Google Code Jam"], "title": "[GCJ 2022 #1A] Double or One Thing", "background": "", "description": "You are given a string of uppercase English letters. You can highlight any number of the letters (possibly all or none of them). The highlighted letters do not need to be consecutive. Then, a new string is produced by processing the letters from left to right: non-highlighted letters are appended once to the new string, while highlighted letters are appended twice.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q5ybwo42.png)\n\nFor example, if the initial string is HELLOWORLD, you could highlight the H, the first and last Ls and the last o to obtain\n\nHELLOWORLD $\\Rightarrow$ HHELLLOWOORLLD. Similarly, if you highlight nothing, you obtain HELLOWORLD, and if you highlight all of the letters, you obtain HHEELLLLOOWWOORRLLDD. Notice how each occurrence of the same letter can be highlighted independently.\n\nGiven a string, there are multiple strings that can be obtained as a result of this process, depending on the highlighting choices. Among all of those strings, output the one that appears first in alphabetical (also known as lexicographical) order.\n\nNote: A string $s$ appears before a different string $t$ in alphabetical order if $s$ is a prefix of $t$ or if at the first place $s$ and $t$ differ, the letter in $s$ is earlier in the alphabet than the letter in $t$. For example, these strings are in alphabetical order: CODE, HELLO, HI, HIM, HOME, JAM.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing a single string $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the string that comes first alphabetically from the set of strings that can be produced from $\\mathbf{S}$ by the process described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, these are all the strings that can be obtained, in alphabetical order: PEEEEL, PEEEELL, PEEEL, PEEELL, PEEL, PEELL, PPEEEEL, PPEEEELL, PPEEEL, PPEEELL, PPEEL, and PPEELL.\n\nIn Sample Case #2, every string that can be obtained contains only As. The shortest of those is alphabetically first, because it is a prefix of all others.\n\nIn Sample Case #3, there are 1024 possible strings which can be generated from CODEJAMDAY out of which CCODDEEJAAMDAAY is the lexicographically smallest one.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is an uppercase letter from the English alphabet.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10$.\n\n**Test Set 2 (15 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1A] Double or One Thing", "background": "", "description": "You are given a string of uppercase English letters. You can highlight any number of the letters (possibly all or none of them). The highlighted letters do not need to be consecutive. Then, a new string is produced by processing the letters from left to right: non-highlighted letters are appended once to the new string, while highlighted letters are appended twice.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q5ybwo42.png)\n\nFor example, if the initial string is HELLOWORLD, you could highlight the H, the first and last Ls and the last o to obtain\n\nHELLOWORLD $\\Rightarrow$ HHELLLOWOORLLD. Similarly, if you highlight nothing, you obtain HELLOWORLD, and if you highlight all of the letters, you obtain HHEELLLLOOWWOORRLLDD. Notice how each occurrence of the same letter can be highlighted independently.\n\nGiven a string, there are multiple strings that can be obtained as a result of this process, depending on the highlighting choices. Among all of those strings, output the one that appears first in alphabetical (also known as lexicographical) order.\n\nNote: A string $s$ appears before a different string $t$ in alphabetical order if $s$ is a prefix of $t$ or if at the first place $s$ and $t$ differ, the letter in $s$ is earlier in the alphabet than the letter in $t$. For example, these strings are in alphabetical order: CODE, HELLO, HI, HIM, HOME, JAM.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing a single string $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the string that comes first alphabetically from the set of strings that can be produced from $\\mathbf{S}$ by the process described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, these are all the strings that can be obtained, in alphabetical order: PEEEEL, PEEEELL, PEEEL, PEEELL, PEEL, PEELL, PPEEEEL, PPEEEELL, PPEEEL, PPEEELL, PPEEL, and PPEELL.\n\nIn Sample Case #2, every string that can be obtained contains only As. The shortest of those is alphabetically first, because it is a prefix of all others.\n\nIn Sample Case #3, there are 1024 possible strings which can be generated from CODEJAMDAY out of which CCODDEEJAAMDAAY is the lexicographically smallest one.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is an uppercase letter from the English alphabet.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10$.\n\n**Test Set 2 (15 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1A] Double or One Thing", "background": "", "description": "给定一个由大写英文字母组成的字符串。你可以选择高亮其中任意数量的字母（可以是全部、部分或不选）。被高亮的字母不需要是连续的。然后，通过从左到右处理字母生成一个新字符串：未高亮的字母在新字符串中只出现一次，而被高亮的字母会重复出现两次。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q5ybwo42.png)\n\n例如，初始字符串为 HELLOWORLD 时，你可以高亮 H、第一个和最后一个 L 以及最后一个 O，得到：HELLOWORLD $\\Rightarrow$ HHELLLOWOORLLD。类似地，如果什么都不高亮，得到的是原字符串 HELLOWORLD；如果全部高亮，则得到 HHEELLLLOOWWOORRLLDD。注意：相同的字母可以独立选择是否高亮。\n\n对于一个给定的字符串，根据高亮选择的不同，可以生成多种不同的结果字符串。在所有可能的生成字符串中，输出按字典序排列最靠前的一个。\n\n注：若字符串 $s$ 是字符串 $t$ 的前缀，或者 $s$ 和 $t$ 在第一个不同字符处 $s$ 的字母在字母表中更靠前，则认为 $s$ 在字典序中排在 $t$ 之前。例如以下字符串按字典序排列为：CODE, HELLO, HI, HIM, HOME, JAM。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例，每个测试用例单独一行，包含一个字符串 $\\mathbf{S}$。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是通过上述过程从 $\\mathbf{S}$ 生成的所有可能字符串中字典序最小的那个。", "hint": "**样例解释**\n\n在样例 #1 中，所有可能的生成字符串按字典序排列为：PEEEEL, PEEEELL, PEEEL, PEEELL, PEEL, PEELL, PPEEEEL, PPEEEELL, PPEEEL, PPEEELL, PPEEL 和 PPEELL。\n\n在样例 #2 中，所有可能的生成字符串都只包含字母 A，其中最短的字符串字典序最靠前，因为它是其他所有字符串的前缀。\n\n在样例 #3 中，从 CODEJAMDAY 可以生成 1024 种不同的字符串，其中 CCODDEEJAAMDAAY 是字典序最小的一个。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 字符串 $\\mathbf{S}$ 中的每个字符都是大写英文字母。\n\n**测试集 1（10 分，可见评测结果）**\n\n- $1 \\leq$ 字符串 $\\mathbf{S}$ 的长度 $\\leq 10$。\n\n**测试集 2（15 分，隐藏评测结果）**\n\n- $1 \\leq$ 字符串 $\\mathbf{S}$ 的长度 $\\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12985", "type": "P", "difficulty": 5, "samples": [["2\n3\n\n10 4 9\n\n3\n\n10 8 12", "\n\n5 1 3\n\n1 10 5\n\n5 2 3\n\n12 8"]], "limits": {"time": [5000], "memory": [1048576]}, "tags": ["数学", "贪心", "2022", "交互题", "Special Judge", "进制", "构造", "Google Code Jam"], "title": "[GCJ 2022 #1A] Equal Sum", "background": "", "description": "You are given a set of distinct integers. You need to separate them into two non-empty subsets such that each element belongs to exactly one of them and the sum of all elements of each subset is the same.\n\nAn anonymous tip told us that the problem above was unlikely to be solved in polynomial time (or something like that), so we decided to change it. Now you get to decide what half of the integers are!\n\nThis is an interactive problem with three phases. In phase 1, you choose $\\mathbf{N}$ distinct integers. In phase 2, you are given another $\\mathbf{N}$ integers that are distinct from each other and from the ones you chose in phase 1. In phase 3, you have to partition those $2\\mathbf{N}$ integers into two subsets, both of which sum to the same amount. All $2\\mathbf{N}$ integers are to be between 1 and $10^9$, inclusive, and it is guaranteed that they sum up to an even number.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing a single integer $\\mathbf{N}$. Then, it must output a line containing $\\mathbf{N}$ distinct integers $A_1, A_2, \\ldots, A_{\\mathbf{N}}$. Each of these integers must be between 1 and $10^9$, inclusive. After that, your program must read a line containing $\\mathbf{N}$ additional integers $B_1, B_2, \\ldots, B_{\\mathbf{N}}$. Finally, your program must output a line containing between 1 and $2\\mathbf{N}-1$ integers from among $A_1, A_2, \\ldots, A_{\\mathbf{N}}, B_1, B_2, \\ldots, B_{\\mathbf{N}}$: the ones chosen to be part of the first subset. The integers from $A$ and $B$ that you do not output are considered to be part of the other subset.\n\nThe next test case starts immediately if there is one. If this was the last test case, the judge will expect no more output and will send no further input to your program. In addition, all $\\mathbf{T}$ test cases are always processed, regardless of whether the final output from your program is correct or not.\n\nNote: It can be shown that given the limits for this problem, there exists a sequence $A_1, A_2, \\ldots, A_{\\mathbf{N}}$ such that any sequence $B_1, B_2, \\ldots, B_{\\mathbf{N}}$ results in a set of $2\\mathbf{N}$ integers that can be separated into two subsets with equal sums.\n\nIf the judge receives an invalidly formatted or invalid line (like outputting an unexpected number of integers, or integers out of range, or repeated integers in a line) from your program at any moment, the judge will print a single number -1 and will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nIn the sample interaction above, the solution gets all cases right and would receive a correct verdict. Notice that the value for $\\mathbf{N}$ does not conform to the limits for the Test Set and is used to simplify the example only. Notice that the judge could have given the solution the integers $\\{2, 7, 100\\}$ for the first case, making it impossible for the solution to find a valid partition into subsets of equal sum.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{N} = 100$.\n- $1 \\leq \\mathbf{B}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{B}_i \\neq A_j$, for all $i, j$.\n- $\\mathbf{B}_i \\neq \\mathbf{B}_j$, for all $i \\neq j$.\n- For each test case, the judge will choose the $\\mathbf{B}_i$s such that the sum of all $2\\mathbf{N}$ integers is even.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1A] Equal Sum", "background": "", "description": "You are given a set of distinct integers. You need to separate them into two non-empty subsets such that each element belongs to exactly one of them and the sum of all elements of each subset is the same.\n\nAn anonymous tip told us that the problem above was unlikely to be solved in polynomial time (or something like that), so we decided to change it. Now you get to decide what half of the integers are!\n\nThis is an interactive problem with three phases. In phase 1, you choose $\\mathbf{N}$ distinct integers. In phase 2, you are given another $\\mathbf{N}$ integers that are distinct from each other and from the ones you chose in phase 1. In phase 3, you have to partition those $2\\mathbf{N}$ integers into two subsets, both of which sum to the same amount. All $2\\mathbf{N}$ integers are to be between 1 and $10^9$, inclusive, and it is guaranteed that they sum up to an even number.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing a single integer $\\mathbf{N}$. Then, it must output a line containing $\\mathbf{N}$ distinct integers $A_1, A_2, \\ldots, A_{\\mathbf{N}}$. Each of these integers must be between 1 and $10^9$, inclusive. After that, your program must read a line containing $\\mathbf{N}$ additional integers $B_1, B_2, \\ldots, B_{\\mathbf{N}}$. Finally, your program must output a line containing between 1 and $2\\mathbf{N}-1$ integers from among $A_1, A_2, \\ldots, A_{\\mathbf{N}}, B_1, B_2, \\ldots, B_{\\mathbf{N}}$: the ones chosen to be part of the first subset. The integers from $A$ and $B$ that you do not output are considered to be part of the other subset.\n\nThe next test case starts immediately if there is one. If this was the last test case, the judge will expect no more output and will send no further input to your program. In addition, all $\\mathbf{T}$ test cases are always processed, regardless of whether the final output from your program is correct or not.\n\nNote: It can be shown that given the limits for this problem, there exists a sequence $A_1, A_2, \\ldots, A_{\\mathbf{N}}$ such that any sequence $B_1, B_2, \\ldots, B_{\\mathbf{N}}$ results in a set of $2\\mathbf{N}$ integers that can be separated into two subsets with equal sums.\n\nIf the judge receives an invalidly formatted or invalid line (like outputting an unexpected number of integers, or integers out of range, or repeated integers in a line) from your program at any moment, the judge will print a single number -1 and will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nIn the sample interaction above, the solution gets all cases right and would receive a correct verdict. Notice that the value for $\\mathbf{N}$ does not conform to the limits for the Test Set and is used to simplify the example only. Notice that the judge could have given the solution the integers $\\{2, 7, 100\\}$ for the first case, making it impossible for the solution to find a valid partition into subsets of equal sum.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{N} = 100$.\n- $1 \\leq \\mathbf{B}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{B}_i \\neq A_j$, for all $i, j$.\n- $\\mathbf{B}_i \\neq \\mathbf{B}_j$, for all $i \\neq j$.\n- For each test case, the judge will choose the $\\mathbf{B}_i$s such that the sum of all $2\\mathbf{N}$ integers is even.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1A] Equal Sum", "background": "", "description": "给定一组互不相同的整数，你需要将它们分成两个非空子集，使得每个元素恰好属于其中一个子集，且两个子集中所有元素的和相等。\n\n匿名提示称上述问题不太可能在多项式时间内解决（或类似结论），因此我们决定修改题目。现在，你可以自行决定其中一半的整数！\n\n这是一个包含三个阶段的交互题：\n1. **阶段1**：你选择 $\\mathbf{N}$ 个互不相同的整数。\n2. **阶段2**：系统会额外提供 $\\mathbf{N}$ 个整数，这些整数彼此不同且与你选择的整数不同。\n3. **阶段3**：你需要将这 $2\\mathbf{N}$ 个整数划分为两个和相等的子集。\n\n所有整数的取值范围为 $1$ 到 $10^9$（含），且保证它们的总和为偶数。\n\n### 交互协议\n\n这是一个交互问题。\n\n初始时，你的程序需读取一个整数 $\\mathbf{T}$ 表示测试用例数量，随后处理 $\\mathbf{T}$ 个测试用例。\n\n对于每个测试用例：\n1. 程序先读取一个整数 $\\mathbf{N}$。\n2. 程序输出一行包含 $\\mathbf{N}$ 个互不相同的整数 $A_1, A_2, \\ldots, A_{\\mathbf{N}}$（每个整数在 $1$ 到 $10^9$ 范围内）。\n3. 程序读取一行包含 $\\mathbf{N}$ 个额外整数 $B_1, B_2, \\ldots, B_{\\mathbf{N}}$。\n4. 程序输出一行包含 $1$ 到 $2\\mathbf{N}-1$ 个整数（从 $A$ 和 $B$ 的并集中选择），表示第一个子集的元素。未输出的元素自动归入第二个子集。\n\n当前测试用例结束后，立即处理下一个（若存在）。所有测试用例均会被处理，无论最终输出是否正确。\n\n注意：可以证明在本题限制下，存在至少一组 $A_1, A_2, \\ldots, A_{\\mathbf{N}}$ 使得对任意给定的 $B_1, B_2, \\ldots, B_{\\mathbf{N}}$，都能将 $2\\mathbf{N}$ 个整数划分为和相等的两个子集。\n\n若程序在任何时刻输出格式非法（如整数数量不符、范围越界或重复），裁判将返回 $-1$ 并终止交互。若程序未及时退出，将判为 **Time Limit Exceeded**。内存超限或运行时错误将得到相应判果。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**样例解释**\n\n上述样例交互中，程序正确解决了所有测试用例。注意：样例中的 $\\mathbf{N}$ 值不符合实际测试集限制，仅用于简化示例。若裁判在第一用例中给出 $\\{2, 7, 100\\}$，则可能无法找到合法划分。\n\n可使用本地测试工具或平台调试。本地测试需配合交互运行器（详见工具文件注释）。\n\n**限制条件**\n\n**测试集 1（可见判果）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $\\mathbf{N} = 100$。\n- $1 \\leq \\mathbf{B}_i \\leq 10^9$（对所有 $i$）。\n- $\\mathbf{B}_i \\neq A_j$（对所有 $i, j$）。\n- $\\mathbf{B}_i \\neq \\mathbf{B}_j$（对所有 $i \\neq j$）。\n- 每个测试用例中，裁判选择的 $\\mathbf{B}_i$ 保证 $2\\mathbf{N}$ 个整数的和为偶数。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12986", "type": "P", "difficulty": 5, "samples": [["3\n3 1\n1\n2\n1\n2 3\n1 2 1\n2 1 2\n3 3\n3 1 1\n3 3 3\n2 3 3", "Case #1: 4\nCase #2: 12\nCase #3: 20"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2022", "Google Code Jam"], "title": "[GCJ 2022 #1A] Weightlifting", "background": "", "description": "You are following a prescribed training for weightlifting. The training consists of a series of exercises that you must do in order. Each exercise requires a specific set of weights to be placed on a machine.\n\nThere are $\\mathbf{W}$ types of different weights. For example, an exercise may require 3 weights of type A and 1 weight of type B, while the next requires 2 weights each of types A, C, and D.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0e2my7uz.png)\n\nThe weights are placed on the machine as a stack. Formally, with a single operation, you can either add a new weight of any type to the top of the stack, or remove the weight that is currently at the top of the stack.\n\nYou can load the weights for each exercise onto the machine's stack in any order. So, if you place the weight of type B at the bottom in the first exercise of the example above, you will have to take all the weights off before putting on the weights for the second exercise. On the other hand, if you place the weight of type B third from the bottom, you can leave two of the weights of type A on the bottom of the stack to be part of the next exercise's set, saving you some time.\n\nGiven the amount of weights of each type needed for each exercise, find the minimum number of operations needed to do them all. You must complete the exercises in the order given. The machine stack starts out empty, and you must leave it empty after you finish with all your exercises.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing 2 integers $\\mathbf{E}$ and $\\mathbf{W}$: the number of exercises and the number of types of weights. Weight types are numbered between 1 and $\\mathbf{W}$. Then, $\\mathbf{E}$ lines follow. The $i$-th of these lines contains $\\mathbf{W}$ integers $\\mathbf{X}_{i,1}$, $\\mathbf{X}_{i,2}$, $\\ldots$, $\\mathbf{X}_{i,\\mathbf{W}}$ representing that the $i$-th exercise requires exactly $\\mathbf{X}_{i,j}$ weights of type $j$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of machine stack operations needed to run through all your exercises.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is only one type of weight. The first exercise needs 1 weight, the second needs 2 weights, and the third needs 1 weight. You can complete the exercise in 4 operations as follows:\n\n1. Add a weight onto the stack. You do the first exercise.\n2. Add a weight onto the stack. You do the second exercise.\n3. Remove a weight from the top of the stack. You do the third exercise.\n4. Remove a weight from the top of the stack. Now the stack becomes empty.\n\nIn Sample Case #2, one way to complete the exercises in 12 operations is as follows:\n\n1. Add a weight of type 2.\n2. Add a weight of type 3.\n3. Add a weight of type 1.\n4. Add a weight of type 2. Now the stack contains weights of types 2, 3, 1, 2 from bottom to top. You do the first exercise.\n5. Remove a weight of type 2 from the top of the stack.\n6. Add a weight of type 3.\n7. Add a weight of type 1. Now the stack contains weights of types 2, 3, 1, 3, 1 from bottom to top. You do the second exercise.\n8. Remove a weight of type 1 from the top of the stack.\n9. Remove a weight of type 3 from the top of the stack.\n10. Remove a weight of type 1 from the top of the stack.\n11. Remove a weight of type 3 from the top of the stack.\n12. Remove a weight of type 2 from the top of the stack. Now the stack becomes empty.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{X}_{i,1} + \\mathbf{X}_{i,2} + \\cdots + \\mathbf{X}_{i,\\mathbf{W}}$, for all $i$. (Each exercise requires at least one weight.)\n\n**Test Set 1 (13 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{E} \\leq 10$.\n- $1 \\leq \\mathbf{W} \\leq 3$.\n- $0 \\leq \\mathbf{X}_{i,j} \\leq 3$, for all $i, j$.\n\n**Test Set 2 (31 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{E} \\leq 100$.\n- $1 \\leq \\mathbf{W} \\leq 100$.\n- $0 \\leq \\mathbf{X}_{i,j} \\leq 100$, for all $i, j$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1A] Weightlifting", "background": "", "description": "You are following a prescribed training for weightlifting. The training consists of a series of exercises that you must do in order. Each exercise requires a specific set of weights to be placed on a machine.\n\nThere are $\\mathbf{W}$ types of different weights. For example, an exercise may require 3 weights of type A and 1 weight of type B, while the next requires 2 weights each of types A, C, and D.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0e2my7uz.png)\n\nThe weights are placed on the machine as a stack. Formally, with a single operation, you can either add a new weight of any type to the top of the stack, or remove the weight that is currently at the top of the stack.\n\nYou can load the weights for each exercise onto the machine's stack in any order. So, if you place the weight of type B at the bottom in the first exercise of the example above, you will have to take all the weights off before putting on the weights for the second exercise. On the other hand, if you place the weight of type B third from the bottom, you can leave two of the weights of type A on the bottom of the stack to be part of the next exercise's set, saving you some time.\n\nGiven the amount of weights of each type needed for each exercise, find the minimum number of operations needed to do them all. You must complete the exercises in the order given. The machine stack starts out empty, and you must leave it empty after you finish with all your exercises.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing 2 integers $\\mathbf{E}$ and $\\mathbf{W}$: the number of exercises and the number of types of weights. Weight types are numbered between 1 and $\\mathbf{W}$. Then, $\\mathbf{E}$ lines follow. The $i$-th of these lines contains $\\mathbf{W}$ integers $\\mathbf{X}_{i,1}$, $\\mathbf{X}_{i,2}$, $\\ldots$, $\\mathbf{X}_{i,\\mathbf{W}}$ representing that the $i$-th exercise requires exactly $\\mathbf{X}_{i,j}$ weights of type $j$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of machine stack operations needed to run through all your exercises.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is only one type of weight. The first exercise needs 1 weight, the second needs 2 weights, and the third needs 1 weight. You can complete the exercise in 4 operations as follows:\n\n1. Add a weight onto the stack. You do the first exercise.\n2. Add a weight onto the stack. You do the second exercise.\n3. Remove a weight from the top of the stack. You do the third exercise.\n4. Remove a weight from the top of the stack. Now the stack becomes empty.\n\nIn Sample Case #2, one way to complete the exercises in 12 operations is as follows:\n\n1. Add a weight of type 2.\n2. Add a weight of type 3.\n3. Add a weight of type 1.\n4. Add a weight of type 2. Now the stack contains weights of types 2, 3, 1, 2 from bottom to top. You do the first exercise.\n5. Remove a weight of type 2 from the top of the stack.\n6. Add a weight of type 3.\n7. Add a weight of type 1. Now the stack contains weights of types 2, 3, 1, 3, 1 from bottom to top. You do the second exercise.\n8. Remove a weight of type 1 from the top of the stack.\n9. Remove a weight of type 3 from the top of the stack.\n10. Remove a weight of type 1 from the top of the stack.\n11. Remove a weight of type 3 from the top of the stack.\n12. Remove a weight of type 2 from the top of the stack. Now the stack becomes empty.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{X}_{i,1} + \\mathbf{X}_{i,2} + \\cdots + \\mathbf{X}_{i,\\mathbf{W}}$, for all $i$. (Each exercise requires at least one weight.)\n\n**Test Set 1 (13 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{E} \\leq 10$.\n- $1 \\leq \\mathbf{W} \\leq 3$.\n- $0 \\leq \\mathbf{X}_{i,j} \\leq 3$, for all $i, j$.\n\n**Test Set 2 (31 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{E} \\leq 100$.\n- $1 \\leq \\mathbf{W} \\leq 100$.\n- $0 \\leq \\mathbf{X}_{i,j} \\leq 100$, for all $i, j$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1A] Weightlifting", "background": "", "description": "你正在按照一套举重训练计划进行训练。该训练由一系列必须按顺序完成的动作组成，每个动作需要在器械上放置特定的配重组合。\n\n共有 $\\mathbf{W}$ 种不同类型的配重。例如，某个动作可能需要 3 个 A 型配重和 1 个 B 型配重，而下一个动作可能需要 2 个 A 型、2 个 C 型和 2 个 D 型配重。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0e2my7uz.png)\n\n配重以**堆栈**形式放置在器械上。每次操作你可以：\n- 将任意类型的新配重添加到堆栈顶部\n- 或移除当前位于堆栈顶部的配重\n\n每个动作所需的配重可以按任意顺序装载。例如，若在第一个动作中将 B 型配重放在最底层，那么在装载第二个动作的配重前需要清空所有配重；但若将 B 型配重放在倒数第三层，则可保留底部的两个 A 型配重用于下一个动作，从而减少操作次数。\n\n给定每个动作所需的各类配重数量，计算完成所有训练所需的最少操作次数。训练必须按给定顺序完成，器械堆栈初始为空，训练结束后也必须恢复为空栈。", "inputFormat": "第一行输入测试用例数量 $\\mathbf{T}$。每个测试用例首行包含两个整数 $\\mathbf{E}$（动作数量）和 $\\mathbf{W}$（配重类型数，编号为 1 到 $\\mathbf{W}$）。随后 $\\mathbf{E}$ 行中，第 $i$ 行包含 $\\mathbf{W}$ 个整数 $\\mathbf{X}_{i,1}, \\mathbf{X}_{i,2}, \\ldots, \\mathbf{X}_{i,\\mathbf{W}}$，表示第 $i$ 个动作需要 $\\mathbf{X}_{i,j}$ 个 $j$ 型配重。\n", "outputFormat": "对每个测试用例输出 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为完成所有训练的最少操作次数。\n", "hint": "**样例解释**\n\n样例 #1 仅含 1 种配重类型：\n1. 添加 1 个配重（完成第 1 个动作）\n2. 再添加 1 个配重（完成第 2 个动作）\n3. 移除 1 个配重（完成第 3 个动作）\n4. 移除最后 1 个配重（恢复空栈）\n\n样例 #2 的 12 次操作方案：\n1. 添加 2 型 → [2]\n2. 添加 3 型 → [2,3] \n3. 添加 1 型 → [2,3,1]\n4. 添加 2 型 → [2,3,1,2]（完成第 1 个动作）\n5. 移除 2 型 → [2,3,1]\n6. 添加 3 型 → [2,3,1,3]\n7. 添加 1 型 → [2,3,1,3,1]（完成第 2 个动作）\n8-12. 按 1→3→1→3→2 顺序移除所有配重\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n- 每个动作至少需要 1 个配重（$\\mathbf{X}_{i,1} + \\cdots + \\mathbf{X}_{i,\\mathbf{W}} \\geq 1$）\n\n**测试集 1（13 分，可见判果）**\n- $1 \\leq \\mathbf{E} \\leq 10$\n- $1 \\leq \\mathbf{W} \\leq 3$ \n- $0 \\leq \\mathbf{X}_{i,j} \\leq 3$\n\n**测试集 2（31 分，隐藏判果）**\n- $1 \\leq \\mathbf{E} \\leq 100$\n- $1 \\leq \\mathbf{W} \\leq 100$\n- $0 \\leq \\mathbf{X}_{i,j} \\leq 100$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12987", "type": "P", "difficulty": 2, "samples": [["4\n2\n1 5\n4\n1 4 2 3\n5\n10 10 10 10 10\n4\n7 1 3 1000000", "Case #1: 2\nCase #2: 3\nCase #3: 5\nCase #4: 2"]], "limits": {"time": [2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2022", "Google Code Jam"], "title": "[GCJ 2022 #1B] Pancake Deque", "background": "", "description": "Pancakes are normally served in stacks, but the Infinite House of Pancakes embraces change! The restaurant's new advertising hook is to serve the pancakes from a deque, or double-ended queue.\n\nYou are a server at the restaurant, and your job is to serve every pancake in the deque. Customers will arrive one at a time, and each one gets a single pancake. You must serve each customer either the leftmost or rightmost pancake in the deque; the choice is yours. When a pancake is served, it disappears from the deque, exposing the pancake that was next to it. Or, once there is only one pancake left, your only choice is to serve that one, and then your job is complete!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jn04ll9k.png)\n\nEach pancake has a deliciousness level. Because customers do not get to choose which pancakes they get, each customer only has to pay for their pancake if it is at least as delicious as each of the pancakes that all of the previous customers got. (The first customer always pays for their pancake, since in that case there are no previous customers.)\n\nHow many customers will pay for their pancake, if you serve the pancakes in an order that maximizes that number?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described with two lines. The first line of a test case contains a single integer $N$, the number of pancakes in the pancake deque. The second line of a test case contains $N$ integers $D_1$, $D_2$, $\\ldots$, $D_N$, where $D_i$ is the deliciousness level of the $i$-th pancake from the left in the deque.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of customers who pay for their pancakes, if you serve the pancakes in an order that maximizes that number.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are two possible orders in which you can serve the pancakes. If you serve the pancake with deliciousness level 5 first, only that one is paid for. If you serve the pancake with deliciousness level 1 first, both are paid for.\n\nSample Case #2 is the image shown in the problem statement. The following are the possible orders (by deliciousness level) in which the pancakes can be served. The underlined pancakes are the ones that customers pay for.\n\n* $\\underline{1}, 4, 2, 3$\n* $\\underline{1}, 4, 3, 2$\n* $\\underline{1}, \\underline{3}, 4, 2$\n* $\\underline{1}, \\underline{3}, 2, \\underline{4}$\n* $\\underline{3}, 1, \\underline{4}, 2$\n* $\\underline{3}, 1, 2, \\underline{4}$\n* $\\underline{3}, 2, 1, \\underline{4}$\n* $\\underline{3}, 2, \\underline{4}, 1$\n\nAs you can see, there are some orders in which 3 pancakes are paid for, and none in which all 4 are.\n\nIn Sample Case #3, all pancakes are paid for regardless of the serving order.\n\nIn Sample Case #4, regardless of which pancake you serve first, the two in the middle will never be paid for. The best you can do is serve the pancake with deliciousness 7 before the pancake with deliciousness 1000000.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D}_{\\mathbf{i}} \\leq 10^{6}$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 20$.\n\n**Test Set 2 (8 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1B] Pancake Deque", "background": "", "description": "Pancakes are normally served in stacks, but the Infinite House of Pancakes embraces change! The restaurant's new advertising hook is to serve the pancakes from a deque, or double-ended queue.\n\nYou are a server at the restaurant, and your job is to serve every pancake in the deque. Customers will arrive one at a time, and each one gets a single pancake. You must serve each customer either the leftmost or rightmost pancake in the deque; the choice is yours. When a pancake is served, it disappears from the deque, exposing the pancake that was next to it. Or, once there is only one pancake left, your only choice is to serve that one, and then your job is complete!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jn04ll9k.png)\n\nEach pancake has a deliciousness level. Because customers do not get to choose which pancakes they get, each customer only has to pay for their pancake if it is at least as delicious as each of the pancakes that all of the previous customers got. (The first customer always pays for their pancake, since in that case there are no previous customers.)\n\nHow many customers will pay for their pancake, if you serve the pancakes in an order that maximizes that number?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described with two lines. The first line of a test case contains a single integer $N$, the number of pancakes in the pancake deque. The second line of a test case contains $N$ integers $D_1$, $D_2$, $\\ldots$, $D_N$, where $D_i$ is the deliciousness level of the $i$-th pancake from the left in the deque.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of customers who pay for their pancakes, if you serve the pancakes in an order that maximizes that number.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are two possible orders in which you can serve the pancakes. If you serve the pancake with deliciousness level 5 first, only that one is paid for. If you serve the pancake with deliciousness level 1 first, both are paid for.\n\nSample Case #2 is the image shown in the problem statement. The following are the possible orders (by deliciousness level) in which the pancakes can be served. The underlined pancakes are the ones that customers pay for.\n\n* $\\underline{1}, 4, 2, 3$\n* $\\underline{1}, 4, 3, 2$\n* $\\underline{1}, \\underline{3}, 4, 2$\n* $\\underline{1}, \\underline{3}, 2, \\underline{4}$\n* $\\underline{3}, 1, \\underline{4}, 2$\n* $\\underline{3}, 1, 2, \\underline{4}$\n* $\\underline{3}, 2, 1, \\underline{4}$\n* $\\underline{3}, 2, \\underline{4}, 1$\n\nAs you can see, there are some orders in which 3 pancakes are paid for, and none in which all 4 are.\n\nIn Sample Case #3, all pancakes are paid for regardless of the serving order.\n\nIn Sample Case #4, regardless of which pancake you serve first, the two in the middle will never be paid for. The best you can do is serve the pancake with deliciousness 7 before the pancake with deliciousness 1000000.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D}_{\\mathbf{i}} \\leq 10^{6}$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 20$.\n\n**Test Set 2 (8 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1B] Pancake Deque", "background": "", "description": "煎饼通常以堆叠的形式供应，但**无限煎饼屋**勇于变革！该餐厅的新广告噱头是将煎饼以双端队列（deque）的形式供应。\n\n你是餐厅的服务员，你的工作是从双端队列中供应所有煎饼。顾客会依次到来，每位顾客获得一个煎饼。你必须为每位顾客供应当前双端队列的最左端或最右端的煎饼，选择权在你手中。当一个煎饼被供应后，它会从队列中消失，露出相邻的煎饼。或者，当只剩一个煎饼时，你只能供应它，此时你的工作就完成了！\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jn04ll9k.png)\n\n每个煎饼有一个美味值。由于顾客无法选择自己获得的煎饼，只有当一个煎饼的美味值**不低于**之前所有顾客获得的煎饼的美味值时，该顾客才需要为其煎饼付费。（第一位顾客总是需要付费，因为此时没有之前的顾客。）\n\n如果你以最大化付费顾客数量的顺序供应煎饼，有多少顾客会为其煎饼付费？", "inputFormat": "输入的第一行包含测试用例的数量 $T$。随后是 $T$ 个测试用例。每个测试用例由两行描述：第一行包含一个整数 $N$，表示双端队列中煎饼的数量；第二行包含 $N$ 个整数 $D_1, D_2, \\ldots, D_N$，其中 $D_i$ 表示队列中从左数第 $i$ 个煎饼的美味值。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是以最大化付费顾客数量的顺序供应煎饼时的付费顾客数。\n", "hint": "**样例解释**\n\n在样例 #1 中，有两种供应煎饼的顺序。如果先供应美味值为 5 的煎饼，则只有该顾客付费；如果先供应美味值为 1 的煎饼，则两位顾客都会付费。\n\n样例 #2 对应题目描述中的图片。以下是可能的供应顺序（按美味值），下划线的煎饼表示顾客需要付费：\n- $\\underline{1}, 4, 2, 3$\n- $\\underline{1}, 4, 3, 2$\n- $\\underline{1}, \\underline{3}, 4, 2$\n- $\\underline{1}, \\underline{3}, 2, \\underline{4}$\n- $\\underline{3}, 1, \\underline{4}, 2$\n- $\\underline{3}, 1, 2, \\underline{4}$\n- $\\underline{3}, 2, 1, \\underline{4}$\n- $\\underline{3}, 2, \\underline{4}, 1$\n\n可以看到，某些顺序下会有 3 个煎饼被付费，但没有一种顺序能让所有 4 个煎饼都付费。\n\n在样例 #3 中，无论以何种顺序供应，所有煎饼都会被付费。\n\n在样例 #4 中，无论先供应哪个煎饼，中间的两个煎饼都不会被付费。最佳策略是先供应美味值为 7 的煎饼，再供应美味值为 1000000 的煎饼。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq D_i \\leq 10^6$（对所有 $i$ 成立）。\n\n**测试集 1（7 分，可见判定）**\n\n- $2 \\leq N \\leq 20$。\n\n**测试集 2（8 分，可见判定）**\n\n- $2 \\leq N \\leq 100$。\n\n**测试集 3（10 分，隐藏判定）**\n\n- $2 \\leq N \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12988", "type": "P", "difficulty": 4, "samples": [["2\n3 3\n30 10 40\n20 50 60\n60 60 50\n5 2\n1 1000000000\n500000000 1000000000\n1 1000000000\n500000000 1\n1 1000000000", "Case #1: 110\nCase #2: 4999999996"]], "limits": {"time": [5000, 5000, 5000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2022", "Google Code Jam"], "title": "[GCJ 2022 #1B] Controlled Inflation", "background": "", "description": "The lines at the air pump at your gas station are getting too long! You want to optimize the process to help customers more quickly inflate their tires, sports balls, giant parade balloon animals, and other products.\n\nThe pump is automatic: you set the pressure to a specific number of pascals and plug the pump into the inflatable product, and it will inflate as needed to that exact pressure. There are only two buttons on the pump: up and down. They increase and decrease the target pressure, respectively, by exactly $1$ pascal.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9382itkr.png)\n\nThere is a line of $\\mathbf{N}$ customers, each of whom brings exactly $\\mathbf{P}$ products that they need to get inflated by the pump. You know the target pressure of each product. You can inflate the products from a customer in any order you want, but you cannot change the order of the customers. Specifically, you must inflate all products from the $i$-th customer before inflating any from the $(i+1)$-th customer. In between handling two products, if those two products have different target pressures, you need to use the buttons on the pump.\n\nThe pump is initially set to 0 pascals, and it can be left at any number after all products of all customers have been inflated. If you order the products of each customer optimally, what is the minimum number of button presses you need?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers, $\\mathbf{N}$ and $\\mathbf{P}$: the number of customers and the number of products each customer brings, respectively. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains $\\mathbf{P}$ integers $\\mathbf{X}_{\\mathbf{i}, 1}, \\mathbf{X}_{\\mathbf{i}, 2}, \\ldots, \\mathbf{X}_{\\mathbf{i}, \\mathbf{P}}$, representing that the $j$-th product that the $i$-th customer brings has a target pressure of $\\mathbf{X}_{\\mathbf{i}, \\mathbf{j}}$ pascals.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of button presses needed to inflate all products according to their specified pressures.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, an optimal way to use the pump is:\n\n1. press up 10 times, setting the pump to 10; pump the product (from customer 1) that needs 10 pascals,\n2. press up 30 times, setting the pump to 40; pump the product (from customer 1) that needs 40 pascals,\n3. press down 10 times, setting the pump to 30; pump the product (from customer 1) that needs 30 pascals,\n4. press down 10 times, setting the pump to 20; pump the product (from customer 2) that needs 20 pascals,\n5. press up 30 times, setting the pump to 50; pump the product (from customer 2) that needs 50 pascals,\n6. press up 10 times, setting the pump to 60; pump the product (from customer 2) and the two products (from customer 3) that need 60 pascals, and finally\n7. press down 10 times, setting the pump to 50; pump the product (from customer 3) that needs 50 pascals.\n\nThis is a total of 110 button presses.\n\nIn Sample Case #2, notice that the answer can be larger than $2^{32}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}, \\mathbf{j}} \\leq 10^{9}$, for all $i, j$.\n\n**Test Set 1 (14 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10$.\n- $2 \\leq \\mathbf{P} \\leq 3$.\n\n**Test Set 2 (21 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$.\n- $2 \\leq \\mathbf{P} \\leq 100$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1B] Controlled Inflation", "background": "", "description": "The lines at the air pump at your gas station are getting too long! You want to optimize the process to help customers more quickly inflate their tires, sports balls, giant parade balloon animals, and other products.\n\nThe pump is automatic: you set the pressure to a specific number of pascals and plug the pump into the inflatable product, and it will inflate as needed to that exact pressure. There are only two buttons on the pump: up and down. They increase and decrease the target pressure, respectively, by exactly $1$ pascal.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9382itkr.png)\n\nThere is a line of $\\mathbf{N}$ customers, each of whom brings exactly $\\mathbf{P}$ products that they need to get inflated by the pump. You know the target pressure of each product. You can inflate the products from a customer in any order you want, but you cannot change the order of the customers. Specifically, you must inflate all products from the $i$-th customer before inflating any from the $(i+1)$-th customer. In between handling two products, if those two products have different target pressures, you need to use the buttons on the pump.\n\nThe pump is initially set to 0 pascals, and it can be left at any number after all products of all customers have been inflated. If you order the products of each customer optimally, what is the minimum number of button presses you need?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers, $\\mathbf{N}$ and $\\mathbf{P}$: the number of customers and the number of products each customer brings, respectively. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains $\\mathbf{P}$ integers $\\mathbf{X}_{\\mathbf{i}, 1}, \\mathbf{X}_{\\mathbf{i}, 2}, \\ldots, \\mathbf{X}_{\\mathbf{i}, \\mathbf{P}}$, representing that the $j$-th product that the $i$-th customer brings has a target pressure of $\\mathbf{X}_{\\mathbf{i}, \\mathbf{j}}$ pascals.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of button presses needed to inflate all products according to their specified pressures.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, an optimal way to use the pump is:\n\n1. press up 10 times, setting the pump to 10; pump the product (from customer 1) that needs 10 pascals,\n2. press up 30 times, setting the pump to 40; pump the product (from customer 1) that needs 40 pascals,\n3. press down 10 times, setting the pump to 30; pump the product (from customer 1) that needs 30 pascals,\n4. press down 10 times, setting the pump to 20; pump the product (from customer 2) that needs 20 pascals,\n5. press up 30 times, setting the pump to 50; pump the product (from customer 2) that needs 50 pascals,\n6. press up 10 times, setting the pump to 60; pump the product (from customer 2) and the two products (from customer 3) that need 60 pascals, and finally\n7. press down 10 times, setting the pump to 50; pump the product (from customer 3) that needs 50 pascals.\n\nThis is a total of 110 button presses.\n\nIn Sample Case #2, notice that the answer can be larger than $2^{32}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}, \\mathbf{j}} \\leq 10^{9}$, for all $i, j$.\n\n**Test Set 1 (14 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10$.\n- $2 \\leq \\mathbf{P} \\leq 3$.\n\n**Test Set 2 (21 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$.\n- $2 \\leq \\mathbf{P} \\leq 100$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1B] Controlled Inflation", "background": "", "description": "你所在的加油站充气泵前的队伍越来越长了！你希望优化流程，帮助顾客更快速地给轮胎、运动球、巨型气球动物等产品充气。\n\n充气泵是自动的：你可以将目标气压设置为特定的帕斯卡数值，将泵连接到充气产品上，它就会按需充气到该精确气压。泵上只有两个按钮：**上**和**下**。它们分别将目标气压精确地增加或减少 $1$ 帕斯卡。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9382itkr.png)\n\n共有 $\\mathbf{N}$ 位顾客排队，每位顾客携带恰好 $\\mathbf{P}$ 个需要充气的产品。你知道每个产品的目标气压。你可以按任意顺序处理每位顾客的产品，但**不能**改变顾客的顺序。具体来说，你必须处理完第 $i$ 位顾客的所有产品后，才能开始处理第 $(i+1)$ 位顾客的产品。在处理两个产品之间，如果它们的目标气压不同，你需要使用泵上的按钮调整气压。\n\n充气泵初始气压为 0 帕斯卡，处理完所有顾客的所有产品后可以停留在任意气压值。如果你能优化每位顾客的产品处理顺序，最少需要按下多少次按钮？\n", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{P}$，分别表示顾客的数量和每位顾客携带的产品数量。接下来是 $\\mathbf{N}$ 行，第 $i$ 行包含 $\\mathbf{P}$ 个整数 $\\mathbf{X}_{\\mathbf{i}, 1}, \\mathbf{X}_{\\mathbf{i}, 2}, \\ldots, \\mathbf{X}_{\\mathbf{i}, \\mathbf{P}}$，表示第 $i$ 位顾客的第 $j$ 个产品的目标气压为 $\\mathbf{X}_{\\mathbf{i}, \\mathbf{j}}$ 帕斯卡。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是按照指定气压充气所有产品所需的最少按钮按压次数。\n", "hint": "**样例解释**\n\n在样例 #1 中，一种最优的充气方式是：\n\n1. 按 **上** 按钮 10 次，将气压设为 10；为顾客 1 的气压需求为 10 的产品充气，\n2. 按 **上** 按钮 30 次，将气压设为 40；为顾客 1 的气压需求为 40 的产品充气，\n3. 按 **下** 按钮 10 次，将气压设为 30；为顾客 1 的气压需求为 30 的产品充气，\n4. 按 **下** 按钮 10 次，将气压设为 20；为顾客 2 的气压需求为 20 的产品充气，\n5. 按 **上** 按钮 30 次，将气压设为 50；为顾客 2 的气压需求为 50 的产品充气，\n6. 按 **上** 按钮 10 次，将气压设为 60；为顾客 2 和顾客 3 的气压需求为 60 的三个产品充气，\n7. 最后按 **下** 按钮 10 次，将气压设为 50；为顾客 3 的气压需求为 50 的产品充气。\n\n总计需要 110 次按钮按压。\n\n在样例 #2 中，请注意答案可能超过 $2^{32}$。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}, \\mathbf{j}} \\leq 10^9$（对所有 $i, j$ 成立）。\n\n**测试集 1（14 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 10$。\n- $2 \\leq \\mathbf{P} \\leq 3$。\n\n**测试集 2（21 分，隐藏判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$。\n- $2 \\leq \\mathbf{P} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12989", "type": "P", "difficulty": 6, "samples": [["1\n\n3\n\n0", "\n00110011\n\n00011001"]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["2022", "交互题", "Special Judge", "构造", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2022 #1B] ASeDatAb", "background": "", "description": "A research consortium has been looking for the best possible database for three years, but they are still having problems. The database stores values as records that hold 8-bit binary strings. Unfortunately, their implementation of the function to set the value of a record is flawed.\n\nEach record of the database is an 8-bit binary string. The bits of the binary string are indexed from 0 to 7 from left to right. When an instruction to set a specific record to a new value $V$ is received, instead of setting the value to $V$ the database does the following:\n\n1. Choose an integer $r$ between 0 and 7, inclusive, and let $W$ be like $V$ but rotated by $r$ to the right. That is, the $((i + r) \\bmod 8)$-th bit of $W$ is the $i$-th bit of $V$.\n2. Replace the current value $X$ of the record with $X$ XOR $W$. That is, the new value of the record has a 1 as its $i$-th bit if and only if the $i$-th bits of $X$ and $W$ are different.\n3. Finally, return the number of bits that are 1 in the new value to the user.\n\nLuckily, it turns out that no matter what the initial value is or what rotation values the database chooses, it is always possible to reset the value of a record to have all bits be 0 with no more than 300 uses of this operation. Implement a program to interact with the database that does this.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nAt the beginning of each test case, the record in the database is set to a value that is not $00000000$. In each test case, your program must process up to $300$ exchanges.\n\nThe $i$-th exchange starts with you outputting a single line containing a single 8-bit binary string to be used as the value $V$ for the operation above. Then, the judge program performs the operation as described and sends you a single line containing a single integer $\\mathbf{N}_{\\mathbf{i}}$ representing the number of bits that are equal to 1 in the updated value of the record.\n\n* If $\\mathbf{N}_{\\mathbf{i}}=0$, it means that you have succeeded and you must start the next test case, or finish the program if it was the last one.\n* If $\\mathbf{N}_{\\mathbf{i}}=-1$ it means that this was the 300-th exchange of the test case but the record never got to a value of all zeroes, so the test is failed. No further test cases will be processed.\n* If $1 \\leq \\mathbf{N}_{\\mathbf{i}} \\leq 8$, it means that the updated value of the record has $\\mathbf{N}_{\\mathbf{i}}$ ones and you may proceed to the next exchange to keep trying to make it contain only zeroes.\n\nYour solution is considered correct if and only if you succeed in setting the value of the record to $00000000$ for all test cases.\n\nIf the judge receives an invalidly formatted or invalid line from your program at any moment, the judge will print a single number $-1$ and will not print any further output. If you receive a $-1$, you must finish correctly and without exceeding the time or memory limits to receive a Wrong Answer judgement. Otherwise, you will receive a judgement informing the exceeded resource or the incorrect termination condition.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently. \n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-1 \\leq \\mathbf{N}_{\\mathbf{i}} \\leq 8$ for all $i$.\n\n**Test Set 1 (25 Pts, Visible Verdict)**\n\nThe initial value of the record is chosen uniformly at random from all 8-bit binary strings that are not $00000000$.\n\nEach rotation value is chosen uniformly at random, and independently of all previous choices and interactions.\n\n**Test Set 2 (15 Pts, Visible Verdict)**\n\nThe judge is adversarial. This means, among other things, that the judge can change the initial value or rotation values as long as it is consistent with all interactions. The initial value is guaranteed to never be $00000000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1B] ASeDatAb", "background": "", "description": "A research consortium has been looking for the best possible database for three years, but they are still having problems. The database stores values as records that hold 8-bit binary strings. Unfortunately, their implementation of the function to set the value of a record is flawed.\n\nEach record of the database is an 8-bit binary string. The bits of the binary string are indexed from 0 to 7 from left to right. When an instruction to set a specific record to a new value $V$ is received, instead of setting the value to $V$ the database does the following:\n\n1. Choose an integer $r$ between 0 and 7, inclusive, and let $W$ be like $V$ but rotated by $r$ to the right. That is, the $((i + r) \\bmod 8)$-th bit of $W$ is the $i$-th bit of $V$.\n2. Replace the current value $X$ of the record with $X$ XOR $W$. That is, the new value of the record has a 1 as its $i$-th bit if and only if the $i$-th bits of $X$ and $W$ are different.\n3. Finally, return the number of bits that are 1 in the new value to the user.\n\nLuckily, it turns out that no matter what the initial value is or what rotation values the database chooses, it is always possible to reset the value of a record to have all bits be 0 with no more than 300 uses of this operation. Implement a program to interact with the database that does this.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nAt the beginning of each test case, the record in the database is set to a value that is not $00000000$. In each test case, your program must process up to $300$ exchanges.\n\nThe $i$-th exchange starts with you outputting a single line containing a single 8-bit binary string to be used as the value $V$ for the operation above. Then, the judge program performs the operation as described and sends you a single line containing a single integer $\\mathbf{N}_{\\mathbf{i}}$ representing the number of bits that are equal to 1 in the updated value of the record.\n\n* If $\\mathbf{N}_{\\mathbf{i}}=0$, it means that you have succeeded and you must start the next test case, or finish the program if it was the last one.\n* If $\\mathbf{N}_{\\mathbf{i}}=-1$ it means that this was the 300-th exchange of the test case but the record never got to a value of all zeroes, so the test is failed. No further test cases will be processed.\n* If $1 \\leq \\mathbf{N}_{\\mathbf{i}} \\leq 8$, it means that the updated value of the record has $\\mathbf{N}_{\\mathbf{i}}$ ones and you may proceed to the next exchange to keep trying to make it contain only zeroes.\n\nYour solution is considered correct if and only if you succeed in setting the value of the record to $00000000$ for all test cases.\n\nIf the judge receives an invalidly formatted or invalid line from your program at any moment, the judge will print a single number $-1$ and will not print any further output. If you receive a $-1$, you must finish correctly and without exceeding the time or memory limits to receive a Wrong Answer judgement. Otherwise, you will receive a judgement informing the exceeded resource or the incorrect termination condition.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently. \n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-1 \\leq \\mathbf{N}_{\\mathbf{i}} \\leq 8$ for all $i$.\n\n**Test Set 1 (25 Pts, Visible Verdict)**\n\nThe initial value of the record is chosen uniformly at random from all 8-bit binary strings that are not $00000000$.\n\nEach rotation value is chosen uniformly at random, and independently of all previous choices and interactions.\n\n**Test Set 2 (15 Pts, Visible Verdict)**\n\nThe judge is adversarial. This means, among other things, that the judge can change the initial value or rotation values as long as it is consistent with all interactions. The initial value is guaranteed to never be $00000000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1B] ASeDatAb", "background": "", "description": "一个研究联盟花费三年时间寻找最佳数据库，但仍存在问题。该数据库以 8 位二进制字符串形式存储记录值。遗憾的是，他们实现记录值设置功能的方式存在缺陷。\n\n数据库的每条记录都是一个 8 位二进制字符串，其位索引从左到右为 0 至 7。当收到将特定记录设置为新值 $V$ 的指令时，数据库并不会直接将其设为 $V$，而是执行以下操作：\n\n1. 选择一个 0 到 7 之间的整数 $r$，并生成 $V$ 向右循环移动 $r$ 位后的值 $W$。即 $W$ 的第 $((i + r) \\bmod 8)$ 位等于 $V$ 的第 $i$ 位。\n2. 将记录的当前值 $X$ 更新为 $X$ 与 $W$ 的异或值（即新值的第 $i$ 位为 1 当且仅当 $X$ 和 $W$ 的第 $i$ 位不同）。\n3. 最后向用户返回新值中 1 的位数。\n\n幸运的是，无论初始值如何或数据库如何选择旋转值，总能通过不超过 300 次操作将记录值重置为全 0。请编写一个程序与数据库交互完成此任务。\n\n### 交互协议\n\n本题为交互题。\n\n初始时，你的程序应读取一个整数 $\\mathbf{T}$ 表示测试用例数量，随后处理 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例开始时，数据库记录会被设为非 $00000000$ 的值。每个测试用例中，你的程序最多可进行 300 轮交互。\n\n每轮交互流程：\n1. 你输出一个 8 位二进制字符串作为操作值 $V$\n2. 评测系统执行前述操作后，返回一个整数 $\\mathbf{N_{i}}$ 表示更新后记录值中 1 的位数\n   - 若 $\\mathbf{N_{i}}=0$ 表示成功，应开始下一测试用例（或程序终止）\n   - 若 $\\mathbf{N_{i}}=-1$ 表示第 300 次操作仍未归零，测试失败（后续用例不再处理）\n   - 若 $1 \\leq \\mathbf{N_{i}} \\leq 8$ 可继续尝试\n\n只有当所有测试用例均成功将记录值归零时，解答才被视为正确。\n\n若检测到非法输出，评测系统将返回 -1 并终止。收到 -1 后需正常退出以避免资源错误判定。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "可使用测试工具进行本地测试（需与代码并行运行）。工具说明详见其注释，注意该工具**并非**真实评测系统。\n\n**数据范围**\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $-1 \\leq \\mathbf{N_{i}} \\leq 8$\n\n**测试集 1（25 分，可见判定）**\n- 初始值为均匀随机生成的非全零 8 位二进制数\n- 旋转值均为独立均匀随机选择\n\n**测试集 2（15 分，可见判定）**\n- 评测系统采用对抗策略（可动态调整初始值和旋转值）\n- 保证初始值不为全零\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12990", "type": "P", "difficulty": 4, "samples": [["6\n5\nCODE JAM MIC EEL ZZZZZ\n6\nCODE JAM MIC EEL ZZZZZ EEK\n2\nOY YO\n2\nHASH CODE\n6\nA AA BB A BA BB\n2\nCAT TAX", "Case #1: ZZZZZJAMMICCODEEEL\nCase #2: IMPOSSIBLE\nCase #3: IMPOSSIBLE\nCase #4: IMPOSSIBLE\nCase #5: BBBBBAAAAA\nCase #6: IMPOSSIBLE"]], "limits": {"time": [5000, 5000, 5000], "memory": [1048576, 1048576, 1048576]}, "tags": ["字符串", "贪心", "2022", "Special Judge", "Google Code Jam"], "title": "[GCJ 2022 #1C] Letter Blocks", "background": "", "description": "It is a rainy day, so you are indoors building towers of letter blocks. A letter block is a wooden cube that has a letter printed on one of its sides. The font used for the letters makes the blocks have a clear orientation: that is, there is only one side that can be pointed down (toward the floor) and one side that can be pointed up (toward the ceiling).\n\nYou have built multiple separate towers so far. Now you want to combine all of them into a single megatower by choosing one of your towers as the base, then picking up another tower (without changing the order of its blocks) and stacking the whole thing on top of that, and so on, until all towers have been used.\n\nAs an additional constraint for the megatower, for any two blocks that have the same letter, all blocks between them must also have that letter. That is, each letter of the alphabet that appears in the megatower needs to appear in one contiguous group (of one or more blocks).\n\nFor example, consider the following three possible megatowers. (These are separate examples, not built from the same original towers. Also note that the different block sizes are just for fun and are not part of the problem.)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s3qed2k7.png)\n\nThe leftmost two megatowers are valid, since each letter appears in a contiguous group. However, the rightmost megatower is not valid, because there is a B in between two Cs.\n\nGiven the towers that you have built so far, can you stack them all up into a valid megatower?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described by two lines. The first line consists of a single integer $\\mathbf{N}$, the number of towers that are currently built. The second line consists of $\\mathbf{N}$ strings $\\mathbf{S}_{1}, \\mathbf{S}_{2}, \\ldots, \\mathbf{S}_{\\mathbf{N}}$ representing the towers. Each of these strings consists of only uppercase letters. The $i$-th letter of each of these strings is the letter on the $i$-th block from the bottom in the represented tower.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string representing a valid megatower as described above, or the word IMPOSSIBLE if no valid megatower can be built. (Notice that the string IMPOSSIBLE can never itself represent a valid megatower, since the two $\\mathbf{i}$ s have other letters in between.)", "hint": "**Sample Explanation 1**\n\nIn Sample Case #1, `JAMMICCODEEELZZZZZ` and `ZZZZZJAMMICCODEEEL` are the only two valid outputs.\n\nIn Sample Case #2, recall that all towers must be used in the megatower, so even though the first five towers together would form a valid megatower (as in Sample Case #1), the additional `EEK` makes the case impossible. No matter how the `EEL` and `EEK` towers are stacked relative to each other, there will be at least two non-contiguous groups of `E`s.\n\nIn Sample Case #3, no matter how you stack the towers, either the two `O`s are not contiguous or the two Ys are not contiguous.\n\nIn Sample Case #4, there are non-H letters in between the `H`s of `HASH`, so this case is also impossible.\n\nIn Sample Case #5, this answer is the only valid one. Also notice that the towers are not necessarily all distinct.\n\nIn Sample Case #6, no matter how you stack the towers, the two `A`s cannot be contiguous.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 10$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 6$.\n\n**Test Set 2 (15 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1C] Letter Blocks", "background": "", "description": "It is a rainy day, so you are indoors building towers of letter blocks. A letter block is a wooden cube that has a letter printed on one of its sides. The font used for the letters makes the blocks have a clear orientation: that is, there is only one side that can be pointed down (toward the floor) and one side that can be pointed up (toward the ceiling).\n\nYou have built multiple separate towers so far. Now you want to combine all of them into a single megatower by choosing one of your towers as the base, then picking up another tower (without changing the order of its blocks) and stacking the whole thing on top of that, and so on, until all towers have been used.\n\nAs an additional constraint for the megatower, for any two blocks that have the same letter, all blocks between them must also have that letter. That is, each letter of the alphabet that appears in the megatower needs to appear in one contiguous group (of one or more blocks).\n\nFor example, consider the following three possible megatowers. (These are separate examples, not built from the same original towers. Also note that the different block sizes are just for fun and are not part of the problem.)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s3qed2k7.png)\n\nThe leftmost two megatowers are valid, since each letter appears in a contiguous group. However, the rightmost megatower is not valid, because there is a B in between two Cs.\n\nGiven the towers that you have built so far, can you stack them all up into a valid megatower?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described by two lines. The first line consists of a single integer $\\mathbf{N}$, the number of towers that are currently built. The second line consists of $\\mathbf{N}$ strings $\\mathbf{S}_{1}, \\mathbf{S}_{2}, \\ldots, \\mathbf{S}_{\\mathbf{N}}$ representing the towers. Each of these strings consists of only uppercase letters. The $i$-th letter of each of these strings is the letter on the $i$-th block from the bottom in the represented tower.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string representing a valid megatower as described above, or the word IMPOSSIBLE if no valid megatower can be built. (Notice that the string IMPOSSIBLE can never itself represent a valid megatower, since the two $\\mathbf{i}$ s have other letters in between.)", "hint": "**Sample Explanation 1**\n\nIn Sample Case #1, `JAMMICCODEEELZZZZZ` and `ZZZZZJAMMICCODEEEL` are the only two valid outputs.\n\nIn Sample Case #2, recall that all towers must be used in the megatower, so even though the first five towers together would form a valid megatower (as in Sample Case #1), the additional `EEK` makes the case impossible. No matter how the `EEL` and `EEK` towers are stacked relative to each other, there will be at least two non-contiguous groups of `E`s.\n\nIn Sample Case #3, no matter how you stack the towers, either the two `O`s are not contiguous or the two Ys are not contiguous.\n\nIn Sample Case #4, there are non-H letters in between the `H`s of `HASH`, so this case is also impossible.\n\nIn Sample Case #5, this answer is the only valid one. Also notice that the towers are not necessarily all distinct.\n\nIn Sample Case #6, no matter how you stack the towers, the two `A`s cannot be contiguous.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 10$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 6$.\n\n**Test Set 2 (15 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1C] Letter Blocks", "background": "", "description": "这是一个雨天，所以你待在室内搭建字母积木塔。一个**字母积木**是一个木制立方体，其一面印有一个字母。使用的字体使积木具有明确的方向性：即只有一个面可以朝下（朝向地板），一个面可以朝上（朝向天花板）。\n\n目前你已经搭建了多个独立的塔。现在你想将它们全部组合成一个**超级塔**：选择其中一座塔作为基底，然后拿起另一座塔（不改变其积木顺序）将其整体堆叠在基底上，以此类推，直到所有塔都被使用。\n\n超级塔还有一个额外限制：对于任意两个相同字母的积木，它们之间的所有积木也必须是该字母。也就是说，字母表中每个出现在超级塔中的字母必须出现在一个连续的组中（一个或多个积木）。\n\n例如，以下是三个可能的超级塔（这些是独立的示例，并非由相同的原始塔构建而成。另外请注意，积木的不同大小仅为趣味性，不属于题目的一部分）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s3qed2k7.png)\n\n最左侧的两个超级塔是合法的，因为每个字母都出现在一个连续的组中。但最右侧的超级塔不合法，因为两个 `C` 之间有一个 `B`。\n\n给定你目前已搭建的塔，能否将它们全部堆叠成一个合法的超级塔？", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。每个测试用例由两行描述。第一行是一个整数 $\\mathbf{N}$，表示当前搭建的塔的数量。第二行包含 $\\mathbf{N}$ 个字符串 $\\mathbf{S}_{1}, \\mathbf{S}_{2}, \\ldots, \\mathbf{S}_{\\mathbf{N}}$，表示这些塔。每个字符串仅由大写字母组成。每个字符串的第 $i$ 个字母表示对应塔中从底部数第 $i$ 个积木的字母。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是表示合法超级塔的字符串，或者如果无法构建合法超级塔，则输出单词 `IMPOSSIBLE`。（注意，字符串 `IMPOSSIBLE` 本身永远不可能表示合法的超级塔，因为两个 `i` 之间有其他字母。）\n", "hint": "**样例解释 1**\n\n在样例 #1 中，`JAMMICCODEEELZZZZZ` 和 `ZZZZZJAMMICCODEEEL` 是仅有的两种合法输出。\n\n在样例 #2 中，请注意所有塔都必须用于超级塔，因此即使前五座塔可以组成一个合法超级塔（如样例 #1），额外的 `EEK` 使得该用例无法实现。无论 `EEL` 和 `EEK` 塔如何堆叠，至少会有两组不连续的 `E`。\n\n在样例 #3 中，无论怎样堆叠塔，要么两个 `O` 不连续，要么两个 `Y` 不连续。\n\n在样例 #4 中，`HASH` 的 `H` 之间有非 `H` 字母，因此该用例也无法实现。\n\n在样例 #5 中，这是唯一的合法答案。另外请注意，塔不一定是完全不同的。\n\n在样例 #6 中，无论怎样堆叠塔，两个 `A` 都无法连续。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$1 \\leq \\text{字符串 } \\mathbf{S}_i \\text{ 的长度} \\leq 10$。\n\n**测试集 1（10 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 6$。\n\n**测试集 2（15 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12991", "type": "P", "difficulty": 6, "samples": [["4\n2 1\n-2 6\n2 1\n-10 10\n1 1\n0\n3 1\n2 -2 2", "Case #1: 3\nCase #2: IMPOSSIBLE\nCase #3: -1000000000000000000\nCase #4: 2"], ["3\n3 10\n-2 3 6\n6 2\n-2 2 1 -2 4 -1\n1 12\n-5", "Case #1: 0\nCase #2: -1 15\nCase #3: 1 1 1 1 1 1 1 1 1 1 1"]], "limits": {"time": [5000, 5000, 10000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2022", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2022 #1C] Squary", "background": "", "description": "Addition and squaring do not commute. That is, the square of the sum of all elements of a list of integers is not necessarily equal to the sum of the squares of those same elements. However, this is true for some lists; one example is $[3,-2,6]$, because $(3+(-2)+6)^{2}=49=3^{2}+(-2)^{2}+6^{2}$. Let us call these lists squary.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qa49q9z1.png)\n\nGiven a (not necessarily squary) list of relatively small integers, we want to know whether it is possible to add at least $1$ and at most $\\mathbf{K}$ more elements such that the final list is squary. Each added element must be an integer between $-10^{18}$ and $10^{18}$, inclusive, and these do not have to be distinct from each other or from the initial list's elements.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The first line contains two integers $\\mathbf{N}$ and $\\mathbf{K}$, the number of elements of the initial list and the maximum number of elements you may add, respectively. The second line contains $\\mathbf{N}$ integers $\\mathbf{E}_{1}, \\mathbf{E}_{2}, \\ldots, \\mathbf{E}_{\\mathbf{N}}$, representing the $\\mathbf{N}$ elements of the initial list.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1). If it is possible to add at least 1 and at most $\\mathbf{K}$ elements (each an integer between $-10^{18}$ and $10^{18}$, inclusive) to the initial list such that the square of the sum of its elements equals the sum of the squares of its elements, $y$ should be $z_{1} z_{2} \\ldots z_{r}$, where $1 \\leq r \\leq \\mathbf{K}$ and the $z_{i}$ values are the additional elements. If there is no way to accomplish this, $y$ should be IMPOSSIBLE.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can end up with the example list given in the problem statement.\n\nIn Sample Case #2, we have to add exactly one element. If we call that element $x$, the sum of the entire list is $x$ and its square is $x^{2}$. The sum of the squares of all elements, on the other hand, is $x^{2}+10^{2}+(-10)^{2}=x^{2}+200 \\neq x^{2}$, so the case is impossible.\n\nIn Sample Case #3, any integer in the $\\left[-10^{18}, 10^{18}\\right]$ range is a valid answer.\n\nIn Sample Case #4, notice that the input might contain duplicate elements, and that it is valid to create even more duplicates with the elements you choose to add.\n\nSample 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn Case #1 of the additional samples, we are given the example list from the problem statement, which is already squary, but we need to add at least one element to it. Adding a 0 keeps the list squary.\n\nIn Case #3 of the additional samples, we present one of multiple possible valid answers. Notice that it is permissible to add fewer than $\\mathbf{K}$ elements; here $\\mathbf{K}$ is 12 but we have only added 11 elements.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100 .$\n- $1 \\leq \\mathbf{N} \\leq 1000 .$\n- $-1000 \\leq \\mathbf{E}_{\\mathbf{i}} \\leq 1000$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $\\mathbf{K}=1$.\n\n**Test Set 2 (22 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $2 \\leq \\mathbf{K} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1C] Squary", "background": "", "description": "Addition and squaring do not commute. That is, the square of the sum of all elements of a list of integers is not necessarily equal to the sum of the squares of those same elements. However, this is true for some lists; one example is $[3,-2,6]$, because $(3+(-2)+6)^{2}=49=3^{2}+(-2)^{2}+6^{2}$. Let us call these lists squary.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qa49q9z1.png)\n\nGiven a (not necessarily squary) list of relatively small integers, we want to know whether it is possible to add at least $1$ and at most $\\mathbf{K}$ more elements such that the final list is squary. Each added element must be an integer between $-10^{18}$ and $10^{18}$, inclusive, and these do not have to be distinct from each other or from the initial list's elements.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The first line contains two integers $\\mathbf{N}$ and $\\mathbf{K}$, the number of elements of the initial list and the maximum number of elements you may add, respectively. The second line contains $\\mathbf{N}$ integers $\\mathbf{E}_{1}, \\mathbf{E}_{2}, \\ldots, \\mathbf{E}_{\\mathbf{N}}$, representing the $\\mathbf{N}$ elements of the initial list.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1). If it is possible to add at least 1 and at most $\\mathbf{K}$ elements (each an integer between $-10^{18}$ and $10^{18}$, inclusive) to the initial list such that the square of the sum of its elements equals the sum of the squares of its elements, $y$ should be $z_{1} z_{2} \\ldots z_{r}$, where $1 \\leq r \\leq \\mathbf{K}$ and the $z_{i}$ values are the additional elements. If there is no way to accomplish this, $y$ should be IMPOSSIBLE.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can end up with the example list given in the problem statement.\n\nIn Sample Case #2, we have to add exactly one element. If we call that element $x$, the sum of the entire list is $x$ and its square is $x^{2}$. The sum of the squares of all elements, on the other hand, is $x^{2}+10^{2}+(-10)^{2}=x^{2}+200 \\neq x^{2}$, so the case is impossible.\n\nIn Sample Case #3, any integer in the $\\left[-10^{18}, 10^{18}\\right]$ range is a valid answer.\n\nIn Sample Case #4, notice that the input might contain duplicate elements, and that it is valid to create even more duplicates with the elements you choose to add.\n\nSample 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn Case #1 of the additional samples, we are given the example list from the problem statement, which is already squary, but we need to add at least one element to it. Adding a 0 keeps the list squary.\n\nIn Case #3 of the additional samples, we present one of multiple possible valid answers. Notice that it is permissible to add fewer than $\\mathbf{K}$ elements; here $\\mathbf{K}$ is 12 but we have only added 11 elements.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100 .$\n- $1 \\leq \\mathbf{N} \\leq 1000 .$\n- $-1000 \\leq \\mathbf{E}_{\\mathbf{i}} \\leq 1000$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $\\mathbf{K}=1$.\n\n**Test Set 2 (22 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $2 \\leq \\mathbf{K} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1C] Squary", "background": "", "description": "加法与平方运算不可交换。也就是说，一个整数列表中所有元素的和的平方，不一定等于这些元素各自的平方和。然而，某些列表满足这一性质，例如 $[3,-2,6]$，因为 $(3+(-2)+6)^{2}=49=3^{2}+(-2)^{2}+6^{2}$。我们将这样的列表称为**平方性列表**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qa49q9z1.png)\n\n给定一个（不一定是平方性的）由较小整数构成的列表，我们想知道是否可以通过添加至少 $1$ 个、至多 $\\mathbf{K}$ 个元素，使得最终的列表具有平方性。每个添加的元素必须是介于 $-10^{18}$ 和 $10^{18}$（含）之间的整数，且这些元素不必互不相同，也不必与初始列表中的元素不同。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。每个测试用例由两行描述。第一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$，分别表示初始列表的元素数量和最多可添加的元素数量。第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{E}_{1}, \\mathbf{E}_{2}, \\ldots, \\mathbf{E}_{\\mathbf{N}}$，表示初始列表的 $\\mathbf{N}$ 个元素。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始）。如果可以通过添加至少 1 个、至多 $\\mathbf{K}$ 个元素（每个元素介于 $-10^{18}$ 和 $10^{18}$ 之间）使得列表元素的平方和等于元素和的平方，则 $y$ 应为 $z_{1} z_{2} \\ldots z_{r}$，其中 $1 \\leq r \\leq \\mathbf{K}$，$z_{i}$ 为添加的元素。如果无法实现，则 $y$ 应为 `IMPOSSIBLE`。", "hint": "**样例解释**\n\n在样例 #1 中，我们可以得到题目描述中的示例列表。\n\n在样例 #2 中，必须恰好添加一个元素 $x$。此时整个列表的和为 $x$，其平方为 $x^{2}$。而所有元素的平方和为 $x^{2}+10^{2}+(-10)^{2}=x^{2}+200 \\neq x^{2}$，因此该用例无法实现。\n\n在样例 #3 中，$\\left[-10^{18}, 10^{18}\\right]$ 范围内的任意整数均为合法答案。\n\n在样例 #4 中，注意输入可能包含重复元素，且通过添加元素创建更多重复也是合法的。\n\n样例 2 符合测试集 2 的限制，但不会用于测试你的提交。\n\n在附加样例的用例 #1 中，我们给出了题目描述中的示例列表（已是平方性列表），但需要至少添加一个元素。添加 0 可以保持列表的平方性。\n\n在附加样例的用例 #3 中，我们展示了一种可能的合法答案。注意可以添加少于 $\\mathbf{K}$ 个元素；此处 $\\mathbf{K}=12$，但我们仅添加了 11 个元素。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{N} \\leq 1000$。\n- 对所有 $i$，$-1000 \\leq \\mathbf{E}_{\\mathbf{i}} \\leq 1000$。\n\n**测试集 1（9 分，可见判定）**\n\n- 时间限制：5 秒。\n- $\\mathbf{K}=1$。\n\n**测试集 2（22 分，可见判定）**\n\n- 时间限制：10 秒。\n- $2 \\leq \\mathbf{K} \\leq 1000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12992", "type": "P", "difficulty": 7, "samples": [["3\n5 2\n5 1\n6 3", "Case #1: 428571432\nCase #2: 571428576\nCase #3: 47619048"]], "limits": {"time": [20000, 20000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2022", "组合数学", "Google Code Jam"], "title": "[GCJ 2022 #1C] Intranets", "background": "", "description": "Apricot Rules LLC is developing a new simplified networking protocol and wants to show off their routing algorithm. In their design, a network consists of $\\mathbf{M}$ machines numbered from 1 to $\\mathbf{M}$, and each pair of machines is connected by a direct link. Each of the links is given a unique integer priority value between 1 and $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)$ and each machine routes traffic according to those priorities.\n\nUnfortunately, the routing algorithm is too aggressive and will route all traffic from a machine through the highest priority link connected to it. This may make some groups of machines isolated from others.\n\nFormally, we say that a machine $m$ uses a link $\\ell$ if (and only if) $\\ell$ is the highest priority link connected to $m$. We also say that a link is active if it is used by at least one of the two machines it connects. Given the link priorities, the original network becomes partitioned into disjoint intranets. Two machines belong to the same intranet if and only if there is some path between them using only active links.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hi8p2brt.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/aiu45d35.png)\n\nFor example, as seen in the left image above, only the links with priorities 6 and 5 are active. This creates two disjoint intranets. However, in the example on the right, three links are active, which results in one intranet consisting of all 4 machines.\n\nAs part of the quality assurance team at Apricot Rules LLC, you are investigating the extent of the problem. You are interested in knowing the probability of there being exactly $\\mathbf{K}$ intranets if the priorities are assigned uniformly at random from among the $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)!$ ways of doing so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing two integers $\\mathbf{M}$ and $\\mathbf{K}$ : the number of machines and the target number of intranets, respectively.", "outputFormat": "For each test case, output one line containing Case # $x: y$, where $x$ is the test case number (starting from 1) and $y$ is the sought probability computed modulo the prime $10^{9}+7$ ($1000000007$), which is defined precisely as follows. Represent the probability as as an irreducible fraction $p / q$ (with $p$ and $q$ being non-negative integers that minimize $p+q$ ). Then, $y$ must equal $p \\cdot q^{-1} \\bmod 10^{9}+7$, where $q^{-1}$ is the modular multiplicative inverse of $q$ with respect to the modulus $10^{9}+7$. It can be shown that under the constraints of this problem, such a number $y$ always exists and is unique.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, consider the following situation. Let's call $\\mathbf{M}=5$ machines $1,2,3,4,5$ and denote the link connecting machine $a$ and machine $b$ by $(a, b)$. Assume that the priorities of links $(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)$ are $9,8,7,6,5,4,3,2,1,10$, respectively. Then machines 1 and 2 use link $(1,2)$, machine 3 uses link $(1,3)$, and machines 4 and 5 use link $(4,5)$. Thus three links $(1,2),(1,3),(4,5)$ are active, and there are two intranets $\\{1,2,3\\}$ and $\\{4,5\\}$. Since $\\mathbf{K}=2$, this situation counts the answer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uoy2l0x6.png)\n\nWe can find that there are $1555200$ ways to assign the priorities to have exactly $2$ intranets among $10 !=3628800$ ways, so the probability is $3 / 7$.\n\nIn Sample Case #2, the probability is $4 / 7$.\n\nIn Sample Case #3, the probability is $1 / 21$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $1 \\leq \\mathbf{K} \\leq \\mathbf{M} / 2$.\n\n**Test Set 1 (17 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{M} \\leq 50$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{M} \\leq 5 \\times 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1C] Intranets", "background": "", "description": "Apricot Rules LLC is developing a new simplified networking protocol and wants to show off their routing algorithm. In their design, a network consists of $\\mathbf{M}$ machines numbered from 1 to $\\mathbf{M}$, and each pair of machines is connected by a direct link. Each of the links is given a unique integer priority value between 1 and $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)$ and each machine routes traffic according to those priorities.\n\nUnfortunately, the routing algorithm is too aggressive and will route all traffic from a machine through the highest priority link connected to it. This may make some groups of machines isolated from others.\n\nFormally, we say that a machine $m$ uses a link $\\ell$ if (and only if) $\\ell$ is the highest priority link connected to $m$. We also say that a link is active if it is used by at least one of the two machines it connects. Given the link priorities, the original network becomes partitioned into disjoint intranets. Two machines belong to the same intranet if and only if there is some path between them using only active links.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hi8p2brt.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/aiu45d35.png)\n\nFor example, as seen in the left image above, only the links with priorities 6 and 5 are active. This creates two disjoint intranets. However, in the example on the right, three links are active, which results in one intranet consisting of all 4 machines.\n\nAs part of the quality assurance team at Apricot Rules LLC, you are investigating the extent of the problem. You are interested in knowing the probability of there being exactly $\\mathbf{K}$ intranets if the priorities are assigned uniformly at random from among the $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)!$ ways of doing so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing two integers $\\mathbf{M}$ and $\\mathbf{K}$ : the number of machines and the target number of intranets, respectively.", "outputFormat": "For each test case, output one line containing Case # $x: y$, where $x$ is the test case number (starting from 1) and $y$ is the sought probability computed modulo the prime $10^{9}+7$ ($1000000007$), which is defined precisely as follows. Represent the probability as as an irreducible fraction $p / q$ (with $p$ and $q$ being non-negative integers that minimize $p+q$ ). Then, $y$ must equal $p \\cdot q^{-1} \\bmod 10^{9}+7$, where $q^{-1}$ is the modular multiplicative inverse of $q$ with respect to the modulus $10^{9}+7$. It can be shown that under the constraints of this problem, such a number $y$ always exists and is unique.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, consider the following situation. Let's call $\\mathbf{M}=5$ machines $1,2,3,4,5$ and denote the link connecting machine $a$ and machine $b$ by $(a, b)$. Assume that the priorities of links $(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)$ are $9,8,7,6,5,4,3,2,1,10$, respectively. Then machines 1 and 2 use link $(1,2)$, machine 3 uses link $(1,3)$, and machines 4 and 5 use link $(4,5)$. Thus three links $(1,2),(1,3),(4,5)$ are active, and there are two intranets $\\{1,2,3\\}$ and $\\{4,5\\}$. Since $\\mathbf{K}=2$, this situation counts the answer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uoy2l0x6.png)\n\nWe can find that there are $1555200$ ways to assign the priorities to have exactly $2$ intranets among $10 !=3628800$ ways, so the probability is $3 / 7$.\n\nIn Sample Case #2, the probability is $4 / 7$.\n\nIn Sample Case #3, the probability is $1 / 21$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $1 \\leq \\mathbf{K} \\leq \\mathbf{M} / 2$.\n\n**Test Set 1 (17 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{M} \\leq 50$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{M} \\leq 5 \\times 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1C] Intranets", "background": "", "description": "Apricot Rules LLC 公司正在开发一种新的简化网络协议，并希望展示其路由算法。在他们的设计中，网络由编号从 1 到 $\\mathbf{M}$ 的 $\\mathbf{M}$ 台机器组成，每对机器之间通过一条直接链路连接。每条链路被赋予一个唯一的整数优先级，优先级值介于 1 到 $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)$ 之间，每台机器根据这些优先级来路由流量。\n\n遗憾的是，该路由算法过于激进，会将一台机器的所有流量都通过与其连接的最高优先级链路进行路由。这可能导致某些机器组与其他机器组隔离。\n\n正式地说，我们说一台机器 $m$ 使用一条链路 $\\ell$，当且仅当 $\\ell$ 是与 $m$ 连接的优先级最高的链路。我们还称一条链路是**活跃的**，如果它被其连接的两台机器中的至少一台使用。根据链路优先级，原始网络将被划分为若干个不相交的**内联网**。两台机器属于同一个内联网，当且仅当它们之间存在一条仅由活跃链路组成的路径。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hi8p2brt.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/aiu45d35.png)\n\n例如，如上图左侧所示，只有优先级为 6 和 5 的链路是活跃的。这形成了两个不相交的内联网。然而，右侧的示例中有三条活跃链路，结果形成了一个包含所有 4 台机器的内联网。\n\n作为 Apricot Rules LLC 公司质量保证团队的一员，你正在调查这个问题的严重程度。你感兴趣的是，如果优先级是从 $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)!$ 种可能的分配方式中均匀随机选择的，那么恰好形成 $\\mathbf{K}$ 个内联网的概率是多少。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例由一行描述，包含两个整数 $\\mathbf{M}$ 和 $\\mathbf{K}$，分别表示机器的数量和目标内联网的数量。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所求概率对质数 $10^{9}+7$（$1000000007$）取模后的结果。具体定义如下：将概率表示为不可约分数 $p/q$（其中 $p$ 和 $q$ 是非负整数，且 $p+q$ 最小），则 $y$ 必须等于 $p \\cdot q^{-1} \\bmod 10^{9}+7$，其中 $q^{-1}$ 是 $q$ 在模 $10^{9}+7$ 下的模逆元。可以证明，在本问题的约束条件下，这样的 $y$ 总是存在且唯一。\n", "hint": "**样例解释**\n\n在样例 #1 中，考虑以下情况。设 $\\mathbf{M}=5$ 台机器为 $1,2,3,4,5$，并将连接机器 $a$ 和机器 $b$ 的链路记为 $(a, b)$。假设链路 $(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)$ 的优先级分别为 $9,8,7,6,5,4,3,2,1,10$。那么机器 1 和 2 使用链路 $(1,2)$，机器 3 使用链路 $(1,3)$，机器 4 和 5 使用链路 $(4,5)$。因此，三条链路 $(1,2),(1,3),(4,5)$ 是活跃的，形成了两个内联网 $\\{1,2,3\\}$ 和 $\\{4,5\\}$。由于 $\\mathbf{K}=2$，这种情况计入答案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uoy2l0x6.png)\n\n我们可以发现，在 $10! = 3628800$ 种优先级分配方式中，有 $1555200$ 种方式会恰好形成 $2$ 个内联网，因此概率为 $3/7$。\n\n在样例 #2 中，概率为 $4/7$。\n\n在样例 #3 中，概率为 $1/21$。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 50$。\n- $1 \\leq \\mathbf{K} \\leq \\mathbf{M}/2$。\n\n**测试集 1（17 分，可见判定）**\n\n- 时间限制：20 秒。\n- $2 \\leq \\mathbf{M} \\leq 50$。\n\n**测试集 2（27 分，隐藏判定）**\n\n- 时间限制：60 秒。\n- $2 \\leq \\mathbf{M} \\leq 5 \\times 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12993", "type": "P", "difficulty": 4, "samples": [["4\n5 4\n5 3\n5 12\n3 1", "Case #1: 2\n2 17\n18 25\nCase #2: IMPOSSIBLE\nCase #3: 2\n11 22\n22 25\nCase #4: IMPOSSIBLE"]], "limits": {"time": [5000, 5000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2022", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2022 #2] Spiraling Into Control", "background": "", "description": "As punishment for being naughty, Dante has been trapped in a strange house with many rooms. The house is an $\\mathbf{N} \\times \\mathbf{N}$ grid of rooms, with $\\mathbf{N}$ odd and greater than 1. The upper left room is numbered 1 , and then the other rooms are numbered $2,3, \\ldots, \\mathbf{N}^{2}$, in a clockwise spiral pattern. That is, the numbering proceeds along the top row of the grid and then makes a 90 degree turn to the right whenever a grid boundary or an already numbered room is encountered, and finishes in the central room of the grid. Because $\\mathbf{N}$ is odd, there is always a room in the exact center of the house, and it is always numbered $\\mathbf{N}^{2}$.\n\nFor example, here are the room numberings for houses with $\\mathbf{N}=3$ and $\\mathbf{N}=5$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/agyafjba.png)\n\nDante starts off in room 1 and is trying to reach the central room (room $\\mathbf{N}^{2}$ ). Throughout his journey, he can only make moves from his current room to higher-numbered, adjacent rooms. (Two rooms must share an edge - not just a corner - to be adjacent.)\n\nDante knows that he could walk from room to room in consecutive numerical order - i.e., if he is currently in room $x$, he would move to room $x+1$, and so on. This would take him exactly $\\mathbf{N}^{2}-1$ moves. But Dante wants to do things his way! Specifically, he wants to reach the central room in exactly $\\mathbf{K}$ moves, for some $\\mathbf{K}$ strictly less than $\\mathbf{N}^{2}-1$.\n\nDante can accomplish this by taking one or more shortcuts. A shortcut is a move between rooms that are not consecutively numbered.\n\nFor example, in the $5 \\times 5$ house above,\n\n- If Dante is at $1$, he cannot move to $17$, but he can move to $2$ or to $16$. The move to $2$ is not a shortcut, since $1+1=2$. The move to $16$ is a shortcut, since $1+1 \\neq 16$.\n- From $2$, it is possible to move to $3$ (not a shortcut) or to $17$ (a shortcut), but not to $1,16$, or $18$.\n- From $24$, Dante can only move to $25$ (not a shortcut).\n- It is not possible to move out of room $25$.\n\nAs a specific example using the $5 \\times 5$ house above, suppose that $\\mathbf{K}=4$. One option is for Dante to move from $1$ to $2$, then move from $2$ to $17$ (which is a shortcut), then move from $17$ to $18$, then move from $18$ to $25$ (which is another shortcut). This is illustrated below (the red arrows represent shortcuts):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/010wa6d8.png)\n\nCan you help Dante find a sequence of exactly $\\mathbf{K}$ moves that gets him to the central room, or tell him that it is impossible?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of one line with two integers $\\mathbf{N}$ and $\\mathbf{K}$, where $\\mathbf{N}$ is the dimension of the house (i.e. the number of rows of rooms, which is the same as the number of columns of rooms), and $\\mathbf{K}$ is the exact number of moves that Dante wants to make while traveling from room 1 to room $\\mathbf{N}^{2}$.", "outputFormat": "For each test case, output one line containing `Case x: y`, where $x$ is the test case number (starting from 1).\n\nIf no valid sequence of exactly $\\mathbf{K}$ moves will get Dante to the central room, $y$ must be IMPOSSIBLE.\n\nOtherwise, $y$ must be an integer: the number of times that Dante takes a shortcut, as described above. (Notice that because Dante wants to finish in strictly less than $\\mathbf{N}^{2}-1$ moves, he must always use at least one shortcut.) Then, output $y$ more lines of two integers each. The $i$-th of these lines represents the $i$-th time in Dante's journey that he takes a shortcut, i.e., he moves from some room $a_{i}$ to another room $b_{i}$ such that $a_{i}+1<b_{i}$.\n\nNotice that because these lines follow the order of the journey, $a_{i}<a_{i+1}$ for all $1 \\leq i<y$.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the problem statement. Dante's route is $1 \\rightarrow 2 \\rightarrow 17 \\rightarrow 18 \\rightarrow 25$. Because $1 \\rightarrow 2$ and $17 \\rightarrow 18$ are moves between consecutively numbered rooms, they are not included in the output. Only the shortcuts $(2 \\rightarrow 17$ and $18 \\rightarrow 25)$ are included.\n\nIn Sample Case #2, there is no solution. (Recall that there is no way for Dante to move diagonally.)\n\nIn Sample Case #3, observe that $22$ appears both as the end of one shortcut and the start of the next. It would not be valid to include the line $11\\ 22\\ 25$ in the output; each line must represent a single shortcut.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ee9lv8u.png)\n\nThere is another solution that uses only one shortcut: Dante can move from $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6$, then move from $6 \\rightarrow 19$ (a shortcut), then move from $19 \\rightarrow 20 \\rightarrow 21 \\rightarrow 22 \\rightarrow 23 \\rightarrow 24 \\rightarrow 25$. This is also valid; there is no requirement to minimize (or maximize) the number of shortcuts taken.\n\nIn Sample Case #4, Dante cannot get to the central room ($9$, in this case) in just one move.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{K}<\\mathbf{N}^{2}-1$.\n- $\\mathbf{N} \\bmod \\quad 2 \\equiv 1$. ($\\mathbf{N}$ is odd.)\n\n**Test Set 1 (3 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $3 \\leq \\mathbf{N} \\leq 9$.\n\n**Test Set 2 (4 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 39$.\n\n**Test Set 3 (13 Pts, Hidden Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 9999$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #2] Spiraling Into Control", "background": "", "description": "As punishment for being naughty, Dante has been trapped in a strange house with many rooms. The house is an $\\mathbf{N} \\times \\mathbf{N}$ grid of rooms, with $\\mathbf{N}$ odd and greater than 1. The upper left room is numbered 1 , and then the other rooms are numbered $2,3, \\ldots, \\mathbf{N}^{2}$, in a clockwise spiral pattern. That is, the numbering proceeds along the top row of the grid and then makes a 90 degree turn to the right whenever a grid boundary or an already numbered room is encountered, and finishes in the central room of the grid. Because $\\mathbf{N}$ is odd, there is always a room in the exact center of the house, and it is always numbered $\\mathbf{N}^{2}$.\n\nFor example, here are the room numberings for houses with $\\mathbf{N}=3$ and $\\mathbf{N}=5$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/agyafjba.png)\n\nDante starts off in room 1 and is trying to reach the central room (room $\\mathbf{N}^{2}$ ). Throughout his journey, he can only make moves from his current room to higher-numbered, adjacent rooms. (Two rooms must share an edge - not just a corner - to be adjacent.)\n\nDante knows that he could walk from room to room in consecutive numerical order - i.e., if he is currently in room $x$, he would move to room $x+1$, and so on. This would take him exactly $\\mathbf{N}^{2}-1$ moves. But Dante wants to do things his way! Specifically, he wants to reach the central room in exactly $\\mathbf{K}$ moves, for some $\\mathbf{K}$ strictly less than $\\mathbf{N}^{2}-1$.\n\nDante can accomplish this by taking one or more shortcuts. A shortcut is a move between rooms that are not consecutively numbered.\n\nFor example, in the $5 \\times 5$ house above,\n\n- If Dante is at $1$, he cannot move to $17$, but he can move to $2$ or to $16$. The move to $2$ is not a shortcut, since $1+1=2$. The move to $16$ is a shortcut, since $1+1 \\neq 16$.\n- From $2$, it is possible to move to $3$ (not a shortcut) or to $17$ (a shortcut), but not to $1,16$, or $18$.\n- From $24$, Dante can only move to $25$ (not a shortcut).\n- It is not possible to move out of room $25$.\n\nAs a specific example using the $5 \\times 5$ house above, suppose that $\\mathbf{K}=4$. One option is for Dante to move from $1$ to $2$, then move from $2$ to $17$ (which is a shortcut), then move from $17$ to $18$, then move from $18$ to $25$ (which is another shortcut). This is illustrated below (the red arrows represent shortcuts):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/010wa6d8.png)\n\nCan you help Dante find a sequence of exactly $\\mathbf{K}$ moves that gets him to the central room, or tell him that it is impossible?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of one line with two integers $\\mathbf{N}$ and $\\mathbf{K}$, where $\\mathbf{N}$ is the dimension of the house (i.e. the number of rows of rooms, which is the same as the number of columns of rooms), and $\\mathbf{K}$ is the exact number of moves that Dante wants to make while traveling from room 1 to room $\\mathbf{N}^{2}$.", "outputFormat": "For each test case, output one line containing `Case x: y`, where $x$ is the test case number (starting from 1).\n\nIf no valid sequence of exactly $\\mathbf{K}$ moves will get Dante to the central room, $y$ must be IMPOSSIBLE.\n\nOtherwise, $y$ must be an integer: the number of times that Dante takes a shortcut, as described above. (Notice that because Dante wants to finish in strictly less than $\\mathbf{N}^{2}-1$ moves, he must always use at least one shortcut.) Then, output $y$ more lines of two integers each. The $i$-th of these lines represents the $i$-th time in Dante's journey that he takes a shortcut, i.e., he moves from some room $a_{i}$ to another room $b_{i}$ such that $a_{i}+1<b_{i}$.\n\nNotice that because these lines follow the order of the journey, $a_{i}<a_{i+1}$ for all $1 \\leq i<y$.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the problem statement. Dante's route is $1 \\rightarrow 2 \\rightarrow 17 \\rightarrow 18 \\rightarrow 25$. Because $1 \\rightarrow 2$ and $17 \\rightarrow 18$ are moves between consecutively numbered rooms, they are not included in the output. Only the shortcuts $(2 \\rightarrow 17$ and $18 \\rightarrow 25)$ are included.\n\nIn Sample Case #2, there is no solution. (Recall that there is no way for Dante to move diagonally.)\n\nIn Sample Case #3, observe that $22$ appears both as the end of one shortcut and the start of the next. It would not be valid to include the line $11\\ 22\\ 25$ in the output; each line must represent a single shortcut.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ee9lv8u.png)\n\nThere is another solution that uses only one shortcut: Dante can move from $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6$, then move from $6 \\rightarrow 19$ (a shortcut), then move from $19 \\rightarrow 20 \\rightarrow 21 \\rightarrow 22 \\rightarrow 23 \\rightarrow 24 \\rightarrow 25$. This is also valid; there is no requirement to minimize (or maximize) the number of shortcuts taken.\n\nIn Sample Case #4, Dante cannot get to the central room ($9$, in this case) in just one move.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{K}<\\mathbf{N}^{2}-1$.\n- $\\mathbf{N} \\bmod \\quad 2 \\equiv 1$. ($\\mathbf{N}$ is odd.)\n\n**Test Set 1 (3 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $3 \\leq \\mathbf{N} \\leq 9$.\n\n**Test Set 2 (4 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 39$.\n\n**Test Set 3 (13 Pts, Hidden Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 9999$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #2] Spiraling Into Control", "background": "", "description": "由于调皮捣蛋，但丁被关进了一间由许多房间组成的奇怪房子。这栋房子是一个 $\\mathbf{N} \\times \\mathbf{N}$ 的网格状房间布局，其中 $\\mathbf{N}$ 为奇数且大于 1。左上角的房间编号为 1，其余房间按顺时针螺旋顺序依次编号为 $2, 3, \\ldots, \\mathbf{N}^{2}$。具体来说，编号从网格的顶行开始，每当遇到网格边界或已编号的房间时，向右转 90 度，最终到达网格正中央的房间。因为 $\\mathbf{N}$ 是奇数，房子中心始终有一个房间，其编号恒为 $\\mathbf{N}^{2}$。\n\n例如，下图展示了 $\\mathbf{N}=3$ 和 $\\mathbf{N}=5$ 时的房间编号：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/agyafjba.png)\n\n但丁从房间 1 出发，试图抵达中心房间（编号 $\\mathbf{N}^{2}$）。在行进过程中，他只能从当前房间移动到编号更大且相邻的房间（两房间必须共享一条边，而非仅共享一个角落）。\n\n但丁知道他可以按连续数字顺序移动——即若当前位于房间 $x$，则下一步移动到 $x+1$，依此类推。这样恰好需要 $\\mathbf{N}^{2}-1$ 步。但他想按自己的方式行动！具体来说，他希望**恰好用 $\\mathbf{K}$ 步**到达中心房间，其中 $\\mathbf{K}$ 严格小于 $\\mathbf{N}^{2}-1$。\n\n为此，但丁需要通过一个或多个**捷径**实现。捷径是指两个非连续编号房间之间的移动。\n\n以 $\\mathbf{N}=5$ 的房屋为例：\n\n- 若但丁位于 $1$，他不能移动到 $17$，但可移动到 $2$ 或 $16$。移动到 $2$ 不是捷径（因为 $1+1=2$），而移动到 $16$ 是捷径（因为 $1+1 \\neq 16$）。\n- 从 $2$ 可移动到 $3$（非捷径）或 $17$（捷径），但不能移动到 $1$、$16$ 或 $18$。\n- 从 $24$ 只能移动到 $25$（非捷径）。\n- 无法从房间 $25$ 移出。\n\n更具体的例子：当 $\\mathbf{N}=5$ 且 $\\mathbf{K}=4$ 时，一种可行方案是 $1 \\rightarrow 2 \\rightarrow 17$（捷径）$\\rightarrow 18 \\rightarrow 25$（捷径）。如下图所示（红色箭头代表捷径）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/010wa6d8.png)\n\n请你帮助但丁找到恰好 $\\mathbf{K}$ 步到达中心房间的路径，或判断其不可能。", "inputFormat": "第一行输入测试用例数量 $\\mathbf{T}$。随后 $\\mathbf{T}$ 行，每行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$，分别表示房屋的维度（行列数）和但丁期望的移动步数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case x: y`，其中 $x$ 为用例编号（从 1 开始）。\n\n若无法用恰好 $\\mathbf{K}$ 步到达中心房间，$y$ 为 **IMPOSSIBLE**。\n\n否则，$y$ 为但丁使用的捷径数量（因 $\\mathbf{K} < \\mathbf{N}^{2}-1$，至少需一次捷径）。随后输出 $y$ 行，每行两个整数 $a_i$ 和 $b_i$，表示第 $i$ 次捷径是从 $a_i$ 移动到 $b_i$（满足 $a_i+1 < b_i$）。\n\n注意：这些行需按行进顺序排列，即对所有 $1 \\leq i < y$ 有 $a_i < a_{i+1}$。", "hint": "**样例解释**\n\n样例 #1 对应题目描述中的示例。但丁的路径为 $1 \\rightarrow 2 \\rightarrow 17 \\rightarrow 18 \\rightarrow 25$。其中 $1 \\rightarrow 2$ 和 $17 \\rightarrow 18$ 是连续移动，故仅输出捷径 $(2 \\rightarrow 17$ 和 $18 \\rightarrow 25)$。\n\n样例 #2 无解（注意但丁无法斜向移动）。\n\n样例 #3 中，数字 $22$ 既是前一次捷径的终点，也是下一次的起点。输出中不能合并为 $11\\ 22\\ 25$，每行必须代表单独一次捷径。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ee9lv8u.png)\n\n另一种仅需一次捷径的方案：$1 \\rightarrow 2 \\rightarrow \\ldots \\rightarrow 6 \\rightarrow 19$（捷径）$\\rightarrow 20 \\rightarrow \\ldots \\rightarrow 25$。此方案同样有效，不要求最小化或最大化捷径次数。\n\n样例 #4 中，但丁无法一步到达中心房间（此处为 $9$）。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{K} < \\mathbf{N}^{2}-1$。\n- $\\mathbf{N} \\bmod 2 \\equiv 1$（$\\mathbf{N}$ 为奇数）。\n\n**测试集 1（3 分，可见判定）**\n\n- 时间限制：5 秒。\n- $3 \\leq \\mathbf{N} \\leq 9$。\n\n**测试集 2（4 分，可见判定）**\n\n- 时间限制：20 秒。\n- $3 \\leq \\mathbf{N} \\leq 39$。\n\n**测试集 3（13 分，隐藏判定）**\n\n- 时间限制：20 秒。\n- $3 \\leq \\mathbf{N} \\leq 9999$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12994", "type": "P", "difficulty": 5, "samples": [["3\n2\n8\n50", "Case #1: 4\nCase #2: 24\nCase #3: 812"]], "limits": {"time": [10000, 10000, 15000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2022", "Google Code Jam"], "title": "[GCJ 2022 #2] Pixelated Circle", "background": "", "description": "Typical computer images are matrices of pixels, with each pixel being a small square of a specific color. Drawing lines that are not perfectly parallel to the axes of the pixel matrix results in imperfections. Drawing circles is an extreme example where those imperfections arise.\n\nSuppose we have a picture consisting of $2 \\mathbf{R}+1$ by $2 \\mathbf{R}+1$ pixels, and we number the rows and columns of pixels between $-\\mathbf{R}$ and $\\mathbf{R}$, such that the center pixel is at row 0 and column 0 . Initially, all pixels are white. Then, a circle of radius $\\mathbf{R}$ and centered in the picture can be drawn in black by the following pseudocode, where `set_pixel_to_black` $(x, y)$ makes the pixel at row $x$ and column $y$ be colored black.\n\n```\ndraw_circle_perimeter(R):\n  for x between -R and R, inclusive {\n    y = round(sqrt(R * R - x * x))   # round to nearest integer, breaking ties towards zero\n    set_pixel_to_black(x, y)\n    set_pixel_to_black(x, -y)\n    set_pixel_to_black(y, x)\n    set_pixel_to_black(-y, x)\n  }\n```\n\nNotice that some pixels may be set to black more than once by the code, but the operation is idempotent (that is, calling `set_pixel_to_black` on a pixel that is already black changes nothing).\n\nThe following is pseudocode for a function to draw a filled circle (starting from an all-white picture).\n\n```\ndraw_circle_filled(R):\n  for x between -R and R, inclusive {\n    for y between -R and R, inclusive {\n      if round(sqrt(x * x + y * y)) <= R:\n        set_pixel_to_black(x, y)\n    }\n  }\n```\n\nAnd finally, the following is pseudocode to incorrectly draw a filled circle:\n\n```\ndraw_circle_filled_wrong(R):\n  for r between 0 and R, inclusive {\n    draw_circle_perimeter(r)\n  }\n```\n\nGiven $\\mathbf{R}$, calculate the number of pixels that would have different colors between a picture in which `draw_circle_filled` $(\\mathbf{R})$ is called and another one in which draw_circle_filled_wrong $(\\mathbf{R})$ is called.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing a single integer $\\mathbf{R}$, the radius of the circle to draw.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of pixels that would have different colors between a picture in which draw_circle_filled $(\\mathbf{R})$ is called and another one in which draw_circle_filled_wrong $(\\mathbf{R})$ is called.", "hint": "In Sample Case #1, $21$ pixels are drawn in black by calling `draw_circle_filled(2)` (shown in the left picture). 17 pixels are drawn in black by calling `draw_circle_filled_wrong(2)` (shown in the right picture). Four pixels would have different colors between the two pictures: $(-1,-1),(-1,1),(1,-1)$, and $(1,1)$, where $(x, y)$ represents the pixel at row $x$ and column $y$, with the rows and columns numbered as described in the statement.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mon7gnuv.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/7e8vljtj.png)\n\nIn Sample Case #2, the following pictures are the images generated by calling `draw_circle_filled(8)` (left) and `draw_circle_filled_wrong(8)` (right).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ropx4q0k.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/hmbxyi6p.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{R} \\leq 100$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- Time limit: 15 seconds.\n- $1 \\leq \\mathbf{R} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #2] Pixelated Circle", "background": "", "description": "Typical computer images are matrices of pixels, with each pixel being a small square of a specific color. Drawing lines that are not perfectly parallel to the axes of the pixel matrix results in imperfections. Drawing circles is an extreme example where those imperfections arise.\n\nSuppose we have a picture consisting of $2 \\mathbf{R}+1$ by $2 \\mathbf{R}+1$ pixels, and we number the rows and columns of pixels between $-\\mathbf{R}$ and $\\mathbf{R}$, such that the center pixel is at row 0 and column 0 . Initially, all pixels are white. Then, a circle of radius $\\mathbf{R}$ and centered in the picture can be drawn in black by the following pseudocode, where `set_pixel_to_black` $(x, y)$ makes the pixel at row $x$ and column $y$ be colored black.\n\n```\ndraw_circle_perimeter(R):\n  for x between -R and R, inclusive {\n    y = round(sqrt(R * R - x * x))   # round to nearest integer, breaking ties towards zero\n    set_pixel_to_black(x, y)\n    set_pixel_to_black(x, -y)\n    set_pixel_to_black(y, x)\n    set_pixel_to_black(-y, x)\n  }\n```\n\nNotice that some pixels may be set to black more than once by the code, but the operation is idempotent (that is, calling `set_pixel_to_black` on a pixel that is already black changes nothing).\n\nThe following is pseudocode for a function to draw a filled circle (starting from an all-white picture).\n\n```\ndraw_circle_filled(R):\n  for x between -R and R, inclusive {\n    for y between -R and R, inclusive {\n      if round(sqrt(x * x + y * y)) <= R:\n        set_pixel_to_black(x, y)\n    }\n  }\n```\n\nAnd finally, the following is pseudocode to incorrectly draw a filled circle:\n\n```\ndraw_circle_filled_wrong(R):\n  for r between 0 and R, inclusive {\n    draw_circle_perimeter(r)\n  }\n```\n\nGiven $\\mathbf{R}$, calculate the number of pixels that would have different colors between a picture in which `draw_circle_filled` $(\\mathbf{R})$ is called and another one in which draw_circle_filled_wrong $(\\mathbf{R})$ is called.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing a single integer $\\mathbf{R}$, the radius of the circle to draw.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of pixels that would have different colors between a picture in which draw_circle_filled $(\\mathbf{R})$ is called and another one in which draw_circle_filled_wrong $(\\mathbf{R})$ is called.", "hint": "In Sample Case #1, $21$ pixels are drawn in black by calling `draw_circle_filled(2)` (shown in the left picture). 17 pixels are drawn in black by calling `draw_circle_filled_wrong(2)` (shown in the right picture). Four pixels would have different colors between the two pictures: $(-1,-1),(-1,1),(1,-1)$, and $(1,1)$, where $(x, y)$ represents the pixel at row $x$ and column $y$, with the rows and columns numbered as described in the statement.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mon7gnuv.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/7e8vljtj.png)\n\nIn Sample Case #2, the following pictures are the images generated by calling `draw_circle_filled(8)` (left) and `draw_circle_filled_wrong(8)` (right).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ropx4q0k.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/hmbxyi6p.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{R} \\leq 100$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- Time limit: 15 seconds.\n- $1 \\leq \\mathbf{R} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #2] Pixelated Circle", "background": "", "description": "典型的计算机图像是由像素组成的矩阵，每个像素是一个特定颜色的小方块。绘制不完美平行于像素矩阵坐标轴的线条会导致瑕疵，而绘制圆形则是这种瑕疵的极端例子。\n\n假设我们有一张由 $2 \\mathbf{R}+1$ 行 $2 \\mathbf{R}+1$ 列像素组成的图片，像素的行和列编号从 $-\\mathbf{R}$ 到 $\\mathbf{R}$，中心像素位于第 0 行第 0 列。初始时，所有像素均为白色。然后，可以通过以下伪代码绘制一个半径为 $\\mathbf{R}$ 且居中的黑色圆，其中 `set_pixel_to_black` $(x, y)$ 将第 $x$ 行第 $y$ 列的像素设为黑色：\n\n```\ndraw_circle_perimeter(R):\n  for x between -R and R, inclusive {\n    y = round(sqrt(R * R - x * x))   # round to nearest integer, breaking ties towards zero\n    set_pixel_to_black(x, y)\n    set_pixel_to_black(x, -y)\n    set_pixel_to_black(y, x)\n    set_pixel_to_black(-y, x)\n  }\n```\n\n注意，某些像素可能被多次设为黑色，但该操作是幂等的（即对已经是黑色的像素调用 `set_pixel_to_black` 不会有任何效果）。\n\n以下是绘制实心圆的伪代码（从全白图片开始）：\n\n```\ndraw_circle_filled(R):\n  for x between -R and R, inclusive {\n    for y between -R and R, inclusive {\n      if round(sqrt(x * x + y * y)) <= R:\n        set_pixel_to_black(x, y)\n    }\n  }\n```\n\n最后，以下是错误绘制实心圆的伪代码：\n\n```\ndraw_circle_filled_wrong(R):\n  for r between 0 and R, inclusive {\n    draw_circle_perimeter(r)\n  }\n```\n\n给定 $\\mathbf{R}$，计算在调用 `draw_circle_filled` $(\\mathbf{R})$ 和调用 `draw_circle_filled_wrong` $(\\mathbf{R})$ 的两张图片中颜色不同的像素数量。\n", "inputFormat": "第一行输入测试用例数量 $\\mathbf{T}$。随后 $\\mathbf{T}$ 行，每行包含一个整数 $\\mathbf{R}$，表示要绘制的圆的半径。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为用例编号（从 1 开始），$y$ 为两张图片中颜色不同的像素数量。\n", "hint": "在样例 #1 中，调用 `draw_circle_filled(2)` 会绘制 21 个黑色像素（左图），调用 `draw_circle_filled_wrong(2)` 会绘制 17 个黑色像素（右图）。两张图片中有 4 个像素颜色不同：$(-1,-1)$、$(-1,1)$、$(1,-1)$ 和 $(1,1)$，其中 $(x, y)$ 表示第 $x$ 行第 $y$ 列的像素，行列编号如题目描述所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mon7gnuv.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/7e8vljtj.png)\n\n在样例 #2 中，左图和右图分别是调用 `draw_circle_filled(8)` 和 `draw_circle_filled_wrong(8)` 生成的图片。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ropx4q0k.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/hmbxyi6p.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试集 1（5 分，可见判定）**\n\n- 时间限制：10 秒。\n- $1 \\leq \\mathbf{R} \\leq 100$。\n\n**测试集 2（隐藏判定）**\n\n- 时间限制：15 秒。\n- $1 \\leq \\mathbf{R} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
