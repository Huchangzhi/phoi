{"pid": "P3169", "type": "P", "difficulty": 6, "samples": [["3\n2\n2", "10536"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递推", "2015", "重庆", "各省省选", "矩阵加速"], "title": "[CQOI2015] 多项式", "background": "", "description": "在学习完二项式定理后，数学老师给出了一道题目：已知整数 $n,t$ 和 $a_k$（$0\\le k\\le n$），求 $b_k$（$0\\le k\\le n$）的表达式使得:\n\n$$\n\\sum_{k=0}^n a_kx^k=\\sum_{k=0}^nb_k(x-t)^k\n$$\n\n同学们很快算出了答案。见大家这么快就搞定了，老师便布置了一个更 BT 的作业：计算某个 $b_k$ 的具体数值！接着便在黑板上写下了 $n,t$ 的数值，由于 $a_k$ 实在太多，不能全写在黑板上，老师只给出了一个 $a_k$ 的递推式，让学生自行计算:\n\n$$\na_k=\n\\begin{cases}\n(1234\\cdot a_{k-1}+5678)\\bmod 3389 & k\\gt 0 \\\\\n1 & k=0 \\\\\n\\end{cases}\n$$\n\n正在学习信息竞赛的你觉得这个作业实在不适合手工完成，便敲起了代码……\n", "inputFormat": "输入文件共三行，第一行为一个正整数 $n$，第二行为一个非负整数 $t$，第三行为一个非负整数 $m$。\n", "outputFormat": "输出一行，为 $b_m$ 的值。", "hint": "数据范围：\n\n对于 $20\\%$ 的数据，$t=0$。\n\n对于另外 $30\\%$ 的数据，$n\\le 10^5$。\n\n对于 $100\\%$ 的数据，$0\\lt n\\le 10^{3000}$，$0\\le t\\le 10^4$，$0\\le n-m\\le 5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2015] Polynomial", "background": "", "description": "After learning the binomial theorem, the math teacher gave a problem: given integers $n, t$ and $a_k$ ($0\\le k\\le n$), find the expressions for $b_k$ ($0\\le k\\le n$) such that:\n\n$$\n\\sum_{k=0}^n a_kx^k=\\sum_{k=0}^nb_k(x-t)^k\n$$\n\nThe students quickly worked out the answer. Seeing everyone finish so fast, the teacher assigned an even more brutal task: compute the specific value of some $b_k$. Then the teacher wrote the values of $n, t$ on the blackboard. Since there were too many $a_k$ to write out, the teacher only provided a recurrence for $a_k$ and asked the students to compute it themselves:\n\n$$\na_k=\n\\begin{cases}\n(1234\\cdot a_{k-1}+5678)\\bmod 3389 & k\\gt 0 \\\\\n1 & k=0 \\\\\n\\end{cases}\n$$\n\nAs someone learning competitive programming, you feel this homework is not suitable for manual calculation, so you start coding.", "inputFormat": "The input consists of three lines. The first line contains a positive integer $n$. The second line contains a non-negative integer $t$. The third line contains a non-negative integer $m$.", "outputFormat": "Output one line containing the value of $b_m$.", "hint": "Constraints:\n\n- For 20% of the testdata, $t=0$.\n- For another 30% of the testdata, $n\\le 10^5$.\n- For 100% of the testdata, $0\\lt n\\le 10^{3000}$, $0\\le t\\le 10^4$, $0\\le n-m\\le 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2015] 多项式", "background": "", "description": "在学习完二项式定理后，数学老师给出了一道题目：已知整数 $n,t$ 和 $a_k$（$0\\le k\\le n$），求 $b_k$（$0\\le k\\le n$）的表达式使得:\n\n$$\n\\sum_{k=0}^n a_kx^k=\\sum_{k=0}^nb_k(x-t)^k\n$$\n\n同学们很快算出了答案。见大家这么快就搞定了，老师便布置了一个更 BT 的作业：计算某个 $b_k$ 的具体数值！接着便在黑板上写下了 $n,t$ 的数值，由于 $a_k$ 实在太多，不能全写在黑板上，老师只给出了一个 $a_k$ 的递推式，让学生自行计算:\n\n$$\na_k=\n\\begin{cases}\n(1234\\cdot a_{k-1}+5678)\\bmod 3389 & k\\gt 0 \\\\\n1 & k=0 \\\\\n\\end{cases}\n$$\n\n正在学习信息竞赛的你觉得这个作业实在不适合手工完成，便敲起了代码……\n", "inputFormat": "输入文件共三行，第一行为一个正整数 $n$，第二行为一个非负整数 $t$，第三行为一个非负整数 $m$。\n", "outputFormat": "输出一行，为 $b_m$ 的值。", "hint": "数据范围：\n\n对于 $20\\%$ 的数据，$t=0$。\n\n对于另外 $30\\%$ 的数据，$n\\le 10^5$。\n\n对于 $100\\%$ 的数据，$0\\lt n\\le 10^{3000}$，$0\\le t\\le 10^4$，$0\\le n-m\\le 5$。\n", "locale": "zh-CN"}}}
{"pid": "P3170", "type": "P", "difficulty": 7, "samples": [["4 4\n....\n#...\n....\n..#.", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "搜索", "2015", "重庆", "各省省选", "记忆化搜索", "哈希 hashing", "轮廓线 DP"], "title": "[CQOI2015] 标识设计", "background": "", "description": "一家名字缩写为 LLL 的公司正在设计 logo，他们的初步方案是在一张方格上放置 $3$ 个 L 形的图案以及一些额外的装饰性图形，例如：![](https://cdn.luogu.com.cn/upload/pic/15558.png)  （灰色区域表示装饰性图形）。\n\n$3$ 个 L 图案和装饰性图形均放置在方格之中，且必须占满方格。L 的横竖笔画长短均可，但长度必须大于 $0$（即不能退化为一条线段）。另外，为了使 L 图案醒目且容易辨别，设计师规定 $3$ 个 L 形图案之间不能有重叠或交叉的部分。当然，L 形图案也不能穿过装饰图形或与之重叠。\n\n现在设计师已经确定了所有装饰性图形的位置，希望你计算一下放置不同的 L 形图案总共可以设计出多少个 logo。\n", "inputFormat": "第一行包含两个空格分开的正整数 $n$ 和 $m$，分别表示方格的行数和列数。\n\n接下来 $n$ 行，每行 $m$ 个字符，第 $(i + 1)$ 行第 $j$ 个字符代表第 $i$ 行第 $j$ 列的图形，该字符只可能为 `.` 或 `#`。`#` 表示该方格为装饰性图形，`.` 表示可以放置 L 图案的空白区域。", "outputFormat": "输出一个整数，为可能的logo总数。\n", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $2\\le n,m\\leq 30$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2015] Logo Design", "background": "", "description": "A company abbreviated as LLL is designing a logo. Their initial plan is to place $3$ L-shaped patterns and some extra decorative shapes on a square grid, for example: ![](https://cdn.luogu.com.cn/upload/pic/15558.png) (the gray area denotes decorative shapes).\n\nThe $3$ L-shaped patterns and the decorative shapes are all placed on the grid, and together they must cover the entire grid. The horizontal and vertical strokes of each L may have any positive length, but each length must be greater than $0$ (i.e., an L cannot degenerate into a straight line segment). In addition, to keep the L patterns clear and recognizable, the $3$ L-shaped patterns must not overlap or cross each other. Of course, an L-shaped pattern also cannot pass through or overlap any decorative shape.\n\nNow that the designer has fixed the positions of all decorative shapes, please compute how many different logos can be designed by placing the L-shaped patterns.", "inputFormat": "The first line contains two space-separated positive integers $n$ and $m$, the numbers of rows and columns of the grid.\n\nThe next $n$ lines each contain $m$ characters. In the $(i + 1)$-th line, the $j$-th character denotes the cell at row $i$, column $j$. Each character is either `.` or `#`. `#` means the cell is a decorative shape, and `.` means it is an empty cell where an L-shaped pattern may be placed.", "outputFormat": "Output a single integer, the total number of possible logos.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $2\\le n,m\\leq 30$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2015] 标识设计", "background": "", "description": "一家名字缩写为 LLL 的公司正在设计 logo，他们的初步方案是在一张方格上放置 $3$ 个 L 形的图案以及一些额外的装饰性图形，例如：![](https://cdn.luogu.com.cn/upload/pic/15558.png)  （灰色区域表示装饰性图形）。\n\n$3$ 个 L 图案和装饰性图形均放置在方格之中，且必须占满方格。L 的横竖笔画长短均可，但长度必须大于 $0$（即不能退化为一条线段）。另外，为了使 L 图案醒目且容易辨别，设计师规定 $3$ 个 L 形图案之间不能有重叠或交叉的部分。当然，L 形图案也不能穿过装饰图形或与之重叠。\n\n现在设计师已经确定了所有装饰性图形的位置，希望你计算一下放置不同的 L 形图案总共可以设计出多少个 logo。\n", "inputFormat": "第一行包含两个空格分开的正整数 $n$ 和 $m$，分别表示方格的行数和列数。\n\n接下来 $n$ 行，每行 $m$ 个字符，第 $(i + 1)$ 行第 $j$ 个字符代表第 $i$ 行第 $j$ 列的图形，该字符只可能为 `.` 或 `#`。`#` 表示该方格为装饰性图形，`.` 表示可以放置 L 图案的空白区域。", "outputFormat": "输出一个整数，为可能的logo总数。\n", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $2\\le n,m\\leq 30$。", "locale": "zh-CN"}}}
{"pid": "P3171", "type": "P", "difficulty": 6, "samples": [["7 10\n1 2 2\n1 5 2\n2 4 1\n2 3 3\n3 7 1\n4 5 4\n4 3 1\n4 6 1\n5 6 2\n6 7 1\n1\n100\n20\n50\n20\n60\n1", "70"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "重庆", "各省省选", "网络流", "最短路"], "title": "[CQOI2015] 网络吞吐量", "background": "路由是指通过计算机网络把信息从源地址传输到目的地址的活动，也是计算机网络设计中的重点和难点。网络中实现路由转发的硬件设备称为路由器。为了使数据包最快的到达目的地，路由器需要选择最优的路径转发数据包。例如在常用的路由算法 OSPF (开放式最短路径优先) 中，路由器会使用经典的 Dijkstra 算法计算最短路径，然后尽量沿最短路径转发数据包。\n", "description": "现在，若已知一个计算机网络中各路由器间的连接情况，以及各个路由器的最大吞吐量（即每秒能转发的数据包数量），网络中的路由器使用 $1$ 到 $n$ 编号，假设所有数据包一定沿最短路径转发，试计算从路由器 $1$ 到路由器 $n$ 的网络的最大吞吐量。计算中忽略转发及传输的时间开销，不考虑链路的带宽限制，即认为数据包可以瞬间通过网络。路由器 $1$ 到路由器 $n$ 作为起点和终点，自身的吞吐量不用考虑，网络上也不存在将 $1$ 和 $n$ 直接相连的链路。\n", "inputFormat": "输入的第一行是用空格隔开的两个整数，分别代表路由器的数量 $n$ 和链路的数量 $m$。\n\n第 $2$ 到第 $(m + 1)$  行，每行三个整数 $u, v, w$，代表存在一条连结路由器 $u$ 和路由器 $v$  的距离为 $w$ 的双向链路。\n\n第 $(m + 2)$ 到第 $(n + m + 1)$  行，每行一个整数，第 $(i + m + 1)$ 行的整数代表路由器 $i$ 的吞吐量 $c_i$。\n", "outputFormat": "输出一行一个整数，代表网络的最大吞吐量。\n", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 500$，$1 \\leq m \\leq 10^5$，$1 \\leq w, c_i \\leq 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2015] Network Throughput", "background": "Routing is the activity of transferring information from a source address to a destination address through a computer network, and it is both a key and difficult part of network design. The hardware device that performs routing and forwarding in a network is called a router. To deliver packets to their destinations as quickly as possible, routers need to choose optimal paths to forward packets. For example, in the commonly used routing algorithm OSPF (Open Shortest Path First), routers use the classic Dijkstra algorithm to compute shortest paths and then forward packets along the shortest paths whenever possible.", "description": "Now, given the connectivity between routers in a computer network and the maximum throughput of each router (i.e., the number of packets it can forward per second), with routers numbered from $1$ to $n$, assume all packets are forwarded strictly along shortest paths. Compute the maximum throughput from router $1$ to router $n$. Ignore the time overhead of forwarding and transmission, and do not consider link bandwidth limits, i.e., assume packets can traverse the network instantaneously. Routers $1$ and $n$ serve as the source and destination, and their own throughputs are not considered. There is also no link that directly connects $1$ and $n$.", "inputFormat": "The first line contains two integers separated by a space, representing the number of routers $n$ and the number of links $m$.\n\nLines $2$ to $(m + 1)$ each contain three integers $u, v, w$, indicating there is an undirected link connecting routers $u$ and $v$ with distance $w$.\n\nLines $(m + 2)$ to $(n + m + 1)$ each contain one integer. The integer on line $(i + m + 1)$ represents the throughput $c_i$ of router $i$.", "outputFormat": "Output a single line containing one integer, representing the maximum throughput of the network.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 500$, $1 \\leq m \\leq 10^5$, and $1 \\leq w, c_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2015] 网络吞吐量", "background": "路由是指通过计算机网络把信息从源地址传输到目的地址的活动，也是计算机网络设计中的重点和难点。网络中实现路由转发的硬件设备称为路由器。为了使数据包最快的到达目的地，路由器需要选择最优的路径转发数据包。例如在常用的路由算法 OSPF (开放式最短路径优先) 中，路由器会使用经典的 Dijkstra 算法计算最短路径，然后尽量沿最短路径转发数据包。\n", "description": "现在，若已知一个计算机网络中各路由器间的连接情况，以及各个路由器的最大吞吐量（即每秒能转发的数据包数量），网络中的路由器使用 $1$ 到 $n$ 编号，假设所有数据包一定沿最短路径转发，试计算从路由器 $1$ 到路由器 $n$ 的网络的最大吞吐量。计算中忽略转发及传输的时间开销，不考虑链路的带宽限制，即认为数据包可以瞬间通过网络。路由器 $1$ 到路由器 $n$ 作为起点和终点，自身的吞吐量不用考虑，网络上也不存在将 $1$ 和 $n$ 直接相连的链路。\n", "inputFormat": "输入的第一行是用空格隔开的两个整数，分别代表路由器的数量 $n$ 和链路的数量 $m$。\n\n第 $2$ 到第 $(m + 1)$  行，每行三个整数 $u, v, w$，代表存在一条连结路由器 $u$ 和路由器 $v$  的距离为 $w$ 的双向链路。\n\n第 $(m + 2)$ 到第 $(n + m + 1)$  行，每行一个整数，第 $(i + m + 1)$ 行的整数代表路由器 $i$ 的吞吐量 $c_i$。\n", "outputFormat": "输出一行一个整数，代表网络的最大吞吐量。\n", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 500$，$1 \\leq m \\leq 10^5$，$1 \\leq w, c_i \\leq 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3172", "type": "P", "difficulty": 6, "samples": [["2 2 2 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2015", "重庆", "各省省选", "最大公约数 gcd", "莫比乌斯反演"], "title": "[CQOI2015] 选数", "background": "", "description": "我们知道，从区间 $[L,H]$（$L$ 和 $H$ 为整数）中选取 $N$ 个整数，总共有 $(H-L+1)^N$ 种方案。小 z 很好奇这样选出的数的最大公约数的规律，他决定对每种方案选出的 $N$ 个整数都求一次最大公约数，以便进一步研究。然而他很快发现工作量太大了，于是向你寻求帮助。你的任务很简单，小 z 会告诉你一个整数 $K$，你需要回答他最大公约数刚好为 $K$ 的选取方案有多少个。\n\n由于方案数较大，你只需要输出其除以 $10^9+7$ 的余数即可。", "inputFormat": "输入一行，包含四个空格分开的正整数，依次为 $N,K,L,H$。\n", "outputFormat": "输出一个整数，为所求方案数除以 $10^9 + 7$ 的余数。\n", "hint": "#### 样例 1 解释\n\n所有可能的选择方案：$(2, 2), (2, 3), (2, 4), (3, 2), (3, 3), (3, 4), (4, 2), (4, 3), (4, 4)$。\n\n其中最大公约数等于 $2$ 的只有 $3$ 组：$(2, 2), (2, 4), (4, 2)$。\n#### 数据规模与约定\n对于 $100\\%$ 的数据，$1\\le N,K\\le 10^9$，$1\\le L\\le H\\le 10^9$，$H-L\\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2015] Choosing Numbers", "background": "", "description": "We know that selecting $N$ integers from the interval $[L, H]$ (where $L$ and $H$ are integers) yields $(H - L + 1)^N$ schemes. Little z is curious about the pattern of the greatest common divisor of the numbers selected in this way. He decides to compute the greatest common divisor of the $N$ integers for every scheme for further study. However, he soon finds the workload too large, so he asks for your help. Your task is simple: Little z will give you an integer $K$, and you need to answer how many selection schemes have their greatest common divisor exactly equal to $K$.\n\nSince the number of schemes can be large, you only need to output the remainder modulo $10^9+7$.", "inputFormat": "The input consists of one line containing four space-separated positive integers, in order: $N, K, L, H$.", "outputFormat": "Output a single integer, which is the remainder of the required count modulo $10^9+7$.", "hint": "Sample 1 Explanation.\n\nAll possible selection schemes: $(2, 2), (2, 3), (2, 4), (3, 2), (3, 3), (3, 4), (4, 2), (4, 3), (4, 4)$.\n\nAmong them, those with greatest common divisor equal to $2$ are only $3$ groups: $(2, 2), (2, 4), (4, 2)$.\n\nConstraints.\n\nFor $100\\%$ of the testdata, $1\\le N, K\\le 10^9$, $1\\le L\\le H\\le 10^9$, $H - L\\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2015] 选数", "background": "", "description": "我们知道，从区间 $[L,H]$（$L$ 和 $H$ 为整数）中选取 $N$ 个整数，总共有 $(H-L+1)^N$ 种方案。小 z 很好奇这样选出的数的最大公约数的规律，他决定对每种方案选出的 $N$ 个整数都求一次最大公约数，以便进一步研究。然而他很快发现工作量太大了，于是向你寻求帮助。你的任务很简单，小 z 会告诉你一个整数 $K$，你需要回答他最大公约数刚好为 $K$ 的选取方案有多少个。\n\n由于方案数较大，你只需要输出其除以 $10^9+7$ 的余数即可。", "inputFormat": "输入一行，包含四个空格分开的正整数，依次为 $N,K,L,H$。\n", "outputFormat": "输出一个整数，为所求方案数除以 $10^9 + 7$ 的余数。\n", "hint": "#### 样例 1 解释\n\n所有可能的选择方案：$(2, 2), (2, 3), (2, 4), (3, 2), (3, 3), (3, 4), (4, 2), (4, 3), (4, 4)$。\n\n其中最大公约数等于 $2$ 的只有 $3$ 组：$(2, 2), (2, 4), (4, 2)$。\n#### 数据规模与约定\n对于 $100\\%$ 的数据，$1\\le N,K\\le 10^9$，$1\\le L\\le H\\le 10^9$，$H-L\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3173", "type": "P", "difficulty": 4, "samples": [["6 4\n2\n1\n3\n1\n4\n4\n1\n2", "42"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "递推", "2009", "河南", "各省省选", "排序", "前缀和", "双指针 two-pointer"], "title": "[HAOI2009] 巧克力", "background": null, "description": "有一块 $n \\times m$ 的矩形巧克力，准备将它切成 $n \\times m$ 块。巧克力上共有 $n-1$ 条横线和 $m-1$ 条竖线，你每次可以沿着其中的一条横线或竖线将巧克力切开，无论切割的长短，沿着每条横线切一次的代价依次为 $y_1,y_2,\\cdots,y_{n-1}$，而沿竖线切割的代价依次为 $x_1,x_2,\\cdots,x_{m-1}$。\n\n例如，对于下图 $6 \\times 4$ 的巧克力，我们先沿着三条横线切割，需要 $3$ 刀，得到 $4$ 条巧克力，然后再将这 $4$ 条巧克力沿竖线切割，每条都需要 $5$ 刀，则最终所花费的代价为 $y_1+y_2+y_3+4 \\times (x_1+x_2+x_3+x_4+x_5)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s0j2oloj.png)\n\n\n当然，上述简单切法不见得是最优切法，那么怎样切割该块巧克力，花费的代价最少呢？", "inputFormat": "第一行为两个整数 $n$ 和 $m$；\n\n接下来 $n-1$ 行，每行一个整数，分别代表 $y_1,y_2,\\cdots,y_{n-1}$；\n\n接下来 $m-1$ 行，每行一个整数，分别代表 $x_1,x_2,\\cdots,x_{m-1}$。", "outputFormat": "输出一整数，为切割巧克力的最小代价。", "hint": "$30\\%$ 的数据，$n \\leq 100,m \\leq 100$；\n\n$100\\%$ 的数据，$n \\leq 10000,m \\leq 10000$；", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2009] Chocolate", "background": "", "description": "There is a rectangular chocolate bar of size $n \\times m$, to be cut into $n \\times m$ pieces. There are $n-1$ horizontal lines and $m-1$ vertical lines on the bar. Each time, you may cut along one of these horizontal or vertical lines. Regardless of the cut length, the costs of cutting along the horizontal lines in order are $y_1,y_2,\\cdots,y_{n-1}$, and along the vertical lines in order are $x_1,x_2,\\cdots,x_{m-1}$.\n\nFor the $6 \\times 4$ chocolate shown below, suppose we first cut along the three horizontal lines, requiring $3$ cuts, producing $4$ chocolate strips. Then we cut these $4$ strips along the vertical lines, each requiring $5$ cuts. The total cost is $y_1+y_2+y_3+4 \\times (x_1+x_2+x_3+x_4+x_5)$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s0j2oloj.png)\n\nOf course, the simple method above is not necessarily optimal. How should we cut this chocolate bar to minimize the total cost?", "inputFormat": "The first line contains two integers $n$ and $m$.\n\nThe next $n-1$ lines each contain one integer, representing $y_1,y_2,\\cdots,y_{n-1}$.\n\nThe next $m-1$ lines each contain one integer, representing $x_1,x_2,\\cdots,x_{m-1}$.", "outputFormat": "Output a single integer, the minimum cost to cut the chocolate.", "hint": "For $30\\%$ of the testdata, $n \\leq 100,m \\leq 100$.\n\nFor $100\\%$ of the testdata, $n \\leq 10000,m \\leq 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2009] 巧克力", "background": null, "description": "有一块 $n \\times m$ 的矩形巧克力，准备将它切成 $n \\times m$ 块。巧克力上共有 $n-1$ 条横线和 $m-1$ 条竖线，你每次可以沿着其中的一条横线或竖线将巧克力切开，无论切割的长短，沿着每条横线切一次的代价依次为 $y_1,y_2,\\cdots,y_{n-1}$，而沿竖线切割的代价依次为 $x_1,x_2,\\cdots,x_{m-1}$。\n\n例如，对于下图 $6 \\times 4$ 的巧克力，我们先沿着三条横线切割，需要 $3$ 刀，得到 $4$ 条巧克力，然后再将这 $4$ 条巧克力沿竖线切割，每条都需要 $5$ 刀，则最终所花费的代价为 $y_1+y_2+y_3+4 \\times (x_1+x_2+x_3+x_4+x_5)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s0j2oloj.png)\n\n\n当然，上述简单切法不见得是最优切法，那么怎样切割该块巧克力，花费的代价最少呢？", "inputFormat": "第一行为两个整数 $n$ 和 $m$；\n\n接下来 $n-1$ 行，每行一个整数，分别代表 $y_1,y_2,\\cdots,y_{n-1}$；\n\n接下来 $m-1$ 行，每行一个整数，分别代表 $x_1,x_2,\\cdots,x_{m-1}$。", "outputFormat": "输出一整数，为切割巧克力的最小代价。", "hint": "$30\\%$ 的数据，$n \\leq 100,m \\leq 100$；\n\n$100\\%$ 的数据，$n \\leq 10000,m \\leq 10000$；", "locale": "zh-CN"}}}
{"pid": "P3174", "type": "P", "difficulty": 4, "samples": [["13 12 \n1 2 \n1 5 \n1 6 \n3 2 \n4 2 \n5 7 \n5 8 \n7 9 \n7 10 \n7 11 \n8 12 \n8 13 ", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "河南", "各省省选", "树形 DP"], "title": "[HAOI2009] 毛毛虫", "background": "感谢由@ScanfN 提供的两组 hack 数据。", "description": "对于一棵树，我们可以将某条链和与该链相连的边抽出来，看上去就象成一个毛毛虫，点数越多，毛毛虫就越大。例如下图左边的树（图 $1$）抽出一部分就变成了右边的一个毛毛虫了（图 $2$）。\n\n![](https://cdn.luogu.com.cn/upload/pic/7967.png)\n", "inputFormat": "输入中第一行两个整数 $N, M$，分别表示树中结点个数和树的边数。\n\n接下来 $M$ 行，每行两个整数 $a, b$ 表示点 $a$ 和点 $b$ 有边连接（$a, b \\le N$）。你可以假定没有一对相同的 $(a, b)$ 会出现一次以上。", "outputFormat": "输出一行一个整数 , 表示最大的毛毛虫的大小。\n", "hint": "对于 $40\\%$ 的数据，$1\\leq N \\le 50000$。\n\n对于 $100\\%$ 的数据，$1\\leq N \\le 300000$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2009] Caterpillar", "background": "Thanks to @ScanfN for providing two sets of hack testdata.", "description": "For a tree, we can extract some path together with the edges incident to that path; it looks like a caterpillar. The more vertices it contains, the larger the caterpillar. For example, extracting part of the tree on the left (Figure $1$) yields the caterpillar on the right (Figure $2$).\n\n![](https://cdn.luogu.com.cn/upload/pic/7967.png)", "inputFormat": "The first line contains two integers $N, M$, denoting the number of vertices and the number of edges in the tree.\n\nThe next $M$ lines each contain two integers $a, b$, indicating that there is an edge between vertices $a$ and $b$ ($a, b \\le N$). You may assume that no identical pair $(a, b)$ appears more than once.", "outputFormat": "Output a single integer on one line, representing the size of the largest caterpillar.", "hint": "For $40\\%$ of the testdata, $1\\leq N \\le 50000$.\n\nFor $100\\%$ of the testdata, $1\\leq N \\le 300000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2009] 毛毛虫", "background": "感谢由@ScanfN 提供的两组 hack 数据。", "description": "对于一棵树，我们可以将某条链和与该链相连的边抽出来，看上去就象成一个毛毛虫，点数越多，毛毛虫就越大。例如下图左边的树（图 $1$）抽出一部分就变成了右边的一个毛毛虫了（图 $2$）。\n\n![](https://cdn.luogu.com.cn/upload/pic/7967.png)\n", "inputFormat": "输入中第一行两个整数 $N, M$，分别表示树中结点个数和树的边数。\n\n接下来 $M$ 行，每行两个整数 $a, b$ 表示点 $a$ 和点 $b$ 有边连接（$a, b \\le N$）。你可以假定没有一对相同的 $(a, b)$ 会出现一次以上。", "outputFormat": "输出一行一个整数 , 表示最大的毛毛虫的大小。\n", "hint": "对于 $40\\%$ 的数据，$1\\leq N \\le 50000$。\n\n对于 $100\\%$ 的数据，$1\\leq N \\le 300000$。", "locale": "zh-CN"}}}
{"pid": "P3175", "type": "P", "difficulty": 6, "samples": [["2\n0.25 0.25 0.25 0.25", "2.6666666667"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "河南", "各省省选", "Special Judge", "容斥原理", "快速沃尔什变换 FWT"], "title": "[HAOI2015] 按位或", "background": "", "description": "刚开始你有一个数字 $0$，每一秒钟你会随机选择一个 $[0,2^n-1]$ 的数字，与你手上的数字进行或（C++,C 的 `|`，pascal 的 `or`）操作。选择数字 $i$ 的概率是 $p_i$。保证 $0\\leq p_i \\leq 1$，$\\sum p_i=1$ 。问期望多少秒后，你手上的数字变成 $2^n-1$。\n", "inputFormat": "第一行输入 $n$ 表示 $n$ 个元素，第二行输入 $2^n$ 个数，第 $i$ 个数表示选到 $i-1$ 的概率。\n", "outputFormat": "仅输出一个数表示答案，绝对误差或相对误差不超过 $10^{-6}$ 即可算通过。如果无解则要输出 `INF`。", "hint": "对于 $100\\%$ 的数据，$n\\leq 20$。\n\n以下为 spj 源代码。\n\n```cpp\n//liuchenrui \n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cmath>\n#define AC {fclose(fstd),fclose(fuser);return 0;}\n#define WA {fclose(fstd),fclose(fuser);return 1;}\n#define PE {fclose(fstd),fclose(fuser);return 5;}\n#define eps 1e-6\nint main(int const argc, char*const argv[]){\n    FILE *fstd,*fuser;\n    fstd=fopen(argv[2],\"r\");\n    fuser=fopen(argv[3],\"r\");\n    //fstd=fopen(\"x1.in\",\"r\");\n    //fuser=fopen(\"x2.in\",\"r\");\n    char s[30],t[30];\n    if(fscanf(fuser,\"%s\",s+1)==-1)WA;\n    fscanf(fstd,\"%s\",t+1);\n    if(s[1]=='I' && t[1]=='I')AC;\n    if(s[1]=='I' || t[1]=='I')WA;\n    double p,q;\n    sscanf(s+1,\"%lf\",&p);\n    sscanf(t+1,\"%lf\",&q);\n    if(fabs(p-q)<eps)AC\n    else{\n        if(fabs(p-q)/q<eps)AC;\n        if(fabs(q-p)/q<eps)AC;\n        if(fabs(p-q)/p<eps)AC;\n        if(fabs(q-p)/p<eps)AC;\n    }\n    WA;\n}\n\n```", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2015] Bitwise OR", "background": "", "description": "Initially, you have the number $0$. Every second, you randomly choose a number from $[0,2^n-1]$ and apply bitwise OR with your current number (C++, C: `|`, Pascal: `or`). The probability of choosing number $i$ is $p_i$. It is guaranteed that $0\\leq p_i \\leq 1$, $\\sum p_i=1$. Find the expected number of seconds until your current number becomes $2^n-1$.", "inputFormat": "The first line contains $n$, the number of elements. The second line contains $2^n$ numbers; the $i$-th number is the probability of selecting $i-1$.", "outputFormat": "Output a single number representing the answer. An absolute or relative error not exceeding $10^{-6}$ is accepted. If there is no solution, output `INF`.", "hint": "For $100\\%$ of the testdata, $n\\leq 20$.\n\nThe following is the SPJ source code.\n\n```cpp\n//liuchenrui \n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cmath>\n#define AC {fclose(fstd),fclose(fuser);return 0;}\n#define WA {fclose(fstd),fclose(fuser);return 1;}\n#define PE {fclose(fstd),fclose(fuser);return 5;}\n#define eps 1e-6\nint main(int const argc, char*const argv[]){\n    FILE *fstd,*fuser;\n    fstd=fopen(argv[2],\"r\");\n    fuser=fopen(argv[3],\"r\");\n    //fstd=fopen(\"x1.in\",\"r\");\n    //fuser=fopen(\"x2.in\",\"r\");\n    char s[30],t[30];\n    if(fscanf(fuser,\"%s\",s+1)==-1)WA;\n    fscanf(fstd,\"%s\",t+1);\n    if(s[1]=='I' && t[1]=='I')AC;\n    if(s[1]=='I' || t[1]=='I')WA;\n    double p,q;\n    sscanf(s+1,\"%lf\",&p);\n    sscanf(t+1,\"%lf\",&q);\n    if(fabs(p-q)<eps)AC\n    else{\n        if(fabs(p-q)/q<eps)AC;\n        if(fabs(q-p)/q<eps)AC;\n        if(fabs(p-q)/p<eps)AC;\n        if(fabs(q-p)/p<eps)AC;\n    }\n    WA;\n}\n\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2015] 按位或", "background": "", "description": "刚开始你有一个数字 $0$，每一秒钟你会随机选择一个 $[0,2^n-1]$ 的数字，与你手上的数字进行或（C++,C 的 `|`，pascal 的 `or`）操作。选择数字 $i$ 的概率是 $p_i$。保证 $0\\leq p_i \\leq 1$，$\\sum p_i=1$ 。问期望多少秒后，你手上的数字变成 $2^n-1$。\n", "inputFormat": "第一行输入 $n$ 表示 $n$ 个元素，第二行输入 $2^n$ 个数，第 $i$ 个数表示选到 $i-1$ 的概率。\n", "outputFormat": "仅输出一个数表示答案，绝对误差或相对误差不超过 $10^{-6}$ 即可算通过。如果无解则要输出 `INF`。", "hint": "对于 $100\\%$ 的数据，$n\\leq 20$。\n\n以下为 spj 源代码。\n\n```cpp\n//liuchenrui \n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cmath>\n#define AC {fclose(fstd),fclose(fuser);return 0;}\n#define WA {fclose(fstd),fclose(fuser);return 1;}\n#define PE {fclose(fstd),fclose(fuser);return 5;}\n#define eps 1e-6\nint main(int const argc, char*const argv[]){\n    FILE *fstd,*fuser;\n    fstd=fopen(argv[2],\"r\");\n    fuser=fopen(argv[3],\"r\");\n    //fstd=fopen(\"x1.in\",\"r\");\n    //fuser=fopen(\"x2.in\",\"r\");\n    char s[30],t[30];\n    if(fscanf(fuser,\"%s\",s+1)==-1)WA;\n    fscanf(fstd,\"%s\",t+1);\n    if(s[1]=='I' && t[1]=='I')AC;\n    if(s[1]=='I' || t[1]=='I')WA;\n    double p,q;\n    sscanf(s+1,\"%lf\",&p);\n    sscanf(t+1,\"%lf\",&q);\n    if(fabs(p-q)<eps)AC\n    else{\n        if(fabs(p-q)/q<eps)AC;\n        if(fabs(q-p)/q<eps)AC;\n        if(fabs(p-q)/p<eps)AC;\n        if(fabs(q-p)/p<eps)AC;\n    }\n    WA;\n}\n\n```", "locale": "zh-CN"}}}
{"pid": "P3176", "type": "P", "difficulty": 6, "samples": [["123\n3", "394608467"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2015", "河南", "各省省选", "矩阵乘法"], "title": "[HAOI2015] 数字串拆分", "background": "", "description": "你有一个长度为 $n$ 的数字串 $s_0$。\n\n定义 $f(s)$ 为将 $s$ 拆分成若干个 $1 \\sim m$ 的数的和的方案数，比如 $m=2$ 时，$f(4)=5$，分别为 $4=1+1+1+1=1+1+2=1+2+1=2+1+1=2+2$。\n\n定义 $g(s)$ 为将 $s$ 这个数字串分割成若干个数字（允许前导 $0$），设他们的和为 $x$，则 $g(s)$ 为所有情况下 $f(x)$ 之和。比如 $g(123)=f(1+2+3)+f(1+23)+f(12+3)+f(123)$。\n\n给定 $s_0$ 和 $m$，求 $g(s)$。\n\n答案对 $998,244,353$ 取模。", "inputFormat": "第一行有一个字符串。代表 $s_0$。\n\n第二行有一个整数，代表 $m$。", "outputFormat": "仅输出一个数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1\\le|s_0|\\le 500$， $1\\le m\\le 5$，$s_0$ 中只有数字字符。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2015] Digit String Partition", "background": "", "description": "You have a digit string $s_0$ of length $n$.\n\nDefine $f(s)$ as the number of ways to split $s$ into a sum of numbers in the range $1 \\sim m$. For example, when $m=2$, $f(4)=5$, namely $4=1+1+1+1=1+1+2=1+2+1=2+1+1=2+2$.\n\nDefine $g(s)$ as follows: split the digit string $s$ into several numbers (leading $0$ are allowed), let their sum be $x$, then $g(s)$ is the sum of $f(x)$ over all such cases. For example, $g(123)=f(1+2+3)+f(1+23)+f(12+3)+f(123)$.\n\nGiven $s_0$ and $m$, compute $g(s_0)$.\n\nTake the answer modulo $998,244,353$.", "inputFormat": "The first line contains a string, which represents $s_0$.\n\nThe second line contains an integer, which represents $m$.", "outputFormat": "Output a single integer representing the answer.", "hint": "#### Constraints and Conventions\n\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\le |s_0| \\le 500$, $1 \\le m \\le 5$, and $s_0$ contains only digit characters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2015] 数字串拆分", "background": "", "description": "你有一个长度为 $n$ 的数字串 $s_0$。\n\n定义 $f(s)$ 为将 $s$ 拆分成若干个 $1 \\sim m$ 的数的和的方案数，比如 $m=2$ 时，$f(4)=5$，分别为 $4=1+1+1+1=1+1+2=1+2+1=2+1+1=2+2$。\n\n定义 $g(s)$ 为将 $s$ 这个数字串分割成若干个数字（允许前导 $0$），设他们的和为 $x$，则 $g(s)$ 为所有情况下 $f(x)$ 之和。比如 $g(123)=f(1+2+3)+f(1+23)+f(12+3)+f(123)$。\n\n给定 $s_0$ 和 $m$，求 $g(s)$。\n\n答案对 $998,244,353$ 取模。", "inputFormat": "第一行有一个字符串。代表 $s_0$。\n\n第二行有一个整数，代表 $m$。", "outputFormat": "仅输出一个数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1\\le|s_0|\\le 500$， $1\\le m\\le 5$，$s_0$ 中只有数字字符。", "locale": "zh-CN"}}}
{"pid": "P3177", "type": "P", "difficulty": 5, "samples": [["3 1\n1 2 1\n1 3 2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2015", "河南", "各省省选", "树形 DP"], "title": "[HAOI2015] 树上染色", "background": "", "description": "有一棵点数为 $n$ 的树，树边有边权。给你一个在 $0 \\sim n$ 之内的正整数 $k$ ，你要在这棵树中选择 $k$ 个点，将其染成黑色，并将其他的 $n-k$ 个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的收益。问收益最大值是多少。", "inputFormat": "第一行包含两个整数 $n,k$。\n\n第二到 $n$ 行每行三个正整数 $u, v, w$，表示该树中存在一条长度为 $w$ 的边 $(u, v)$。输入保证所有点之间是联通的。", "outputFormat": "输出一个正整数，表示收益的最大值。\n", "hint": "对于 $100\\%$ 的数据，$0 \\leq k \\leq n \\leq 2000$，$1 \\leq w \\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2015] Tree Coloring", "background": "", "description": "There is a tree with $n$ nodes, and each edge has a weight. You are given a positive integer $k$ in $0 \\sim n$. You need to choose $k$ nodes and color them black, and color the remaining $n - k$ nodes white. After coloring all nodes, you gain a profit equal to the sum of pairwise distances among black nodes plus the sum of pairwise distances among white nodes. What is the maximum possible profit?", "inputFormat": "The first line contains two integers $n, k$.\n\nLines $2$ to $n$ each contain three positive integers $u, v, w$, indicating that there is an edge $(u, v)$ of length $w$ in the tree. The input guarantees that all nodes are connected.", "outputFormat": "Output a single positive integer, the maximum profit.", "hint": "For $100\\%$ of the testdata, $0 \\leq n, k \\leq 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2015] 树上染色", "background": "", "description": "有一棵点数为 $n$ 的树，树边有边权。给你一个在 $0 \\sim n$ 之内的正整数 $k$ ，你要在这棵树中选择 $k$ 个点，将其染成黑色，并将其他的 $n-k$ 个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的收益。问收益最大值是多少。", "inputFormat": "第一行包含两个整数 $n,k$。\n\n第二到 $n$ 行每行三个正整数 $u, v, w$，表示该树中存在一条长度为 $w$ 的边 $(u, v)$。输入保证所有点之间是联通的。", "outputFormat": "输出一个正整数，表示收益的最大值。\n", "hint": "对于 $100\\%$ 的数据，$0 \\leq k \\leq n \\leq 2000$，$1 \\leq w \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3178", "type": "P", "difficulty": 5, "samples": [["5 5\n1 2 3 4 5\n1 2\n1 4\n2 3\n2 5\n3 3\n1 2 1\n3 5\n2 1 2\n3 3", "6\n9\n13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "河南", "线段树", "各省省选", "深度优先搜索 DFS", "树链剖分"], "title": "[HAOI2015] 树上操作", "background": "", "description": "有一棵点数为 $N$ 的树，以点 $1$ 为根，且树有点权。然后有 $M$ 个操作，分为三种：\n- 操作 $1$：把某个节点 $x$ 的点权增加 $a$。\n- 操作 $2$：把某个节点 $x$ 为根的子树中所有点的点权都增加 $a$。\n- 操作 $3$：询问某个节点 $x$ 到根的路径中所有点的点权和。\n", "inputFormat": "第一行包含两个整数 $N,M$。表示点数和操作数。  \n接下来一行 $N$ 个整数，表示树中节点的初始权值。  \n接下来 $N-1$ 行每行两个正整数 $\\mathit{from},\\mathit{to}$， 表示该树中存在一条边 $(\\mathit{from},\\mathit{to})$。  \n再接下来 $M$ 行，每行分别表示一次操作。其中第一个数表示该操作的种类，之后接这个操作的参数。\n", "outputFormat": "对于每个询问操作，输出该询问的答案。答案之间用换行隔开。\n", "hint": "对于 $100\\%$ 的数据，$1\\le N,M\\le10^5$，且所有输入数据的绝对值都不会超过 $10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2015] Operations on a Tree", "background": "", "description": "There is a tree with $N$ nodes, rooted at node $1$, and each node has a weight. There are $M$ operations of three types:\n- Operation $1$: increase the weight of node $x$ by $a$.\n- Operation $2$: increase the weight of every node in the subtree rooted at node $x$ by $a$.\n- Operation $3$: query the sum of weights of all nodes on the path from node $x$ to the root.", "inputFormat": "The first line contains two integers $N, M$, representing the number of nodes and the number of operations.  \nThe next line contains $N$ integers, representing the initial weights of the nodes.  \nEach of the next $N-1$ lines contains two positive integers $\\mathit{from}, \\mathit{to}$, indicating that there is an edge $(\\mathit{from}, \\mathit{to})$ in the tree.  \nThen there are $M$ lines, each describing one operation. The first number indicates the type of the operation, followed by the parameters of that operation.", "outputFormat": "For each query operation, output the answer. Print each answer on a new line.", "hint": "For $100\\%$ of the testdata, $1 \\le N, M \\le 10^5$, and the absolute values of all input numbers do not exceed $10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2015] 树上操作", "background": "", "description": "有一棵点数为 $N$ 的树，以点 $1$ 为根，且树有点权。然后有 $M$ 个操作，分为三种：\n- 操作 $1$：把某个节点 $x$ 的点权增加 $a$。\n- 操作 $2$：把某个节点 $x$ 为根的子树中所有点的点权都增加 $a$。\n- 操作 $3$：询问某个节点 $x$ 到根的路径中所有点的点权和。\n", "inputFormat": "第一行包含两个整数 $N,M$。表示点数和操作数。  \n接下来一行 $N$ 个整数，表示树中节点的初始权值。  \n接下来 $N-1$ 行每行两个正整数 $\\mathit{from},\\mathit{to}$， 表示该树中存在一条边 $(\\mathit{from},\\mathit{to})$。  \n再接下来 $M$ 行，每行分别表示一次操作。其中第一个数表示该操作的种类，之后接这个操作的参数。\n", "outputFormat": "对于每个询问操作，输出该询问的答案。答案之间用换行隔开。\n", "hint": "对于 $100\\%$ 的数据，$1\\le N,M\\le10^5$，且所有输入数据的绝对值都不会超过 $10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P3179", "type": "P", "difficulty": 7, "samples": [["3\n2\n2\n1 2\n2\n2 3", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "博弈论", "2015", "河南", "各省省选", "SG 函数"], "title": "[HAOI2015] 数组游戏", "background": null, "description": "有一个长度为 $n$ 的数组，甲乙两人在上面进行这样一个游戏：首先，数组上有一些格子是白的，有一些是黑的。然后两人轮流进行操作。\n\n每次操作选择一个白色的格子，假设它的下标为 $x$。接着，选择一个大小在 $1\\ldots \\lfloor\\dfrac{n}{x}\\rfloor$ 之间的整数 $k$，然后将下标为 $x,2\\times x,\\ldots ,k\\times x$ 的格子都进行颜色翻转。不能操作的人输。\n\n现在甲（先手）有一些询问。每次他会给你一个数组的初始状态，你要求出对于这种初始状态他是否有必胜策略。", "inputFormat": "第一行包含一个整数 $n$，表示数组的长度。\n\n第二行包含一个整数 $k$，表示询问的个数。\n\n接下来 $2\\times k$ 行，每两行表示一次询问。\n\n在这两行中，第一行一个正整数 $w$，表示数组中有多少个格子是白色的，第二行则有 $w$ 个 $1$ 到 $n$ 之间的正整数，表示白色格子的对应下标。", "outputFormat": "对于每个询问，输出一行一个字符串，若先手必胜输出 `Yes`，否则输出 `No`。", "hint": "#### 样例输入输出 1 解释\n\n在第一个询问中，甲选择点 $1$，然后将格子 $1\\times 1$ 和 $2\\times 1$ 翻过来即可。\n\n第二个询问中，无论甲选择哪个点，都只能翻掉一个格子。乙只需翻掉另一个格子就行了。\n\n#### 数据规模与约定\n\n对于 $30 \\%$ 的数据，$n \\leq 20$；    \n对于 $50 \\%$ 的数据，$n \\leq 10^6$；    \n对于 $70 \\%$ 的数据，$n \\leq 10^7$；    \n对于 $100 \\%$ 的数据，$n \\leq 10^9$，$k,w \\leq 100$，不会有格子在同一次询问中多次出现。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2015] Array Game", "background": "", "description": "There is an array of length $n$. Two players, A and B, play the following game on it: initially, some cells in the array are white and some are black. The players take turns.\n\nOn each turn, the current player chooses a white cell with index $x$. Then they choose an integer $k$ between $1 \\ldots \\lfloor \\dfrac{n}{x} \\rfloor$, and flip the colors of all cells with indices $x, 2\\times x, \\ldots, k\\times x$. The player who cannot make a move loses.\n\nNow A (the first player) has several queries. For each query, you are given an initial state of the array. You need to determine whether A has a winning strategy for that initial state.", "inputFormat": "The first line contains an integer $n$, the length of the array.\n\nThe second line contains an integer $k$, the number of queries.\n\nThe next $2\\times k$ lines describe the queries, two lines per query.\n\nIn these two lines, the first line contains a positive integer $w$, the number of white cells in the array. The second line contains $w$ integers between $1$ and $n$, inclusive, which are the indices of the white cells.", "outputFormat": "For each query, output one line with a string: output `Yes` if the first player has a winning strategy, otherwise output `No`.", "hint": "#### Explanation for Sample Input/Output 1\n\nIn the first query, A chooses index $1$ and flips cells $1\\times 1$ and $2\\times 1$.\n\nIn the second query, no matter which index A chooses, they can flip only one cell. B can then flip the other cell.\n\n#### Constraints\n\nFor $30\\%$ of the testdata, $n \\leq 20$.\n\nFor $50\\%$ of the testdata, $n \\leq 10^6$.\n\nFor $70\\%$ of the testdata, $n \\leq 10^7$.\n\nFor $100\\%$ of the testdata, $n \\leq 10^9$, $k, w \\leq 100$, and no cell appears more than once within a single query.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2015] 数组游戏", "background": null, "description": "有一个长度为 $n$ 的数组，甲乙两人在上面进行这样一个游戏：首先，数组上有一些格子是白的，有一些是黑的。然后两人轮流进行操作。\n\n每次操作选择一个白色的格子，假设它的下标为 $x$。接着，选择一个大小在 $1\\ldots \\lfloor\\dfrac{n}{x}\\rfloor$ 之间的整数 $k$，然后将下标为 $x,2\\times x,\\ldots ,k\\times x$ 的格子都进行颜色翻转。不能操作的人输。\n\n现在甲（先手）有一些询问。每次他会给你一个数组的初始状态，你要求出对于这种初始状态他是否有必胜策略。", "inputFormat": "第一行包含一个整数 $n$，表示数组的长度。\n\n第二行包含一个整数 $k$，表示询问的个数。\n\n接下来 $2\\times k$ 行，每两行表示一次询问。\n\n在这两行中，第一行一个正整数 $w$，表示数组中有多少个格子是白色的，第二行则有 $w$ 个 $1$ 到 $n$ 之间的正整数，表示白色格子的对应下标。", "outputFormat": "对于每个询问，输出一行一个字符串，若先手必胜输出 `Yes`，否则输出 `No`。", "hint": "#### 样例输入输出 1 解释\n\n在第一个询问中，甲选择点 $1$，然后将格子 $1\\times 1$ 和 $2\\times 1$ 翻过来即可。\n\n第二个询问中，无论甲选择哪个点，都只能翻掉一个格子。乙只需翻掉另一个格子就行了。\n\n#### 数据规模与约定\n\n对于 $30 \\%$ 的数据，$n \\leq 20$；    \n对于 $50 \\%$ 的数据，$n \\leq 10^6$；    \n对于 $70 \\%$ 的数据，$n \\leq 10^7$；    \n对于 $100 \\%$ 的数据，$n \\leq 10^9$，$k,w \\leq 100$，不会有格子在同一次询问中多次出现。", "locale": "zh-CN"}}}
{"pid": "P3180", "type": "P", "difficulty": 6, "samples": [["10 12\n1 10 4 5 2 10 1 8 4 8\n1 2\n1 3\n1 4\n2 5\n4 6\n4 7\n7 8\n2 9\n8 10\n1 6\n8 10\n4 7\n10\n0 3 9\n1 7 6\n0 5 2\n1 10 9\n0 5 7\n1 7 4\n0 7 3\n1 2 7\n0 3 4\n0 3 8", "0\r\n1\r\n0\r\n1\r\n0\r\n1\r\n0\r\n2\r\n0\r\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "河南", "各省省选", "仙人掌"], "title": "[HAOI2016] 地图", "background": "", "description": "一天 rin 来到了一个遥远的都市。这个都市有 $n$ 个建筑，编号从 $1$ 到 $n$，其中市中心编号为 $1$，这个都市有 $m$ 条双向通行的街道，每条街道连接着两个建筑，其中某些街道首尾相连连接成了一个环。\n\nrin 通过长时间的走访，已经清楚了这个都市的两个特点：\n1. 从市中心出发可以到达所有的建筑物。\n2. 任意一条街道最多存在与一个简单环中。令 rin 心花怒放的是，每个建筑物都会有拉面售卖。拉面有很多不同的种类，但对于 rin 而言只有油腻程度的不同，因此我们把油腻程度相同的拉面看做同一种拉面。\n\n由于不同建筑物的拉面的油腻程度可能不同，我们用一个正整数来表示拉面的油腻程度。\n\n要知道，拉面可是 rin 的最爱，但是现在到了下班高峰期，都市的交通变得非常的堵塞。 rin 只能通过没有被堵死的街道通行，去品尝所在建筑物的拉面。\n\n现在 rin 想知道，如果她正在编号为 $x$ 的建筑物，那么在从市中心到 $x$ 的所有简单路径经过的街道都被堵死的情况下，rin 可以品尝到的拉面中（注意没有出现的拉面是不能算在里面的）：\n\n1. 油腻程度 $\\leq y$ 且品尝次数为奇数次的拉面有多少种？\n2. 油腻程度 $\\leq y$ 且品尝次数为偶数次的拉面有多少种？", "inputFormat": "第一行两个正整数 $n, m$，含义如题所示。\n\n第二行一共 $N$ 个正整数，第 $i$ 个数 $A_i$ 表示第 $i$ 个建筑物出售的拉面的油腻程度。\n\n接下来 $M$ 行，每行两个正整数 $x, y$，表示在建筑物 $x, y$ 之间有一条双向通行的街道。数据保证 $1 \\leq x < y \\leq N$。\n\n接下来一行一个正整数 $Q$，表示询问个数。\n\n接下来 $Q$ 行每行三个非负整数 $ty, x, y$，$ty=0$ 时表示询问偶数，$ty=1$ 表示询问奇数。\n\n$N \\leq 100000, M \\leq 150000, Q \\leq 100000, A_i \\leq 10^6$。\n\n提示：请注意数据范围中的 $\\leq$，特殊条件中提到的??均为询问中的 $y$，对于所有的数据，有 $y \\leq 10^6$。\n", "outputFormat": "一共 $Q$ 行，对于每个询问输出一个答案。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2016] Map", "background": "", "description": "One day, rin came to a distant metropolis. The city has $n$ buildings, numbered $1$ to $n$, with the city center being building $1$. There are $m$ bidirectional streets, each connecting two buildings, and some streets connect end to end to form a cycle.\n\nAfter long observation, rin has learned two facts about this city:\n1. From the city center, all buildings are reachable.\n2. Any street belongs to at most one simple cycle.\n\nEvery building sells ramen. There are many kinds of ramen, but for rin only the greasiness level matters, so we treat ramen with the same greasiness level as the same type. We use a positive integer to denote the greasiness level.\n\nIt is rush hour, and traffic is very jammed. rin can only travel along streets that are not blocked.\n\nNow rin wants to know: if she is at building $x$, and all streets lying on every simple path from the city center to $x$ are blocked, then among the ramen she can taste (note that types that do not appear at all must not be counted):\n1. How many types have greasiness $\\leq y$ and appear an odd number of times?\n2. How many types have greasiness $\\leq y$ and appear an even number of times? Here “even” means a positive even number of occurrences; types with zero occurrences are not counted.\n\nConstraints:\n- $n \\leq 100000$, $m \\leq 150000$, $Q \\leq 100000$, $A_i \\leq 10^6$.", "inputFormat": "- The first line contains two positive integers $n, m$.\n- The second line contains $n$ positive integers; the $i$-th number $A_i$ is the greasiness level of the ramen sold at building $i$.\n- The next $m$ lines each contain two positive integers $x, y$, meaning there is a bidirectional street between buildings $x$ and $y$. It is guaranteed that $1 \\leq x < y \\leq n$.\n- The next line contains a single positive integer $Q$, the number of queries.\n- The next $Q$ lines each contain three non-negative integers $ty, x, y$. When $ty = 0$, it asks for the count of types with an even number of occurrences; when $ty = 1$, it asks for the count of types with an odd number of occurrences.", "outputFormat": "Output $Q$ lines. For each query, output a single integer: the answer to that query.", "hint": "Please pay attention to the $\\leq$ in Constraints. The $y$ mentioned above is the $y$ in the queries. For all testdata, $y \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2016] 地图", "background": "", "description": "一天 rin 来到了一个遥远的都市。这个都市有 $n$ 个建筑，编号从 $1$ 到 $n$，其中市中心编号为 $1$，这个都市有 $m$ 条双向通行的街道，每条街道连接着两个建筑，其中某些街道首尾相连连接成了一个环。\n\nrin 通过长时间的走访，已经清楚了这个都市的两个特点：\n1. 从市中心出发可以到达所有的建筑物。\n2. 任意一条街道最多存在与一个简单环中。令 rin 心花怒放的是，每个建筑物都会有拉面售卖。拉面有很多不同的种类，但对于 rin 而言只有油腻程度的不同，因此我们把油腻程度相同的拉面看做同一种拉面。\n\n由于不同建筑物的拉面的油腻程度可能不同，我们用一个正整数来表示拉面的油腻程度。\n\n要知道，拉面可是 rin 的最爱，但是现在到了下班高峰期，都市的交通变得非常的堵塞。 rin 只能通过没有被堵死的街道通行，去品尝所在建筑物的拉面。\n\n现在 rin 想知道，如果她正在编号为 $x$ 的建筑物，那么在从市中心到 $x$ 的所有简单路径经过的街道都被堵死的情况下，rin 可以品尝到的拉面中（注意没有出现的拉面是不能算在里面的）：\n\n1. 油腻程度 $\\leq y$ 且品尝次数为奇数次的拉面有多少种？\n2. 油腻程度 $\\leq y$ 且品尝次数为偶数次的拉面有多少种？", "inputFormat": "第一行两个正整数 $n, m$，含义如题所示。\n\n第二行一共 $N$ 个正整数，第 $i$ 个数 $A_i$ 表示第 $i$ 个建筑物出售的拉面的油腻程度。\n\n接下来 $M$ 行，每行两个正整数 $x, y$，表示在建筑物 $x, y$ 之间有一条双向通行的街道。数据保证 $1 \\leq x < y \\leq N$。\n\n接下来一行一个正整数 $Q$，表示询问个数。\n\n接下来 $Q$ 行每行三个非负整数 $ty, x, y$，$ty=0$ 时表示询问偶数，$ty=1$ 表示询问奇数。\n\n$N \\leq 100000, M \\leq 150000, Q \\leq 100000, A_i \\leq 10^6$。\n\n提示：请注意数据范围中的 $\\leq$，特殊条件中提到的??均为询问中的 $y$，对于所有的数据，有 $y \\leq 10^6$。\n", "outputFormat": "一共 $Q$ 行，对于每个询问输出一个答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3181", "type": "P", "difficulty": 6, "samples": [["aabb\nbbaa", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "2016", "河南", "各省省选", "后缀数组 SA"], "title": "[HAOI2016] 找相同字符", "background": "", "description": "给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。\n", "inputFormat": "两行，两个字符串 $s_1,s_2$，长度分别为 $n_1,n_2$。\n", "outputFormat": "输出一个整数表示答案。\n", "hint": "$1\\le n_1,n_2\\le 2\\times 10^5$，字符串中只有小写字母。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2016] Find Identical Characters", "background": "", "description": "Given two strings, count the number of ways to take one substring from each string such that the two substrings are equal. Two ways are different if and only if at least one of the substrings has a different position.", "inputFormat": "Two lines: two strings $s_1, s_2$, of lengths $n_1, n_2$, respectively.", "outputFormat": "Output a single integer representing the answer.", "hint": "$1 \\le n_1, n_2 \\le 2 \\times 10^5$, and the strings contain only lowercase letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2016] 找相同字符", "background": "", "description": "给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。\n", "inputFormat": "两行，两个字符串 $s_1,s_2$，长度分别为 $n_1,n_2$。\n", "outputFormat": "输出一个整数表示答案。\n", "hint": "$1\\le n_1,n_2\\le 2\\times 10^5$，字符串中只有小写字母。", "locale": "zh-CN"}}}
{"pid": "P3182", "type": "P", "difficulty": 3, "samples": [["2\n0 1\n1 0", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["高精度", "递推", "2016", "河南", "各省省选"], "title": "[HAOI2016] 放棋子", "background": "", "description": "给你一个 $N\\times N$ 的矩阵，每行有一个障碍，数据保证任意两个障碍不在同一行，任意两个障碍不在同一列，要求你在这个矩阵上放 $N$ 枚棋子（障碍的位置不能放棋子），要求你放 $N$ 个棋子也满足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少种方案。\n", "inputFormat": "第一行一个 $N$，接下来一个 $N \\times N$ 的矩阵。$N\\leq 200$，0 表示没有障碍，1 表示有障碍。\n", "outputFormat": "一个整数，即合法的方案数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2016] Placing Pieces", "background": "", "description": "Given an $N\\times N$ matrix. Each row contains exactly one obstacle; it is guaranteed that no two obstacles are in the same row or the same column. You need to place $N$ pieces on this matrix (you cannot place a piece on a cell with an obstacle) such that each row contains exactly one piece and each column contains exactly one piece. Find the number of valid arrangements.", "inputFormat": "The first line contains an integer $N$, followed by an $N \\times N$ matrix. $N\\leq 200$. $0$ denotes no obstacle, and $1$ denotes an obstacle.", "outputFormat": "A single integer, the number of valid arrangements.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2016] 放棋子", "background": "", "description": "给你一个 $N\\times N$ 的矩阵，每行有一个障碍，数据保证任意两个障碍不在同一行，任意两个障碍不在同一列，要求你在这个矩阵上放 $N$ 枚棋子（障碍的位置不能放棋子），要求你放 $N$ 个棋子也满足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少种方案。\n", "inputFormat": "第一行一个 $N$，接下来一个 $N \\times N$ 的矩阵。$N\\leq 200$，0 表示没有障碍，1 表示有障碍。\n", "outputFormat": "一个整数，即合法的方案数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3183", "type": "P", "difficulty": 3, "samples": [["10 16\n1 2\n1 4\n1 10\n2 3\n2 5\n4 3\n4 5\n4 8\n6 5\n7 6\n7 9\n8 5\n9 8\n10 6\n10 7\n10 9", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "图论", "2016", "河南", "各省省选", "记忆化搜索", "拓扑排序"], "title": "[HAOI2016] 食物链", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/13153.png) \n\n如图所示为某生态系统的食物网示意图，据图回答第 1 小题  \n现在给你 $n$ 个物种和 $m$ 条能量流动关系，求其中的食物链条数。物种的名称为从 $1$ 到 $n$ 编号 $M$ 条能量流动关系形如 $a_1,b_1,a_2,b_2,a_3,b_3,\\ldots,a_{m-1},b_{m-1},a_m,b_m$。其中 $a_i$ 和 $b_i$ 表示能量从物种 $a_i$ 流向物种 $b_i$，注意单独的一种孤立生物不算一条食物链。\n", "inputFormat": "第一行两个整数 $n, m$，接下来 $m$ 行每行两个整数 $a_i$ 和 $b_i$ 描述 $m$ 条能量流动关系。", "outputFormat": "一个整数即食物网中的食物链条数。", "hint": "数据保证输入数据符合生物学特点，且不会有重复的能量流动关系出现，题目保证答案不会爆 `int`。\n\n对于 $100 \\%$ 的数据，$1 \\leq N \\leq 100000$，$0 \\leq m \\leq 200000$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2016] Food Chain", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/13153.png)\n\nThe figure shows a schematic food web of an ecosystem. You are given $n$ species and $m$ energy-flow relations; compute the number of food chains. Species are labeled from $1$ to $n$. The $m$ energy-flow relations are given as pairs $a_1, b_1, a_2, b_2, a_3, b_3, \\ldots, a_{m-1}, b_{m-1}, a_m, b_m$, where $a_i$ and $b_i$ mean that energy flows from species $a_i$ to species $b_i$. Note that a single isolated species does not count as a food chain.", "inputFormat": "The first line contains two integers $n, m$. The next $m$ lines each contain two integers $a_i$ and $b_i$ describing the $m$ energy-flow relations.", "outputFormat": "Output a single integer: the number of food chains in the food web.", "hint": "The testdata guarantee that the input conforms to biological properties, and there are no duplicate energy-flow relations. The answer is guaranteed not to overflow a 32-bit signed int.\n\nConstraints: for $100\\%$ of the testdata, $1 \\leq n \\leq 100000$, $0 \\leq m \\leq 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2016] 食物链", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/13153.png) \n\n如图所示为某生态系统的食物网示意图，据图回答第 1 小题  \n现在给你 $n$ 个物种和 $m$ 条能量流动关系，求其中的食物链条数。物种的名称为从 $1$ 到 $n$ 编号 $M$ 条能量流动关系形如 $a_1,b_1,a_2,b_2,a_3,b_3,\\ldots,a_{m-1},b_{m-1},a_m,b_m$。其中 $a_i$ 和 $b_i$ 表示能量从物种 $a_i$ 流向物种 $b_i$，注意单独的一种孤立生物不算一条食物链。\n", "inputFormat": "第一行两个整数 $n, m$，接下来 $m$ 行每行两个整数 $a_i$ 和 $b_i$ 描述 $m$ 条能量流动关系。", "outputFormat": "一个整数即食物网中的食物链条数。", "hint": "数据保证输入数据符合生物学特点，且不会有重复的能量流动关系出现，题目保证答案不会爆 `int`。\n\n对于 $100 \\%$ 的数据，$1 \\leq N \\leq 100000$，$0 \\leq m \\leq 200000$。", "locale": "zh-CN"}}}
{"pid": "P3184", "type": "P", "difficulty": 2, "samples": [["4 6\n3 2 7 5\n2 3\n2 4\n2 5\n2 7\n4 6\n8 10", "2\n2\n3\n4\n1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "线段树", "二分", "USACO", "树状数组", "离散化", "排序", "前缀和"], "title": "[USACO16DEC] Counting Haybales S", "background": "", "description": "Farmer John has just arranged his $N$ haybales ($1 \\leq N \\leq 100,000$) at various points along the one-dimensional road running across his farm.  To make sure they are spaced out appropriately, please help him answer $Q$ queries ($1 \\leq Q \\leq 100,000$), each asking for the number of haybales within a specific interval along the road.", "inputFormat": "The first line contains $N$ and $Q$.\n\nThe next line contains $N$ distinct integers, each in the range $0 \\ldots 1,000,000,000$, indicating that there is a haybale at each of those locations.\n\nEach of the next $Q$ lines contains two integers $A$ and $B$($0 \\leq A \\leq B \\leq 1,000,000,000$) giving a query for the number of haybales between $A$ and $B$, inclusive.", "outputFormat": "You should write $Q$ lines of output.  For each query, output the number of haybales in its respective interval.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO16DEC] Counting Haybales S", "background": "", "description": "Farmer John has just arranged his $N$ haybales ($1 \\leq N \\leq 100,000$) at various points along the one-dimensional road running across his farm.  To make sure they are spaced out appropriately, please help him answer $Q$ queries ($1 \\leq Q \\leq 100,000$), each asking for the number of haybales within a specific interval along the road.", "inputFormat": "The first line contains $N$ and $Q$.\n\nThe next line contains $N$ distinct integers, each in the range $0 \\ldots 1,000,000,000$, indicating that there is a haybale at each of those locations.\n\nEach of the next $Q$ lines contains two integers $A$ and $B$($0 \\leq A \\leq B \\leq 1,000,000,000$) giving a query for the number of haybales between $A$ and $B$, inclusive.", "outputFormat": "You should write $Q$ lines of output.  For each query, output the number of haybales in its respective interval.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO16DEC] Counting Haybales S", "background": "", "description": "Farmer John 刚刚将他的 $N$ 个干草捆（$1 \\leq N \\leq 100,000$）安排在他农场的一维道路上的各个位置。为了确保它们之间的间距合适，请帮助他回答 $Q$ 个查询（$1 \\leq Q \\leq 100,000$），每个查询询问在道路的特定区间内有多少个干草捆。", "inputFormat": "第一行包含 $N$ 和 $Q$。\n\n第二行包含 $N$ 个不同的整数，每个整数的范围在 $0 \\ldots 1,000,000,000$ 之间，表示每个位置上有一个干草捆。\n\n接下来的 $Q$ 行每行包含两个整数 $A$ 和 $B$（$0 \\leq A \\leq B \\leq 1,000,000,000$），表示一个查询，询问在 $A$ 到 $B$（包括 $A$ 和 $B$）的区间内有多少个干草捆。", "outputFormat": "你需要输出 $Q$ 行。对于每个查询，输出其对应区间内的干草捆数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3185", "type": "P", "difficulty": 6, "samples": [["2\n4\n1 0 1 5000\n3\n0 0 1", "0 2 3\n1\n-1 -1 -1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论", "2007", "各省省选", "湖南", "枚举"], "title": "[HNOI2007] 分裂游戏", "background": "", "description": "聪聪和睿睿最近迷上了一款叫做分裂的游戏。\n\n该游戏的规则是： 共有 $n$ 个瓶子， 标号为 $0, 1, \\ldots, n-1$，第 $i$ 个瓶子中装有 $p_i$ 颗巧克力豆，两个人轮流取豆子，每一轮每人选择 $3$ 个瓶子，标号为 $i,j,k$, 并要保证 $i \\lt j, j \\leq k$，且第 $i$ 个瓶子中至少要有 $1$ 颗巧克力豆，随后这个人从第 $i$ 个瓶子中拿走一颗豆子并在 $j,k$ 中各放入一粒豆子（$j$ 可能等于 $k$） 。如果轮到某人而他无法按规则取豆子，那么他将输掉比赛。胜利者可以拿走所有的巧克力豆！\n\n两人最后决定由聪聪先取豆子，为了能够得到最终的巧克力豆，聪聪自然希望赢得比赛。他思考了一下，发现在有的情况下，先拿的人一定有办法取胜，但是他不知道对于其他情况是否有必胜策略，更不知道第一步该如何取。他决定偷偷请教聪明的你，希望你能告诉他，在给定每个瓶子中的最初豆子数后是否能让自己得到所有巧克力豆，他还希望你告诉他第一步该如何取，并且为了必胜，第一步有多少种取法？ \n", "inputFormat": "输入文件第一行是一个整数 $t$，表示测试数据的组数。\n\n每组测试数据的第一行是瓶子的个数 $n$，接下来的一行有 $n$ 个由空格隔开的非负整数，表示每个瓶子中的豆子数。", "outputFormat": "对于每组测试数据，输出包括两行，第一行为用一个空格两两隔开的三个整数，表示要想赢得游戏，第一步应该选取的 $3$ 个瓶子的编号 $i,j,k$，如果有多组符合要求的解，那么输出字典序最小的一组。如果无论如何都无法赢得游戏，那么输出用一个空格两两隔开的三个 $-1$。\n\n第二行表示要想确保赢得比赛，第一步有多少种不同的取法。", "hint": "$1 \\leq t \\leq 10$，$2 \\leq n \\leq 21$，$0 \\leq p_i \\leq 10^4$，", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2007] Split Game", "background": "", "description": "Congcong and Ruirui have become obsessed with a game called Split.\n\nThe rules are as follows: There are $n$ bottles labeled $0, 1, \\ldots, n-1$. Bottle $i$ initially contains $p_i$ chocolate beans. The two players take turns. On each turn, a player chooses three bottles with indices $i, j, k$ such that $i \\lt j$ and $j \\leq k$, and bottle $i$ must contain at least $1$ bean. The player removes one bean from bottle $i$ and adds one bean to each of bottles $j$ and $k$ (note that $j$ may equal $k$). If it is a player’s turn and they cannot make a move following the rules, they lose. The winner takes all the chocolate beans.\n\nCongcong moves first. He wants to know whether he can force a win given the initial numbers of beans in each bottle. He also wants you to tell him how to play the first move, and, to ensure victory, how many different first moves there are.", "inputFormat": "The first line of input contains an integer $t$, the number of test cases.\n\nFor each test case, the first line contains the number of bottles $n$. The next line contains $n$ space-separated non-negative integers, the number of beans in each bottle.", "outputFormat": "For each test case, output two lines. The first line contains three integers separated by single spaces, representing the indices $i, j, k$ that should be chosen on the first move to guarantee a win. If there are multiple valid answers, output the lexicographically smallest triple. If it is impossible to win no matter what, output three $-1$ separated by single spaces.\n\nThe second line contains the number of distinct first moves that ensure a win.", "hint": "Constraints: $1 \\leq t \\leq 10$, $2 \\leq n \\leq 21$, $0 \\leq p_i \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2007] 分裂游戏", "background": "", "description": "聪聪和睿睿最近迷上了一款叫做分裂的游戏。\n\n该游戏的规则是： 共有 $n$ 个瓶子， 标号为 $0, 1, \\ldots, n-1$，第 $i$ 个瓶子中装有 $p_i$ 颗巧克力豆，两个人轮流取豆子，每一轮每人选择 $3$ 个瓶子，标号为 $i,j,k$, 并要保证 $i \\lt j, j \\leq k$，且第 $i$ 个瓶子中至少要有 $1$ 颗巧克力豆，随后这个人从第 $i$ 个瓶子中拿走一颗豆子并在 $j,k$ 中各放入一粒豆子（$j$ 可能等于 $k$） 。如果轮到某人而他无法按规则取豆子，那么他将输掉比赛。胜利者可以拿走所有的巧克力豆！\n\n两人最后决定由聪聪先取豆子，为了能够得到最终的巧克力豆，聪聪自然希望赢得比赛。他思考了一下，发现在有的情况下，先拿的人一定有办法取胜，但是他不知道对于其他情况是否有必胜策略，更不知道第一步该如何取。他决定偷偷请教聪明的你，希望你能告诉他，在给定每个瓶子中的最初豆子数后是否能让自己得到所有巧克力豆，他还希望你告诉他第一步该如何取，并且为了必胜，第一步有多少种取法？ \n", "inputFormat": "输入文件第一行是一个整数 $t$，表示测试数据的组数。\n\n每组测试数据的第一行是瓶子的个数 $n$，接下来的一行有 $n$ 个由空格隔开的非负整数，表示每个瓶子中的豆子数。", "outputFormat": "对于每组测试数据，输出包括两行，第一行为用一个空格两两隔开的三个整数，表示要想赢得游戏，第一步应该选取的 $3$ 个瓶子的编号 $i,j,k$，如果有多组符合要求的解，那么输出字典序最小的一组。如果无论如何都无法赢得游戏，那么输出用一个空格两两隔开的三个 $-1$。\n\n第二行表示要想确保赢得比赛，第一步有多少种不同的取法。", "hint": "$1 \\leq t \\leq 10$，$2 \\leq n \\leq 21$，$0 \\leq p_i \\leq 10^4$，", "locale": "zh-CN"}}}
{"pid": "P3186", "type": "P", "difficulty": 7, "samples": [["17 18\n74 82 82 76 101 114 97 97 92 77 86 92 77 81 121 75 83\n89 82 74 61 67 74 77 90 75 83 119 125 121 138 175 124 81\n69 64 64 69 69 75 75 69 72 108 160 162 166 178 193 145 82\n57 64 75 99 110 122 117 75 64 81 119 110 119 127 137 91 61\n70 97 113 113 114 148 170 127 78 72 82 72 89 96 96 78 72\n69 128 123 92 72 108 161 141 72 61 69 72 110 102 75 70 65\n69 141 118 75 59 75 130 123 83 72 89 108 166 156 108 97 72\n92 148 108 69 64 78 130 130 78 66 72 83 158 167 138 138 72\n85 143 80 66 72 80 141 121 72 66 64 80 72 92 150 150 74\n83 146 92 75 78 85 146 134 66 75 72 75 66 61 107 146 69\n82 139 89 69 69 78 141 141 64 75 64 69 72 64 93 144 82\n96 148 104 82 83 95 148 148 70 69 69 69 64 69 113 155 78\n91 143 104 78 84 104 141 127 72 86 128 114 61 72 128 146 69\n101 145 96 61 70 102 139 117 80 97 175 175 114 120 132 97 76\n119 170 127 75 81 124 141 104 75 84 152 169 139 135 103 57 55\n101 172 162 115 119 142 127 70 75 72 110 104 87 84 57 53 32\n78 110 154 154 132 116 80 57 91 99 81 70 53 50 48 18 14\n72 80 107 99 83 81 69 64 77 87 76 70 55 53 48 18 10", "2\n03"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "湖南"], "title": "[HNOI2007] 所罗门的咒语", "background": null, "description": "所罗门的宝藏被一个强大的咒语封印着，只有用特殊的咒语才能打开。为了给后来人留下一线开启的希望，所罗门将开启宝藏的咒语隐藏在巨大的所罗门广场。\n\n所罗门广场由边长为 $1$ 米的正方形大理石板铺成，据说由于所罗门魔法的作用，在每个雷电交加的黎明，广场上的每块大理石板会发出不同的微弱的光芒，而那些亮度大于某个值的大理石板作为一个整体来看，就是开启所罗门宝藏的咒语，但由于年久失修，有的大理石板可能产生错误的亮度。\n\n图 1 为在一个雷电交加的黎明从太空看所罗门广场的一个实例。通过所罗门的藏书可以知道，开启所罗门宝藏的咒语是由 $15$ 种字符 `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `A`, `D`, `E`, `L`, `X` 中的若干个组成的长度小于 $10$ 的符号串，这些符号按照从左到右的顺序大致排成一行，如图 1 所示。\n\n现已在一个雷电交加的黎明搜集到所罗门广场上各块大理石板的亮度，亮度值用 $0$ 到 $255$ 的整数来度量，你能破译出开启所罗门宝藏的咒语么？\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pko6syac.png)", "inputFormat": "第一行包含用一个空格隔开的 $2$ 个整数 $L$ 和 $H$，其中 $L$ 表示所罗门广场包含的大理石板的列数，$5 \\le L \\le 100$，$H$ 表示所罗门广场包含的大理石板的行数，$5 \\le H \\le 100$。\n\n接下来的 $H$ 行，每行有 $L$ 个由一个空格隔开的整数，不妨记接下来的第 $i$ 行，第 $j$ 列的整数为 $V_{ij}$，则有 $0 \\le V_{ij} \\le 255$。", "outputFormat": "第一行为正整数 $t$，表示咒语的长度。第二行为一个长度为 $t$ 的字符串，表示识别出的咒语。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2007] Solomon's Spell", "background": "", "description": "Solomon's treasure is sealed by a powerful spell, and only a special incantation can open it. To leave a glimmer of hope for future generations, Solomon hid the incantation needed to open the treasure within the vast Solomon Square.\n\nSolomon Square is paved with square marble slabs with side length $1$ meter. It is said that due to Solomon's magic, at every lightning-filled dawn, each marble slab emits a faint light of varying intensity. Those slabs whose brightness exceeds a certain threshold, when viewed as a whole, form the incantation to open Solomon's treasure. However, due to years of disrepair, some slabs may have incorrect brightness.\n\nFigure 1 shows an example view of Solomon Square from space during a lightning-filled dawn. According to Solomon's books, the incantation to open the treasure consists of several of the 15 characters `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `A`, `D`, `E`, `L`, `X`, forming a string of length less than $10$. These symbols are roughly arranged in a single line from left to right, as shown in Figure 1.\n\nThe brightness of each marble slab on Solomon Square has been collected during a lightning-filled dawn. The brightness values are measured by integers from $0$ to $255$. Can you decipher the incantation that opens Solomon's treasure?\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pko6syac.png)", "inputFormat": "The first line contains two integers $L$ and $H$ separated by a space, where $L$ is the number of columns of marble slabs in Solomon Square, $5 \\le L \\le 100$, and $H$ is the number of rows, $5 \\le H \\le 100$.\n\nThe next $H$ lines each contain $L$ integers separated by a space. Let the integer in the $i$-th line and the $j$-th column be $V_{ij}$, then $0 \\le V_{ij} \\le 255$.", "outputFormat": "The first line contains a positive integer $t$, indicating the length of the incantation. The second line contains a string of length $t$, representing the recognized incantation.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2007] 所罗门的咒语", "background": null, "description": "所罗门的宝藏被一个强大的咒语封印着，只有用特殊的咒语才能打开。为了给后来人留下一线开启的希望，所罗门将开启宝藏的咒语隐藏在巨大的所罗门广场。\n\n所罗门广场由边长为 $1$ 米的正方形大理石板铺成，据说由于所罗门魔法的作用，在每个雷电交加的黎明，广场上的每块大理石板会发出不同的微弱的光芒，而那些亮度大于某个值的大理石板作为一个整体来看，就是开启所罗门宝藏的咒语，但由于年久失修，有的大理石板可能产生错误的亮度。\n\n图 1 为在一个雷电交加的黎明从太空看所罗门广场的一个实例。通过所罗门的藏书可以知道，开启所罗门宝藏的咒语是由 $15$ 种字符 `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `A`, `D`, `E`, `L`, `X` 中的若干个组成的长度小于 $10$ 的符号串，这些符号按照从左到右的顺序大致排成一行，如图 1 所示。\n\n现已在一个雷电交加的黎明搜集到所罗门广场上各块大理石板的亮度，亮度值用 $0$ 到 $255$ 的整数来度量，你能破译出开启所罗门宝藏的咒语么？\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pko6syac.png)", "inputFormat": "第一行包含用一个空格隔开的 $2$ 个整数 $L$ 和 $H$，其中 $L$ 表示所罗门广场包含的大理石板的列数，$5 \\le L \\le 100$，$H$ 表示所罗门广场包含的大理石板的行数，$5 \\le H \\le 100$。\n\n接下来的 $H$ 行，每行有 $L$ 个由一个空格隔开的整数，不妨记接下来的第 $i$ 行，第 $j$ 列的整数为 $V_{ij}$，则有 $0 \\le V_{ij} \\le 255$。", "outputFormat": "第一行为正整数 $t$，表示咒语的长度。第二行为一个长度为 $t$ 的字符串，表示识别出的咒语。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3187", "type": "P", "difficulty": 6, "samples": [["6\n1.0 3.00000\n1 4.00000\n2.0000 1\n3 0.0000\n3.00000 6\n6.0 3.0", "18.00000\n3.00000 0.00000\n6.00000 3.00000\n3.00000 6.00000\n0.00000 3.00000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2007", "各省省选", "湖南", "Special Judge", "枚举", "凸包", "旋转卡壳"], "title": "[HNOI2007] 最小矩形覆盖", "background": "", "description": "给定一些点的坐标，求能够覆盖所有点的最小面积的矩形，输出所求矩形的面积和四个顶点坐标。", "inputFormat": "第一行为一个整数 $n$，从第 $2$ 至第 $n+1$ 行每行有两个浮点数（精确到至多五位小数，不使用科学计数法），表示一个顶点的 $x$ 和 $y$ 坐标。", "outputFormat": "第一行为一个浮点数，表示所求矩形的面积，接下来 $4$ 行每行表示一个顶点坐标，**按逆时针**输出顶点坐标。", "hint": "$3 \\le n \\le 50000$，坐标范围 $\\in [0,10]$。保证覆盖所有点所需要的最小矩形面积至少是 $0.1$。\n\n如果你的矩形面积为 $S'$，正确答案为 $S$，那么当 $\\frac{|S'-S|}{\\max\\{1,S\\}}<10^{-4}$，且所有点满足在矩形内或者到矩形的距离 $<10^{-4}$ 时，你的答案会被判定为正确（你可以忽略这段话，简而言之你的答案只要不是有特别大的精度误差就可以通过）。\n\n感谢 @intruder 提供题目简述\n", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2007] Minimum Rectangle Cover", "background": "", "description": "Given the coordinates of several points, find the rectangle with the minimum area that covers all the points. Output the area of the rectangle and the coordinates of its four vertices.", "inputFormat": "The first line contains an integer $n$. From line $2$ to line $n+1$, each line contains two floating-point numbers (with up to five decimal places, not in scientific notation), representing the $x$ and $y$ coordinates of a point.", "outputFormat": "The first line contains a floating-point number, which is the area of the rectangle. The next $4$ lines each contain the coordinates of a vertex, output in **counterclockwise** order.", "hint": "$3 \\le n \\le 50000$, coordinate range $\\in [0, 10]$. It is guaranteed that the minimum rectangle area needed to cover all points is at least $0.1$.\n\nIf your rectangle area is $S'$, and the correct answer is $S$, then your answer will be judged correct when $\\frac{|S' - S|}{\\max\\{1, S\\}} < 10^{-4}$, and all points are inside the rectangle or have distance $< 10^{-4}$ to the rectangle (you can ignore this paragraph; in short, your answer will pass as long as the numerical error is not particularly large).\n\nThanks to @intruder for providing the problem summary.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2007] 最小矩形覆盖", "background": "", "description": "给定一些点的坐标，求能够覆盖所有点的最小面积的矩形，输出所求矩形的面积和四个顶点坐标。", "inputFormat": "第一行为一个整数 $n$，从第 $2$ 至第 $n+1$ 行每行有两个浮点数（精确到至多五位小数，不使用科学计数法），表示一个顶点的 $x$ 和 $y$ 坐标。", "outputFormat": "第一行为一个浮点数，表示所求矩形的面积，接下来 $4$ 行每行表示一个顶点坐标，**按逆时针**输出顶点坐标。", "hint": "$3 \\le n \\le 50000$，坐标范围 $\\in [0,10]$。保证覆盖所有点所需要的最小矩形面积至少是 $0.1$。\n\n如果你的矩形面积为 $S'$，正确答案为 $S$，那么当 $\\frac{|S'-S|}{\\max\\{1,S\\}}<10^{-4}$，且所有点满足在矩形内或者到矩形的距离 $<10^{-4}$ 时，你的答案会被判定为正确（你可以忽略这段话，简而言之你的答案只要不是有特别大的精度误差就可以通过）。\n\n感谢 @intruder 提供题目简述\n", "locale": "zh-CN"}}}
{"pid": "P3188", "type": "P", "difficulty": 5, "samples": [["4 10\n8 9\n5 8\n4 6\n2 5\n4 13\n8 9\n5 8\n4 6\n2 5\n16 75594681\n393216 5533\n2 77\n32768 467\n29360128 407840\n112 68\n24576 372\n768 60\n33554432 466099\n16384 318\n33554432 466090\n2048 111\n24576 350\n9216 216\n12582912 174768\n16384 295\n1024 76\n-1 -1", "14\n19\n1050650"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "各省省选", "湖南", "背包 DP", "进制"], "title": "[HNOI2007] 梦幻岛宝珠", "background": "", "description": "给你 $n$ 颗宝石，每颗宝石都有重量和价值。要你从这些宝石中选取一些宝石，保证总重量不超过 $W$，且总价值最大，并输出最大的总价值。\n", "inputFormat": "输入文件中包含多组数据。每组数据的格式如下：\n\n第一行是两个正整数 $n$ 和 $W$，分别表示宝石的数目和最多能带走的宝石重量。\n\n接下来的 $n$ 行，每行有两个正整数 $w_i,v_i$，分别表示第 $i$ 颗宝石的重量和价值。\n\n最后一组数据的后面有两个 $-1$，表示文件的结束。这两个 $-1$ 并不代表一组数据，你不需对这组数据输出结果。  \n\n输入文件中数据的组数不超过 $20$。\n", "outputFormat": "对于输入的每组数据，输出一个整数 $c$，表示小 P 最多能带走的宝石的总价值。  \n每个结果整数 $c$ 单独占一行。\n", "hint": "### 数据范围及约定\n\n对于 $100\\%$ 的数据，$1\\le n \\le 100$，$1\\le W,w_i,v_i \\le 2^{30}$。  \n保证每个 $w_i$ 能写成 $a \\times 2^b\\space (a,b \\in \\mathbb N)$ 的形式，$a \\leq 10$ , $b \\leq 30$，且答案不超过 $2^{30}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2007] Dream Island Orbs", "background": "", "description": "You are given $n$ gems, each with a weight and a value. Choose some of these gems so that the total weight does not exceed $W$, and the total value is maximized. Output the maximum total value.", "inputFormat": "The input contains multiple test cases. Each test case is formatted as follows:\n\nThe first line contains two positive integers $n$ and $W$, representing the number of gems and the maximum total weight you can carry.\n\nThe next $n$ lines each contain two positive integers $w_i, v_i$, representing the weight and value of the $i$-th gem.\n\nAfter the last test case, there are two $-1$ indicating the end of file. These two $-1$ do not represent a test case, and you should not output a result for them.  \nThe number of test cases in the input file does not exceed $20$.", "outputFormat": "For each test case, output an integer $c$, the maximum total value of the gems you can carry.  \nPrint each integer $c$ on a separate line.", "hint": "### Constraints\n\nFor $100\\%$ of the testdata, $1\\le n \\le 100$, $1\\le W,w_i,v_i \\le 2^{30}$.  \nIt is guaranteed that each $w_i$ can be written as $a \\times 2^b\\space (a,b \\in \\mathbb N)$ with $a \\leq 10$, $b \\leq 30$, and the answer does not exceed $2^{30}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2007] 梦幻岛宝珠", "background": "", "description": "给你 $n$ 颗宝石，每颗宝石都有重量和价值。要你从这些宝石中选取一些宝石，保证总重量不超过 $W$，且总价值最大，并输出最大的总价值。\n", "inputFormat": "输入文件中包含多组数据。每组数据的格式如下：\n\n第一行是两个正整数 $n$ 和 $W$，分别表示宝石的数目和最多能带走的宝石重量。\n\n接下来的 $n$ 行，每行有两个正整数 $w_i,v_i$，分别表示第 $i$ 颗宝石的重量和价值。\n\n最后一组数据的后面有两个 $-1$，表示文件的结束。这两个 $-1$ 并不代表一组数据，你不需对这组数据输出结果。  \n\n输入文件中数据的组数不超过 $20$。\n", "outputFormat": "对于输入的每组数据，输出一个整数 $c$，表示小 P 最多能带走的宝石的总价值。  \n每个结果整数 $c$ 单独占一行。\n", "hint": "### 数据范围及约定\n\n对于 $100\\%$ 的数据，$1\\le n \\le 100$，$1\\le W,w_i,v_i \\le 2^{30}$。  \n保证每个 $w_i$ 能写成 $a \\times 2^b\\space (a,b \\in \\mathbb N)$ 的形式，$a \\leq 10$ , $b \\leq 30$，且答案不超过 $2^{30}$。\n", "locale": "zh-CN"}}}
