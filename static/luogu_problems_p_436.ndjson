{"pid": "P9840", "type": "P", "difficulty": 2, "samples": [["3 3 3\n", "RRDD"], ["4 3 2\n", "DLDLDLUR"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Oops, It's Yesterday Twice More", "background": "", "description": "After the great success in 2018, 2019, and 2020, Nanjing University of Aeronautics and Astronautics (NUAA) will host the $\\textit{International Collegiate Programming Contest}$ (ICPC) Nanjing regional for the fourth time.\n\nTeam $\\textbf{\\textit{Power of Two}}$ and team $\\textbf{\\textit{Three Hold Two}}$ won the champion for Tsinghua University in 2018 and 2019. In 2020, team $\\textbf{\\textit{Inverted Cross}}$ from Peking University won the champion. In 2021, there are around $700$ teams including $\\textbf{the defending champion}$ participating in the contest. We are so excited to see who will win this year!\n\nAlthough we can't gather in Nanjing this time due to the pandemic, we should still be grateful for the hard work done by all staff and volunteers for this contest. Thank you all for your great contribution to this contest!\n\nIn the 2018 contest, problem K, $\\textbf{\\textit{Kangaroo Puzzle}}$, requires the contestants to construct an operation sequence for the game:\n\n> The puzzle is a grid with $n$ rows and $m$ columns ($1 \\le n, m \\le 20$) and there are some (at least $2$) kangaroos standing in the puzzle. The player's goal is to control them to get together. There are some walls in some cells and the kangaroos cannot enter the cells with walls. The other cells are empty. The kangaroos can move from an empty cell to an adjacent empty cell in four directions: up, down, left, and right.\n>\n> There is exactly one kangaroo in every empty cell in the beginning and the player can control the kangaroos by pressing the button U, D, L, R on the keyboard. The kangaroos will move simultaneously according to the button you press.\n>\n> The contestant needs to construct an operating sequence of at most $5 \\times 10^4$ steps consisting of U, D, L, R only to achieve the goal.\n\nIn the 2020 contest, problem A, $\\textbf{\\textit{Ah, It's Yesterday Once More}}$, requires the contestants to construct an input map to hack the following code of the problem described before:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\nNow in the 2021 contest, Paimon prepares another version of the problem for you. You are given a grid with $n$ rows and $n$ columns ($2 \\leq n \\leq 500$). All cells are empty and there is one kangaroo standing in each cell.\n\nSimilarly, you can control the kangaroos by pressing the button U, D, L, R on the keyboard. The kangaroos will move simultaneously according to the button you press. Specifically, for any kangaroo located in the cell on the $i$-th row and the $j$-th column, indicated by $(i,j)$:\n\n- Button U: it will move to $(i-1,j)$ if $i>1$. Otherwise, it will stay in the same grid.\n- Button D: it will move to $(i+1,j)$ if $i<n$. Otherwise, it will stay in the same grid.\n- Button L: it will move to $(i,j-1)$ if $j>1$. Otherwise, it will stay in the same grid.\n- Button R: it will move to $(i,j+1)$ if $j<n$. Otherwise, it will stay in the same grid.\n\nYou need to construct an operating sequence consisting only of characters `U`, `D`, `L`, and `R`. After applying it, you must make sure every kangaroo will gather at the specific cell $(a,b)$. The length of the operating sequence cannot exceed $3(n-1)$.", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line of the input contains three integers $n$, $a$, $b$ ($2 \\leq n \\leq 500$, $ 1 \\leq a,b \\leq n$) indicating the size of the grid and the target cell.", "outputFormat": "Output a string consisting only of characters `U`, `D`, `L` and `R` in one line. And its length mustn't exceed $3(n-1)$. It can be proved that the answer always exists.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Oops, It's Yesterday Twice More", "background": "", "description": "After the great success in 2018, 2019, and 2020, Nanjing University of Aeronautics and Astronautics (NUAA) will host the $\\textit{International Collegiate Programming Contest}$ (ICPC) Nanjing regional for the fourth time.\n\nTeam $\\textbf{\\textit{Power of Two}}$ and team $\\textbf{\\textit{Three Hold Two}}$ won the champion for Tsinghua University in 2018 and 2019. In 2020, team $\\textbf{\\textit{Inverted Cross}}$ from Peking University won the champion. In 2021, there are around $700$ teams including $\\textbf{the defending champion}$ participating in the contest. We are so excited to see who will win this year!\n\nAlthough we can't gather in Nanjing this time due to the pandemic, we should still be grateful for the hard work done by all staff and volunteers for this contest. Thank you all for your great contribution to this contest!\n\nIn the 2018 contest, problem K, $\\textbf{\\textit{Kangaroo Puzzle}}$, requires the contestants to construct an operation sequence for the game:\n\n> The puzzle is a grid with $n$ rows and $m$ columns ($1 \\le n, m \\le 20$) and there are some (at least $2$) kangaroos standing in the puzzle. The player's goal is to control them to get together. There are some walls in some cells and the kangaroos cannot enter the cells with walls. The other cells are empty. The kangaroos can move from an empty cell to an adjacent empty cell in four directions: up, down, left, and right.\n>\n> There is exactly one kangaroo in every empty cell in the beginning and the player can control the kangaroos by pressing the button U, D, L, R on the keyboard. The kangaroos will move simultaneously according to the button you press.\n>\n> The contestant needs to construct an operating sequence of at most $5 \\times 10^4$ steps consisting of U, D, L, R only to achieve the goal.\n\nIn the 2020 contest, problem A, $\\textbf{\\textit{Ah, It's Yesterday Once More}}$, requires the contestants to construct an input map to hack the following code of the problem described before:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\nNow in the 2021 contest, Paimon prepares another version of the problem for you. You are given a grid with $n$ rows and $n$ columns ($2 \\leq n \\leq 500$). All cells are empty and there is one kangaroo standing in each cell.\n\nSimilarly, you can control the kangaroos by pressing the button U, D, L, R on the keyboard. The kangaroos will move simultaneously according to the button you press. Specifically, for any kangaroo located in the cell on the $i$-th row and the $j$-th column, indicated by $(i,j)$:\n\n- Button U: it will move to $(i-1,j)$ if $i>1$. Otherwise, it will stay in the same grid.\n- Button D: it will move to $(i+1,j)$ if $i<n$. Otherwise, it will stay in the same grid.\n- Button L: it will move to $(i,j-1)$ if $j>1$. Otherwise, it will stay in the same grid.\n- Button R: it will move to $(i,j+1)$ if $j<n$. Otherwise, it will stay in the same grid.\n\nYou need to construct an operating sequence consisting only of characters `U`, `D`, `L`, and `R`. After applying it, you must make sure every kangaroo will gather at the specific cell $(a,b)$. The length of the operating sequence cannot exceed $3(n-1)$.", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line of the input contains three integers $n$, $a$, $b$ ($2 \\leq n \\leq 500$, $ 1 \\leq a,b \\leq n$) indicating the size of the grid and the target cell.", "outputFormat": "Output a string consisting only of characters `U`, `D`, `L` and `R` in one line. And its length mustn't exceed $3(n-1)$. It can be proved that the answer always exists.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Oops, It's Yesterday Twice More", "background": "", "description": "继 2018、2019 和 2020 年的巨大成功之后，南京航空航天大学（NUAA）将第四次举办国际大学生程序设计竞赛（ICPC）南京赛区。\n\n2018 年和 2019 年，清华大学的队伍“Power of Two”和“三人行二”分别获得了冠军。2020 年，北京大学的队伍“Inverted Cross”赢得了冠军。2021 年，大约有 700 支队伍，包括卫冕冠军，参加了比赛。我们非常期待今年谁将获胜！\n\n尽管由于疫情我们无法在南京聚集，但我们仍然应该感谢所有工作人员和志愿者为这次比赛所做的辛勤工作。感谢你们对这次比赛的巨大贡献！\n\n在 2018 年的比赛中，问题 K，“Kangaroo Puzzle”，要求参赛者为游戏构建一个操作序列：\n\n> 这个谜题是一个有 $n$ 行 $m$ 列的网格（$1 \\le n, m \\le 20$），其中有一些（至少 2 个）袋鼠站在网格中。玩家的目标是控制它们聚在一起。某些格子中有墙，袋鼠不能进入有墙的格子。其他格子是空的。袋鼠可以从一个空格子移动到相邻的空格子，方向有四个：上、下、左、右。\n>\n> 一开始每个空格子中恰好有一个袋鼠，玩家可以通过按键盘上的 U、D、L、R 按钮来控制袋鼠。袋鼠将根据你按下的按钮同时移动。\n>\n> 参赛者需要构建一个最多 $5 \\times 10^4$ 步的操作序列，仅包含 U、D、L、R，以实现目标。\n\n在 2020 年的比赛中，问题 A，“Ah, It's Yesterday Once More”，要求参赛者构建一个输入地图以破解之前描述的问题的以下代码：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\n现在在 2021 年的比赛中，Paimon 为你准备了该问题的另一个版本。你得到一个有 $n$ 行 $n$ 列的网格（$2 \\leq n \\leq 500$）。所有格子都是空的，每个格子中有一个袋鼠。\n\n同样，你可以通过按键盘上的 U、D、L、R 按钮来控制袋鼠。袋鼠将根据你按下的按钮同时移动。具体来说，对于位于第 $i$ 行第 $j$ 列的袋鼠，用 $(i,j)$ 表示：\n\n- 按钮 U：如果 $i>1$，它将移动到 $(i-1,j)$。否则，它将停留在同一格子。\n- 按钮 D：如果 $i<n$，它将移动到 $(i+1,j)$。否则，它将停留在同一格子。\n- 按钮 L：如果 $j>1$，它将移动到 $(i,j-1)$。否则，它将停留在同一格子。\n- 按钮 R：如果 $j<n$，它将移动到 $(i,j+1)$。否则，它将停留在同一格子。\n\n你需要构建一个仅由字符 `U`、`D`、`L` 和 `R` 组成的操作序列。在应用它之后，你必须确保每只袋鼠都聚集在特定的格子 $(a,b)$。操作序列的长度不能超过 $3(n-1)$。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行也是唯一一行包含三个整数 $n$，$a$，$b$（$2 \\leq n \\leq 500$，$1 \\leq a,b \\leq n$），表示网格的大小和目标格子。", "outputFormat": "输出一个仅由字符 `U`、`D`、`L` 和 `R` 组成的字符串，并且其长度不能超过 $3(n-1)$。可以证明答案总是存在的。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9841", "type": "P", "difficulty": 7, "samples": [["4\n0 1 1\n0 0\n1\n1 0 0\n1 1\n0\n", "1\n2 1 3 4 1\n"], ["4\n3 3 3\n0 0\n0\n0 0 0\n3 3\n3\n", "1\n1 2 3 4 -3\n"], ["5\n-12 15 -12 1\n37 14 7\n7 9\n-11\n12 5 1 13\n-1 -4 -7\n-5 -9\n18\n", "-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["搜索", "2021", "Special Judge", "O2优化", "构造", "ICPC", "分类讨论", "南京"], "title": "[ICPC 2021 Nanjing R] Puzzle in Inazuma", "background": "", "description": "Every traveler knows that they'll be rewarded with a treasure box after solving the puzzles in Inazuma, but few know that these puzzles are designed by Yae Miko, the Guuji of the Grand Narukami Shrine, to test whether the traveler is strong enough to save her friend Raiden Shogun and people of Inazuma.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p50zu2m6.png)\n\nAfter a traveler passes the test Yae will have to reset the puzzles to the initial state. But this time she has some troubles and even doubts that whether some of them are already broken.\n\nYae's puzzle can be considered as a weighted undirected complete graph $G$ before resetting. We also denote the initial state as another weighted undirected complete graph $H$. Both $G$ and $H$ have exactly $n$ vertices, and these vertices are labeled from $1$ to $n$.\n\nTo reset graph $G$ to $H$ Yae can perform the following operation any number of times:\n- First select four distinct vertices $a$, $b$, $c$, $d$ and an integer $x$. Note that she can select a different set of $a$, $b$, $c$, $d$ and $x$ each time.\n- Let $(i, j)$ be the edge between vertices $i$ and $j$. Increase the weight of $(a, b)$, $(a, c)$ and $(a, d)$ by $x$ and also decrease the weight of $(b, c)$, $(b, d)$ and $(c, d)$ by $x$.\n\nPlease help Yae determine whether she can change graph $G$ to graph $H$. If yes you also shall tell her the detailed steps.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains an integer $n$ ($4 \\leq n \\leq 100$) indicating the number of vertices in graph $G$ and $H$.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains $(n - i)$ integers $w_{i, i + 1}, w_{i, i + 2}, \\cdots, w_{i, n}$ ($-100 \\le w_{i, j} \\le 100$) where $w_{i, j}$ indicates the weight of the edge connecting vertices $i$ and $j$ in graph $G$.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains $(n - i)$ integers $v_{i, i + 1}, v_{i, i + 2}, \\cdots, v_{i, n}$ ($-100 \\le v_{i, j} \\le 100$) where $v_{i, j}$ indicates the weight of the edge connecting vertices $i$ and $j$ in graph $H$.", "outputFormat": "If Yae cannot change $G$ to $H$, output `-1`.\n\nOtherwise first output an integer $m$ ($0 \\le m \\le 10^5$) in one line indicating the number of operations Yae needs.\n\nFor the following $m$ lines, output five integers $a_i$, $b_i$, $c_i$, $d_i$ and $x_i$ in the $i$-th line separated by a space, indicating that for the $i$-th operation Yae choose vertices $a_i$, $b_i$, $c_i$, $d_i$ and integer $x_i$. Note that $a_i$, $b_i$, $c_i$, $d_i$ must be distinct and $-10^9 \\le x_i \\le 10^9$.\n\nIt can be proved that if graph $G$ can be changed to graph $H$ there exists a solution with no more than $10^5$ operations.\n\nNote that you don't have to minimize $m$. If there are multiple solutions, output any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Puzzle in Inazuma", "background": "", "description": "Every traveler knows that they'll be rewarded with a treasure box after solving the puzzles in Inazuma, but few know that these puzzles are designed by Yae Miko, the Guuji of the Grand Narukami Shrine, to test whether the traveler is strong enough to save her friend Raiden Shogun and people of Inazuma.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p50zu2m6.png)\n\nAfter a traveler passes the test Yae will have to reset the puzzles to the initial state. But this time she has some troubles and even doubts that whether some of them are already broken.\n\nYae's puzzle can be considered as a weighted undirected complete graph $G$ before resetting. We also denote the initial state as another weighted undirected complete graph $H$. Both $G$ and $H$ have exactly $n$ vertices, and these vertices are labeled from $1$ to $n$.\n\nTo reset graph $G$ to $H$ Yae can perform the following operation any number of times:\n- First select four distinct vertices $a$, $b$, $c$, $d$ and an integer $x$. Note that she can select a different set of $a$, $b$, $c$, $d$ and $x$ each time.\n- Let $(i, j)$ be the edge between vertices $i$ and $j$. Increase the weight of $(a, b)$, $(a, c)$ and $(a, d)$ by $x$ and also decrease the weight of $(b, c)$, $(b, d)$ and $(c, d)$ by $x$.\n\nPlease help Yae determine whether she can change graph $G$ to graph $H$. If yes you also shall tell her the detailed steps.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains an integer $n$ ($4 \\leq n \\leq 100$) indicating the number of vertices in graph $G$ and $H$.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains $(n - i)$ integers $w_{i, i + 1}, w_{i, i + 2}, \\cdots, w_{i, n}$ ($-100 \\le w_{i, j} \\le 100$) where $w_{i, j}$ indicates the weight of the edge connecting vertices $i$ and $j$ in graph $G$.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains $(n - i)$ integers $v_{i, i + 1}, v_{i, i + 2}, \\cdots, v_{i, n}$ ($-100 \\le v_{i, j} \\le 100$) where $v_{i, j}$ indicates the weight of the edge connecting vertices $i$ and $j$ in graph $H$.", "outputFormat": "If Yae cannot change $G$ to $H$, output `-1`.\n\nOtherwise first output an integer $m$ ($0 \\le m \\le 10^5$) in one line indicating the number of operations Yae needs.\n\nFor the following $m$ lines, output five integers $a_i$, $b_i$, $c_i$, $d_i$ and $x_i$ in the $i$-th line separated by a space, indicating that for the $i$-th operation Yae choose vertices $a_i$, $b_i$, $c_i$, $d_i$ and integer $x_i$. Note that $a_i$, $b_i$, $c_i$, $d_i$ must be distinct and $-10^9 \\le x_i \\le 10^9$.\n\nIt can be proved that if graph $G$ can be changed to graph $H$ there exists a solution with no more than $10^5$ operations.\n\nNote that you don't have to minimize $m$. If there are multiple solutions, output any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Puzzle in Inazuma", "background": null, "description": "每个旅行者都知道，在稻妻解开谜题后，他们会得到一个宝箱，但很少有人知道这些谜题是由鸣神大社的宫司八重神子设计的，用来测试旅行者是否足够强大以拯救她的朋友雷电将军和稻妻的人民。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p50zu2m6.png)\n\n在旅行者通过测试后，八重神子必须将谜题重置为初始状态。但这次她遇到了一些麻烦，甚至怀疑其中一些谜题是否已经损坏。\n\n在重置之前，八重神子的谜题可以被视为一个加权无向完全图 $G$。我们也将初始状态表示为另一个加权无向完全图 $H$。$G$ 和 $H$ 都有 $n$ 个顶点，这些顶点从 $1$ 到 $n$ 标记。\n\n为了将图 $G$ 重置为 $H$，八重神子可以执行以下操作任意次：\n- 首先选择四个不同的顶点 $a$，$b$，$c$，$d$ 和一个整数 $x$。注意，每次她可以选择不同的 $a$，$b$，$c$，$d$ 和 $x$。\n- 令 $(i, j)$ 为顶点 $i$ 和 $j$ 之间的边。将 $(a, b)$，$(a, c)$ 和 $(a, d)$ 的权重增加 $x$，同时将 $(b, c)$，$(b, d)$ 和 $(c, d)$ 的权重减少 $x$。\n\n请帮助八重神子确定她是否可以将图 $G$ 变为图 $H$。如果可以，你还需要告诉她详细的步骤。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含一个整数 $n$ ($4 \\leq n \\leq 100$)，表示图 $G$ 和 $H$ 中的顶点数。\n\n接下来的 $(n - 1)$ 行中，第 $i$ 行包含 $(n - i)$ 个整数 $w_{i, i + 1}, w_{i, i + 2}, \\cdots, w_{i, n}$ ($-100 \\le w_{i, j} \\le 100$)，其中 $w_{i, j}$ 表示图 $G$ 中连接顶点 $i$ 和 $j$ 的边的权重。\n\n接下来的 $(n - 1)$ 行中，第 $i$ 行包含 $(n - i)$ 个整数 $v_{i, i + 1}, v_{i, i + 2}, \\cdots, v_{i, n}$ ($-100 \\le v_{i, j} \\le 100$)，其中 $v_{i, j}$ 表示图 $H$ 中连接顶点 $i$ 和 $j$ 的边的权重。", "outputFormat": "如果八重神子不能将 $G$ 变为 $H$，输出 `-1`。\n\n否则，首先输出一个整数 $m$ ($0 \\le m \\le 10^5$) 表示八重神子需要的操作次数。\n\n在接下来的 $m$ 行中，每行输出五个整数 $a_i$，$b_i$，$c_i$，$d_i$ 和 $x_i$，用空格分隔，表示在第 $i$ 次操作中，八重神子选择顶点 $a_i$，$b_i$，$c_i$，$d_i$ 和整数 $x_i$。注意，$a_i$，$b_i$，$c_i$，$d_i$ 必须是不同的，且 $-10^9 \\le x_i \\le 10^9$。\n\n可以证明，如果图 $G$ 可以变为图 $H$，则存在一个不超过 $10^5$ 次操作的解决方案。\n\n注意，你不必最小化 $m$。如果有多个解决方案，输出其中任何一个。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9842", "type": "P", "difficulty": 3, "samples": [["5 2\n2 2 4 4 4\n", "5\n"], ["7 1\n3 2 3 2 2 2 3\n", "6\n"], ["7 1\n2 3 2 3 2 3 3\n", "5\n"], ["9 -100\n-1 -2 1 2 -1 -2 1 -2 1\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Klee in Solitary Confinement", "background": "", "description": "Since the traveler comes, People in Monstadt suddenly raise great interest in computer programming and algorithms, including Klee, the Spark Knight of the Knights of Favonius.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcnn0v4q.png)\n\nBeing sent to solitary confinement by Jean again, Klee decides to spend time learning the famous Mo's algorithm, which can compute with a time complexity of $\\mathcal{O}(n^{1.5})$ for some range query problem without modifications.\n\nTo check whether Klee has truly mastered the algorithm (or in fact making another bombs secretly), Jean gives her a problem of an integer sequence $a_1, a_2, \\cdots, a_n$ along with some queries $[l_i, r_i]$ requiring her to find the mode number in the contiguous subsequence $a_{l_i}, a_{l_i + 1}, \\cdots, a_{r_i}$. The mode number is the most common number (that is to say, the number which appears the maximum number of times) in the subsequence.\n\nWith the help of Mo's algorithm, Klee solves that problem without effort, but another problem comes into her mind. Given an integer sequence $a_1, a_2, \\cdots, a_n$ of length $n$ and an integer $k$, you can perform the following operation at most once: Choose two integers $l$ and $r$ such that $1 \\le l \\le r \\le n$ and add $k$ to every $a_i$ where $l \\le i \\le r$. Note that it is OK not to perform this operation. Compute the maximum occurrence of the mode number of the whole sequence if you choose to perform (or not perform) the operation optimally.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le n \\le 10^6$, $-10^6 \\le k \\le 10^6$) indicating the length of the sequence and the additive number.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($-10^6 \\le a_i \\le 10^6$) indicating the original sequence.", "outputFormat": "Output one line containing one integer indicating the maximum occurrence of the mode number of the whole sequence after performing (or not performing) the operation.", "hint": "For the first sample test case, choose $l = 1$ and $r = 2$ and we'll result in the sequence $\\{4, 4, 4, 4, 4\\}$. The mode number is obviously $4$ which appears $5$ times.\n\nFor the second sample test case, choose $l = 4$ and $r = 6$ and we'll result in the sequence $\\{3, 2, 3, 3, 3, 3, 3\\}$. The mode number is $3$ which appears $6$ times.\n\nFor the fourth sample test case, choose not to perform the operation. The mode number is $1$ and $-2$ which both appear $3$ times.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Klee in Solitary Confinement", "background": "", "description": "Since the traveler comes, People in Monstadt suddenly raise great interest in computer programming and algorithms, including Klee, the Spark Knight of the Knights of Favonius.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcnn0v4q.png)\n\nBeing sent to solitary confinement by Jean again, Klee decides to spend time learning the famous Mo's algorithm, which can compute with a time complexity of $\\mathcal{O}(n^{1.5})$ for some range query problem without modifications.\n\nTo check whether Klee has truly mastered the algorithm (or in fact making another bombs secretly), Jean gives her a problem of an integer sequence $a_1, a_2, \\cdots, a_n$ along with some queries $[l_i, r_i]$ requiring her to find the mode number in the contiguous subsequence $a_{l_i}, a_{l_i + 1}, \\cdots, a_{r_i}$. The mode number is the most common number (that is to say, the number which appears the maximum number of times) in the subsequence.\n\nWith the help of Mo's algorithm, Klee solves that problem without effort, but another problem comes into her mind. Given an integer sequence $a_1, a_2, \\cdots, a_n$ of length $n$ and an integer $k$, you can perform the following operation at most once: Choose two integers $l$ and $r$ such that $1 \\le l \\le r \\le n$ and add $k$ to every $a_i$ where $l \\le i \\le r$. Note that it is OK not to perform this operation. Compute the maximum occurrence of the mode number of the whole sequence if you choose to perform (or not perform) the operation optimally.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le n \\le 10^6$, $-10^6 \\le k \\le 10^6$) indicating the length of the sequence and the additive number.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($-10^6 \\le a_i \\le 10^6$) indicating the original sequence.", "outputFormat": "Output one line containing one integer indicating the maximum occurrence of the mode number of the whole sequence after performing (or not performing) the operation.", "hint": "For the first sample test case, choose $l = 1$ and $r = 2$ and we'll result in the sequence $\\{4, 4, 4, 4, 4\\}$. The mode number is obviously $4$ which appears $5$ times.\n\nFor the second sample test case, choose $l = 4$ and $r = 6$ and we'll result in the sequence $\\{3, 2, 3, 3, 3, 3, 3\\}$. The mode number is $3$ which appears $6$ times.\n\nFor the fourth sample test case, choose not to perform the operation. The mode number is $1$ and $-2$ which both appear $3$ times.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Klee in Solitary Confinement", "background": null, "description": "自从旅行者来到蒙德，蒙德的人们突然对计算机编程和算法产生了极大的兴趣，包括西风骑士团的火花骑士可莉。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcnn0v4q.png)\n\n被琴再次关进禁闭室后，可莉决定花时间学习著名的莫队算法，该算法可以在不进行修改的情况下以 $\\mathcal{O}(n^{1.5})$ 的时间复杂度计算某些区间查询问题。\n\n为了检查可莉是否真正掌握了该算法（或者实际上是在秘密制造另一个炸弹），琴给了她一个整数序列 $a_1, a_2, \\cdots, a_n$ 和一些查询 $[l_i, r_i]$，要求她找到连续子序列 $a_{l_i}, a_{l_i + 1}, \\cdots, a_{r_i}$ 中的众数。众数是指在子序列中出现次数最多的数字。\n\n在莫队算法的帮助下，可莉毫不费力地解决了这个问题，但她脑海中又出现了另一个问题。给定一个长度为 $n$ 的整数序列 $a_1, a_2, \\cdots, a_n$ 和一个整数 $k$，你可以最多进行一次以下操作：选择两个整数 $l$ 和 $r$，使得 $1 \\le l \\le r \\le n$，并 $a_i$ 加上 $k$，其中 $l \\le i \\le r$。注意可以选择不进行此操作。计算如果你选择最优地进行（或不进行）操作，整个序列的众数的最大出现次数。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含两个整数 $n$ 和 $k$（$1 \\le n \\le 10^6$，$-10^6 \\le k \\le 10^6$），表示序列的长度和要添加的数。\n\n输入的第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$-10^6 \\le a_i \\le 10^6$），表示原始序列。", "outputFormat": "输出一行，包含一个整数，表示在最优地进行（或不进行）操作后，整个序列的众数的最大出现次数。", "hint": "对于第一个样例测试用例，选择 $l = 1$ 和 $r = 2$，我们将得到序列 $\\{4, 4, 4, 4, 4\\}$。显然，众数是 $4$，出现了 $5$ 次。\n\n对于第二个样例测试用例，选择 $l = 4$ 和 $r = 6$，我们将得到序列 $\\{3, 2, 3, 3, 3, 3, 3\\}$。众数是 $3$，出现了 $6$ 次。\n\n对于第四个样例测试用例，选择不进行操作。众数是 $1$ 和 $-2$，它们都出现了 $3$ 次。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9843", "type": "P", "difficulty": 4, "samples": [["3\n5\n2 3 2 1 5\n3\n1 2 3\n1\n1\n", "0 2 3 5 7\n0 2 4\n0\n"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["2021", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Paimon Sorting", "background": "", "description": "Paimon just invents a new sorting algorithm which looks much like $\\textit{bubble sort}$, with a few differences. It accepts a $1$-indexed sequence $A$ of length $n$ and sorts it. Its pseudo-code is shown below.\n\n```cpp\n// The Sorting Algorithm\nSORT(A)\n  for i from 1 to n // n is the number of elements if A\n    for j from 1 to n\n      if a[i] < a[j] // a[i] is the i-th element in A\n        Swap a[i] and a[j]\n```\n\n\nIf you don't believe this piece of algorithm can sort a sequence it will also be your task to prove it. Anyway here comes the question:\n\nGiven an integer sequence $A = a_1, a_2, \\cdots, a_n$ of length $n$, for each of its prefix $A_k$ of length $k$ (that is, for each $1 \\le k \\le n$, consider the subsequence $A_k = a_1, a_2, \\cdots, a_k$), count the number of swaps performed if we call $\\text{SORT}(A_k)$.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the length of the sequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$) indicating the given sequence.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing $n$ integers $s_1, s_2, \\cdots, s_n$ separated by a space, where $s_i$ is the number of swaps performed if we call $\\text{SORT}(A_i)$.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Paimon Sorting", "background": "", "description": "Paimon just invents a new sorting algorithm which looks much like $\\textit{bubble sort}$, with a few differences. It accepts a $1$-indexed sequence $A$ of length $n$ and sorts it. Its pseudo-code is shown below.\n\n```cpp\n// The Sorting Algorithm\nSORT(A)\n  for i from 1 to n // n is the number of elements if A\n    for j from 1 to n\n      if a[i] < a[j] // a[i] is the i-th element in A\n        Swap a[i] and a[j]\n```\n\n\nIf you don't believe this piece of algorithm can sort a sequence it will also be your task to prove it. Anyway here comes the question:\n\nGiven an integer sequence $A = a_1, a_2, \\cdots, a_n$ of length $n$, for each of its prefix $A_k$ of length $k$ (that is, for each $1 \\le k \\le n$, consider the subsequence $A_k = a_1, a_2, \\cdots, a_k$), count the number of swaps performed if we call $\\text{SORT}(A_k)$.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the length of the sequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$) indicating the given sequence.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing $n$ integers $s_1, s_2, \\cdots, s_n$ separated by a space, where $s_i$ is the number of swaps performed if we call $\\text{SORT}(A_i)$.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Paimon Sorting", "background": "", "description": "派蒙刚刚发明了一种新的排序算法，看起来很像“冒泡排序”，但有一些不同之处。它接受一个长度为 $n$ 的从 1 开始索引的序列 $A$ 并对其进行排序。其伪代码如下所示。\n\n```cpp\n// 排序算法\nSORT(A)\n  for i from 1 to n // n 是 A 中元素的数量\n    for j from 1 to n\n      if a[i] < a[j] // a[i] 是 A 中的第 i 个元素\n        Swap a[i] and a[j]\n```\n\n如果你不相信这段算法可以对一个序列进行排序，你的任务就是证明它。无论如何，问题如下：\n\n给定一个整数序列 $A = a_1, a_2, \\cdots, a_n$，对于其每个长度为 $k$ 的前缀 $A_k$（即，对于每个 $1 \\le k \\le n$，考虑子序列 $A_k = a_1, a_2, \\cdots, a_k$），计算调用 $\\text{SORT}(A_k)$ 时执行的交换次数。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($1 \\le n \\le 10^5$)，表示序列的长度。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$)，表示给定的序列。\n\n保证所有测试用例的 $n$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含 $n$ 个用空格分隔的整数 $s_1, s_2, \\cdots, s_n$，其中 $s_i$ 是调用 $\\text{SORT}(A_i)$ 时执行的交换次数。\n\n请不要在每行的末尾输出多余的空格，否则你的解答可能会被判为错误！", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9844", "type": "P", "difficulty": 5, "samples": [["3 1 1\n8 1 6\n2 3 2\n2 2 0 0\n", "1\n"], ["4 3 3\n2 3 2 2\n1 1 6\n1 3 3\n1 3 6\n2 2 2 3\n1 4 1 3\n4 4 2 3\n", "180\n825\n8\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["线段树", "2021", "Special Judge", "O2优化", "矩阵乘法", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Paimon Segment Tree", "background": "", "description": "Paimon just learns the persistent segment tree and decides to practice immediately. Therefore, Lumine gives her an easy problem to start:\n\nGiven a sequence $a_1, a_2, \\cdots, a_n$ of length $n$, Lumine will apply $m$ modifications to the sequence. In the $i$-th modification, indicated by three integers $l_i$, $r_i$ ($1 \\le l_i \\le r_i \\le n$) and $x_i$, Lumine will change $a_k$ to $(a_k + x_i)$ for all $l_i \\le k \\le r_i$.\n\nLet $a_{i, t}$ be the value of $a_i$ just after the $t$-th operation. This way we can keep track of all historial versions of $a_i$. Note that $a_{i,t}$ might be the same as $a_{i,t-1}$ if it hasn't been modified in the $t$-th modification. For completeness we also define $a_{i, 0}$ as the initial value of $a_i$.\n\nAfter all modifications have been applied, Lumine will give Paimon $q$ queries about the sum of squares among the historical values. The $k$-th query is indicated by four integers $l_k$, $r_k$, $x_k$ and $y_k$ and requires Paimon to calculate\n\n$$\\sum\\limits_{i=l_k}^{r_k}\\sum\\limits_{j=x_k}^{y_k} a_{i, j}^2$$\n\nPlease help Paimon compute the result for all queries. As the answer might be very large, please output the answer modulo $10^9 + 7$.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains three integers $n$, $m$ and $q$ ($1 \\le n, m, q \\le 5 \\times 10^4$) indicating the length of the sequence, the number of modifications and the number of queries.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($|a_i| < 10^9 + 7$) indicating the initial sequence.\n\nFor the following $m$ lines, the $i$-th line contains three integers $l_i$, $r_i$ and $x_i$ ($1 \\le l_i \\le r_i \\le n$, $|x_i| < 10^9 + 7$) indicating the $i$-th modification.\n\nFor the following $q$ lines, the $i$-th line contains four integers $l_i$, $r_i$, $x_i$ and $y_i$ ($1 \\le l_i \\le r_i \\le n$, $0 \\le x_i \\le y_i \\le m$) indicating the $i$-th query.", "outputFormat": "For each query output one line containing one integer indicating the answer modulo $10^9 + 7$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Paimon Segment Tree", "background": "", "description": "Paimon just learns the persistent segment tree and decides to practice immediately. Therefore, Lumine gives her an easy problem to start:\n\nGiven a sequence $a_1, a_2, \\cdots, a_n$ of length $n$, Lumine will apply $m$ modifications to the sequence. In the $i$-th modification, indicated by three integers $l_i$, $r_i$ ($1 \\le l_i \\le r_i \\le n$) and $x_i$, Lumine will change $a_k$ to $(a_k + x_i)$ for all $l_i \\le k \\le r_i$.\n\nLet $a_{i, t}$ be the value of $a_i$ just after the $t$-th operation. This way we can keep track of all historial versions of $a_i$. Note that $a_{i,t}$ might be the same as $a_{i,t-1}$ if it hasn't been modified in the $t$-th modification. For completeness we also define $a_{i, 0}$ as the initial value of $a_i$.\n\nAfter all modifications have been applied, Lumine will give Paimon $q$ queries about the sum of squares among the historical values. The $k$-th query is indicated by four integers $l_k$, $r_k$, $x_k$ and $y_k$ and requires Paimon to calculate\n\n$$\\sum\\limits_{i=l_k}^{r_k}\\sum\\limits_{j=x_k}^{y_k} a_{i, j}^2$$\n\nPlease help Paimon compute the result for all queries. As the answer might be very large, please output the answer modulo $10^9 + 7$.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains three integers $n$, $m$ and $q$ ($1 \\le n, m, q \\le 5 \\times 10^4$) indicating the length of the sequence, the number of modifications and the number of queries.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($|a_i| < 10^9 + 7$) indicating the initial sequence.\n\nFor the following $m$ lines, the $i$-th line contains three integers $l_i$, $r_i$ and $x_i$ ($1 \\le l_i \\le r_i \\le n$, $|x_i| < 10^9 + 7$) indicating the $i$-th modification.\n\nFor the following $q$ lines, the $i$-th line contains four integers $l_i$, $r_i$, $x_i$ and $y_i$ ($1 \\le l_i \\le r_i \\le n$, $0 \\le x_i \\le y_i \\le m$) indicating the $i$-th query.", "outputFormat": "For each query output one line containing one integer indicating the answer modulo $10^9 + 7$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Paimon Segment Tree", "background": null, "description": "派蒙刚刚学习了可持久化线段树，她想马上练习一下。因此，荧决定给她出一道简单的问题：\n\n给定数列 $a_1, a_2, \\cdots, a_n$，并进行 $m$ 次操作。操作包含 $3$ 个参数 $l_i, r_i$ ($1 \\le l_i \\le r_i \\le n$) 和 $x_i$，代表对该序列第 $l_i$ 到第 $r_i$ 个元素加上 $x_i$。\n\n记 $a_{i, t}$ 为 $t$ 次操作后 $a_i$ 的值。注意若 $a_i$ 未被修改，则 $a_{i,t}$ 的值与 $a_{i,t-1}$ 相同。定义 $a_{i, 0}$ 是 $a_i$ 的初始值。\n\n\n完成所有操作后，荧进行 $q$ 次询问，询问包含 $4$ 个整数 $l_k, r_k, x_k$ 和 $y_k$，派蒙需要回答\n\n$$\\sum\\limits_{i=l_k}^{r_k}\\sum\\limits_{j=x_k}^{y_k} a_{i, j}^2$$\n\n请将答案对 $10^9 + 7$ 取模后输出。", "inputFormat": "每个测试点含一组测试数据。\n\n第一行 $3$ 个整数 $n, m, q (1 \\le n, m, q \\le 5 \\times 10^4)$ 分别表示数列的长度，操作的次数和询问的次数。\n\n第 $2$ 行 $n$ 个整数 $a_1, a_2, \\cdots, a_n(|a_i| < 10^9 + 7)$，表示原始数列。\n\n接下来 $m$ 行每行 $3$ 个整数 $l_i, r_i, x_i(1 \\le l_i \\le r_i \\le n, |x_i| < 10^9 + 7)$，表示区间加操作。\n\n接下来$q$行每行包含四个整数 $l_i, r_i, x_i, y_i (1 \\le l_i \\le r_i \\le n, 0 \\le x_i \\le y_i \\le m)$，表示询问。", "outputFormat": "对每个询问单起一行输出答案模 $10^9 + 7$ 的结果。", "hint": "数据范围见输入格式。", "locale": "zh-CN"}}}
{"pid": "P9845", "type": "P", "difficulty": 7, "samples": [["3\n4\n0 3\n3 0\n2 3\n3 2\n5\n4 0\n5 -5\n-4 -2\n1 -2\n-5 -2\n4\n0 1\n1 0\n0 2\n1 1\n", "17.2111025509\n36.6326947621\n0.0000000000\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["计算几何", "2021", "Special Judge", "O2优化", "凸包", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Paimon Polygon", "background": "", "description": "Paimon just puts $(n+1)$ distinct points on the plane, one of which is a special point $O=(0,0)$, and denote the group of remaining points as $\\mathbb{S}$.\n\nWe call a point set $\\mathbb{U}$ $\\textit{strict convex set}$, if and only if $|\\mathbb{U}| \\ge 3$ and all the points from $\\mathbb{U}$ lie exactly on the convex hull built from $\\mathbb{U}$, with no three points lying on the same line.\n\nYou should divide $\\mathbb{S}$ into two sets $\\mathbb{A}$ and $\\mathbb{B}$ so that:\n- $\\mathbb{A} \\cap \\mathbb{B}=\\emptyset$.\n- $\\mathbb{A} \\cup \\mathbb{B}=\\mathbb{S}$.\n- $|\\mathbb{A}| \\ge 2, |\\mathbb{B}| \\ge 2$.\n- The point set $\\mathbb{A} \\cup \\{O\\}$ is a $\\textit{strict convex set}$, and denote its convex hull as $C_{\\mathbb{A} \\cup \\{O\\}}$.\n- The point set $\\mathbb{B} \\cup \\{O\\}$ is a $\\textit{strict convex set}$, and denote its convex hull as $C_{\\mathbb{B} \\cup \\{O\\}}$.\n- The outlines(edges) of $C_{\\mathbb{A} \\cup \\{O\\}}$ and $C_{\\mathbb{B} \\cup \\{O\\}}$ only intersect at point $O$. That is, only one point $O$ satisfies that it lies both on the outlines of $C_{\\mathbb{A} \\cup \\{O\\}}$ and $C_{\\mathbb{B} \\cup \\{O\\}}$.\n\nPlease help Paimon to maximize the sum of the perimeters of these two convex hulls. That is, find a valid division $\\mathbb{A}$ and $\\mathbb{B}$ which maximizes $(L(C_{\\mathbb{A} \\cup \\{O\\}}) + L(C_{\\mathbb{B} \\cup \\{O\\}}))$, where $L(\\text{polygon})$ means the perimeter of that polygon.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $n$ ($4 \\le n \\le 5 \\times 10^5$) indicating the number of points in $\\mathbb{S}$.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$, $(x_i, y_i) \\ne (0, 0)$) indicating the location of the $i$-th point in $\\mathbb{S}$.\n\nIt's guaranteed that the points given in the same test case are pairwise different. However, there may be three points lying on the same line.\n\nIt's also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing a number indicating the maximum total perimeter. If there does not exist a valid division output `0` instead.\n\nYour answer will be accepted if the relative or absolute error is less than $10^{-6}$.", "hint": "A valid division (left) and an invalid division (right) of the first sample test case are shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v17tmtdh.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Paimon Polygon", "background": "", "description": "Paimon just puts $(n+1)$ distinct points on the plane, one of which is a special point $O=(0,0)$, and denote the group of remaining points as $\\mathbb{S}$.\n\nWe call a point set $\\mathbb{U}$ $\\textit{strict convex set}$, if and only if $|\\mathbb{U}| \\ge 3$ and all the points from $\\mathbb{U}$ lie exactly on the convex hull built from $\\mathbb{U}$, with no three points lying on the same line.\n\nYou should divide $\\mathbb{S}$ into two sets $\\mathbb{A}$ and $\\mathbb{B}$ so that:\n- $\\mathbb{A} \\cap \\mathbb{B}=\\emptyset$.\n- $\\mathbb{A} \\cup \\mathbb{B}=\\mathbb{S}$.\n- $|\\mathbb{A}| \\ge 2, |\\mathbb{B}| \\ge 2$.\n- The point set $\\mathbb{A} \\cup \\{O\\}$ is a $\\textit{strict convex set}$, and denote its convex hull as $C_{\\mathbb{A} \\cup \\{O\\}}$.\n- The point set $\\mathbb{B} \\cup \\{O\\}$ is a $\\textit{strict convex set}$, and denote its convex hull as $C_{\\mathbb{B} \\cup \\{O\\}}$.\n- The outlines(edges) of $C_{\\mathbb{A} \\cup \\{O\\}}$ and $C_{\\mathbb{B} \\cup \\{O\\}}$ only intersect at point $O$. That is, only one point $O$ satisfies that it lies both on the outlines of $C_{\\mathbb{A} \\cup \\{O\\}}$ and $C_{\\mathbb{B} \\cup \\{O\\}}$.\n\nPlease help Paimon to maximize the sum of the perimeters of these two convex hulls. That is, find a valid division $\\mathbb{A}$ and $\\mathbb{B}$ which maximizes $(L(C_{\\mathbb{A} \\cup \\{O\\}}) + L(C_{\\mathbb{B} \\cup \\{O\\}}))$, where $L(\\text{polygon})$ means the perimeter of that polygon.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $n$ ($4 \\le n \\le 5 \\times 10^5$) indicating the number of points in $\\mathbb{S}$.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$, $(x_i, y_i) \\ne (0, 0)$) indicating the location of the $i$-th point in $\\mathbb{S}$.\n\nIt's guaranteed that the points given in the same test case are pairwise different. However, there may be three points lying on the same line.\n\nIt's also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing a number indicating the maximum total perimeter. If there does not exist a valid division output `0` instead.\n\nYour answer will be accepted if the relative or absolute error is less than $10^{-6}$.", "hint": "A valid division (left) and an invalid division (right) of the first sample test case are shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v17tmtdh.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Paimon Polygon", "background": "", "description": "派蒙在平面上放置了$n+1$个互异的点，其中有一特殊点$O=(0,0)$，并记其余点为$\\mathbb{S}$。\n\n我们称一个点集 $\\mathbb{U}$ 为$\\textit{strict convex set}$，当且仅当点集中点的个数大于等于3（$|\\mathbb{U}| \\ge 3$）且$\\mathbb{U}$中的所有点位于$\\mathbb{U}$构成的凸包上，且任意三点不共线。\n\n\n你需要将$\\mathbb{S}$划分为两个集合 $\\mathbb{A}$ 和$\\mathbb{B}$，使其满足\n- $\\mathbb{A} \\cap \\mathbb{B}=\\emptyset$.\n- $\\mathbb{A} \\cup \\mathbb{B}=\\mathbb{S}$.\n- $|\\mathbb{A}| \\ge 2, |\\mathbb{B}| \\ge 2$.\n\n- 点集 $\\mathbb{A} \\cup \\{O\\}$ 是 $\\textit{strict convex set}$，并记它的凸包为$C_{\\mathbb{A} \\cup \\{O\\}}$。\n- 点集 $\\mathbb{B} \\cup \\{O\\}$是 $\\textit{strict convex set}$，并记它的凸包为 $C_{\\mathbb{B} \\cup \\{O\\}}$。\n- $C_{\\mathbb{A} \\cup \\{O\\}}$和 $C_{\\mathbb{B} \\cup \\{O\\}}$ 的轮廓 仅在 $O$相交。 这也就是说，仅有点$O$既在$C_{\\mathbb{A} \\cup \\{O\\}}$的轮廓上，又在$C_{\\mathbb{B} \\cup \\{O\\}}$的轮廓上。\n  \n请协助派蒙计算出这两个凸包周长之和的最大值。\n这也就是说，找到一个合法的划分方案$\\mathbb{A}$ 和 $\\mathbb{B}$，使得 $(L(C_{\\mathbb{A} \\cup \\{O\\}}) + L(C_{\\mathbb{B} \\cup \\{O\\}}))$最大，其中$L(\\text{polygon})$代表多边形的周长。", "inputFormat": "多组测试数据，第一行给出数据组数 $T$。\n\n第一行给出一个整数 $n$ ($4 \\le n \\le 5 \\times 10^5$) ，表示 $\\mathbb{S}$ 中点的个数。\n\n接下来$n$行，第$i$行 包含两个整数 $x_i$ 和 $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$, $(x_i, y_i) \\ne (0, 0)$) 表示 $\\mathbb{S}$ 中第 $i$个点的坐标。\n\n保证同一组测试数据中的点互异，但可能存在三点共线。\n\n保证 所有测试数据中$n$之和不超过 $10^6$.", "outputFormat": "每组测试数据单起一行输出一个整数，表示两个凸包的周长之和的最大值。如不存在合法的划分方案，输出`0`。\n与标准答案的相对或绝对误差小于 $10^{-6}$的答案会被视作正确答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9846", "type": "P", "difficulty": 6, "samples": [["2\n5\n1 7 3 5 4\n1 3\n2 3\n3 4\n4 5\n4 6\n1\n1000000000\n1 2\n", "16\n1000000000\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2021", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Paimon's Tree", "background": "", "description": "Paimon has found a tree with $(n + 1)$ initially white vertices in her left pocket and decides to play with it. A tree with $(n + 1)$ nodes is an undirected connected graph with $n$ edges.\n\nPaimon will give you an integer sequence $a_1, a_2, \\cdots, a_n$ of length $n$. We first need to select a vertex in the tree and paint it black. Then we perform the following operation $n$ times.\n\nDuring the $i$-th operation, we select a white vertex $x_i$ which is directly connected with a black vertex $y_i$ by an edge, set the weight of that edge to $a_i$ and also paint $x_i$ in black. After these $n$ operations we get a tree whose edges are all weighted.\n\nWhat's the maximum length of the diameter of the weighted tree if we select the vertices optimally? The diameter of a weighted tree is the longest simple path in that tree. The length of a simple path is the sum of the weights of all edges in that path.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 5 \\times 10^3$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 150$) indicating the length of the sequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) indicating the sequence.\n\nFor the following $n$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n + 1$) indicating that there is an edge connecting vertex $u_i$ and $v_i$ in the tree.\n\nIt's guaranteed that there is at most $10$ test cases satisfying $n > 20$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum length of the diameter of the tree.", "hint": "For the first sample test case, we select the vertices in the order of $1, 3, 4, 5, 2, 6$, resulting in the weighted tree of the following image. It's obvious that the longest simple path is of length $16$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vamukdcv.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Paimon's Tree", "background": "", "description": "Paimon has found a tree with $(n + 1)$ initially white vertices in her left pocket and decides to play with it. A tree with $(n + 1)$ nodes is an undirected connected graph with $n$ edges.\n\nPaimon will give you an integer sequence $a_1, a_2, \\cdots, a_n$ of length $n$. We first need to select a vertex in the tree and paint it black. Then we perform the following operation $n$ times.\n\nDuring the $i$-th operation, we select a white vertex $x_i$ which is directly connected with a black vertex $y_i$ by an edge, set the weight of that edge to $a_i$ and also paint $x_i$ in black. After these $n$ operations we get a tree whose edges are all weighted.\n\nWhat's the maximum length of the diameter of the weighted tree if we select the vertices optimally? The diameter of a weighted tree is the longest simple path in that tree. The length of a simple path is the sum of the weights of all edges in that path.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 5 \\times 10^3$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 150$) indicating the length of the sequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) indicating the sequence.\n\nFor the following $n$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n + 1$) indicating that there is an edge connecting vertex $u_i$ and $v_i$ in the tree.\n\nIt's guaranteed that there is at most $10$ test cases satisfying $n > 20$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum length of the diameter of the tree.", "hint": "For the first sample test case, we select the vertices in the order of $1, 3, 4, 5, 2, 6$, resulting in the weighted tree of the following image. It's obvious that the longest simple path is of length $16$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vamukdcv.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Paimon's Tree", "background": "", "description": "# Paimon's Tree\n\n## Translation\n\n\n派蒙在她的左口袋中找到了一颗有 $(n+1)$ 个白色节点的树。一颗有 $(n+1)$ 个节点的树是一个有 $n$ 条边的无向连通图。\n\n派蒙会给你一个长度为 $n$ 的整数序列 $a_1,a_2,...,a_n$ 。我们首先需要选择这棵树中的一个节点并将它涂黑。接下来进行以下操作 $n$ 次。\n\n> 在第 $i$ 次操作中，我们选择一个与一个黑色节点 $y_i$ 直连的白色节点 $x_i$ ，将这条边的权值设为 $a_i$ ，并且将节点 $x_i$ 涂黑。\n\n进行上述的 $n$ 次操作后，我们会得到一棵每条边都有权值的树。\n\n在最优的选择节点策略下，这颗树的直径最大是多少？一棵树的直径是这棵树中的最长简单路径的长度。一条简单路径的长度是这条路径中所有边的权值之和。", "inputFormat": "一次运行将会给出多个测试数据。输入的第一行包含一个整数 $T$ ，表示测试数据的组数。\n\n对于每个测试数据：\n\n> 第一行包括一个整数 $n$ ，表示序列 $a$ 的长度。\n>\n> 第二行包括 $n$ 个整数 $a_1,a_2,...,a_n$ ，表示序列 $a$ 的内容。\n>\n> 在接下来的 $n$ 行中，第 $i$ 行包括两个整数 $u_i$ 与 $v_i$ ，表示在这棵树上 $u_i$ 与 $v_i$ 有一条连边。", "outputFormat": "对于每个测试数据，输出一行，表示这棵树在最优操作下的直径长度。", "hint": "* $1\\le T\\le 5\\times 10^3$\n* $1\\le n\\le 150$\n* $1\\le a_i\\le 10^9$\n* $1\\le u_i,v_i\\le n+1$\n* 保证每个样例中最多有 $10$ 组测试数据满足 $n>20$ 。", "locale": "zh-CN"}}}
{"pid": "P9847", "type": "P", "difficulty": 5, "samples": [["2\n5\n1 10 100 1000 10000\n1 2 1 1 1\n1 2\n1 3\n2 4\n2 5\n5\n1 10 100 1000 10000\n1 3 1 1 1\n1 2\n1 3\n2 4\n2 5\n", "10101\n10111\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2021", "Special Judge", "O2优化", "树形 DP", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Crystalfly", "background": "", "description": "Paimon is catching crystalflies on a tree, which are a special kind of butterflies in Teyvat. A tree is a connected graph consisting of $n$ vertices and $(n - 1)$ undirected edges. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/awi9prsr.png)\n\nThere are initially $a_i$ crystalflies on the $i$-th vertex. When Paimon reaches a vertex, she can catch all the remaining crystalflies on the vertex immediately. However, the crystalflies are timid. When Paimon reaches a vertex, all the crystalflies on the adjacent vertices will be disturbed. For the $i$-th vertex, if the crystalflies on the vertex are disturbed for the first time at the beginning of the $t'$-th second, they will disappear at the end of the $(t' + t_{i})$-th second.\n\nAt the beginning of the $0$-th second, Paimon reaches vertex $1$ and stays there before the beginning of the $1$-st second. Then at the beginning of each following second, she can choose one of the two operations:\n- Move to one of the adjacent vertices of her current vertex and stay there before the beginning of the next second (if the crystalflies in the destination will disappear at the end of that second she can still catch them).\n- Stay still in her current vertex before the beginning of the next second.\n\nCalculate the maximum number of crystalflies Paimon can catch in $10^{10^{10^{10^{10}}}}$ seconds.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the number of vertices.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) where $a_i$ is the number of crystalflies on the $i$-th vertex.\n\nThe third line contains $n$ integers $t_1, t_2, \\cdots, t_n$ ($1 \\le t_i \\le 3$) where $t_i$ is the time before the crystalflies on the $i$-th vertex disappear after disturbed.\n\nFor the next $(n - 1)$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertices $u_i$ and $v_i$ in the tree.\n\nIt's guaranteed that the sum of $n$ of all the test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum number of crystalflies Paimon can catch.", "hint": "For the first sample test case, follow the strategy below.\n- During the $0$-th second\n  - Paimon arrives at vertex $1$;\n  - Paimon catches $1$ crystalfly;\n  - Crystalflies in vertices $2$ and $3$ are disturbed.\n- During the $1$-st second\n  - Paimon arrives at vertex $3$;\n  - Paimon catches $100$ crystalflies.\n- During the $2$-nd second\n  - Paimon arrives at vertex $1$;\n  - Crystalflies in vertex $2$ disappears.\n- During the $3$-rd second\n  - Paimon arrives at vertex $2$;\n  - Crystalflies in vertices $4$ and $5$ are disturbed.\n- During the $4$-th second\n  - Paimon arrives at vertex $5$;\n  - Paimon catches $10000$ crystalflies;\n  - Crystalflies in vertex $4$ disappears.\n\nFor the second sample test case, the optimal strategy is the same with the first sample test case. Crystalflies in vertex $2$ are scheduled to disappear at the end of the $3$-rd (instead of the $2$-nd) second, allowing Paimon to catch them.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Crystalfly", "background": "", "description": "Paimon is catching crystalflies on a tree, which are a special kind of butterflies in Teyvat. A tree is a connected graph consisting of $n$ vertices and $(n - 1)$ undirected edges. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/awi9prsr.png)\n\nThere are initially $a_i$ crystalflies on the $i$-th vertex. When Paimon reaches a vertex, she can catch all the remaining crystalflies on the vertex immediately. However, the crystalflies are timid. When Paimon reaches a vertex, all the crystalflies on the adjacent vertices will be disturbed. For the $i$-th vertex, if the crystalflies on the vertex are disturbed for the first time at the beginning of the $t'$-th second, they will disappear at the end of the $(t' + t_{i})$-th second.\n\nAt the beginning of the $0$-th second, Paimon reaches vertex $1$ and stays there before the beginning of the $1$-st second. Then at the beginning of each following second, she can choose one of the two operations:\n- Move to one of the adjacent vertices of her current vertex and stay there before the beginning of the next second (if the crystalflies in the destination will disappear at the end of that second she can still catch them).\n- Stay still in her current vertex before the beginning of the next second.\n\nCalculate the maximum number of crystalflies Paimon can catch in $10^{10^{10^{10^{10}}}}$ seconds.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the number of vertices.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) where $a_i$ is the number of crystalflies on the $i$-th vertex.\n\nThe third line contains $n$ integers $t_1, t_2, \\cdots, t_n$ ($1 \\le t_i \\le 3$) where $t_i$ is the time before the crystalflies on the $i$-th vertex disappear after disturbed.\n\nFor the next $(n - 1)$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertices $u_i$ and $v_i$ in the tree.\n\nIt's guaranteed that the sum of $n$ of all the test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum number of crystalflies Paimon can catch.", "hint": "For the first sample test case, follow the strategy below.\n- During the $0$-th second\n  - Paimon arrives at vertex $1$;\n  - Paimon catches $1$ crystalfly;\n  - Crystalflies in vertices $2$ and $3$ are disturbed.\n- During the $1$-st second\n  - Paimon arrives at vertex $3$;\n  - Paimon catches $100$ crystalflies.\n- During the $2$-nd second\n  - Paimon arrives at vertex $1$;\n  - Crystalflies in vertex $2$ disappears.\n- During the $3$-rd second\n  - Paimon arrives at vertex $2$;\n  - Crystalflies in vertices $4$ and $5$ are disturbed.\n- During the $4$-th second\n  - Paimon arrives at vertex $5$;\n  - Paimon catches $10000$ crystalflies;\n  - Crystalflies in vertex $4$ disappears.\n\nFor the second sample test case, the optimal strategy is the same with the first sample test case. Crystalflies in vertex $2$ are scheduled to disappear at the end of the $3$-rd (instead of the $2$-nd) second, allowing Paimon to catch them.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Crystalfly", "background": "", "description": "派蒙正在一棵树上抓晶蝶，这是一种提瓦特中特殊的蝴蝶。树是由 $n$ 个顶点和 $(n - 1)$ 条无向边组成的连通图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/awi9prsr.png)\n\n初始时，第 $i$ 个顶点上有 $a_i$ 只晶蝶。当派蒙到达一个顶点时，她可以立即抓住该顶点上的所有剩余晶蝶。然而，晶蝶很胆小。当派蒙到达一个顶点时，所有相邻顶点上的晶蝶都会受到惊扰。对于第 $i$ 个顶点，如果晶蝶在第 $t'$ 秒开始时首次受到惊扰，它们将在 $(t' + t_{i})$ 秒结束时消失。\n\n在第 $0$ 秒开始时，派蒙到达顶点 $1$ 并在第 $1$ 秒开始前停留在那里。然后在接下来的每一秒开始时，她可以选择以下两种操作之一：\n- 移动到当前顶点的一个相邻顶点，并在下一秒开始前停留在那里（如果目的地的晶蝶将在该秒结束时消失，她仍然可以抓住它们）。\n- 在当前顶点停留到下一秒开始前。\n\n计算派蒙在 $10^{10^{10^{10^{10}}}}$ 秒内可以抓住的最多晶蝶数量。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($1 \\le n \\le 10^5$)，表示顶点的数量。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$)，其中 $a_i$ 是第 $i$ 个顶点上的晶蝶数量。\n\n第三行包含 $n$ 个整数 $t_1, t_2, \\cdots, t_n$ ($1 \\le t_i \\le 3$)，其中 $t_i$ 是第 $i$ 个顶点上的晶蝶在受到惊扰后消失前的时间。\n\n接下来的 $(n - 1)$ 行中，第 $i$ 行包含两个整数 $u_i$ 和 $v_i$ ($1 \\le u_i, v_i \\le n$)，表示树中连接顶点 $u_i$ 和 $v_i$ 的一条边。\n\n保证所有测试用例的 $n$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示派蒙可以抓住的最多晶蝶数量。", "hint": "对于第一个样例测试用例，按照以下策略进行：\n- 在第 $0$ 秒\n  - 派蒙到达顶点 $1$；\n  - 派蒙抓住 $1$ 只晶蝶；\n  - 顶点 $2$ 和 $3$ 的晶蝶受到惊扰。\n- 在第 $1$ 秒\n  - 派蒙到达顶点 $3$；\n  - 派蒙抓住 $100$ 只晶蝶。\n- 在第 $2$ 秒\n  - 派蒙到达顶点 $1$；\n  - 顶点 $2$ 的晶蝶消失。\n- 在第 $3$ 秒\n  - 派蒙到达顶点 $2$；\n  - 顶点 $4$ 和 $5$ 的晶蝶受到惊扰。\n- 在第 $4$ 秒\n  - 派蒙到达顶点 $5$；\n  - 派蒙抓住 $10000$ 只晶蝶；\n  - 顶点 $4$ 的晶蝶消失。\n\n对于第二个样例测试用例，最佳策略与第一个样例测试用例相同。顶点 $2$ 的晶蝶计划在第 $3$ 秒结束时消失（而不是第 $2$ 秒），这使得派蒙可以抓住它们。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9848", "type": "P", "difficulty": 5, "samples": [["2\n4\n3\n1 1\n2 2\n6 2\n4\n3 1\n3 3\n5 1\n7 3\n3\n1\n4 2\n3\n1 1\n6 2\n9 1\n", "3\n3\n"]], "limits": {"time": [2000, 2000, 2000], "memory": [262144, 262144, 262144]}, "tags": ["动态规划 DP", "2021", "Special Judge", "O2优化", "动态规划优化", "前缀和", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Cloud Retainer's Game", "background": "", "description": "Cloud Retainer, the builder of the Dwelling in the clouds above Qingyun Peak, is very interested in mechanics. Although there is more than one month away from the Lantern Rite Festival in Liyue, she has already started the design of a gaming event for it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ye0zfdit.png)\n\nThe game is mainly about releasing pinballs to get a score as high as possible. It is played on the 2-dimensional plane with two horizontal straight lines $y = 0$ and $y = H$. Between the two lines, there are $n$ tiny wooden boards and $m$ coins, both can be regarded as single points. The $i$-th wooden board is located at $(x_i, y_i)$ while the $i$-th coin is located at $(x'_i, y'_i)$.\n\nA pinball is released from $(10^{-9}, 10^{-9})$ by the player. Let $\\overrightarrow{v} = (v_x, v_y)$ be the velocity of the ball (that is to say, if the ball is currently located at $(x, y)$ it will move to $(x + v_x\\epsilon, y + v_y\\epsilon)$ after $\\epsilon$ seconds). Initially $\\overrightarrow{v} = (1, 1)$.\n\nWhen the ball hits a wooden board or one of the two horizontal straight lines, $v_y$ will be negated (that is, $v_y$ becomes $-v_y$) while $v_x$ remains unchanged. If the ball hits a coin, the player's score is increased by $1$ and the velocity of the ball remains unchanged.\n\nTo gain a higher score, the player can choose to remove any number of wooden boards before the pinball is released. It is also OK not to remove any wooden board. Cloud Retainer wants you to help her estimate the difficulty by computing the maximum score the player can get after $10^{10^{10^{10^{10}}}}$ seconds under the best strategy?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $H$ ($2 \\le H \\le 10^9$).\n\nThe second line contains one integer $n$ ($1 \\le n \\le 10^5$) indicating the number of wooden boards.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($1 \\le x_i \\le 10^9$, $1 \\le y_i < H$) indicating a wooden board located at $(x_i, y_i)$.\n\nThe following line contains one integer $m$ ($1 \\le m \\le 10^5$) indicating the number of coins.\n\nFor the following $m$ lines, the $i$-th line contains two integers $x'_i$ and $y'_i$ ($1 \\le x'_i \\le 10^9$, $1 \\le y'_i < H$) indicating a coin located at $(x'_i, y'_i)$.\n\nIt's guaranteed that the given $(n + m)$ points in the same test case will be distinct. It's also guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum score the player can get after removing some (or not removing any) wooden boards.", "hint": "The two sample test cases are shown below. Solid diamonds represent the remaining wooden boards, while hollow diamonds represent the removed wooden boards and round dots represent the coins.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/st3aejoc.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oojtcbv6.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Cloud Retainer's Game", "background": "", "description": "Cloud Retainer, the builder of the Dwelling in the clouds above Qingyun Peak, is very interested in mechanics. Although there is more than one month away from the Lantern Rite Festival in Liyue, she has already started the design of a gaming event for it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ye0zfdit.png)\n\nThe game is mainly about releasing pinballs to get a score as high as possible. It is played on the 2-dimensional plane with two horizontal straight lines $y = 0$ and $y = H$. Between the two lines, there are $n$ tiny wooden boards and $m$ coins, both can be regarded as single points. The $i$-th wooden board is located at $(x_i, y_i)$ while the $i$-th coin is located at $(x'_i, y'_i)$.\n\nA pinball is released from $(10^{-9}, 10^{-9})$ by the player. Let $\\overrightarrow{v} = (v_x, v_y)$ be the velocity of the ball (that is to say, if the ball is currently located at $(x, y)$ it will move to $(x + v_x\\epsilon, y + v_y\\epsilon)$ after $\\epsilon$ seconds). Initially $\\overrightarrow{v} = (1, 1)$.\n\nWhen the ball hits a wooden board or one of the two horizontal straight lines, $v_y$ will be negated (that is, $v_y$ becomes $-v_y$) while $v_x$ remains unchanged. If the ball hits a coin, the player's score is increased by $1$ and the velocity of the ball remains unchanged.\n\nTo gain a higher score, the player can choose to remove any number of wooden boards before the pinball is released. It is also OK not to remove any wooden board. Cloud Retainer wants you to help her estimate the difficulty by computing the maximum score the player can get after $10^{10^{10^{10^{10}}}}$ seconds under the best strategy?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $H$ ($2 \\le H \\le 10^9$).\n\nThe second line contains one integer $n$ ($1 \\le n \\le 10^5$) indicating the number of wooden boards.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($1 \\le x_i \\le 10^9$, $1 \\le y_i < H$) indicating a wooden board located at $(x_i, y_i)$.\n\nThe following line contains one integer $m$ ($1 \\le m \\le 10^5$) indicating the number of coins.\n\nFor the following $m$ lines, the $i$-th line contains two integers $x'_i$ and $y'_i$ ($1 \\le x'_i \\le 10^9$, $1 \\le y'_i < H$) indicating a coin located at $(x'_i, y'_i)$.\n\nIt's guaranteed that the given $(n + m)$ points in the same test case will be distinct. It's also guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum score the player can get after removing some (or not removing any) wooden boards.", "hint": "The two sample test cases are shown below. Solid diamonds represent the remaining wooden boards, while hollow diamonds represent the removed wooden boards and round dots represent the coins.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/st3aejoc.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oojtcbv6.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Cloud Retainer's Game", "background": null, "description": "云堇，青云峰上云中居的建造者，对机械非常感兴趣。虽然距离璃月的海灯节还有一个多月的时间，她已经开始为其设计一个游戏活动。\n\n游戏主要是关于释放弹珠以获得尽可能高的分数。它在二维平面上进行，平面上有两条水平直线 $y = 0$ 和 $y = H$。在这两条直线之间，有 $n$ 块小木板和 $m$ 个硬币，两者都可以视为单个点。第 $i$ 块木板位于 $(x_i, y_i)$，而第 $i$ 个硬币位于 $(x'_i, y'_i)$。\n\n玩家从 $(10^{-9}, 10^{-9})$ 处释放一个弹珠。设 $\\overrightarrow{v} = (v_x, v_y)$ 为弹珠的速度（也就是说，如果弹珠当前位于 $(x, y)$，则在 $\\epsilon$ 秒后它将移动到 $(x + v_x\\epsilon, y + v_y\\epsilon)$）。初始时 $\\overrightarrow{v} = (1, 1)$。\n\n当弹珠撞到木板或两条水平直线之一时，$v_y$ 将被取反（即 $v_y$ 变为 $-v_y$），而 $v_x$ 保持不变。如果弹珠撞到硬币，玩家的分数增加 $1$，弹珠的速度保持不变。\n\n为了获得更高的分数，玩家可以选择在释放弹珠之前移除任意数量的木板。也可以不移除任何木板。云堇希望你帮助她通过计算在最佳策略下经过 $10^{10^{10^{10^{10}}}}$ 秒后玩家可以获得的最高分数来估计游戏的难度。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $H$ ($2 \\le H \\le 10^9$)。\n\n第二行包含一个整数 $n$ ($1 \\le n \\le 10^5$)，表示木板的数量。\n\n接下来的 $n$ 行中，第 $i$ 行包含两个整数 $x_i$ 和 $y_i$ ($1 \\le x_i \\le 10^9$, $1 \\le y_i < H$)，表示位于 $(x_i, y_i)$ 的木板。\n\n接下来的一行包含一个整数 $m$ ($1 \\le m \\le 10^5$)，表示硬币的数量。\n\n接下来的 $m$ 行中，第 $i$ 行包含两个整数 $x'_i$ 和 $y'_i$ ($1 \\le x'_i \\le 10^9$, $1 \\le y'_i < H$)，表示位于 $(x'_i, y'_i)$ 的硬币。\n\n保证同一测试用例中给出的 $(n + m)$ 个点是不同的。也保证所有测试用例中 $n$ 的总和和 $m$ 的总和都不会超过 $5 \\times 10^5$。", "outputFormat": "对于每个测试用例输出一行，包含一个整数，表示在移除一些（或不移除任何）木板后玩家可以获得的最高分数。", "hint": "下面显示了两个示例测试用例。实心菱形表示剩余的木板，空心菱形表示被移除的木板，圆点表示硬币。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9849", "type": "P", "difficulty": 5, "samples": [["5\n4 7\n9 8\n32 84\n11 35\n2 1\n", "2\n7\n5\n4\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "递推", "2021", "Special Judge", "O2优化", "最大公约数 gcd", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Xingqiu's Joke", "background": "", "description": "Once again, Xingqiu hides Chongyun's ice cream into a box with a strange lock. Liyue's summer has been always very hot and Chongyun suffers more because of his excessive yang (positive) energy, so he needs that ice cream desperately.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2dtcr426.png)\n\nThere are two integers $a$ and $b$ on the lock. Chongyun can perform the following three types of operations any number of times:\n- Minus $1$ from both $a$ and $b$;\n- Plus $1$ to both $a$ and $b$;\n- Divide both $a$ and $b$ by one of their common $\\textbf{prime}$ factor (that is to say, divide them by a $\\textbf{prime}$ $g$ where $a$ and $b$ are both divisible by $g$).\n\nThe box will be unlocked if either $a$ or $b$ or both become $1$. To help Chongyun gets the ice cream back as quickly as possible, please tell him the minimum number of operations needed to unlock the box.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 300$) indicating the number of test cases. For each test case:\n\nThe first and only line contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$, $a \\ne b$).", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of operations to make $a$ or $b$ or both equal $1$.", "hint": "For the first sample test case, the optimal way is $(4, 7) \\rightarrow (3, 6) \\rightarrow (1, 2)$.\n\nFor the second sample test case, the optimal way is to apply the first type of operation $7$ times.\n\nFor the third sample test case, the optimal way is $(32, 84) \\rightarrow (16, 42) \\rightarrow (15, 41) \\rightarrow (14, 40) \\rightarrow (13, 39) \\rightarrow (1, 3)$.\n\nFor the fourth sample test case, the optimal way is $(11, 35) \\rightarrow (12, 36) \\rightarrow (6, 18) \\rightarrow (2, 6) \\rightarrow (1, 3)$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Xingqiu's Joke", "background": "", "description": "Once again, Xingqiu hides Chongyun's ice cream into a box with a strange lock. Liyue's summer has been always very hot and Chongyun suffers more because of his excessive yang (positive) energy, so he needs that ice cream desperately.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2dtcr426.png)\n\nThere are two integers $a$ and $b$ on the lock. Chongyun can perform the following three types of operations any number of times:\n- Minus $1$ from both $a$ and $b$;\n- Plus $1$ to both $a$ and $b$;\n- Divide both $a$ and $b$ by one of their common $\\textbf{prime}$ factor (that is to say, divide them by a $\\textbf{prime}$ $g$ where $a$ and $b$ are both divisible by $g$).\n\nThe box will be unlocked if either $a$ or $b$ or both become $1$. To help Chongyun gets the ice cream back as quickly as possible, please tell him the minimum number of operations needed to unlock the box.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 300$) indicating the number of test cases. For each test case:\n\nThe first and only line contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$, $a \\ne b$).", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of operations to make $a$ or $b$ or both equal $1$.", "hint": "For the first sample test case, the optimal way is $(4, 7) \\rightarrow (3, 6) \\rightarrow (1, 2)$.\n\nFor the second sample test case, the optimal way is to apply the first type of operation $7$ times.\n\nFor the third sample test case, the optimal way is $(32, 84) \\rightarrow (16, 42) \\rightarrow (15, 41) \\rightarrow (14, 40) \\rightarrow (13, 39) \\rightarrow (1, 3)$.\n\nFor the fourth sample test case, the optimal way is $(11, 35) \\rightarrow (12, 36) \\rightarrow (6, 18) \\rightarrow (2, 6) \\rightarrow (1, 3)$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Xingqiu's Joke", "background": "![image](https://cdn.luogu.com.cn/upload/image_hosting/2dtcr426.png)", "description": "有 $T$ 个盒子，每盒子上有一个锁，锁上有两个整数 $a$ 和 $b$。你可以对这个锁做若干次以下 3 种操作：\n\n- $a$ 和 $b$ 分别减去 $1$\n- $a$ 和 $b$ 分别增加 $1$\n- $a$ 和 $b$ 分别除以它们共同的素数因子\n\n如果 $a$ 或 $b$ 或两者都变为 $1$，盒子就会解锁。请你编写一个程序，计算每个盒子的锁打开的最少步骤数量。", "inputFormat": "第一行输入一个整数 $T(1≤T≤300)$。\n\n接下来 $T$ 行，每行输入 $a$ 和 $b$（$1\\le a,b\\le 10^9$ 且 $a\\neq b$），表示每个盒子的锁的信息。", "outputFormat": "共输出 $T$ 行，每行输出对应盒子解锁的最少步骤。", "hint": "对于第一个样例，最优解之一为 $(4, 7) \\rightarrow (3, 6) \\rightarrow (1, 2)$。\n\n对于第二个样例，最优解之一是执行第一类操作 $7$ 次。\n\n对于第三个样例，最优解之一是 $(32, 84) \\rightarrow (16, 42) \\rightarrow (15, 41) \\rightarrow (14, 40) \\rightarrow (13, 39) \\rightarrow (1, 3)$。\n\n对于第四个样例，最优解之一是 $(11, 35) \\rightarrow (12, 36) \\rightarrow (6, 18) \\rightarrow (2, 6) \\rightarrow (1, 3)$。", "locale": "zh-CN"}}}
{"pid": "P9850", "type": "P", "difficulty": 7, "samples": [["7 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n", "3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2021", "Special Judge", "O2优化", "容斥原理", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Ancient Magic Circle in Teyvat", "background": "", "description": "Astrologist Mona Megistus discovers an ancient magic circle in Teyvat recently.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gohzab6t.png)\n\nThe magic circle looks like a complete graph with $n$ vertices, where $m$ edges are colored red and other edges are colored blue. Note that a complete graph is a simple undirected graph in which every pair of distinct vertices is connected by a unique edge.\n\nMona realizes that if she chooses four different vertices such that the six edges between these four vertices are of the same color, she will get a *key* from the magic circle. If the color is red, she will get a *red key*, and if the color is blue, she will get a *blue key*.\n\nBase on the information written in the ancient books Mona has read, the magic power of the ancient magic circle is the absolute difference between the number of *red keys* and the number of the number of *blue keys* she can get from the magic circle.\n\nMona needs your help badly, since calculating the magic power of the magic circle is really a tough job.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains two integers $n$ and $m$ ($4 \\le n \\le 10^5$, $0 \\le m \\le \\min(\\frac{n(n-1)}{2}, 2 \\times 10^5)$) indicating the number of vertices and the number of edges colored red of the ancient magic circle.\n\nFor the following $m$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($u_i < v_i$) indicating a red edge connecting vertices $u_i$ and $v_i$. It is guaranteed that each edge appears at most once.", "outputFormat": "Output one line containing one integer indicating the magic power of the ancient magic circle.", "hint": "For the sample case, there is only one *red key* $(1,2,3,4)$ and there are four *blue keys* $(1,5,6,7)$, $(2,5,6,7)$, $(3,5,6,7)$ and $(4,5,6,7)$ in the ancient magic circle, thus the magic power of the magic circle is $|1-4|=3$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Ancient Magic Circle in Teyvat", "background": "", "description": "Astrologist Mona Megistus discovers an ancient magic circle in Teyvat recently.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gohzab6t.png)\n\nThe magic circle looks like a complete graph with $n$ vertices, where $m$ edges are colored red and other edges are colored blue. Note that a complete graph is a simple undirected graph in which every pair of distinct vertices is connected by a unique edge.\n\nMona realizes that if she chooses four different vertices such that the six edges between these four vertices are of the same color, she will get a *key* from the magic circle. If the color is red, she will get a *red key*, and if the color is blue, she will get a *blue key*.\n\nBase on the information written in the ancient books Mona has read, the magic power of the ancient magic circle is the absolute difference between the number of *red keys* and the number of the number of *blue keys* she can get from the magic circle.\n\nMona needs your help badly, since calculating the magic power of the magic circle is really a tough job.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains two integers $n$ and $m$ ($4 \\le n \\le 10^5$, $0 \\le m \\le \\min(\\frac{n(n-1)}{2}, 2 \\times 10^5)$) indicating the number of vertices and the number of edges colored red of the ancient magic circle.\n\nFor the following $m$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($u_i < v_i$) indicating a red edge connecting vertices $u_i$ and $v_i$. It is guaranteed that each edge appears at most once.", "outputFormat": "Output one line containing one integer indicating the magic power of the ancient magic circle.", "hint": "For the sample case, there is only one *red key* $(1,2,3,4)$ and there are four *blue keys* $(1,5,6,7)$, $(2,5,6,7)$, $(3,5,6,7)$ and $(4,5,6,7)$ in the ancient magic circle, thus the magic power of the magic circle is $|1-4|=3$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Ancient Magic Circle in Teyvat", "background": "", "description": "占星师 Mona Megistus 最近在 Teyvat 发现了一个古老的魔法阵。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gohzab6t.png)\n\n这个魔法阵看起来像一个有 $n$ 个顶点的完全图，其中 $m$ 条边被染成红色，其他边被染成蓝色。注意，完全图是一个简单的无向图，其中每一对不同的顶点之间都由一条唯一的边连接。\n\nMona 意识到，如果她选择四个不同的顶点，使得这四个顶点之间的六条边颜色相同，她将从魔法阵中获得一个“钥匙”。如果颜色是红色，她将获得一个“红色钥匙”；如果颜色是蓝色，她将获得一个“蓝色钥匙”。\n\n根据 Mona 阅读的古书中写的信息，古老魔法阵的魔力是她可以从魔法阵中获得的“红色钥匙”和“蓝色钥匙”数量的绝对差。\n\nMona 非常需要你的帮助，因为计算魔法阵的魔力实在是一项艰巨的工作。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含两个整数 $n$ 和 $m$ ($4 \\le n \\le 10^5$, $0 \\le m \\le \\min(\\frac{n(n-1)}{2}, 2 \\times 10^5)$)，表示古老魔法阵的顶点数和红色边的数量。\n\n接下来的 $m$ 行中，第 $i$ 行包含两个整数 $u_i$ 和 $v_i$ ($u_i < v_i$)，表示连接顶点 $u_i$ 和 $v_i$ 的红色边。保证每条边最多出现一次。", "outputFormat": "输出一行，包含一个整数，表示古老魔法阵的魔力。", "hint": "对于示例情况，古老魔法阵中只有一个“红色钥匙” $(1,2,3,4)$，而有四个“蓝色钥匙” $(1,5,6,7)$、$(2,5,6,7)$、$(3,5,6,7)$ 和 $(4,5,6,7)$，因此魔法阵的魔力是 $|1-4|=3$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9851", "type": "P", "difficulty": 6, "samples": [["2\n5\n00000\n3\n001\n", "7\n2 5 1 2 3 4 2\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "Special Judge", "O2优化", "构造", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Secret of Tianqiu Valley", "background": "", "description": "In the north tower of Tianqiu Valley's ruins, there are some flame torch puzzles and Lumine the traveler is facing the last and the hardest one.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sihi5us5.png)\n\nThere are $n$ torches in a circle and some torches have been ignited initially. The $i$-th and the $(i \\bmod n +1)$-th are adjacent for all $1 \\le i \\le n$.\n\nTo solve the puzzle, all the torches should be ignited. In each move, Lumine can ignite an extinguished torch, and the status of the adjacent torches will be reversed affected by the supernatural. That is, each of the adjacent torches will be ignited if it is currently extinguished, or be extinguished if it is currently ignited.\n\nTime is money, Lumine wants to solve the puzzle in $2n$ moves or determine that the puzzle is unsolvable.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line of the input contains an integer $n$ ($3 \\le n \\le 10^5$) indicating the number of torches in the circle.\n\nThe second line contains a binary string $s_1s_2\\cdots s_n$ of length $n$ ($s_i \\in \\{\\text{`0'}, \\text{`1'}\\}$). If $s_i = \\text{`0'}$ the $i$-th torch is extinguished initially; If $s_i = \\text{`1'}$ the $i$-th torch is ignited initially. It is guaranteed that not all the torches have been ignited initially.\n\nIt is also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "If the puzzle is unsolvable, output `0`.\n\nOtherwise, output an integer $k$ $(1 \\le k \\le 2n)$ in the first line indicating the number of moves Lumine needs to solve the puzzle. Then output a line containing $k$ integers $t_1, t_2, \\cdots, t_k$ separated by a space, where $t_i$ indicating that Lumine will ignite the $t_i$-th torch in the $i$-th move. If there are multiple answers print any of them.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "For the first sample test case, the status of the torch will change like this: $00000$ $\\to$ $11100$ $\\to$ $01111$ $\\to$ $10110$ $\\to$ $01010$ $\\to$ $00100$ $\\to$ $00011$ $\\to$ $11111$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Secret of Tianqiu Valley", "background": "", "description": "In the north tower of Tianqiu Valley's ruins, there are some flame torch puzzles and Lumine the traveler is facing the last and the hardest one.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sihi5us5.png)\n\nThere are $n$ torches in a circle and some torches have been ignited initially. The $i$-th and the $(i \\bmod n +1)$-th are adjacent for all $1 \\le i \\le n$.\n\nTo solve the puzzle, all the torches should be ignited. In each move, Lumine can ignite an extinguished torch, and the status of the adjacent torches will be reversed affected by the supernatural. That is, each of the adjacent torches will be ignited if it is currently extinguished, or be extinguished if it is currently ignited.\n\nTime is money, Lumine wants to solve the puzzle in $2n$ moves or determine that the puzzle is unsolvable.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line of the input contains an integer $n$ ($3 \\le n \\le 10^5$) indicating the number of torches in the circle.\n\nThe second line contains a binary string $s_1s_2\\cdots s_n$ of length $n$ ($s_i \\in \\{\\text{`0'}, \\text{`1'}\\}$). If $s_i = \\text{`0'}$ the $i$-th torch is extinguished initially; If $s_i = \\text{`1'}$ the $i$-th torch is ignited initially. It is guaranteed that not all the torches have been ignited initially.\n\nIt is also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "If the puzzle is unsolvable, output `0`.\n\nOtherwise, output an integer $k$ $(1 \\le k \\le 2n)$ in the first line indicating the number of moves Lumine needs to solve the puzzle. Then output a line containing $k$ integers $t_1, t_2, \\cdots, t_k$ separated by a space, where $t_i$ indicating that Lumine will ignite the $t_i$-th torch in the $i$-th move. If there are multiple answers print any of them.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "For the first sample test case, the status of the torch will change like this: $00000$ $\\to$ $11100$ $\\to$ $01111$ $\\to$ $10110$ $\\to$ $01010$ $\\to$ $00100$ $\\to$ $00011$ $\\to$ $11111$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Secret of Tianqiu Valley", "background": "", "description": "在天穹谷遗迹的北塔中，有一些火炬谜题，旅行者荧正面临最后一个也是最难的一个。\n\n在一个圆圈中有 $n$ 个火炬，初始时有些火炬已经被点燃。对于所有 $1 \\le i \\le n$，第 $i$ 个和第 $(i \\bmod n +1)$ 个火炬是相邻的。\n\n为了破解这个谜题，所有的火炬都应该被点燃。在每一步中，荧可以点燃一个熄灭的火炬，并且受超自然力量影响，相邻火炬的状态将被反转。也就是说，如果相邻火炬当前是熄灭的，它将被点燃；如果当前是点燃的，它将被熄灭。\n\n时间就是金钱，荧希望在 $2n$ 步内解决这个谜题，或者确定这个谜题是无法解决的。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n输入的第一行包含一个整数 $n$ ($3 \\le n \\le 10^5$)，表示圆圈中火炬的数量。\n\n第二行包含一个长度为 $n$ 的二进制字符串 $s_1s_2\\cdots s_n$ ($s_i \\in \\{\\text{`0'}, \\text{`1'}\\}$)。如果 $s_i = \\text{`0'}$，则第 $i$ 个火炬初始时是熄灭的；如果 $s_i = \\text{`1'}$，则第 $i$ 个火炬初始时是点燃的。保证初始时并非所有火炬都被点燃。\n\n还保证所有测试用例的 $n$ 之和不超过 $10^6$。", "outputFormat": "如果谜题无法解决，输出 `0`。\n\n否则，第一行输出一个整数 $k$ $(1 \\le k \\le 2n)$，表示荧需要的移动次数。然后输出一行包含 $k$ 个用空格分隔的整数 $t_1, t_2, \\cdots, t_k$，其中 $t_i$ 表示荧将在第 $i$ 次移动中点燃第 $t_i$ 个火炬。如果有多个答案，输出任意一个。\n\n请不要在每行的末尾输出多余的空格，否则您的解决方案可能被认为不正确！", "hint": "对于第一个样例测试用例，火炬的状态将如下变化：$00000$ $\\to$ $11100$ $\\to$ $01111$ $\\to$ $10110$ $\\to$ $01010$ $\\to$ $00100$ $\\to$ $00011$ $\\to$ $11111$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9852", "type": "P", "difficulty": 3, "samples": [["5\n4\n1 -3 2 -4\n11\n91 66 73 71 32 83 72 79 84 33 93\n12\n91 66 73 71 32 83 72 79 84 33 33 93\n13\n91 66 73 71 32 83 72 79 84 33 33 33 93\n1\n0\n", "10\n713\n746\n779\n0\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Windblume Festival", "background": "", "description": "The Windblume Festival in Mondstadt is coming! People are preparing windblumes for Barbatos and for those they love and adore. The Windblume Festival is also an opportunity to improve the relationships people have.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nbhhi3bg.png)\n\nDuring the festival, a famous game will be played every year, invented by Jean, the Acting Grand Master of the Knights of Favonius. In the game, $n$ players numbered from $1$ to $n$ stand in a circle, each holding an integer with them. Each turn, one player will be removed. The game will end when there is only one player left.\n\nFor each turn, let $k$ be the number of players remaining and $a_i$ be the integer player $i$ holds. Two adjacent players, $x$ and $(x \\bmod k + 1)$ are selected and player $(x \\bmod k + 1)$ is removed from the game. Player $x$'s integer will then change from $a_x$ to $(a_x - a_{x \\bmod k + 1})$. Player $y$ in this turn will become player $(y - 1)$ in the next turn for all $x < y \\le k$, though the integer they hold will not change.\n\nJean wants to know the maximum possible integer held by the last remaining player in the game by selecting the players in each round optimally.", "inputFormat": "There are multiple test cases. The first line of the input contains one integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $n$ ($1 \\le n \\le 10^6$) indicating the initial number of players.\n\nThe next line contains $n$ integers $a_i$ ($-10^9 \\le a_i \\le 10^9$) where $a_i$ is the integer held by player $i$ at the beginning.\n\nIt is guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible integer.", "hint": "For the first sample test case follow the strategy shown below, where the underlined integers are the integers held by the players selected in each turn.\n\n$\\{\\underline{1}, -3, 2, \\underline{-4}\\}$ (select $x = 4$) $\\to$ $\\{-3, \\underline{2, -5}\\}$ (select $x = 2$) $\\to$ $\\{\\underline{-3, 7}\\}$ (select $x = 2$) $\\to$ $\\{10\\}$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Windblume Festival", "background": "", "description": "The Windblume Festival in Mondstadt is coming! People are preparing windblumes for Barbatos and for those they love and adore. The Windblume Festival is also an opportunity to improve the relationships people have.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nbhhi3bg.png)\n\nDuring the festival, a famous game will be played every year, invented by Jean, the Acting Grand Master of the Knights of Favonius. In the game, $n$ players numbered from $1$ to $n$ stand in a circle, each holding an integer with them. Each turn, one player will be removed. The game will end when there is only one player left.\n\nFor each turn, let $k$ be the number of players remaining and $a_i$ be the integer player $i$ holds. Two adjacent players, $x$ and $(x \\bmod k + 1)$ are selected and player $(x \\bmod k + 1)$ is removed from the game. Player $x$'s integer will then change from $a_x$ to $(a_x - a_{x \\bmod k + 1})$. Player $y$ in this turn will become player $(y - 1)$ in the next turn for all $x < y \\le k$, though the integer they hold will not change.\n\nJean wants to know the maximum possible integer held by the last remaining player in the game by selecting the players in each round optimally.", "inputFormat": "There are multiple test cases. The first line of the input contains one integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $n$ ($1 \\le n \\le 10^6$) indicating the initial number of players.\n\nThe next line contains $n$ integers $a_i$ ($-10^9 \\le a_i \\le 10^9$) where $a_i$ is the integer held by player $i$ at the beginning.\n\nIt is guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible integer.", "hint": "For the first sample test case follow the strategy shown below, where the underlined integers are the integers held by the players selected in each turn.\n\n$\\{\\underline{1}, -3, 2, \\underline{-4}\\}$ (select $x = 4$) $\\to$ $\\{-3, \\underline{2, -5}\\}$ (select $x = 2$) $\\to$ $\\{\\underline{-3, 7}\\}$ (select $x = 2$) $\\to$ $\\{10\\}$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Windblume Festival", "background": "", "description": "蒙德城的风花节即将到来！人们正在为巴巴托斯和他们所爱的人准备风花。风花节也是一个改善人际关系的机会。\n\n在节日期间，每年都会玩一个由代理团长琴发明的著名游戏。在游戏中，编号从 $1$ 到 $n$ 的 $n$ 个玩家围成一个圈，每人手中持有一个整数。每一轮，将有一名玩家被移除。游戏将在只剩下一名玩家时结束。\n\n在每一轮中，设 $k$ 为剩余玩家的数量，$a_i$ 为玩家 $i$ 手中的整数。选择两个相邻的玩家 $x$ 和 $(x \\bmod k + 1)$，并将玩家 $(x \\bmod k + 1)$ 移出游戏。然后玩家 $x$ 的整数将从 $a_x$ 变为 $(a_x - a_{x \\bmod k + 1})$。在本轮中，玩家 $y$ 在下一轮中将成为玩家 $(y - 1)$，对于所有 $x < y \\le k$，尽管他们手中的整数不会改变。\n\n琴想知道通过在每轮中最优地选择玩家，最后剩下的玩家手中可能持有的最大整数。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($1 \\le n \\le 10^6$)，表示初始的玩家数量。\n\n下一行包含 $n$ 个整数 $a_i$ ($-10^9 \\le a_i \\le 10^9$)，其中 $a_i$ 是玩家 $i$ 在开始时持有的整数。\n\n保证所有测试用例中 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示可能的最大整数。", "hint": "对于第一个样例测试用例，遵循如下策略，其中下划线的整数是每轮中被选中的玩家持有的整数。\n\n$\\{\\underline{1}, -3, 2, \\underline{-4}\\}$（选择 $x = 4$）$\\to$ $\\{-3, \\underline{2, -5}\\}$（选择 $x = 2$）$\\to$ $\\{\\underline{-3, 7}\\}$（选择 $x = 2$）$\\to$ $\\{10\\}$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9853", "type": "P", "difficulty": 2, "samples": [["3 4\n2x+4=10\n-3x+13=10\n4x-8=16\n1 6\n1 8\n3 6\n4 5", "3\n3\n2\n0"], ["5 3\n5x-2=13\n8x+5=45\n4x-12=8\n-2x+10=4\n3x-7=2\n1 3\n1 5\n3 5", "1\n2\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "二分", "2023", "O2优化", "语言月赛"], "title": "[入门赛 #17] 方程求解", "background": "", "description": "小 A 有 $n$ 个关于 $x$ 的方程，第 $i$ 个方程形如 $a_ix_i+b_i=c_i$。方程的解 $x$ 均为正整数，例如下面几个方程都是符合要求的方程：\n\n```\n2x+4=10\n-3x+13=10\n4x-8=16\n```\n\n其中，第一组方程的解为 $x_1=3$，第二组方程的解为 $x_2=1$，第三组方程的解为 $x_3=6$。\n\n小 A 想要知道，给定 $L,R$，在 $L\\leq x\\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。为了防止你欺骗他，他会询问你 $Q$ 次。", "inputFormat": "第一行输入两个正整数 $n,Q$，分别表示小 A 有的方程数，以及小 A 想要向你询问的次数。\n\n第二行开始，往下 $n$ 行，每行一个字符串，描述一个方程。\n\n第 $(n+2)$ 行开始，往下 $Q$ 行，每行两个正整数 $L,R$，表示一次询问，即给定 $L,R$，询问在 $L\\leq x\\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。", "outputFormat": "对于每次询问，输出一行一个整数，表示有多少个在 $L\\leq x\\leq R$ 的范围内的正整数 $x$，满足 $x$ 是其中至少一个方程的解。", "hint": "**【样例解释】**\n\n对于第一组样例，即为题目中的举例。三组方程的解分别为 $x_1=3,x_2=1,x_3=6$。则：\n\n- 对于 $1\\leq x\\leq 6$ 的范围，有 $3$ 个 $x$ 的取值（$x=1,3,6$）是其中至少一个方程的解；\n- 对于 $1\\leq x\\leq 8$ 的范围，同上所述；\n- 对于 $3\\leq x\\leq 6$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,6$）是其中至少一个方程的解；\n- 对于 $4\\leq x\\leq 5$ 的范围，不存在一个 $x$ 是其中至少一个方程的解；\n- 因此分别输出 $3,3,2,0$。\n\n对于第二组样例，五组方程的解分别为 $x_1=3,x_2=5,x_3=5,x_4=3,x_5=3$。则：\n\n- 对于 $1\\leq x\\leq 3$ 的范围，只有 $x=3$ 满足是其中至少一个方程的解；\n- 对于 $1\\leq x\\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；\n- 对于 $3\\leq x\\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；\n- 因此分别输出 $1,2,2$。\n\n**【数据范围】**\n\n数据保证，$1\\leq n,Q\\leq 2\\times 10^5$，方程中 $a_i,b_i,c_i$ 满足 $1 \\leq |a_i|,|b_i|,|c_i| \\leq 10^9$，每一组方程的解 $x_i$ 必定为正整数。询问时的 $L,R$ 满足 $1\\leq L\\leq R\\leq 2\\times 10^9$。\n\n本题输入数据较大，请注意代码输入输出的运行效率。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #17] 方程求解", "background": "", "description": "小 A 有 $n$ 个关于 $x$ 的方程，第 $i$ 个方程形如 $a_ix_i+b_i=c_i$。方程的解 $x$ 均为正整数，例如下面几个方程都是符合要求的方程：\n\n```\n2x+4=10\n-3x+13=10\n4x-8=16\n```\n\n其中，第一组方程的解为 $x_1=3$，第二组方程的解为 $x_2=1$，第三组方程的解为 $x_3=6$。\n\n小 A 想要知道，给定 $L,R$，在 $L\\leq x\\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。为了防止你欺骗他，他会询问你 $Q$ 次。", "inputFormat": "第一行输入两个正整数 $n,Q$，分别表示小 A 有的方程数，以及小 A 想要向你询问的次数。\n\n第二行开始，往下 $n$ 行，每行一个字符串，描述一个方程。\n\n第 $(n+2)$ 行开始，往下 $Q$ 行，每行两个正整数 $L,R$，表示一次询问，即给定 $L,R$，询问在 $L\\leq x\\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。", "outputFormat": "对于每次询问，输出一行一个整数，表示有多少个在 $L\\leq x\\leq R$ 的范围内的正整数 $x$，满足 $x$ 是其中至少一个方程的解。", "hint": "**【样例解释】**\n\n对于第一组样例，即为题目中的举例。三组方程的解分别为 $x_1=3,x_2=1,x_3=6$。则：\n\n- 对于 $1\\leq x\\leq 6$ 的范围，有 $3$ 个 $x$ 的取值（$x=1,3,6$）是其中至少一个方程的解；\n- 对于 $1\\leq x\\leq 8$ 的范围，同上所述；\n- 对于 $3\\leq x\\leq 6$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,6$）是其中至少一个方程的解；\n- 对于 $4\\leq x\\leq 5$ 的范围，不存在一个 $x$ 是其中至少一个方程的解；\n- 因此分别输出 $3,3,2,0$。\n\n对于第二组样例，五组方程的解分别为 $x_1=3,x_2=5,x_3=5,x_4=3,x_5=3$。则：\n\n- 对于 $1\\leq x\\leq 3$ 的范围，只有 $x=3$ 满足是其中至少一个方程的解；\n- 对于 $1\\leq x\\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；\n- 对于 $3\\leq x\\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；\n- 因此分别输出 $1,2,2$。\n\n**【数据范围】**\n\n数据保证，$1\\leq n,Q\\leq 2\\times 10^5$，方程中 $a_i,b_i,c_i$ 满足 $1 \\leq |a_i|,|b_i|,|c_i| \\leq 10^9$，每一组方程的解 $x_i$ 必定为正整数。询问时的 $L,R$ 满足 $1\\leq L\\leq R\\leq 2\\times 10^9$。\n\n本题输入数据较大，请注意代码输入输出的运行效率。", "locale": "zh-CN"}}}
{"pid": "P9854", "type": "P", "difficulty": 1, "samples": [["69\n1.73", "Normal weight"], ["84.5\n1.8", "Overweight"]], "limits": {"time": [1000, 1000, 1000], "memory": [131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 J1] Body Mass Index", "background": "", "description": "The Body Mass Index (BMI) is one of the calculations used by doctors to assess an adult’s health. The doctor measures the patient’s height (in metres) and weight (in kilograms), then calculates the BMI using the formula:\n\n$$\\text{BMI} = \\dfrac{\\text{weight}}{\\text{height} \\times \\text{height}}$$\n\nWrite a program which prompts for the patient’s height and weight, calculates the BMI, and displays the corresponding message from the table below.\n\n| BMI Category | Message |\n| :----------: | :----------: |\n| More than $25$ | Overweight |\n| Between $18.5$ and $25.0$ (inclusive)  | Normal weight |\n| Less than $18.5$ | Underweight |", "inputFormat": "On the first line, enter your weight, and on the second line, enter your height (in meters).", "outputFormat": "Output the information corresponding to the BMI value obtained.", "hint": "**Explanation for Output in Sample Input 1**:\n\nThe BMI is $69 \\div (1.73 \\times 1.73)$, which is approximately $23.0545$. According to the table, this is a \"Normal weight\".\n\n**Explanation for Output in Sample Input 2**:\n\nThe BMI is $84.5 \\div (1.8 \\times 1.8)$, which is approximately $26.0802$. According to the table, this is \"Overweight\".", "locale": "en", "translations": {"en": {"title": "[CCC 2008 J1] Body Mass Index", "background": "", "description": "The Body Mass Index (BMI) is one of the calculations used by doctors to assess an adult’s health. The doctor measures the patient’s height (in metres) and weight (in kilograms), then calculates the BMI using the formula:\n\n$$\\text{BMI} = \\dfrac{\\text{weight}}{\\text{height} \\times \\text{height}}$$\n\nWrite a program which prompts for the patient’s height and weight, calculates the BMI, and displays the corresponding message from the table below.\n\n| BMI Category | Message |\n| :----------: | :----------: |\n| More than $25$ | Overweight |\n| Between $18.5$ and $25.0$ (inclusive)  | Normal weight |\n| Less than $18.5$ | Underweight |", "inputFormat": "On the first line, enter your weight, and on the second line, enter your height (in meters).", "outputFormat": "Output the information corresponding to the BMI value obtained.", "hint": "**Explanation for Output in Sample Input 1**:\n\nThe BMI is $69 \\div (1.73 \\times 1.73)$, which is approximately $23.0545$. According to the table, this is a \"Normal weight\".\n\n**Explanation for Output in Sample Input 2**:\n\nThe BMI is $84.5 \\div (1.8 \\times 1.8)$, which is approximately $26.0802$. According to the table, this is \"Overweight\".", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 J1] Body Mass Index", "background": null, "description": "身体质量指数（BMI）是医生用来评估成年人健康状况的计算方法之一。医生测量患者的身高（以米为单位）和体重（以千克为单位），然后使用公式计算 BMI：\n\n$$\\text{BMI} = \\dfrac{\\text{weight}}{\\text{height} \\times \\text{height}}$$\n\n编写一个程序，提示输入患者的身高和体重，计算 BMI，并输出下表中的相应的英文信息。\n\n| BMI 分类 | 信息 |\n| :----------: | :----------: |\n| 超过 $25$ | 超重 (Overweight)|\n| 在 $18.5$ 和 $25.0$ 之间（含） | 正常体重 (Normal weight)|\n| 小于 $18.5$ | 体重过轻 (Underweight)|", "inputFormat": "第一行输入你的体重，第二行输入你的身高（以米为单位）。", "outputFormat": "输出与所获得的 BMI 值对应的信息。", "hint": "**样例输入 1 的输出解释**：\n\nBMI 为 $69 \\div (1.73 \\times 1.73)$，约为 $23.0545$。根据表格，这是“正常体重”。\n\n**样例输入 2 的输出解释**：\n\nBMI 为 $84.5 \\div (1.8 \\times 1.8)$，约为 $26.0802$。根据表格，这是“超重”。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9855", "type": "P", "difficulty": 1, "samples": [["2\n1\n3\n1\n2\n3\n4\n1", "B C D A E"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 J2] Do the Shuffle", "background": "", "description": "Those tiny music machines that play your digital music are really computers that keep track of and play music files. The CCC music player $(C^3MP)$ is currently in development and will be hitting the stores soon! In this problem, you have to simulate a $C^3MP$.\n\nThe $C^3MP$ music player will hold $5$ songs in memory, whose titles will always be `A`, `B`, `C`, `D`, `E`. The $C^3MP$ also keeps track of a playlist, which is an ordering of all the songs. The $C^3MP$ has 4 buttons that the user will press to rearrange the playlist and play the songs.\n\nInitially, the $C^3MP$ playist is `A,B,C,D,E`. The $4$ control buttons do the following:\n\n- button $1$: move the first song of the playlist to the end of the playlist. For example: `A,B,C,D,E` will change to `B,C,D,E,A`.\n\n- button $2$: move the last song of the playlist to the start of the playlist. For example, `A,B,C,D,E` will change to `E,A,B,C,D`.\n\n- button $3$: swap the first two songs of the playlist. For example, `A,B,C,D,E` will change to `B,A,C,D,E`.\n\n- button $4$: stop rearranging songs and output the playlist.", "inputFormat": "You need to write a program to simulate a CCC music player. Your program should repeatedly ask for two positive integers b and n. Here b represents the button number that the user wants to press, $1 \\leq b \\leq 4$, and n represents the number of times that the user wants to press button b. You can assume that n always satisfies $1 \\leq n \\leq 10$.", "outputFormat": "The input will always finish with the pair of inputs $(b = 4, n = 1)$ when this happens, you should print the order of songs in the current playlist and your program should end. You can assume that the user will only ever press button $4$ once.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 J2] Do the Shuffle", "background": "", "description": "Those tiny music machines that play your digital music are really computers that keep track of and play music files. The CCC music player $(C^3MP)$ is currently in development and will be hitting the stores soon! In this problem, you have to simulate a $C^3MP$.\n\nThe $C^3MP$ music player will hold $5$ songs in memory, whose titles will always be `A`, `B`, `C`, `D`, `E`. The $C^3MP$ also keeps track of a playlist, which is an ordering of all the songs. The $C^3MP$ has 4 buttons that the user will press to rearrange the playlist and play the songs.\n\nInitially, the $C^3MP$ playist is `A,B,C,D,E`. The $4$ control buttons do the following:\n\n- button $1$: move the first song of the playlist to the end of the playlist. For example: `A,B,C,D,E` will change to `B,C,D,E,A`.\n\n- button $2$: move the last song of the playlist to the start of the playlist. For example, `A,B,C,D,E` will change to `E,A,B,C,D`.\n\n- button $3$: swap the first two songs of the playlist. For example, `A,B,C,D,E` will change to `B,A,C,D,E`.\n\n- button $4$: stop rearranging songs and output the playlist.", "inputFormat": "You need to write a program to simulate a CCC music player. Your program should repeatedly ask for two positive integers b and n. Here b represents the button number that the user wants to press, $1 \\leq b \\leq 4$, and n represents the number of times that the user wants to press button b. You can assume that n always satisfies $1 \\leq n \\leq 10$.", "outputFormat": "The input will always finish with the pair of inputs $(b = 4, n = 1)$ when this happens, you should print the order of songs in the current playlist and your program should end. You can assume that the user will only ever press button $4$ once.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 J2] Do the Shuffle", "background": "", "description": "那些播放数字音乐的小型音乐设备实际上是计算机，它们负责管理和播放音乐文件。CCC 音乐播放器 $(C^3MP)$ 正在开发中，并将很快上市！在这个问题中，你需要模拟一个 $C^3MP$。\n\n$C^3MP$ 音乐播放器将会在内存中保存 5 首歌曲，其标题总是 `A`、`B`、`C`、`D`、`E`。$C^3MP$ 还会记录一个播放列表，即所有歌曲的排序。$C^3MP$ 有 4 个按钮，用户可以按下这些按钮来重新排列播放列表并播放歌曲。\n\n最初，$C^3MP$ 的播放列表是 `A,B,C,D,E`。这 4 个控制按钮的功能如下：\n\n- 按钮 $1$：将播放列表中的第一首歌移动到播放列表的末尾。例如：`A,B,C,D,E` 将变为 `B,C,D,E,A`。\n\n- 按钮 $2$：将播放列表中的最后一首歌移动到播放列表的开头。例如：`A,B,C,D,E` 将变为 `E,A,B,C,D`。\n\n- 按钮 $3$：交换播放列表中的前两首歌。例如：`A,B,C,D,E` 将变为 `B,A,C,D,E`。\n\n- 按钮 $4$：停止重新排列歌曲并输出播放列表。", "inputFormat": "你需要编写一个程序来模拟 CCC 音乐播放器。你的程序应反复询问两个正整数 b 和 n。这里 b 表示用户想按下的按钮编号，$1 \\leq b \\leq 4$，n 表示用户想按下按钮 b 的次数。你可以假设 n 总是满足 $1 \\leq n \\leq 10$。", "outputFormat": "输入总是以一对输入 $(b = 4, n = 1)$ 结束，当这种情况发生时，你应该打印当前播放列表中的歌曲顺序，并且你的程序应该结束。你可以假设用户只会按一次按钮 $4$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9856", "type": "P", "difficulty": 2, "samples": [["GPS", "15"], ["ECHO ROCK", "29"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 J3] GPS Text Entry", "background": "", "description": "For her birthday, Sandy got a Global Positioning System (GPS) unit, which is an electronic device she can use to track the local hiking trails. Along the way Sandy can mark waypoints that can be recorded on a map when she gets home. A description of each waypoint can be entered in the unit, however the device does not have a keypad. Instead it has four cursor buttons, up, down, left, and right, and a button to accept the letter. The keypad looks like the following:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cqgjhd0p.png)\n\nThe screen displays a grid of the letters and symbols that can be used to “type out” the description. Here is the layout of the grid:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/btdfon2b.png)\n\nWhen you enter the name of the waypoint, the cursor starts at the `A`. You must move the cursor to the location of the next letter or symbol and then accept that letter. The cursor can only move to squares which are adjacent horizontally or vertically (not diagonally). Once you have entered all the letters in the description, you need to move the cursor to `enter` and accept the entire phrase.\n\nYou are to write a program that will calculate the number of cursor movements it takes to “type in” a phrase. For example, to enter the word `GPS`, starting from the `A` position, you would move down $1$ to select `G`, then move right $3$ and down $1$ to select `P`, then move down 1 and left $3$ to select `S` and finally move down $1$ and right $5$ to select `enter`. This is a total of $15$ cursor movements. Note that the total number of cursor movements does not change if you choose to move down and then across or across and then down. Also note that you cannot move beyond the boundaries of the grid (e.g., you cannot move off the grid nor `wrap-around` the grid).", "inputFormat": "The input for your program will be a string of at most $40$ characters. You may assume that all characters in the string are contained in the grid", "outputFormat": "The output for your program will be an integer that is the total number of cursor movements needed\nto enter the string using the grid layout given.", "hint": "数据保证合法。", "locale": "en", "translations": {"en": {"title": "[CCC 2008 J3] GPS Text Entry", "background": "", "description": "For her birthday, Sandy got a Global Positioning System (GPS) unit, which is an electronic device she can use to track the local hiking trails. Along the way Sandy can mark waypoints that can be recorded on a map when she gets home. A description of each waypoint can be entered in the unit, however the device does not have a keypad. Instead it has four cursor buttons, up, down, left, and right, and a button to accept the letter. The keypad looks like the following:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cqgjhd0p.png)\n\nThe screen displays a grid of the letters and symbols that can be used to “type out” the description. Here is the layout of the grid:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/btdfon2b.png)\n\nWhen you enter the name of the waypoint, the cursor starts at the `A`. You must move the cursor to the location of the next letter or symbol and then accept that letter. The cursor can only move to squares which are adjacent horizontally or vertically (not diagonally). Once you have entered all the letters in the description, you need to move the cursor to `enter` and accept the entire phrase.\n\nYou are to write a program that will calculate the number of cursor movements it takes to “type in” a phrase. For example, to enter the word `GPS`, starting from the `A` position, you would move down $1$ to select `G`, then move right $3$ and down $1$ to select `P`, then move down 1 and left $3$ to select `S` and finally move down $1$ and right $5$ to select `enter`. This is a total of $15$ cursor movements. Note that the total number of cursor movements does not change if you choose to move down and then across or across and then down. Also note that you cannot move beyond the boundaries of the grid (e.g., you cannot move off the grid nor `wrap-around` the grid).", "inputFormat": "The input for your program will be a string of at most $40$ characters. You may assume that all characters in the string are contained in the grid", "outputFormat": "The output for your program will be an integer that is the total number of cursor movements needed\nto enter the string using the grid layout given.", "hint": "数据保证合法。", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 J3] GPS Text Entry", "background": "", "description": "在生日时，Sandy 收到了一个全球定位系统（GPS）设备，这是一种电子设备，她可以用来追踪本地的徒步旅行路线。途中，Sandy 可以标记航点，并在回家后将其记录在地图上。每个航点的描述可以输入到设备中，但设备没有键盘。相反，它有四个光标按钮：上、下、左、右，以及一个接受字母的按钮。键盘看起来如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cqgjhd0p.png)\n\n屏幕显示了可以用来“输入”描述的字母和符号的网格。网格布局如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/btdfon2b.png)\n\n当你输入航点的名称时，光标从 `A` 开始。你必须将光标移动到下一个字母或符号的位置，然后接受该字母。光标只能水平或垂直移动到相邻的方格（不能对角线移动）。一旦你输入了描述中的所有字母，你需要将光标移动到 `enter` 并接受整个短语。\n\n你需要编写一个程序来计算输入一个短语所需的光标移动次数。例如，要输入单词 `GPS`，从 `A` 位置开始，你需要向下移动 $1$ 次选择 `G`，然后向右移动 $3$ 次并向下移动 $1$ 次选择 `P`，然后向下移动 $1$ 次并向左移动 $3$ 次选择 `S`，最后向下移动 $1$ 次并向右移动 $5$ 次选择 `enter`。这总共需要 $15$ 次光标移动。注意，总的光标移动次数不会因为你选择先向下再向右或先向右再向下而改变。还要注意，你不能超出网格的边界（例如，你不能移出网格或“环绕”网格）。", "inputFormat": "你的程序的输入将是一个最多 $40$ 个字符的字符串。你可以假设字符串中的所有字符都包含在网格中。", "outputFormat": "你的程序的输出将是一个整数，即使用给定网格布局输入字符串所需的光标移动总数。", "hint": "数据保证合法。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9857", "type": "P", "difficulty": 2, "samples": [["1\n+ 1 2\n- 2 2\n+ 2 - 2 1\n- - 3 + 2 1 9\n0", "1\n1 2 +\n2 2 -\n2 2 1 - +\n3 2 1 + - 9 -"]], "limits": {"time": [1000, 1000, 1000], "memory": [131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 J4] From Prefix to Postfix", "background": "", "description": "Prefix notation is a non-conventional notation for writing arithmetic expressions. The standard way of writing arithmetic expressions, also known as infix notation, positions a binary operator between the operands, e.g., $3 + 4$, while in prefix notation the operator is positioned before the operands, e.g., $+$ $3$ $4$. Similarly, the prefix notation for $5$ $-$ $2$ is $-$ $5$ $2$. A nice property of prefix expressions with binary operators is that parentheses are not required since there is no ambiguity about the order of operations. For example, the prefix representation of $5 - (4 - 2)$ is $-5$ $-$ $4$ $2$, while the prefix representation of $(5 - 4) - 2$ is $-$ $-$ $5$ $4$ $2$. The prefix notation is also known as Polish notation, due to Jan Łukasiewicz, a Polish logician, who invented it around $1920$.\n\nSimilarly, in postfix notation, orreverse Polish notation, the operator is positioned after the operands.\n\nFor example, postfix representation of the infix expression $(5 - 4) - 2$ is $5$ $4$ $-$ $2$ $-$. Your task is to write a program that translates a prefix arithmetic expression into a postfix arithmetic expression.", "inputFormat": "Each line contains an arithmetic prefix expression. The operators are $+$ and $-$, and numbers are all single-digit decimal numbers. The operators and numbers are separated by exactly one space with no leading spaces on the line. The end of input is marked by $0$ on a single line. You can assume that each input line contains a valid prefix expression with less than $20$ operators.", "outputFormat": "Translate each expression into postfix notation and produce it on a separate line. The numbers and operators are separated by at least one space. The final $0$ is not translated.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 J4] From Prefix to Postfix", "background": "", "description": "Prefix notation is a non-conventional notation for writing arithmetic expressions. The standard way of writing arithmetic expressions, also known as infix notation, positions a binary operator between the operands, e.g., $3 + 4$, while in prefix notation the operator is positioned before the operands, e.g., $+$ $3$ $4$. Similarly, the prefix notation for $5$ $-$ $2$ is $-$ $5$ $2$. A nice property of prefix expressions with binary operators is that parentheses are not required since there is no ambiguity about the order of operations. For example, the prefix representation of $5 - (4 - 2)$ is $-5$ $-$ $4$ $2$, while the prefix representation of $(5 - 4) - 2$ is $-$ $-$ $5$ $4$ $2$. The prefix notation is also known as Polish notation, due to Jan Łukasiewicz, a Polish logician, who invented it around $1920$.\n\nSimilarly, in postfix notation, orreverse Polish notation, the operator is positioned after the operands.\n\nFor example, postfix representation of the infix expression $(5 - 4) - 2$ is $5$ $4$ $-$ $2$ $-$. Your task is to write a program that translates a prefix arithmetic expression into a postfix arithmetic expression.", "inputFormat": "Each line contains an arithmetic prefix expression. The operators are $+$ and $-$, and numbers are all single-digit decimal numbers. The operators and numbers are separated by exactly one space with no leading spaces on the line. The end of input is marked by $0$ on a single line. You can assume that each input line contains a valid prefix expression with less than $20$ operators.", "outputFormat": "Translate each expression into postfix notation and produce it on a separate line. The numbers and operators are separated by at least one space. The final $0$ is not translated.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 J4] From Prefix to Postfix", "background": "", "description": "前缀表示法是一种非传统的算术表达式书写方式。标准的算术表达式书写方式，也被称为中缀表示法，将二元运算符置于操作数之间，例如 $3 + 4$，而在前缀表示法中，运算符置于操作数之前，例如 $+$ $3$ $4$。类似地，$5 - 2$ 的前缀表示法是 $-$ $5$ $2$。具有二元运算符的前缀表达式的一个优点是无需括号，因为运算顺序没有歧义。例如，$5 - (4 - 2)$ 的前缀表示为 $-5$ $-$ $4$ $2$，而 $(5 - 4) - 2$ 的前缀表示为 $-$ $-$ $5$ $4$ $2$。前缀表示法也被称为波兰表示法，以纪念波兰逻辑学家 Jan Łukasiewicz，他在 1920 年左右发明了这种表示法。\n\n类似地，在后缀表示法或逆波兰表示法中，运算符置于操作数之后。\n\n例如，中缀表达式 $(5 - 4) - 2$ 的后缀表示为 $5$ $4$ $-$ $2$ $-$。你的任务是编写一个程序，将前缀算术表达式转换为后缀算术表达式。", "inputFormat": "每行包含一个算术前缀表达式。运算符为 $+$ 和 $-$，数字均为单位数的十进制数。运算符和数字之间用一个空格分隔，行首没有空格。输入的结束由单独一行的 $0$ 标记。可以假设每个输入行包含少于 20 个运算符的有效前缀表达式。", "outputFormat": "将每个表达式转换为后缀表示法，并在单独的行上输出。数字和运算符之间至少用一个空格分隔。最后的 $0$ 不翻译。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9858", "type": "P", "difficulty": 1, "samples": [["Saskatoon -20\nToronto -2\nWinnipeg -40\nVancouver 8\nHalifax 0\nMontreal -4\nWaterloo -3", "Winnipeg"]], "limits": {"time": [1000, 1000, 1000], "memory": [131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 S1] It’s Cold Here!", "background": "", "description": "Canada is cold in winter, but some parts are colder than others. Your task is very simple, you need to find the coldest city in Canada. So, when given a list of cities and their temperatures, you are to determine which city in the list has the lowest temperature and is thus the coldest.", "inputFormat": "The input is a sequence of city names and temperature values. Temperatures are integer, possibly preceded with a `-` sign. There is a single space between the city name and the temperature. No city name contains any whitespace and is always less than $256$ characters in length. There is at least one city in the list, no more than $10000$ cities, and the last city is always Waterloo. You may assume that the temperature is not less than $-273$ and not more than $200$.", "outputFormat": "You are to output the name of the coldest city on a single line with no whitespace before or after\nthe name. You may assume that there will not be more than one city which is the coldest.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 S1] It’s Cold Here!", "background": "", "description": "Canada is cold in winter, but some parts are colder than others. Your task is very simple, you need to find the coldest city in Canada. So, when given a list of cities and their temperatures, you are to determine which city in the list has the lowest temperature and is thus the coldest.", "inputFormat": "The input is a sequence of city names and temperature values. Temperatures are integer, possibly preceded with a `-` sign. There is a single space between the city name and the temperature. No city name contains any whitespace and is always less than $256$ characters in length. There is at least one city in the list, no more than $10000$ cities, and the last city is always Waterloo. You may assume that the temperature is not less than $-273$ and not more than $200$.", "outputFormat": "You are to output the name of the coldest city on a single line with no whitespace before or after\nthe name. You may assume that there will not be more than one city which is the coldest.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 S1] It’s Cold Here!", "background": "", "description": "加拿大的冬天很冷，但有些地方比其他地方更冷。你的任务非常简单，你需要找出加拿大最冷的城市。因此，当给定一个城市及其温度的列表时，你需要确定列表中哪个城市的温度最低，从而找出最冷的城市。", "inputFormat": "输入是一系列城市名称和温度值。温度是整数，可能带有 `-` 号。城市名称和温度之间有一个空格。没有城市名称包含空格，且长度总是小于 $256$ 个字符。列表中至少有一个城市，不超过 $10000$ 个城市，最后一个城市总是 Waterloo。你可以假设温度不低于 $-273$ 且不高于 $200$。", "outputFormat": "你需要在一行中输出最冷城市的名称，名称前后没有空格。可以假设不会有多个城市同时是最冷的。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9859", "type": "P", "difficulty": 2, "samples": [["2\n3\n4\n0", "13\n29\n49"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 S2] Pennies in the Ring", "background": "", "description": "The game “Pennies in the Ring” is often played by bored computer programmers who have gotten tired of playing solitare. The objective is to see how many pennies can be put into a circle. The circle is drawn on a grid, with its center at the coordinate $(0, 0)$. A single penny is placed on every integer grid coordinate (e.g., $(1, 1)$,$(1, 2)$, etc.) that lies within or on the circle. It’s not a very exciting game, but it’s very good for wasting time. Your goal is to calculate how many pennies are needed for a circle with a given radius.", "inputFormat": "The input is a sequence of positive integer values, one per line, where each integer is the radius of a circle. You can assume the radius will be less than or equal to $25000$. The last integer will be indicated by $0$. You may assume that the grid is large enough for two pennies to be on adjacent integer coordinates and not touch.", "outputFormat": "You are to output, each on its own line, the number of pennies needed for each circle. You do not need to output $0$ for the last $0$. You may assume that the number of possible pennies is less than $2$ billion (which is only $20$ million dollars: computer scientists have lots of money).", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 S2] Pennies in the Ring", "background": "", "description": "The game “Pennies in the Ring” is often played by bored computer programmers who have gotten tired of playing solitare. The objective is to see how many pennies can be put into a circle. The circle is drawn on a grid, with its center at the coordinate $(0, 0)$. A single penny is placed on every integer grid coordinate (e.g., $(1, 1)$,$(1, 2)$, etc.) that lies within or on the circle. It’s not a very exciting game, but it’s very good for wasting time. Your goal is to calculate how many pennies are needed for a circle with a given radius.", "inputFormat": "The input is a sequence of positive integer values, one per line, where each integer is the radius of a circle. You can assume the radius will be less than or equal to $25000$. The last integer will be indicated by $0$. You may assume that the grid is large enough for two pennies to be on adjacent integer coordinates and not touch.", "outputFormat": "You are to output, each on its own line, the number of pennies needed for each circle. You do not need to output $0$ for the last $0$. You may assume that the number of possible pennies is less than $2$ billion (which is only $20$ million dollars: computer scientists have lots of money).", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 S2] Pennies in the Ring", "background": "", "description": "游戏“环中的便士”通常由厌倦了玩纸牌的无聊计算机程序员玩。目标是看看可以在一个圆中放多少便士。圆画在一个网格上，其中心在坐标 $(0, 0)$。在每个整数网格坐标（例如，$(1, 1)$，$(1, 2)$ 等）上放置一个便士，该坐标位于圆内或圆上。这不是一个非常刺激的游戏，但非常适合消磨时间。你的目标是计算给定半径的圆需要多少便士。", "inputFormat": "输入是一系列正整数值，每行一个，其中每个整数是一个圆的半径。你可以假设半径将小于或等于 $25000$。最后一个整数将由 $0$ 指示。你可以假设网格足够大，以至于两个便士可以在相邻的整数坐标上而不接触。", "outputFormat": "你需要输出每个圆所需的便士数量，每个输出占一行。你不需要为最后的 $0$ 输出 $0$。你可以假设可能的便士数量小于 $20$ 亿（这仅仅是 $2000$ 万美元：计算机科学家有很多钱）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
