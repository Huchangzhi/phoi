{"pid": "P6830", "type": "P", "difficulty": 5, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "并查集", "IOI", "交互题", "Special Judge", "深度优先搜索 DFS"], "title": "[IOI 2020] 连接擎天树", "background": "**这是一道交互题。**\n\n本题仅支持 C++ 系列语言，提交时**不需要**包含 `supertrees.h` 头文件，但**需要**在程序开头包含 `vector` 头文件以及声明函数 `void build(std::vector<std::vector<int> > b);`", "description": "滨海湾花园是新加坡的一个大型自然公园。公园内有 $n$ 个塔，称之为“擎天树”。这些塔的编号为 $0$ 到 $n-1$。我们希望建立一个桥的集合（桥的数目大于等于 $0$）。每⼀座桥连接两个不同的塔，而且可以双向通行。没有两座桥连接相同的一对塔。\n\n一条从塔 $x$ 到塔 $y$ 的路径是一个满足以下条件的塔序列（塔的数目大于等于 $1$）：\n\n- 序列的第一个元素是 $x$，\n- 序列的最后一个元素是 $y$，\n- 序列中所有元素互不相同，\n\n序列中每两个相邻元素（塔）都是被某一座桥连接起来的。\n\n注意根据定义，一个塔到它自己有且仅有一条路径，并且从塔 $i$ 到塔 $j$ 的不同路径的数目和从塔 $j$ 到塔 $i$ 的不同路径的数目是一样的。\n\n负责该项设计的首席设计师希望待建造的桥梁要符合：任意给定 $0 \\le i,j \\le n-1$，恰好有 $p[i][j]$ 条从塔 $i$ 到塔 $j$ 的不同路径，其中 $0 \\le p[i][j] \\le 3$。\n\n请构造一个桥的集合来满足设计师的要求，或判定这样的桥梁集合不可能存在。\n\n#### 实现细节\n\n你需要实现下面的这个函数：\n\n```cpp\nint construct(std::vector<std::vector<int> > p)\n```\n\n- $p$：⼀个表示设计师要求的 $n \\times n$ 数组。\n- 如果这个建设方案是存在的，该函数应该恰好调用一次 `build`（见下文）来给出建设方案，然后应返回 $1$。\n- 否则，该函数应该返回 $0$，并且不要调用 `build`。\n- 该函数将被调用恰好一次。\n\n函数 `build` 定义如下：\n\n```cpp\nvoid build(std::vector<std::vector<int> > b)\n```\n  \n- $b$：一个 $n \\times n$ 的数组，$b[i][j]=1$ 表示有一座桥连接塔 $i$ 和塔 $j$，否则 $b[i][j]=0$。\n- 注意该数组必须满足：对所有 $0 \\le i,j \\le n-1$，$b[i][j]=b[j][i]$；并且对所有 $0 \\le i \\le n-1$，$b[i][i]=0$。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑以下调用：\n\n```cpp\nconstruct([[1, 1, 2, 2], [1, 1, 2, 2], [2, 2, 1, 2], [2, 2, 2, 1]])\n```\n  \n这表明从塔 $0$ 到塔 $1$ 恰好有一条路径。对于所有其他的塔对 $(x,y)(0 \\le x<y \\le 3)$, 恰好有两条不同的路径连接塔 $x$ 和塔 $y$。这可以通过建设 $4$ 座桥来实现：连接塔对 $(0, 1), (1, 2), (1, 3)$ 和 $(2,3)$。\n\n为了给出这个解决方案，函数 `construct` 应该做以下调用：\n\n```cpp\nbuild([[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]])\n  ```\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lf8q5wrk.png)\n\n函数应该返回 $1$。\n\n对于这个例子，存在多种不同的建设方案来满足要求，所有这些方案都被认为是正确的。\n\n#### 例 2\n\n考虑以下调用：\n\n```cpp\nconstruct([[1, 0], [0, 1]])\n```\n  \n  这表明无法在两个塔之间进行旅行。这只能通过不建设桥梁来满足。\n\n因此，函数 `construct` 应该做以下调用：\n```cpp\nbuild([[0, 0], [0, 0]])\n```\n  然后，函数 `construct` 应该返回 $1$。\n  \n  #### 例 3\n  \n考虑以下调用：\n\n```cpp\nconstruct([[1, 3], [3, 1]])\n```\n\n这表明从塔 $0$ 到塔 $1$ 恰好有 $3$ 条路径。这些要求无法满足。因此，函数 `construct` 应该返回 $0$ 并且不要调用 `build`。\n\n#### 约束条件\n\n- $1\\le n\\le 1000$\n- $p[i][i]=1$（对所有 $0 \\le i \\le n-1$）\n- $p[i][j]=p[j][i]$（对所有 $0 \\le i,j \\le n-1$）\n- $0 \\le p[i][j] \\le 3$（对所有 $0 \\le i,j \\le n-1$）\n\n#### 子任务\n\n1. （11 分）$p[i][j]=1$（对所有 $0 \\le i,j \\le n-1$）\n2. （10 分）$p[i][j] \\in \\{0,1\\}$（对所有 $0 \\le i,j \\le n-1$）\n1. （19 分）$p[i][j] \\in \\{0,2\\}$（对所有 $i \\ne j,0 \\le i,j \\le n-1$）\n1. （35 分）$0 \\le p[i][j]\\le 2$（对所有 $0 \\le i,j \\le n-1$）并且至少有一种建设方案满足要求\n1. （21 分）$0 \\le p[i][j] \\le 2$（对所有 $0 \\le i,j \\le n-1$）\n1. （4 分）没有额外约束条件\n\n#### 评测程序示例\n\n评测程序示例以如下格式读取输入数据：\n\n第 $1$ 行：$n$       \n第 $2+i$ 行（$0 \\le i \\le n+1$）：$p[i][0]\\ p[i][1]\\ \\ldots\\ p[i][n]$\n\n评测程序示例的输出格式如下：\n\n第 $1$ 行: `construct` 的返回值。\n\n如果 `construct` 的返回值为 $1$，评测程序示例会额外打印：\n\n第 $2+i$ 行（$0 \\le i \\le n+1$）：$b[i][0]\\ b[i][1]\\ \\ldots\\ b[i][n]$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2020] 连接擎天树", "background": "**这是一道交互题。**\n\n本题仅支持 C++ 系列语言，提交时**不需要**包含 `supertrees.h` 头文件，但**需要**在程序开头包含 `vector` 头文件以及声明函数 `void build(std::vector<std::vector<int> > b);`", "description": "滨海湾花园是新加坡的一个大型自然公园。公园内有 $n$ 个塔，称之为“擎天树”。这些塔的编号为 $0$ 到 $n-1$。我们希望建立一个桥的集合（桥的数目大于等于 $0$）。每⼀座桥连接两个不同的塔，而且可以双向通行。没有两座桥连接相同的一对塔。\n\n一条从塔 $x$ 到塔 $y$ 的路径是一个满足以下条件的塔序列（塔的数目大于等于 $1$）：\n\n- 序列的第一个元素是 $x$，\n- 序列的最后一个元素是 $y$，\n- 序列中所有元素互不相同，\n\n序列中每两个相邻元素（塔）都是被某一座桥连接起来的。\n\n注意根据定义，一个塔到它自己有且仅有一条路径，并且从塔 $i$ 到塔 $j$ 的不同路径的数目和从塔 $j$ 到塔 $i$ 的不同路径的数目是一样的。\n\n负责该项设计的首席设计师希望待建造的桥梁要符合：任意给定 $0 \\le i,j \\le n-1$，恰好有 $p[i][j]$ 条从塔 $i$ 到塔 $j$ 的不同路径，其中 $0 \\le p[i][j] \\le 3$。\n\n请构造一个桥的集合来满足设计师的要求，或判定这样的桥梁集合不可能存在。\n\n#### 实现细节\n\n你需要实现下面的这个函数：\n\n```cpp\nint construct(std::vector<std::vector<int> > p)\n```\n\n- $p$：⼀个表示设计师要求的 $n \\times n$ 数组。\n- 如果这个建设方案是存在的，该函数应该恰好调用一次 `build`（见下文）来给出建设方案，然后应返回 $1$。\n- 否则，该函数应该返回 $0$，并且不要调用 `build`。\n- 该函数将被调用恰好一次。\n\n函数 `build` 定义如下：\n\n```cpp\nvoid build(std::vector<std::vector<int> > b)\n```\n  \n- $b$：一个 $n \\times n$ 的数组，$b[i][j]=1$ 表示有一座桥连接塔 $i$ 和塔 $j$，否则 $b[i][j]=0$。\n- 注意该数组必须满足：对所有 $0 \\le i,j \\le n-1$，$b[i][j]=b[j][i]$；并且对所有 $0 \\le i \\le n-1$，$b[i][i]=0$。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑以下调用：\n\n```cpp\nconstruct([[1, 1, 2, 2], [1, 1, 2, 2], [2, 2, 1, 2], [2, 2, 2, 1]])\n```\n  \n这表明从塔 $0$ 到塔 $1$ 恰好有一条路径。对于所有其他的塔对 $(x,y)(0 \\le x<y \\le 3)$, 恰好有两条不同的路径连接塔 $x$ 和塔 $y$。这可以通过建设 $4$ 座桥来实现：连接塔对 $(0, 1), (1, 2), (1, 3)$ 和 $(2,3)$。\n\n为了给出这个解决方案，函数 `construct` 应该做以下调用：\n\n```cpp\nbuild([[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]])\n  ```\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lf8q5wrk.png)\n\n函数应该返回 $1$。\n\n对于这个例子，存在多种不同的建设方案来满足要求，所有这些方案都被认为是正确的。\n\n#### 例 2\n\n考虑以下调用：\n\n```cpp\nconstruct([[1, 0], [0, 1]])\n```\n  \n  这表明无法在两个塔之间进行旅行。这只能通过不建设桥梁来满足。\n\n因此，函数 `construct` 应该做以下调用：\n```cpp\nbuild([[0, 0], [0, 0]])\n```\n  然后，函数 `construct` 应该返回 $1$。\n  \n  #### 例 3\n  \n考虑以下调用：\n\n```cpp\nconstruct([[1, 3], [3, 1]])\n```\n\n这表明从塔 $0$ 到塔 $1$ 恰好有 $3$ 条路径。这些要求无法满足。因此，函数 `construct` 应该返回 $0$ 并且不要调用 `build`。\n\n#### 约束条件\n\n- $1\\le n\\le 1000$\n- $p[i][i]=1$（对所有 $0 \\le i \\le n-1$）\n- $p[i][j]=p[j][i]$（对所有 $0 \\le i,j \\le n-1$）\n- $0 \\le p[i][j] \\le 3$（对所有 $0 \\le i,j \\le n-1$）\n\n#### 子任务\n\n1. （11 分）$p[i][j]=1$（对所有 $0 \\le i,j \\le n-1$）\n2. （10 分）$p[i][j] \\in \\{0,1\\}$（对所有 $0 \\le i,j \\le n-1$）\n1. （19 分）$p[i][j] \\in \\{0,2\\}$（对所有 $i \\ne j,0 \\le i,j \\le n-1$）\n1. （35 分）$0 \\le p[i][j]\\le 2$（对所有 $0 \\le i,j \\le n-1$）并且至少有一种建设方案满足要求\n1. （21 分）$0 \\le p[i][j] \\le 2$（对所有 $0 \\le i,j \\le n-1$）\n1. （4 分）没有额外约束条件\n\n#### 评测程序示例\n\n评测程序示例以如下格式读取输入数据：\n\n第 $1$ 行：$n$       \n第 $2+i$ 行（$0 \\le i \\le n+1$）：$p[i][0]\\ p[i][1]\\ \\ldots\\ p[i][n]$\n\n评测程序示例的输出格式如下：\n\n第 $1$ 行: `construct` 的返回值。\n\n如果 `construct` 的返回值为 $1$，评测程序示例会额外打印：\n\n第 $2+i$ 行（$0 \\le i \\le n+1$）：$b[i][0]\\ b[i][1]\\ \\ldots\\ b[i][n]$", "locale": "zh-CN"}}}
{"pid": "P6831", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2020", "IOI", "交互题", "Special Judge"], "title": "[IOI 2020] 嘉年华奖券", "background": "**本题为交互题。**\n\n请在程序开头声明 `void allocate_tickets(std::vector<std::vector<int> > s);` 和使用 vector 头文件，并且请在调用函数前加上 `extern \"C\"`。\n\n请使用 **C++17 / 20** 提交。", "description": "Ringo 正在参加在新加坡举办的一个嘉年华活动。他的口袋里装有一些奖券，这些奖券可以在嘉年华的游戏展位使用。假设共有 $n$ 种颜色的奖券，每张奖券涂上了其中的一种颜色并且印上了一个非负整数。不同奖券上的数字可能相同。依据嘉年华活动的规则要求，$n$ 保证是偶数。\n\nRingo 每种颜色的奖券有 $m$ 张，也就是说他共有 $n \\cdot m$ 张奖券。其中，第 $i$ 种颜色对应的第 $j$ 张奖券上印的数字为 $x[i][j]$（$0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）。\n\n一次奖券游戏要进行 $k$ 轮，轮次的序号从 $0$ 到 $k-1$。每一轮按照下面的方式进行：\n\n- 首先，Ringo 从每种颜色的奖券中各选出一张奖券，形成一个 $n$ 张奖券的 **集合**。\n- 随后，游戏负责人记录下这个集合中奖券上的数字 $a[0],a[1],\\ldots,a[n-1]$。不需要考虑这 $n$ 个整数的顺序。\n- 接下来，游戏负责人从一个幸运抽奖箱中抽取一张特殊卡片，上面印有整数 $b$。\n- 对于上述集合中每一个奖券上的数字 $a[i](0\\le i \\le n-1)$，游戏负责人会计算 $a[i]$ 和 $b$ 的差的绝对值。让 $S$ 代表这 $n$ 个差的绝对值之和。\n- 所得到的数字 $S$ 就是 Ringo 本轮能够获得的奖励数额。\n- 一轮游戏结束后，本轮集合中的奖券全部被丢弃，不会在未来的轮次所使用。\n\n当 $k$ 轮游戏结束后，Ringo 会丢弃口袋中的所有奖券。\n\n通过仔细观察，Ringo 发现这个奖券游戏被操控了！实际上，幸运抽奖箱里面内置了一台打印机。在每一轮，游戏负责人首先找到一个能够最小化当前轮次游戏奖励的整数 $b$，然后将该数字打印在他所抽取的特殊卡片上。\n\n知道了这些信息之后，Ringo 想要设计每轮游戏中的奖券分配方案，使得 $k$ 轮游戏中获得的总体奖励数额之和最大。\n\n#### 实现细节\n\n你需要实现下面这个函数：\n\n```cpp\nlong long find_maximum(int k,std::vector<std::vector<int>> x)\n```\n\n- $k$：游戏的轮数。\n- $x$：一个 $n \\times m$ 的数组，记录了奖券上的数字。每种颜色的奖券按照上面的数字非递减顺序排序。\n- 这个函数只会被调用一次。\n- 这个函数应该只调用一次函数 `allocate_tickets`（参见下面的内容），它描述了 $k$ 轮游戏中的奖券分配方案，每一轮对应一个奖券集合。奖券的分配方案应该使得所获奖励数额之和达到最大。\n- 这个函数需要返回能够获得的最大的奖励数额之和。\n\n函数 `allocate_tickets` 按照如下的方式进行定义：\n\n```cpp\nvoid allocate_tickets(std::vector<std::vector<int>> s)\n```\n  \n- $s$：一个 $n \\times m$ 的数组。如果第 $i$ 种颜色的第 $j$ 张奖券如果被分配到了第 $r$ 轮游戏，那么 $s[i][j]$ 的值应该为 $r$；如果未被使用，应该为 $-1$。\n- 对于 $0 \\le i \\le n-1$，在 $s[i][0],s[i][1],\\ldots,s[i][m-1]$ 中，每个值 $0,1,\\ldots,k-1$ 必须只出现一次，而其他元素应该为 $-1$。\n- 如果存在多种奖券分配方案能够达到最优的奖励数值，可以给出其中任何一种最优方案。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑下面的函数调用：\n\n```cpp\nfind_maximum(2, [[0, 2, 5],[1, 1, 3]])\n  ```\n这意味着：\n\n- 游戏共进行 $k=2$ 轮；\n- 第 $0$ 种颜色奖券上的整数数字分别是 $0,2$ 和 $5$；\n- 第 $1$ 种颜色奖券上的整数数字分别是 $1,1$ 和 $3$；\n\n一种能够获得最优奖励数值的分配方案是：\n\n- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $0$ 张奖券（印有整数 $0$）和第 $1$ 种颜色的第 $2$ 张奖券（印有整数 $3$）。本轮获得的最小奖励数额是 $3$。例如，游戏负责人可以选择 $b=1$：$|1-0| + |1-3| = 1+2 = 3$。\n- 在第 $1$ 轮，Ringo 选择第 $0$ 种颜色的第 $2$ 张奖券（印有整数 $5$）和第 $1$ 种颜色的第 $1$ 张奖券（印有整数 $1$）。本轮能够获得的最小奖励是 $4$。例如，游戏负责人可以选择 $b=3$：$|3-1|+|3-5|=2+2=4$。\n- 因此，本次游戏两轮的奖励之和为 $3+4=7$。\n\n为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：\n\n```cpp\nallocate_tickets([[0, -1, 1], [-1, 1, 0]])\n```\n  \n  最终，函数 `find_maximum` 应该返回数字 $7$。\n  \n#### 例 2\n\n考虑下面的函数调用：\n\n```cpp\nfind_maximum(1, [[5, 9], [1, 4], [3, 6], [2, 7]])\n```\n\n这意味着：\n\n- 游戏只进行一轮；\n- 第 $0$ 种颜色奖券上的数字分别是 $5$ 和 $9$；\n- 第 $1$ 种颜色奖券上的数字分别是 $1$ 和 $4$；\n- 第 $2$ 种颜色奖券上的数字分别是 $3$ 和 $6$；\n- 第 $3$ 种颜色奖券上的数字分别是 $2$ 和 $7$；\n\n一种能够获得最优奖励的分配方案是：\n\n- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $1$ 张奖券（印有整数 $9$），第 $1$ 种颜色的第 $0$ 张奖券（印有整数 $1$），第 $2$ 种颜色的第 $0$ 张奖券（印有整数 $3$），第 $3$ 种颜色的第 $1$ 张奖券（印有整数 $7$）。本轮能够获得的最小奖励是 $12$。例如，游戏负责人可以选择 $b=3$：$|3-9| + |3-1| + |3-3| + |3-7| = 6 + 2 + 0 + 4 = 12$。\n\n为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：\n\n```cpp\nallocate_tickets([[-1, 0], [0, -1], [0, -1], [-1, 0]])\n```\n\n最终，函数 `find_maximum` 应该返回数字 $12$。\n\n#### 约束条件\n\n- $2\\le n\\le 1500$ 且 $n$ 为偶数\n- $1\\le k\\le m\\le 1500$\n- $0 \\le x[i][j] \\le 10^9$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n- $x[i][j-1] \\le x[i][j]$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n\n#### 子任务\n\n1. （11 分）$m=1$\n2. （16 分）$k=1$\n3. （14 分）$0 \\le x[i][j] \\le 1$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n4. （14 分）$k=m$\n5. （12 分）$n,m \\le 80$\n6. （23 分）$n,m \\le 300$\n7. （10 分）没有额外约束条件\n\n#### 评测程序示例\n\n评测程序示例按照下面的格式读入数据：\n\n第 $1$ 行：$n\\ m\\ k$        \n第 $2+i$ 行（$0 \\le i \\le n-1$）：$x[i][0]\\ x[i][1]\\ \\ldots \\ x[i][m-1]$\n\n评测程序示例按照下面的格式打印你的答案：\n\n第 $1$ 行：`find_maximum` 的返回值       \n第 $2+i$ 行（$0 \\le i \\le n-1$）：$s[i][0]\\ s[i][1]\\ \\ldots\\ s[i][m-1]$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2020] 嘉年华奖券", "background": "**本题为交互题。**\n\n请在程序开头声明 `void allocate_tickets(std::vector<std::vector<int> > s);` 和使用 vector 头文件，并且请在调用函数前加上 `extern \"C\"`。\n\n请使用 **C++17 / 20** 提交。", "description": "Ringo 正在参加在新加坡举办的一个嘉年华活动。他的口袋里装有一些奖券，这些奖券可以在嘉年华的游戏展位使用。假设共有 $n$ 种颜色的奖券，每张奖券涂上了其中的一种颜色并且印上了一个非负整数。不同奖券上的数字可能相同。依据嘉年华活动的规则要求，$n$ 保证是偶数。\n\nRingo 每种颜色的奖券有 $m$ 张，也就是说他共有 $n \\cdot m$ 张奖券。其中，第 $i$ 种颜色对应的第 $j$ 张奖券上印的数字为 $x[i][j]$（$0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）。\n\n一次奖券游戏要进行 $k$ 轮，轮次的序号从 $0$ 到 $k-1$。每一轮按照下面的方式进行：\n\n- 首先，Ringo 从每种颜色的奖券中各选出一张奖券，形成一个 $n$ 张奖券的 **集合**。\n- 随后，游戏负责人记录下这个集合中奖券上的数字 $a[0],a[1],\\ldots,a[n-1]$。不需要考虑这 $n$ 个整数的顺序。\n- 接下来，游戏负责人从一个幸运抽奖箱中抽取一张特殊卡片，上面印有整数 $b$。\n- 对于上述集合中每一个奖券上的数字 $a[i](0\\le i \\le n-1)$，游戏负责人会计算 $a[i]$ 和 $b$ 的差的绝对值。让 $S$ 代表这 $n$ 个差的绝对值之和。\n- 所得到的数字 $S$ 就是 Ringo 本轮能够获得的奖励数额。\n- 一轮游戏结束后，本轮集合中的奖券全部被丢弃，不会在未来的轮次所使用。\n\n当 $k$ 轮游戏结束后，Ringo 会丢弃口袋中的所有奖券。\n\n通过仔细观察，Ringo 发现这个奖券游戏被操控了！实际上，幸运抽奖箱里面内置了一台打印机。在每一轮，游戏负责人首先找到一个能够最小化当前轮次游戏奖励的整数 $b$，然后将该数字打印在他所抽取的特殊卡片上。\n\n知道了这些信息之后，Ringo 想要设计每轮游戏中的奖券分配方案，使得 $k$ 轮游戏中获得的总体奖励数额之和最大。\n\n#### 实现细节\n\n你需要实现下面这个函数：\n\n```cpp\nlong long find_maximum(int k,std::vector<std::vector<int>> x)\n```\n\n- $k$：游戏的轮数。\n- $x$：一个 $n \\times m$ 的数组，记录了奖券上的数字。每种颜色的奖券按照上面的数字非递减顺序排序。\n- 这个函数只会被调用一次。\n- 这个函数应该只调用一次函数 `allocate_tickets`（参见下面的内容），它描述了 $k$ 轮游戏中的奖券分配方案，每一轮对应一个奖券集合。奖券的分配方案应该使得所获奖励数额之和达到最大。\n- 这个函数需要返回能够获得的最大的奖励数额之和。\n\n函数 `allocate_tickets` 按照如下的方式进行定义：\n\n```cpp\nvoid allocate_tickets(std::vector<std::vector<int>> s)\n```\n  \n- $s$：一个 $n \\times m$ 的数组。如果第 $i$ 种颜色的第 $j$ 张奖券如果被分配到了第 $r$ 轮游戏，那么 $s[i][j]$ 的值应该为 $r$；如果未被使用，应该为 $-1$。\n- 对于 $0 \\le i \\le n-1$，在 $s[i][0],s[i][1],\\ldots,s[i][m-1]$ 中，每个值 $0,1,\\ldots,k-1$ 必须只出现一次，而其他元素应该为 $-1$。\n- 如果存在多种奖券分配方案能够达到最优的奖励数值，可以给出其中任何一种最优方案。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑下面的函数调用：\n\n```cpp\nfind_maximum(2, [[0, 2, 5],[1, 1, 3]])\n  ```\n这意味着：\n\n- 游戏共进行 $k=2$ 轮；\n- 第 $0$ 种颜色奖券上的整数数字分别是 $0,2$ 和 $5$；\n- 第 $1$ 种颜色奖券上的整数数字分别是 $1,1$ 和 $3$；\n\n一种能够获得最优奖励数值的分配方案是：\n\n- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $0$ 张奖券（印有整数 $0$）和第 $1$ 种颜色的第 $2$ 张奖券（印有整数 $3$）。本轮获得的最小奖励数额是 $3$。例如，游戏负责人可以选择 $b=1$：$|1-0| + |1-3| = 1+2 = 3$。\n- 在第 $1$ 轮，Ringo 选择第 $0$ 种颜色的第 $2$ 张奖券（印有整数 $5$）和第 $1$ 种颜色的第 $1$ 张奖券（印有整数 $1$）。本轮能够获得的最小奖励是 $4$。例如，游戏负责人可以选择 $b=3$：$|3-1|+|3-5|=2+2=4$。\n- 因此，本次游戏两轮的奖励之和为 $3+4=7$。\n\n为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：\n\n```cpp\nallocate_tickets([[0, -1, 1], [-1, 1, 0]])\n```\n  \n  最终，函数 `find_maximum` 应该返回数字 $7$。\n  \n#### 例 2\n\n考虑下面的函数调用：\n\n```cpp\nfind_maximum(1, [[5, 9], [1, 4], [3, 6], [2, 7]])\n```\n\n这意味着：\n\n- 游戏只进行一轮；\n- 第 $0$ 种颜色奖券上的数字分别是 $5$ 和 $9$；\n- 第 $1$ 种颜色奖券上的数字分别是 $1$ 和 $4$；\n- 第 $2$ 种颜色奖券上的数字分别是 $3$ 和 $6$；\n- 第 $3$ 种颜色奖券上的数字分别是 $2$ 和 $7$；\n\n一种能够获得最优奖励的分配方案是：\n\n- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $1$ 张奖券（印有整数 $9$），第 $1$ 种颜色的第 $0$ 张奖券（印有整数 $1$），第 $2$ 种颜色的第 $0$ 张奖券（印有整数 $3$），第 $3$ 种颜色的第 $1$ 张奖券（印有整数 $7$）。本轮能够获得的最小奖励是 $12$。例如，游戏负责人可以选择 $b=3$：$|3-9| + |3-1| + |3-3| + |3-7| = 6 + 2 + 0 + 4 = 12$。\n\n为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：\n\n```cpp\nallocate_tickets([[-1, 0], [0, -1], [0, -1], [-1, 0]])\n```\n\n最终，函数 `find_maximum` 应该返回数字 $12$。\n\n#### 约束条件\n\n- $2\\le n\\le 1500$ 且 $n$ 为偶数\n- $1\\le k\\le m\\le 1500$\n- $0 \\le x[i][j] \\le 10^9$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n- $x[i][j-1] \\le x[i][j]$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n\n#### 子任务\n\n1. （11 分）$m=1$\n2. （16 分）$k=1$\n3. （14 分）$0 \\le x[i][j] \\le 1$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n4. （14 分）$k=m$\n5. （12 分）$n,m \\le 80$\n6. （23 分）$n,m \\le 300$\n7. （10 分）没有额外约束条件\n\n#### 评测程序示例\n\n评测程序示例按照下面的格式读入数据：\n\n第 $1$ 行：$n\\ m\\ k$        \n第 $2+i$ 行（$0 \\le i \\le n-1$）：$x[i][0]\\ x[i][1]\\ \\ldots \\ x[i][m-1]$\n\n评测程序示例按照下面的格式打印你的答案：\n\n第 $1$ 行：`find_maximum` 的返回值       \n第 $2+i$ 行（$0 \\le i \\le n-1$）：$s[i][0]\\ s[i][1]\\ \\ldots\\ s[i][m-1]$", "locale": "zh-CN"}}}
{"pid": "P6832", "type": "P", "difficulty": 1, "samples": [["abababab", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "贪心", "2020", "O2优化", "洛谷月赛"], "title": "[Cnoi2020] 子弦", "background": "", "description": "Cirno 有一个字符串 $\\texttt{S}$，并希望你能求出 $\\texttt{S}$ 出现次数最多的非空子串的出现次数，记作 $p$。", "inputFormat": "一行，一个字符串 $\\texttt{S}$。", "outputFormat": "一行，一个整数 $p$。", "hint": "### 数据范围与约定\n\n对于 $100\\%$ 的数据保证: $0< |\\texttt{S}| \\le 10^7$，$\\texttt{S}_x\\in[\\texttt{a},\\texttt{z}]$。\n\n#### 子任务「本题采用捆绑测试」\n - Subtask1（$40\\%$）：$|\\texttt{S}| \\le 100$。\n - Subtask2（$40\\%$）：$|\\texttt{S}| \\le 10^5$。\n - Subtask3（$20\\%$）：无特殊限制。\n\n### 名词解释\n - **子串**：字符串中任意个连续的字符组成的子序列称为该串的子串。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Cnoi2020] 子弦", "background": "", "description": "Cirno 有一个字符串 $\\texttt{S}$，并希望你能求出 $\\texttt{S}$ 出现次数最多的非空子串的出现次数，记作 $p$。", "inputFormat": "一行，一个字符串 $\\texttt{S}$。", "outputFormat": "一行，一个整数 $p$。", "hint": "### 数据范围与约定\n\n对于 $100\\%$ 的数据保证: $0< |\\texttt{S}| \\le 10^7$，$\\texttt{S}_x\\in[\\texttt{a},\\texttt{z}]$。\n\n#### 子任务「本题采用捆绑测试」\n - Subtask1（$40\\%$）：$|\\texttt{S}| \\le 100$。\n - Subtask2（$40\\%$）：$|\\texttt{S}| \\le 10^5$。\n - Subtask3（$20\\%$）：无特殊限制。\n\n### 名词解释\n - **子串**：字符串中任意个连续的字符组成的子序列称为该串的子串。\n", "locale": "zh-CN"}}}
{"pid": "P6833", "type": "P", "difficulty": 4, "samples": [["5 5 1 2 4\n1 8 1 6 6\n1 1 1 2 4\n8 3 1 2 2\n1 2 1 9 1\n1 0 9 1 1", "15"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "2020", "O2优化", "最短路", "洛谷月赛"], "title": "[Cnoi2020] 雷雨", "background": "> 令人不安的云开始笼罩天空。  \n巨大的建筑在强风中轧轧作响。  \n幻想乡中响彻着不和协音。  \n——「东方辉针城 ～ Double Dealing Character」\n\n一个雷雨交加的夜晚，一束闪电击中了雾之湖畔的红魔馆和迷途竹林。\n\n似乎有什么大事要发生，Cirno 在小屋静静地中思考着。", "description": "幻想乡的纵切面可以抽象成一个 $n\\times m$ 的矩形。\n\n其中每一个 $1\\times 1$ 的单元格 $(i,j)$ 都有一个**电阻计量值**(虚构的概念) $R_{i,j}$。\n\n闪电从**雷雨云**上的 $\\texttt{O}(n,a)$ 发出，击中了**地面**上的*红魔馆* $\\texttt{A}(1,b)$ 与*迷途竹林* $\\texttt{B}(1,c)$。\n\n雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 $\\texttt{O}$ 到 $\\texttt{A}$ 与 $\\texttt{B}$ 的**两条路径的并集**的电阻计量值的和最小。\n\n所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。", "inputFormat": "第一行，五个整数 $n,m,a,b,c$。$(0<a,b,c\\le m)$\n\n以下 $n$ 行，每行 $m$ 个整数，表示电阻计量 $R_{i,j}$，其中第一行表示雷雨云，最后一行表示地面。", "outputFormat": "一行，一个整数，表示答案。", "hint": "## 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ozs40i3.png)\n\n如图黄色线为闪电的路径。\n\n## 数据范围与约定\n\n对于 $100\\%$ 的数据保证：$0<n,m \\le 1000$，$0 \\le R_{i,j}\\le 10^9$，$0< a,b,c \\le m$。\n\n#### 子任务「本题采用捆绑测试」\n\n - Subtask1（$10\\%$）: $R_{i,j}\\in\\{1\\}$。\n - Subtask2（$10\\%$）: $R_{i,j}\\in\\{0,1\\}$。\n - Subtask3（$10\\%$）: $a=b=c$。\n - Subtask4（$10\\%$）: $n,m \\le 5$。\n - Subtask5（$60\\%$）: 无特殊限制。\n ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Cnoi2020] 雷雨", "background": "> 令人不安的云开始笼罩天空。  \n巨大的建筑在强风中轧轧作响。  \n幻想乡中响彻着不和协音。  \n——「东方辉针城 ～ Double Dealing Character」\n\n一个雷雨交加的夜晚，一束闪电击中了雾之湖畔的红魔馆和迷途竹林。\n\n似乎有什么大事要发生，Cirno 在小屋静静地中思考着。", "description": "幻想乡的纵切面可以抽象成一个 $n\\times m$ 的矩形。\n\n其中每一个 $1\\times 1$ 的单元格 $(i,j)$ 都有一个**电阻计量值**(虚构的概念) $R_{i,j}$。\n\n闪电从**雷雨云**上的 $\\texttt{O}(n,a)$ 发出，击中了**地面**上的*红魔馆* $\\texttt{A}(1,b)$ 与*迷途竹林* $\\texttt{B}(1,c)$。\n\n雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 $\\texttt{O}$ 到 $\\texttt{A}$ 与 $\\texttt{B}$ 的**两条路径的并集**的电阻计量值的和最小。\n\n所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。", "inputFormat": "第一行，五个整数 $n,m,a,b,c$。$(0<a,b,c\\le m)$\n\n以下 $n$ 行，每行 $m$ 个整数，表示电阻计量 $R_{i,j}$，其中第一行表示雷雨云，最后一行表示地面。", "outputFormat": "一行，一个整数，表示答案。", "hint": "## 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ozs40i3.png)\n\n如图黄色线为闪电的路径。\n\n## 数据范围与约定\n\n对于 $100\\%$ 的数据保证：$0<n,m \\le 1000$，$0 \\le R_{i,j}\\le 10^9$，$0< a,b,c \\le m$。\n\n#### 子任务「本题采用捆绑测试」\n\n - Subtask1（$10\\%$）: $R_{i,j}\\in\\{1\\}$。\n - Subtask2（$10\\%$）: $R_{i,j}\\in\\{0,1\\}$。\n - Subtask3（$10\\%$）: $a=b=c$。\n - Subtask4（$10\\%$）: $n,m \\le 5$。\n - Subtask5（$60\\%$）: 无特殊限制。\n ", "locale": "zh-CN"}}}
{"pid": "P6834", "type": "P", "difficulty": 5, "samples": [["3 2\n2 1 3", "499122180"], ["10 1\n580461319 261515299 384092031 741339597 746815717 566875585 354719606 821499852 330315651 349091676", "553073655"], ["10 9\n497873025 114058764 159468194 207476408 138162972 678927661 223886159 325207554 470061543 658861685", "180853894"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "O2优化", "洛谷月赛"], "title": "[Cnoi2020] 梦原", "background": "> 成熟是一种明亮而不刺眼的光辉，一种圆润而不腻耳的音响，一种不再需要对别人察言观色的从容，一种终于停止向周围申述求告的大气，一种不理会哄闹的微笑，一种洗刷了偏激的淡漠,一种无须声张的厚实，一种并不陡峭的高度。勃郁的豪情发过了酵，尖利的山风收住了劲，湍急的溪流汇成了湖。  \n——余秋雨《文化苦旅》\n\n在一个偶然的梦境中，Cirno 发现了一棵树，在一望无际的昏暗平原上，发出了淡淡的蓝色荧光。\n\nHere lies $\\ \\ \\ \\ \\ \\ \\ \\ \\ $.  ", "description": "不幸的是，这棵树尚未长成，只有一个根节点 $1$。\n\nCirno 只能知道这棵树将会有 $n$ 个结点，上面分别有 $a_1,a_2,\\ldots,a_n$ 颗果实，却无法知道树的形状。\n\n但是树的生长总是具有某种规律。\n\n对于结点 $i$，它会**等概率地**从 $[i-k,i-1] \\cap N^+$ 中选择一个结点连接，并成为那个节点的子节点。\n\n其中，$k$ 是一个 Cirno 已经测出的常数。\n\n为了摘下所有的果实，在树长成之后，Cirno 会多次使用魔法。其中每次会在树上选一个联通块，并从联通块内每个结点上摘取一个果子（必须保证该联通块内**每个结点都有果子**）。\n\n显然，Cirno 会采取**最佳策略**使得使用魔法的次数最少。\n\n现在，Cirno 已经知道了 $n$，$k$ 和每个结点将会长出的果子数 $a_i$，请你帮她计算出她最少使用的魔法次数的数学期望。为了简单起见，你只需要输出答案除以 $998244353$ 的余数。", "inputFormat": "第一行输入两个整数 $n$，$k$，含义如上所述。\n\n第二行输入 $n$ 个整数，表示 $a_1,a_2,\\cdots,a_n$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "## 样例 1 解释：\n\n可能长成的树有如下两种（黑色为结点编号，红色为结点上果子数）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vpdxwme.png)\n\n最佳方案是对联通块 $\\{1,2,3\\}$ 和 $\\{1\\}$ 各使用一次魔法，$\\{3\\}$ 使用两次，共四次。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nnbwq0af.png)\n\n最佳方案对联通块 $\\{1,2,3\\},\\{1,3\\}$ 和 $\\{3\\}$ 各使用一次魔法，共三次。\n\n所以答案为 $\\frac{7}{2}\\equiv 499122180\\pmod{998244353}$\n\n## 数据范围与约定\n\n对于 $100\\%$ 的数据，保证 $1\\le k<n\\le 10^6$，$0\\le a_i<998244353$。\n\n### 子任务「本题采用捆绑测试」\n\n- Subtask1（$10\\%$）: $k=1$。\n- Subtask2（$10\\%$）: $n \\le 10$，$a_i \\in \\{0,1\\}$。\n- Subtask3（$10\\%$）: $n \\le 10$。\n- Subtask4（$10\\%$）: $n \\le 1000$。\n- Subtask5（$60\\%$）: 无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Cnoi2020] 梦原", "background": "> 成熟是一种明亮而不刺眼的光辉，一种圆润而不腻耳的音响，一种不再需要对别人察言观色的从容，一种终于停止向周围申述求告的大气，一种不理会哄闹的微笑，一种洗刷了偏激的淡漠,一种无须声张的厚实，一种并不陡峭的高度。勃郁的豪情发过了酵，尖利的山风收住了劲，湍急的溪流汇成了湖。  \n——余秋雨《文化苦旅》\n\n在一个偶然的梦境中，Cirno 发现了一棵树，在一望无际的昏暗平原上，发出了淡淡的蓝色荧光。\n\nHere lies $\\ \\ \\ \\ \\ \\ \\ \\ \\ $.  ", "description": "不幸的是，这棵树尚未长成，只有一个根节点 $1$。\n\nCirno 只能知道这棵树将会有 $n$ 个结点，上面分别有 $a_1,a_2,\\ldots,a_n$ 颗果实，却无法知道树的形状。\n\n但是树的生长总是具有某种规律。\n\n对于结点 $i$，它会**等概率地**从 $[i-k,i-1] \\cap N^+$ 中选择一个结点连接，并成为那个节点的子节点。\n\n其中，$k$ 是一个 Cirno 已经测出的常数。\n\n为了摘下所有的果实，在树长成之后，Cirno 会多次使用魔法。其中每次会在树上选一个联通块，并从联通块内每个结点上摘取一个果子（必须保证该联通块内**每个结点都有果子**）。\n\n显然，Cirno 会采取**最佳策略**使得使用魔法的次数最少。\n\n现在，Cirno 已经知道了 $n$，$k$ 和每个结点将会长出的果子数 $a_i$，请你帮她计算出她最少使用的魔法次数的数学期望。为了简单起见，你只需要输出答案除以 $998244353$ 的余数。", "inputFormat": "第一行输入两个整数 $n$，$k$，含义如上所述。\n\n第二行输入 $n$ 个整数，表示 $a_1,a_2,\\cdots,a_n$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "## 样例 1 解释：\n\n可能长成的树有如下两种（黑色为结点编号，红色为结点上果子数）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vpdxwme.png)\n\n最佳方案是对联通块 $\\{1,2,3\\}$ 和 $\\{1\\}$ 各使用一次魔法，$\\{3\\}$ 使用两次，共四次。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nnbwq0af.png)\n\n最佳方案对联通块 $\\{1,2,3\\},\\{1,3\\}$ 和 $\\{3\\}$ 各使用一次魔法，共三次。\n\n所以答案为 $\\frac{7}{2}\\equiv 499122180\\pmod{998244353}$\n\n## 数据范围与约定\n\n对于 $100\\%$ 的数据，保证 $1\\le k<n\\le 10^6$，$0\\le a_i<998244353$。\n\n### 子任务「本题采用捆绑测试」\n\n- Subtask1（$10\\%$）: $k=1$。\n- Subtask2（$10\\%$）: $n \\le 10$，$a_i \\in \\{0,1\\}$。\n- Subtask3（$10\\%$）: $n \\le 10$。\n- Subtask4（$10\\%$）: $n \\le 1000$。\n- Subtask5（$60\\%$）: 无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P6835", "type": "P", "difficulty": 5, "samples": [["1 5 5\n1 1\n2 2\n3 3\n4 4\n5 5", "10"], ["2 5 5\n1 1\n2 1\n3 2\n4 3\n5 4", "30"], ["3 5 5\n1 1\n2 1\n3 1\n4 1\n5 1", "62"], ["4 5 5\n1 1\n3 1\n4 2\n5 1\n5 5", "35"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2020", "O2优化", "期望", "洛谷月赛"], "title": "[Cnoi2020] 线形生物", "background": "> 为了能够在冥界过上这种愉快的生活而不是被判入地狱，人类们摒弃了自行结束生命的做法，拼尽全力地生活着。如此看来，人类似乎也显得有些积极与可爱了呢。  （射命丸 文） \n\n线形生物沿着一维的阶梯向着冥界单向地前行着。\n\n照这样的话，它只需要一级一级地，走 $n$ 步就能够到达白玉楼。\n\n但 Cirno 觉得这样太单调了，于是，一维的壁垒被打破，链状的道路生出了花椰菜状的枝桠。\n\n", "description": "线形生物要从 $1$ 号台阶走到 $n+1$ 号台阶。\n\n最开始，$1,2,3,\\ldots,n$ 号台阶都有一条连向下一台阶的有向边 $i\\rightarrow i+1$。\n\n之后 Cirno 加入了 $m$ 条**返祖边** $u_i \\rightarrow v_i (u_i \\ge v_i)$，它们构成了一个**返祖图**。\n\n线形生物每步会 **等概率地** 选取当前台阶的一条出边并走向对应的台阶。\n\n当走到 $n+1$ 号台阶时，线形生物就会停止行走。\n\n同时，Cirno 会统计线性生物总共走的步数，记作 $\\delta$。\n\nCirno 想知道 $E(\\delta)$（即 $\\delta$ 的**数学期望**）对 $998244353$ 取模后的结果。", "inputFormat": "第一行三个整数 $id$，$n$，$m$。\n\n以下 $m$ 行，每行两个整数 $u_i$，$v_i$。\n\n$id$ 表示 subtask 编号，其它字母含义同上文。", "outputFormat": "一行，一个整数 $E(\\delta)$，字母含义同上文。", "hint": "## 后置数学知识\n - **可能用到的幂级数求和** : 若 $x>1$，则有 $\\sum\\limits_{i=1}^{\\infty}\\big(\\frac{1}{x}\\big)^i=\\frac{1}{x}+\\frac{1}{x^2}+\\frac{1}{x^3}+\\cdots=\\frac{1}{x-1}$。\n - **数学期望** : 随机试验中每次可能结果的概率乘以其结果的总和，反映随机变量平均取值的大小。\n - **离散期望公式** : $E(x)=\\sum\\limits_{k=1}^{\\infty}x_kp_k$。\n \n## 数据范围与约定\n\n对于 $100\\%$ 的数据，保证：$id \\in \\{1,2,3,4,5\\}$，$0 < n,m \\le 10^6$，$1 \\le v_i \\le u_i \\le n$。\n\n#### 子任务「本题采用捆绑测试」\n\n - Subtask1（$10\\%$）: 返祖图中所有点都有自环且所有边均为自环(未画出)，总图形如 :  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/6fikv6ft.png)\n   \n - Subtask2（$10\\%$）: 返祖图中所有点均向且仅向自己的前驱连边，特别地，$1$ 号节点的前驱是 $1$ 号节点，总图形如 :  \n   ![](https://cdn.luogu.com.cn/upload/image_hosting/6rc9dazb.png)\n \n - Subtask3（$10\\%$）: 返祖图中所有点均向且仅向 $1$ 号节点连边，总图形如 :  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/wup1ctvu.png)\n \n - Subtask4（$10\\%$）: $n \\le 100$，$m \\le 1000$。\n \n - Subtask5（$60\\%$）: 无特殊限制。\n \n ## 后记\n \n  题目名称出自 th17 东方鬼形兽 6 Boss 埴安神袿姬 Hard / Lunatic 难度符卡 線形「リニアクリーチャー」。\n  ", "locale": "zh-CN", "translations": {"en": {"title": "[Cnoi2020] Linear Creatures.", "background": "> In order to live happily in the Underworld rather than being sentenced to hell, humans have abandoned the practice of ending their own lives and are doing their best to live. From this perspective, humans seem somewhat positive and lovable. (Shameimaru Aya)\n\nLinear creatures move one-way toward the Underworld along a one-dimensional staircase.\n\nIn that case, it only needs to climb step by step for $n$ steps to reach Hakugyokurou.\n\nBut Cirno felt this was too monotonous, so the one-dimensional barrier was broken, and the chain-like road grew cauliflower-like branches.", "description": "A linear creature needs to walk from step $1$ to step $n+1$.\n\nAt the beginning, for steps $1,2,3,\\ldots,n$, each step has a directed edge to the next step $i\\rightarrow i+1$.\n\nThen Cirno adds $m$ **atavistic edges** $u_i \\rightarrow v_i (u_i \\ge v_i)$, which form an **atavistic graph**.\n\nAt each step, the linear creature will choose **uniformly at random** one outgoing edge from the current step and move to the corresponding step.\n\nWhen it reaches step $n+1$, it stops walking.\n\nMeanwhile, Cirno counts the total number of steps the linear creature takes, denoted by $\\delta$.\n\nCirno wants to know the value of $E(\\delta)$ (i.e. the **mathematical expectation** of $\\delta$) modulo $998244353$.", "inputFormat": "The first line contains three integers $id$, $n$, and $m$.\n\nThe next $m$ lines each contain two integers $u_i$ and $v_i$.\n\n$id$ indicates the subtask ID. The meanings of the other letters are the same as above.", "outputFormat": "One line with one integer: $E(\\delta)$. The meanings of the letters are the same as above.", "hint": "## Required Mathematical Knowledge\n - **Power series summation that may be used**: If $x>1$, then $\\sum\\limits_{i=1}^{\\infty}\\big(\\frac{1}{x}\\big)^i=\\frac{1}{x}+\\frac{1}{x^2}+\\frac{1}{x^3}+\\cdots=\\frac{1}{x-1}$.\n - **Mathematical expectation**: In a random experiment, the sum of the probability of each possible outcome multiplied by its outcome, reflecting the average value of a random variable.\n - **Discrete expectation formula**: $E(x)=\\sum\\limits_{k=1}^{\\infty}x_kp_k$.\n\n## Constraints and Conventions\n\nFor $100\\%$ of the testdata, it is guaranteed that $id \\in \\{1,2,3,4,5\\}$, $0 < n,m \\le 10^6$, and $1 \\le v_i \\le u_i \\le n$.\n\n#### Subtasks (This problem uses bundled evaluation)\n\n - Subtask1 ($10\\%$): In the atavistic graph, every node has a self-loop and all edges are self-loops (not drawn). The whole graph looks like:  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/6fikv6ft.png)\n\n - Subtask2 ($10\\%$): In the atavistic graph, every node has an edge to and only to its predecessor. In particular, the predecessor of node $1$ is node $1$. The whole graph looks like:  \n   ![](https://cdn.luogu.com.cn/upload/image_hosting/6rc9dazb.png)\n\n - Subtask3 ($10\\%$): In the atavistic graph, every node has an edge to and only to node $1$. The whole graph looks like:  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/wup1ctvu.png)\n\n - Subtask4 ($10\\%$): $n \\le 100$, $m \\le 1000$.\n\n - Subtask5 ($60\\%$): No special restrictions.\n\n## Postscript\n\nThe problem name comes from Touhou Kikeijuu (th17), Stage 6 Boss Keiki Haniyasushin, Hard / Lunatic difficulty spell card: 線形「リニアクリーチャー」.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Cnoi2020] 线形生物", "background": "> 为了能够在冥界过上这种愉快的生活而不是被判入地狱，人类们摒弃了自行结束生命的做法，拼尽全力地生活着。如此看来，人类似乎也显得有些积极与可爱了呢。  （射命丸 文） \n\n线形生物沿着一维的阶梯向着冥界单向地前行着。\n\n照这样的话，它只需要一级一级地，走 $n$ 步就能够到达白玉楼。\n\n但 Cirno 觉得这样太单调了，于是，一维的壁垒被打破，链状的道路生出了花椰菜状的枝桠。\n\n", "description": "线形生物要从 $1$ 号台阶走到 $n+1$ 号台阶。\n\n最开始，$1,2,3,\\ldots,n$ 号台阶都有一条连向下一台阶的有向边 $i\\rightarrow i+1$。\n\n之后 Cirno 加入了 $m$ 条**返祖边** $u_i \\rightarrow v_i (u_i \\ge v_i)$，它们构成了一个**返祖图**。\n\n线形生物每步会 **等概率地** 选取当前台阶的一条出边并走向对应的台阶。\n\n当走到 $n+1$ 号台阶时，线形生物就会停止行走。\n\n同时，Cirno 会统计线性生物总共走的步数，记作 $\\delta$。\n\nCirno 想知道 $E(\\delta)$（即 $\\delta$ 的**数学期望**）对 $998244353$ 取模后的结果。", "inputFormat": "第一行三个整数 $id$，$n$，$m$。\n\n以下 $m$ 行，每行两个整数 $u_i$，$v_i$。\n\n$id$ 表示 subtask 编号，其它字母含义同上文。", "outputFormat": "一行，一个整数 $E(\\delta)$，字母含义同上文。", "hint": "## 后置数学知识\n - **可能用到的幂级数求和** : 若 $x>1$，则有 $\\sum\\limits_{i=1}^{\\infty}\\big(\\frac{1}{x}\\big)^i=\\frac{1}{x}+\\frac{1}{x^2}+\\frac{1}{x^3}+\\cdots=\\frac{1}{x-1}$。\n - **数学期望** : 随机试验中每次可能结果的概率乘以其结果的总和，反映随机变量平均取值的大小。\n - **离散期望公式** : $E(x)=\\sum\\limits_{k=1}^{\\infty}x_kp_k$。\n \n## 数据范围与约定\n\n对于 $100\\%$ 的数据，保证：$id \\in \\{1,2,3,4,5\\}$，$0 < n,m \\le 10^6$，$1 \\le v_i \\le u_i \\le n$。\n\n#### 子任务「本题采用捆绑测试」\n\n - Subtask1（$10\\%$）: 返祖图中所有点都有自环且所有边均为自环(未画出)，总图形如 :  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/6fikv6ft.png)\n   \n - Subtask2（$10\\%$）: 返祖图中所有点均向且仅向自己的前驱连边，特别地，$1$ 号节点的前驱是 $1$ 号节点，总图形如 :  \n   ![](https://cdn.luogu.com.cn/upload/image_hosting/6rc9dazb.png)\n \n - Subtask3（$10\\%$）: 返祖图中所有点均向且仅向 $1$ 号节点连边，总图形如 :  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/wup1ctvu.png)\n \n - Subtask4（$10\\%$）: $n \\le 100$，$m \\le 1000$。\n \n - Subtask5（$60\\%$）: 无特殊限制。\n \n ## 后记\n \n  题目名称出自 th17 东方鬼形兽 6 Boss 埴安神袿姬 Hard / Lunatic 难度符卡 線形「リニアクリーチャー」。\n  ", "locale": "zh-CN"}}}
{"pid": "P6836", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2020", "IOI", "交互题"], "title": "[IOI 2020] 装饼干", "background": "### 注意：本题仅支持 C++ 语言提交，且不应使用 C++14 (GCC 9)。\n\n你无需在代码中添加：\n\n```cpp\n#include \"biscuits.h\"\n```", "description": "Khong 阿姨在组织一场有 $x$ 位选手参加的竞赛，她打算给每位选手一 **袋饼干**。总共有 $k$ 种不同类型的饼干，编号为从 $0$ 到 $k-1$。类型为 $i(0 \\le i \\le k-1)$ 的每块饼干都有一个 **口味值** $2^i$。在 Khong 阿姨的食品储藏室里，有 $a[i]$（有可能为 $0$）块类型为 $i$ 的饼干。\n\n对每种类型的饼干，Khong 阿姨在每个袋子都会装上 $0$ 或者多块。所有袋子里面类型为 $i$ 的饼干的总块数不能超过 $a[i]$。一个袋子里面所有饼干的口味值的总和，被称为这袋饼干的 **总口味值**。\n\n请帮 Khong 阿姨算一下，究竟存在多少不同的 $y$ 值，使得她可以装出 $x$ 袋饼干，而且每袋饼干的总口味值都等于 $y$。\n\n#### 实现细节\n\n你需要实现下面的这个函数：\n\n```cpp\nlong long count_tastiness(long long x, std::vector<long long> a)\n```\n\n- $x$：需要装的饼干袋的数量。\n- $a$：长度为 $k$ 的数组。对 $0 \\le i \\le k-1$，$a[i]$ 表示在食物储藏室里类型为 $i$ 的饼干数量。\n- 此函数应当返回不同 $y$ 值的数目，使得阿姨可以装出 $x$ 袋饼干，且每袋饼干的总口味值都为 $y$。\n- 此函数会被调用 $q$ 次 (对于允许的 $q$ 值，详见约束条件和子任务部分)。每次调用应当被看成是独立的场景。", "inputFormat": "见实现细节。", "outputFormat": "见实现细节。", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑如下调用：\n\n```cpp\ncount_tastiness(3, [5, 2, 1])\n```\n\n这意味着阿姨打算装 $3$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：\n\n- $5$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，\n- $2$ 块类型为 $1$ 的饼干，每块的口味值为 $2$，\n- $1$ 块类型为 $2$ 的饼干，其口味值为 $4$。\n\n$y$ 能够取的值为 $[0,1,2,3,4]$。举例来说，为了装出总口味值均为 $3$ 的 $3$ 袋饼干，阿姨可以这样装：\n\n- 一袋饼干里有 $3$ 块类型为 $0$ 的饼干，以及\n- 两袋饼干，其中各有一块类型为 $0$ 的饼干和一块类型为 $1$ 的饼干。\n\n由于总共有 $5$ 个可能的 $y$ 值，函数应当返回 $5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/db3xoxfy.png)\n\n#### 例 2\n\n考虑如下调用：\n\n```cpp\ncount_tastiness(2, [2, 1, 2])\n```\n\n这意味着阿姨打算装 $2$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：\n\n- $2$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，\n- $1$ 块类型为 $1$ 的饼干，其口味值为 $2$，\n- $2$ 块类型为 $2$ 的饼干，每块的口味值为 $4$。\n\n$y$ 能够取的值为 $[0,1,2,4,5,6]$。由于总共有 $6$ 个可能的 $y$ 值，函数应当返回 $6$。\n\n#### 约束条件\n\n- $1 \\le k \\le 60$\n- $1 \\le q \\le 1000$\n- $1 \\le x \\le 10^{18}$\n- $0 \\le a[i] \\le 10^{18}$（对于所有的 $0 \\le i \\le k-1$）\n- 对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^{18}$。\n\n#### 子任务\n\n1. (9 分) $q \\le 10$，且对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^5$。\n2. (12 分) $x=1,q \\le 10$\n3. (21 分) $x \\le 10^4,q \\le 10$\n4. (35 分) 对于 `count_tastiness` 的每次调用，正确的返回结果都不会超过 $2 \\times 10^5$。\n5. (23 分) 没有附加限制条件。\n\n#### 评测程序示例\n\n评测程序示例将读取如下格式的输入数据。第一行包含一个整数 $q$。接下来是 $q$ 对这样的两行：它们按照下面的格式来描述一个单独的场景：\n\n第 $1$ ⾏：$k\\ x$       \n第 $2$ ⾏：$a[0]\\ a[1]\\ \\ldots\\ a[k-1]$\n\n评测程序示例的输出结果的格式如下：\n\n第 $i$ 行 ($1 \\le i \\le q$)：`count_tastiness` 对于输入数据中第 $i$ 个场景的返回值。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2020] 装饼干", "background": "### 注意：本题仅支持 C++ 语言提交，且不应使用 C++14 (GCC 9)。\n\n你无需在代码中添加：\n\n```cpp\n#include \"biscuits.h\"\n```", "description": "Khong 阿姨在组织一场有 $x$ 位选手参加的竞赛，她打算给每位选手一 **袋饼干**。总共有 $k$ 种不同类型的饼干，编号为从 $0$ 到 $k-1$。类型为 $i(0 \\le i \\le k-1)$ 的每块饼干都有一个 **口味值** $2^i$。在 Khong 阿姨的食品储藏室里，有 $a[i]$（有可能为 $0$）块类型为 $i$ 的饼干。\n\n对每种类型的饼干，Khong 阿姨在每个袋子都会装上 $0$ 或者多块。所有袋子里面类型为 $i$ 的饼干的总块数不能超过 $a[i]$。一个袋子里面所有饼干的口味值的总和，被称为这袋饼干的 **总口味值**。\n\n请帮 Khong 阿姨算一下，究竟存在多少不同的 $y$ 值，使得她可以装出 $x$ 袋饼干，而且每袋饼干的总口味值都等于 $y$。\n\n#### 实现细节\n\n你需要实现下面的这个函数：\n\n```cpp\nlong long count_tastiness(long long x, std::vector<long long> a)\n```\n\n- $x$：需要装的饼干袋的数量。\n- $a$：长度为 $k$ 的数组。对 $0 \\le i \\le k-1$，$a[i]$ 表示在食物储藏室里类型为 $i$ 的饼干数量。\n- 此函数应当返回不同 $y$ 值的数目，使得阿姨可以装出 $x$ 袋饼干，且每袋饼干的总口味值都为 $y$。\n- 此函数会被调用 $q$ 次 (对于允许的 $q$ 值，详见约束条件和子任务部分)。每次调用应当被看成是独立的场景。", "inputFormat": "见实现细节。", "outputFormat": "见实现细节。", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑如下调用：\n\n```cpp\ncount_tastiness(3, [5, 2, 1])\n```\n\n这意味着阿姨打算装 $3$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：\n\n- $5$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，\n- $2$ 块类型为 $1$ 的饼干，每块的口味值为 $2$，\n- $1$ 块类型为 $2$ 的饼干，其口味值为 $4$。\n\n$y$ 能够取的值为 $[0,1,2,3,4]$。举例来说，为了装出总口味值均为 $3$ 的 $3$ 袋饼干，阿姨可以这样装：\n\n- 一袋饼干里有 $3$ 块类型为 $0$ 的饼干，以及\n- 两袋饼干，其中各有一块类型为 $0$ 的饼干和一块类型为 $1$ 的饼干。\n\n由于总共有 $5$ 个可能的 $y$ 值，函数应当返回 $5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/db3xoxfy.png)\n\n#### 例 2\n\n考虑如下调用：\n\n```cpp\ncount_tastiness(2, [2, 1, 2])\n```\n\n这意味着阿姨打算装 $2$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：\n\n- $2$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，\n- $1$ 块类型为 $1$ 的饼干，其口味值为 $2$，\n- $2$ 块类型为 $2$ 的饼干，每块的口味值为 $4$。\n\n$y$ 能够取的值为 $[0,1,2,4,5,6]$。由于总共有 $6$ 个可能的 $y$ 值，函数应当返回 $6$。\n\n#### 约束条件\n\n- $1 \\le k \\le 60$\n- $1 \\le q \\le 1000$\n- $1 \\le x \\le 10^{18}$\n- $0 \\le a[i] \\le 10^{18}$（对于所有的 $0 \\le i \\le k-1$）\n- 对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^{18}$。\n\n#### 子任务\n\n1. (9 分) $q \\le 10$，且对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^5$。\n2. (12 分) $x=1,q \\le 10$\n3. (21 分) $x \\le 10^4,q \\le 10$\n4. (35 分) 对于 `count_tastiness` 的每次调用，正确的返回结果都不会超过 $2 \\times 10^5$。\n5. (23 分) 没有附加限制条件。\n\n#### 评测程序示例\n\n评测程序示例将读取如下格式的输入数据。第一行包含一个整数 $q$。接下来是 $q$ 对这样的两行：它们按照下面的格式来描述一个单独的场景：\n\n第 $1$ ⾏：$k\\ x$       \n第 $2$ ⾏：$a[0]\\ a[1]\\ \\ldots\\ a[k-1]$\n\n评测程序示例的输出结果的格式如下：\n\n第 $i$ 行 ($1 \\le i \\le q$)：`count_tastiness` 对于输入数据中第 $i$ 个场景的返回值。", "locale": "zh-CN"}}}
{"pid": "P6837", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "IOI", "交互题", "Special Judge"], "title": "[IOI 2020] 数蘑菇", "background": "不要 `#include \"mushrooms.h\"`。\n\n你需要在文件头加入以下内容，并**使用 $\\text{\\textcolor{red}{C++\\,23}}$ 提交**：\n\n```cpp line-numbers\n#include <vector>\nint use_machine(std::vector<int> x);\n```", "description": "研究蘑菇的专家安德鲁在研究新加坡的本地蘑菇。\n\n作为研究的一部分，安德鲁采集了 $n$ 个蘑菇，编号为 $0$ 到 $n-1$。每个蘑菇均为两种蘑菇种类之⼀，称为 $A$ 或 $B$。\n\n安德鲁知道**蘑菇 $0$ 属于种类 $A$**, 但是由于这两种蘑菇看起来很相似，他不知道蘑菇 $1$ 到 $n-1$ 属于哪一种。\n\n幸运的是，安德鲁的实验室里有一台机器可以帮助他。在使用这台机器时，需要将两个或者多个蘑菇放到机器里，并摆成一排（以任意顺序），然后打开机器。接下来，这台机器会计算所有不属于同一种类的**相邻**蘑菇对的个数。例如，如果你把种类为 $\\left[A, B, B, A\\right]$ 的蘑菇（按照这个顺序）放到机器中，结果应该是 $2$。\n\n但是，因为机器操作非常昂贵，机器只能使用有限的次数。此外，在机器的所有使用中，放置到机器中的蘑菇总数不能超过 $10^5$。请使用这台机器帮助安德鲁来数一数他采集了多少个种类为 $A$ 的蘑菇。\n\n#### 实现细节\n\n你需要实现以下函数：\n\n```cpp line-numbers\nint count_mushrooms(int n)\n```\n\n- `n`: 安德鲁采集到的蘑菇数量。\n- 该函数应该被调用恰好一次，而且要返回种类为 $A$ 的蘑菇的个数。\n\n以上函数可以调用以下函数：\n\n```cpp line-numbers\nint use_machine(vector<int> x)\n```\n\n- `x`: 一个长度介于 $2$ 和 $n$ 的数组（包括 $2$ 和 $n$)，按顺序给出放在机器中的蘑菇的编号。\n- `x` 的元素必须是在 $0$ 到 $n-1$ 之间（包括 $0$ 和 $n-1$) **互不相同** 的整数。\n- 假设数组 `x` 的长度为 $d$。那么，此函数返回不同的下标 $j$ 的个数，满足 $0 \\le j \\le d-2$ 并且 $x[j]$ 和 $x[j+1]$ 属于不同种类。\n- 该函数最多可以被调用 $2 \\times 10^4$ 次。\n- 在对函数 `use_machine` 的所有调用中，所有被传到该函数 `use_machine` 的 $x$ 的总长度不能超过 $10^5$。", "inputFormat": null, "outputFormat": null, "hint": "#### 样例说明\n\n#### 例 1\n\n考虑以下场景：有 $3$ 个蘑菇，种类依次为 $\\left[A,B,B\\right]$。函数 `count_mushrooms` 用以下方式调用：\n\n```cpp line-numbers\ncount_mushrooms(3)\n```\n\n该函数可以调用 `use_machine([0, 1, 2])`，在该场景下调用返回 $1$。函数接着调用 `use_machine([2, 1])`，该调用返回 $0$。\n\n此时，已经有足够的信息来推出只有 $1$ 个 $A$ 类蘑菇。所以，函数 `count_mushrooms` 应该返回 $1$。\n\n#### 例 2\n\n考虑一个例子：有 $4$ 个蘑菇，种类依次为 $\\left[A,B,A,A\\right]$。函数 `count_mushrooms` 被调用如下：\n\n```cpp line-numbers\ncount_mushrooms(4)\n```\n\n该函数可以调用 `use_machine([0, 2, 1, 3])`，该调用返回 $2$。接着调用 `use_machine([1,2])`，该调用返回 $1$。\n\n此时，已有足够的信息推出：有 $3$ 个 $A$ 类蘑菇。因此，函数 `count_mushrooms` 应该返回 $3$。\n\n#### 约束条件\n\n- $2 \\le n \\le 2 \\times 10^4$\n\n#### 计分\n\n在所有测试用例中，如果对函数 `use_machine` 的调用不符合上面所述的要求，或者 `count_mushrooms` 的返回值不正确，你的解答得分将为 $0$。否则，令 $Q$ 为所有测试样例中对函数 `use_machine` 的最大调用次数。那么，得分将按照以下表格进行计算：\n\n|条件|得分|\n|:-:|:-:|\n|$2 \\times 10^4 \\le Q$|$0$|\n|$10010 < Q \\le 2 \\times 10^4$|$10$|\n|$904 < Q \\le 10010$|$25$|\n|$226 < Q \\le 904$|$\\dfrac{226}{Q} \\cdot 100$|\n|$Q \\le 226$|$100$|\n\n在有些测试用例上，评测程序的行为是自适应的。也就是说，在这些测试用例中，评测程序并没有一个固定的蘑菇种类序列。相反，评测程序中所给出的回答可能依赖于此前对 `use_machine` 的调用。\n\n但是可以保证，评测程序中所给出的回答满足：在每次交互之后，至少存在一个蘑菇种类序列，它能够与当前所给出过的所有回答都相符。\n\n#### 评测程序示例\n\n评测程序示例读入一个整数数组 $s$，该数组给出了蘑菇的种类。对于所有 $0 \\le i \\le n-1$，$s[i]=0$ 表示蘑菇 $i$ 的种类是 $A$，$s[i]=1$ 表示蘑菇 $i$ 的种类是 $B$。评测程序示例读取如下格式的输入数据：\n\n第 $1$ 行: $n$ \\\n第 $2$ 行: $s[0]\\ s[1]\\ \\ldots\\ s[n-1]$\n\n评测程序示例的输出为如下格式：\n\n第 $1$ 行: `count_mushrooms` 的返回值。 \\\n第 $2$ 行: 调用 `use_machine` 的次数。\n\n注意评测程序示例不是自适应的。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2020] 数蘑菇", "background": "不要 `#include \"mushrooms.h\"`。\n\n你需要在文件头加入以下内容，并**使用 $\\text{\\textcolor{red}{C++\\,23}}$ 提交**：\n\n```cpp line-numbers\n#include <vector>\nint use_machine(std::vector<int> x);\n```", "description": "研究蘑菇的专家安德鲁在研究新加坡的本地蘑菇。\n\n作为研究的一部分，安德鲁采集了 $n$ 个蘑菇，编号为 $0$ 到 $n-1$。每个蘑菇均为两种蘑菇种类之⼀，称为 $A$ 或 $B$。\n\n安德鲁知道**蘑菇 $0$ 属于种类 $A$**, 但是由于这两种蘑菇看起来很相似，他不知道蘑菇 $1$ 到 $n-1$ 属于哪一种。\n\n幸运的是，安德鲁的实验室里有一台机器可以帮助他。在使用这台机器时，需要将两个或者多个蘑菇放到机器里，并摆成一排（以任意顺序），然后打开机器。接下来，这台机器会计算所有不属于同一种类的**相邻**蘑菇对的个数。例如，如果你把种类为 $\\left[A, B, B, A\\right]$ 的蘑菇（按照这个顺序）放到机器中，结果应该是 $2$。\n\n但是，因为机器操作非常昂贵，机器只能使用有限的次数。此外，在机器的所有使用中，放置到机器中的蘑菇总数不能超过 $10^5$。请使用这台机器帮助安德鲁来数一数他采集了多少个种类为 $A$ 的蘑菇。\n\n#### 实现细节\n\n你需要实现以下函数：\n\n```cpp line-numbers\nint count_mushrooms(int n)\n```\n\n- `n`: 安德鲁采集到的蘑菇数量。\n- 该函数应该被调用恰好一次，而且要返回种类为 $A$ 的蘑菇的个数。\n\n以上函数可以调用以下函数：\n\n```cpp line-numbers\nint use_machine(vector<int> x)\n```\n\n- `x`: 一个长度介于 $2$ 和 $n$ 的数组（包括 $2$ 和 $n$)，按顺序给出放在机器中的蘑菇的编号。\n- `x` 的元素必须是在 $0$ 到 $n-1$ 之间（包括 $0$ 和 $n-1$) **互不相同** 的整数。\n- 假设数组 `x` 的长度为 $d$。那么，此函数返回不同的下标 $j$ 的个数，满足 $0 \\le j \\le d-2$ 并且 $x[j]$ 和 $x[j+1]$ 属于不同种类。\n- 该函数最多可以被调用 $2 \\times 10^4$ 次。\n- 在对函数 `use_machine` 的所有调用中，所有被传到该函数 `use_machine` 的 $x$ 的总长度不能超过 $10^5$。", "inputFormat": null, "outputFormat": null, "hint": "#### 样例说明\n\n#### 例 1\n\n考虑以下场景：有 $3$ 个蘑菇，种类依次为 $\\left[A,B,B\\right]$。函数 `count_mushrooms` 用以下方式调用：\n\n```cpp line-numbers\ncount_mushrooms(3)\n```\n\n该函数可以调用 `use_machine([0, 1, 2])`，在该场景下调用返回 $1$。函数接着调用 `use_machine([2, 1])`，该调用返回 $0$。\n\n此时，已经有足够的信息来推出只有 $1$ 个 $A$ 类蘑菇。所以，函数 `count_mushrooms` 应该返回 $1$。\n\n#### 例 2\n\n考虑一个例子：有 $4$ 个蘑菇，种类依次为 $\\left[A,B,A,A\\right]$。函数 `count_mushrooms` 被调用如下：\n\n```cpp line-numbers\ncount_mushrooms(4)\n```\n\n该函数可以调用 `use_machine([0, 2, 1, 3])`，该调用返回 $2$。接着调用 `use_machine([1,2])`，该调用返回 $1$。\n\n此时，已有足够的信息推出：有 $3$ 个 $A$ 类蘑菇。因此，函数 `count_mushrooms` 应该返回 $3$。\n\n#### 约束条件\n\n- $2 \\le n \\le 2 \\times 10^4$\n\n#### 计分\n\n在所有测试用例中，如果对函数 `use_machine` 的调用不符合上面所述的要求，或者 `count_mushrooms` 的返回值不正确，你的解答得分将为 $0$。否则，令 $Q$ 为所有测试样例中对函数 `use_machine` 的最大调用次数。那么，得分将按照以下表格进行计算：\n\n|条件|得分|\n|:-:|:-:|\n|$2 \\times 10^4 \\le Q$|$0$|\n|$10010 < Q \\le 2 \\times 10^4$|$10$|\n|$904 < Q \\le 10010$|$25$|\n|$226 < Q \\le 904$|$\\dfrac{226}{Q} \\cdot 100$|\n|$Q \\le 226$|$100$|\n\n在有些测试用例上，评测程序的行为是自适应的。也就是说，在这些测试用例中，评测程序并没有一个固定的蘑菇种类序列。相反，评测程序中所给出的回答可能依赖于此前对 `use_machine` 的调用。\n\n但是可以保证，评测程序中所给出的回答满足：在每次交互之后，至少存在一个蘑菇种类序列，它能够与当前所给出过的所有回答都相符。\n\n#### 评测程序示例\n\n评测程序示例读入一个整数数组 $s$，该数组给出了蘑菇的种类。对于所有 $0 \\le i \\le n-1$，$s[i]=0$ 表示蘑菇 $i$ 的种类是 $A$，$s[i]=1$ 表示蘑菇 $i$ 的种类是 $B$。评测程序示例读取如下格式的输入数据：\n\n第 $1$ 行: $n$ \\\n第 $2$ 行: $s[0]\\ s[1]\\ \\ldots\\ s[n-1]$\n\n评测程序示例的输出为如下格式：\n\n第 $1$ 行: `count_mushrooms` 的返回值。 \\\n第 $2$ 行: 调用 `use_machine` 的次数。\n\n注意评测程序示例不是自适应的。", "locale": "zh-CN"}}}
{"pid": "P6838", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "IOI", "Special Judge", "深度优先搜索 DFS", "通信题"], "title": "[IOI 2020] 网络站点（无法评测）", "background": null, "description": "新加坡的互联网主干网由 $n$ 个网络站点组成，这些站点分配了从 $0$ 到 $n-1$ 的 **序号**。互联网中还有 $n-1$ 条双向链路，它们从 $0$ 到 $n-2$ 编号。每条链路连接两个不同的站点。被一条链路连接着的两个站点互相称作对方的邻居。\n\n一个由互不相同的站点所组成的站点序列 $a_0,a_1,\\ldots,a_p$ 被称作一条从站点 $x$ 到站点 $y$ 的路径，当且仅当 $a_0=x$，$a_p=y$，并且序列中每两个连续的站点都是邻居。保证从任意站点 $x$ 到任意其他站点 $y$ **有且仅有** 一条路径。\n\n任意站点 $x$ 可以生成一个数据包，并把它发送给任意其他站点 $y$，站点 $y$ 称作这个数据包的 **目的站点**。数据包需要按下述规则在站点 $x$ 到站点 $y$ 的唯一路径上进行路由。假设数据包当前发送到了站点 $z$，其中 $y$ 是数据包的目的站点且 $z \\ne y$，则站点 $z$ 会：\n\n1. 执行 **路由函数**，找到 $z$ 到 $y$ 的唯⼀路径中 $z$ 的邻居。然后\n2. 将数据包转发给这个邻居。\n\n然而，站点有存储内存限制，可能无法存下路由函数中需要使用的完整的主干网链路列表。\n\n你的任务是实现主干网的路由机制，它由两个函数组成。\n\n- 第一个函数的输入参数为 $n$、主干网链路的列表和一个整数 $k \\ge n-1$。该函数需要为每个站点分配一个独一无二的 **编号**，其大小在 $0$ 到 $k$ 之间（包括 $0$ 和 $k$）。\n- 第二个函数是路由函数，它在站点编号分配好后部署到所有站点上。它的输入参数如下：\n\t- $s$，数据包当前所处的站点的 **编号**，\n\t- $t$，数据包的目的站点的 **编号** $(t \\ne s)$，\n\t- $c$，表示 $s$ 的所有邻居站点的 **编号** 的列表。\n\n该函数应该返回一个 $s$ 的邻居的 **编号**，表示数据包需要转发到的下个站点。\n\n在每个子任务中，你的得分取决于所有站点被分配到的编号的最大值（通常来说，编号最大值越小越好）。\n\n#### 实现细节\n\n你需要实现下列函数：\n\n```cpp\nint[] label(int n, int k, int[] u, int[] v)\n```\n\n- $n$: 主干网中站点的数量。\n- $k$: 可用的编号的最大值。\n- $u$ 和 $v$: 大小为 $n-1$ 的数组，表示链路。对每个 $i(0 \\le i \\le n-2)$，链路 $i$ 连接着序号为 $u[i]$ 和 $v[i]$ 的站点。\n- 该函数应该返回一个大小为 $n$ 的数组 $L$。对每个 $i(0 \\le i \\le n-1)$，$L[i]$ 表示序号为 $i$ 的站点所分配到的编号。数组 $L$ 中的所有元素必须互不相同并且大小在 $0$ 到 $k$ 之间。\n\n```cpp\nint find_next_station(int s, int t, int[] c)\n```\n\n- $s$: 数据包当前所在站点的编号。\n- $t$: 数据包目的站点的编号。\n- $c$: 一个数组，包含 $s$ 的所有邻居的编号。数组 $c$ 按照元素大小升序排列。\n- 该函数应该返回一个 $s$ 的邻居的编号，表示数据包需要转发到的下个站点。\n\n每个测试用例包含一个或多个独立的场景（也就是不同的主干网描述）。 对于一个包含 $r$ 个场景的测试用例，调用上述函数的评测程序会按下列步骤运行恰好两次。\n\n程序第一次运行期间：\n\n- `label` 函数被调用 $r$ 次。\n- 返回的编号将被评测系统保存。\n- 并且 `find_next_station` 不会被调用。\n\n程序第二次运行期间：\n\n- `find_next_station` 会被调用若干次。对于每次调用，评测程序会选择任意某个场景，该场景中的 `label` 函数所返回的编号方式将用于本次 `find_next_station` 调用。\n- `label` 不会被调用。\n- 特别地，在评测程序第一次运行期间，保存在静态或全局变量中的信息将无法在 `find_next_station` 函数中使用。", "inputFormat": null, "outputFormat": null, "hint": "#### 样例说明\n\n#### 例 1\n\n考虑下列调用：\n\n```cpp\nlabel(5, 10, [0, 1, 1, 2], [1, 2, 3, 4])\n```\n\n共有 $5$ 个站点和 $4$ 条链路，链路对应的站点序号对分别为 $(0,1)$, $(1,2)$, $(1,3)$ 和 $(2,4)$。编号的大小范围为 $0$ 到 $k=10$。\n\n为了返回下列编号方案：\n\n|序号|编号|\n|:-:|:-:|\n|$0$| $6$|\n|$1$| $2$|\n|$2$|$9$|\n|$3$ |$3$|\n|$4$ |$7$|\n\n函数 `label` 应该返回 $[6,2,9,3,7]$。下图中的数字表示站点的序号（左图）与分配到的编号（右图）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xpq3km1p.png)\n\n假设编号按照上图所示进行分配，考虑下列的调用：\n\n```cpp\nfind_next_station(9, 6, [2, 7])\n```\n\n它表示数据包当前所处的站点编号为 $9$，其目的站点的编号为 $6$。从当前站点到目的站点的路径上，站点编号依次为 $[9,2,6]$。因此，函数应该返回 $2$，表示数据包应该转发给编号为 $2$ 的站点（其序号为 $1$）。\n\n考虑另一个可能的调用：\n\n```cpp\nfind_next_station(2, 3, [3, 6, 9])\n  ```\n该函数应该返回 $3$，因为目的站点（编号 $3$）是当前站点（编号 $2$）的邻居，因此目的站点直接接收到了数据包。\n\n#### 约束条件\n\n- $1 \\le r \\le 10$\n\n对于 `label` 的每次调用：\n\n- $2 \\le n \\le 1000$\n- $k \\ge n-1$\n- $0 \\le u[i],v[i] \\le n-1$（对于所有 $0 \\le i \\le n-2$）\n\n对于 `find_next_station` 的每次调用，其输入参数来自于任意选择的某次之前对 `label` 的调用。考虑它所产生的编号，\n\n- $s$ 和 $t$ 是两个不同站点的编号。\n- $c$ 是编号为 $s$ 的站点的所有邻居的编号的序列，升序排列。\n\n对于每个测试用例，所有场景加到⼀起，传递给函数  `find_next_station` 的所有数组 $c$ 的总长度不超过 $10^5$。\n\n#### 子任务\n\n1. （5 分）$k=1000$，不会出现拥有多于 $2$ 个邻居的站点。\n2. （8 分）$k=1000$，链路 $i$ 连接站点 $i+1$ 和 $\\lfloor\\frac{i}{2}\\rfloor$。\n3. （16 分）$k=10^6$，最多一个站点拥有多于 $2$ 个的邻居。\n4. （10 分）$n \\le 8$，$k = 10^9$\n5. （61 分）$k = 10^9$\n\n在子任务 5 中，你可以获得部分分。 令 $m$ 为所有场景中 `label` 返回的最大编号。 对于这个子任务，你的得分将根据下表计算得到：\n\n|最大编号|得分|\n|:-:|:-:|\n|$m \\ge 10^9$|$0$|\n|$2000 \\le m < 10^9$|$50 \\cdot \\log_{5 \\cdot10^5}(\\frac{10^9}{m})$|\n|$1000 < m < 5000$|$50$|\n|$m \\le 1000$|$61$|\n\n#### 评测程序示例\n\n评测程序示例以如下格式读取输入数据：\n\n第 $1$ 行：$r$\n\n接下来是 $r$ 块内容，每块描述了一个单独的场景，格式如下：\n\n第 $1$ 行：$n\\ k$        \n第 $2+i(0 \\le i \\le n-2)$ 行：$u[i]\\ v[i]$         \n第 $1+n$ 行：$q$，`find_next_station` 的调用次数    \n第 $2+n+j(0 \\le j \\le q-1)$ 行：$z[j]\\ y[j]\\ w[j]$，第 $j$ 次调用 `find_next_station` 时所涉及的站点的 **序号**。此时，数据包在站点 $z[j]$，目的站点为 $y[j]$，应该要转发给站点 $w[j]$。\n\n评测程序示例以如下格式打印你的结果：\n\n第 $1$ 行：$m$\n\n接下来是 $r$ 块内容，分别对应输入中的场景。每块的格式如下：\n\n第 $1+j(0 \\le j \\le q-1)$ 行：站点的 **序号**，它所对应的 **编号** 是第 $j$ 次调用 `find_next_station` 时返回的结果。\n\n注意：评测程序示例每次执行时会同时调用 `label` 和 `find_next_station`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2020] 网络站点（无法评测）", "background": null, "description": "新加坡的互联网主干网由 $n$ 个网络站点组成，这些站点分配了从 $0$ 到 $n-1$ 的 **序号**。互联网中还有 $n-1$ 条双向链路，它们从 $0$ 到 $n-2$ 编号。每条链路连接两个不同的站点。被一条链路连接着的两个站点互相称作对方的邻居。\n\n一个由互不相同的站点所组成的站点序列 $a_0,a_1,\\ldots,a_p$ 被称作一条从站点 $x$ 到站点 $y$ 的路径，当且仅当 $a_0=x$，$a_p=y$，并且序列中每两个连续的站点都是邻居。保证从任意站点 $x$ 到任意其他站点 $y$ **有且仅有** 一条路径。\n\n任意站点 $x$ 可以生成一个数据包，并把它发送给任意其他站点 $y$，站点 $y$ 称作这个数据包的 **目的站点**。数据包需要按下述规则在站点 $x$ 到站点 $y$ 的唯一路径上进行路由。假设数据包当前发送到了站点 $z$，其中 $y$ 是数据包的目的站点且 $z \\ne y$，则站点 $z$ 会：\n\n1. 执行 **路由函数**，找到 $z$ 到 $y$ 的唯⼀路径中 $z$ 的邻居。然后\n2. 将数据包转发给这个邻居。\n\n然而，站点有存储内存限制，可能无法存下路由函数中需要使用的完整的主干网链路列表。\n\n你的任务是实现主干网的路由机制，它由两个函数组成。\n\n- 第一个函数的输入参数为 $n$、主干网链路的列表和一个整数 $k \\ge n-1$。该函数需要为每个站点分配一个独一无二的 **编号**，其大小在 $0$ 到 $k$ 之间（包括 $0$ 和 $k$）。\n- 第二个函数是路由函数，它在站点编号分配好后部署到所有站点上。它的输入参数如下：\n\t- $s$，数据包当前所处的站点的 **编号**，\n\t- $t$，数据包的目的站点的 **编号** $(t \\ne s)$，\n\t- $c$，表示 $s$ 的所有邻居站点的 **编号** 的列表。\n\n该函数应该返回一个 $s$ 的邻居的 **编号**，表示数据包需要转发到的下个站点。\n\n在每个子任务中，你的得分取决于所有站点被分配到的编号的最大值（通常来说，编号最大值越小越好）。\n\n#### 实现细节\n\n你需要实现下列函数：\n\n```cpp\nint[] label(int n, int k, int[] u, int[] v)\n```\n\n- $n$: 主干网中站点的数量。\n- $k$: 可用的编号的最大值。\n- $u$ 和 $v$: 大小为 $n-1$ 的数组，表示链路。对每个 $i(0 \\le i \\le n-2)$，链路 $i$ 连接着序号为 $u[i]$ 和 $v[i]$ 的站点。\n- 该函数应该返回一个大小为 $n$ 的数组 $L$。对每个 $i(0 \\le i \\le n-1)$，$L[i]$ 表示序号为 $i$ 的站点所分配到的编号。数组 $L$ 中的所有元素必须互不相同并且大小在 $0$ 到 $k$ 之间。\n\n```cpp\nint find_next_station(int s, int t, int[] c)\n```\n\n- $s$: 数据包当前所在站点的编号。\n- $t$: 数据包目的站点的编号。\n- $c$: 一个数组，包含 $s$ 的所有邻居的编号。数组 $c$ 按照元素大小升序排列。\n- 该函数应该返回一个 $s$ 的邻居的编号，表示数据包需要转发到的下个站点。\n\n每个测试用例包含一个或多个独立的场景（也就是不同的主干网描述）。 对于一个包含 $r$ 个场景的测试用例，调用上述函数的评测程序会按下列步骤运行恰好两次。\n\n程序第一次运行期间：\n\n- `label` 函数被调用 $r$ 次。\n- 返回的编号将被评测系统保存。\n- 并且 `find_next_station` 不会被调用。\n\n程序第二次运行期间：\n\n- `find_next_station` 会被调用若干次。对于每次调用，评测程序会选择任意某个场景，该场景中的 `label` 函数所返回的编号方式将用于本次 `find_next_station` 调用。\n- `label` 不会被调用。\n- 特别地，在评测程序第一次运行期间，保存在静态或全局变量中的信息将无法在 `find_next_station` 函数中使用。", "inputFormat": null, "outputFormat": null, "hint": "#### 样例说明\n\n#### 例 1\n\n考虑下列调用：\n\n```cpp\nlabel(5, 10, [0, 1, 1, 2], [1, 2, 3, 4])\n```\n\n共有 $5$ 个站点和 $4$ 条链路，链路对应的站点序号对分别为 $(0,1)$, $(1,2)$, $(1,3)$ 和 $(2,4)$。编号的大小范围为 $0$ 到 $k=10$。\n\n为了返回下列编号方案：\n\n|序号|编号|\n|:-:|:-:|\n|$0$| $6$|\n|$1$| $2$|\n|$2$|$9$|\n|$3$ |$3$|\n|$4$ |$7$|\n\n函数 `label` 应该返回 $[6,2,9,3,7]$。下图中的数字表示站点的序号（左图）与分配到的编号（右图）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xpq3km1p.png)\n\n假设编号按照上图所示进行分配，考虑下列的调用：\n\n```cpp\nfind_next_station(9, 6, [2, 7])\n```\n\n它表示数据包当前所处的站点编号为 $9$，其目的站点的编号为 $6$。从当前站点到目的站点的路径上，站点编号依次为 $[9,2,6]$。因此，函数应该返回 $2$，表示数据包应该转发给编号为 $2$ 的站点（其序号为 $1$）。\n\n考虑另一个可能的调用：\n\n```cpp\nfind_next_station(2, 3, [3, 6, 9])\n  ```\n该函数应该返回 $3$，因为目的站点（编号 $3$）是当前站点（编号 $2$）的邻居，因此目的站点直接接收到了数据包。\n\n#### 约束条件\n\n- $1 \\le r \\le 10$\n\n对于 `label` 的每次调用：\n\n- $2 \\le n \\le 1000$\n- $k \\ge n-1$\n- $0 \\le u[i],v[i] \\le n-1$（对于所有 $0 \\le i \\le n-2$）\n\n对于 `find_next_station` 的每次调用，其输入参数来自于任意选择的某次之前对 `label` 的调用。考虑它所产生的编号，\n\n- $s$ 和 $t$ 是两个不同站点的编号。\n- $c$ 是编号为 $s$ 的站点的所有邻居的编号的序列，升序排列。\n\n对于每个测试用例，所有场景加到⼀起，传递给函数  `find_next_station` 的所有数组 $c$ 的总长度不超过 $10^5$。\n\n#### 子任务\n\n1. （5 分）$k=1000$，不会出现拥有多于 $2$ 个邻居的站点。\n2. （8 分）$k=1000$，链路 $i$ 连接站点 $i+1$ 和 $\\lfloor\\frac{i}{2}\\rfloor$。\n3. （16 分）$k=10^6$，最多一个站点拥有多于 $2$ 个的邻居。\n4. （10 分）$n \\le 8$，$k = 10^9$\n5. （61 分）$k = 10^9$\n\n在子任务 5 中，你可以获得部分分。 令 $m$ 为所有场景中 `label` 返回的最大编号。 对于这个子任务，你的得分将根据下表计算得到：\n\n|最大编号|得分|\n|:-:|:-:|\n|$m \\ge 10^9$|$0$|\n|$2000 \\le m < 10^9$|$50 \\cdot \\log_{5 \\cdot10^5}(\\frac{10^9}{m})$|\n|$1000 < m < 5000$|$50$|\n|$m \\le 1000$|$61$|\n\n#### 评测程序示例\n\n评测程序示例以如下格式读取输入数据：\n\n第 $1$ 行：$r$\n\n接下来是 $r$ 块内容，每块描述了一个单独的场景，格式如下：\n\n第 $1$ 行：$n\\ k$        \n第 $2+i(0 \\le i \\le n-2)$ 行：$u[i]\\ v[i]$         \n第 $1+n$ 行：$q$，`find_next_station` 的调用次数    \n第 $2+n+j(0 \\le j \\le q-1)$ 行：$z[j]\\ y[j]\\ w[j]$，第 $j$ 次调用 `find_next_station` 时所涉及的站点的 **序号**。此时，数据包在站点 $z[j]$，目的站点为 $y[j]$，应该要转发给站点 $w[j]$。\n\n评测程序示例以如下格式打印你的结果：\n\n第 $1$ 行：$m$\n\n接下来是 $r$ 块内容，分别对应输入中的场景。每块的格式如下：\n\n第 $1+j(0 \\le j \\le q-1)$ 行：站点的 **序号**，它所对应的 **编号** 是第 $j$ 次调用 `find_next_station` 时返回的结果。\n\n注意：评测程序示例每次执行时会同时调用 `label` 和 `find_next_station`。", "locale": "zh-CN"}}}
{"pid": "P6839", "type": "P", "difficulty": 7, "samples": [["2 4 1\nw 1\nha 9", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "各省省选", "北京"], "title": "[BJOI2016] 打字机", "background": "", "description": "小 J 在搬家的过程中发现了一台古老的打字机。 好奇的小 J 决定研究如何使用它。首先，需要将一条长度为 $m$ \n的纸带放入打字机。打字机上共有 26 个按键，分别是小写字母 `a` 到 `z` 。每当你按下一个按键时，打字机\n就会立即在纸带上打印出那个字符，并将纸带平移一个单位距离。聪明的小 J 很快就掌握了这款打字机的使用技巧，并想尝试新的挑战。\n\n他拿出了一本字典，挑选了 $n$ 个单词，并给每个单词设定了分数。纸带中每出现一次指定的单词，就会得到对应的分数。例如， 单词 `eye` 的分数为 $2$， `year` 的分数为 $3$，那么纸带 `eyeyeyear` 的分数为 $9$ 分。小 J 希望挑战自己，打出分数最高的纸带。\n\n特别地，小 J 偶尔会手抖，按到自己不想输入的字符。由于这台古老的打字机没有退格（删除）功能，所以小 J 只能接受按错这个事实，重新规划在按错的情况下如何得最高分。倘若小 J 有可能在任意位置按错按键，并保证整个过程中按错的次数不超过 $k$ 次，那么请你算出他在最坏情况下的最高得分是多少。", "inputFormat": "第一行包含 3 个非负整数 $n, m, k$，分别表示单词数量、纸带长度和最多按错次数。\n\n接下来 $n$ 行，每行为一个字符串 $S$ 和正整数 $a_i$，由空格隔开，描述一个单词及其得分。", "outputFormat": "仅一行，包含一个整数，表示最坏情况下的最大得分。", "hint": "【样例解释】\n\n以下是一种错误思路：\n\n\"共 $4$ 种情况，即第 $1$ 位按错、第 $2$ 位按错、第 $3$ 位按错和第 $4$ 位按错。\n1. 第 $1$ 位按错（不妨假设按成 `x`，下同），最高得分为 `xwha`，得分为 $10$。\n2. 第 $2$ 位按错，最高得分为 `wxha`，同样为 $10$ 分。\n3. 第 $3$ 位按错，最高得分为 `haxw`，同样为 $10$ 分。\n4. 第 $4$ 位按错，最高得分为 `hawx`，同样为 $10$ 分。\n\n综上，最坏情况下最高得分为 $10$ 分。\"\n\n这种思路的错误之处在于，你不能根据哪一位按错决定你第一位按哪个键。 换种说法，你在哪一位按错，是在按下那个按键之后才能知道的事情。 正确的思路如下：\n\n1. 第 $1$ 位先按 `h`，倘若按对， 跳至 2，倘若按错， 跳至 4；\n2. 第 $2$ 位按 `a`，倘若按对， 跳至 3，倘若按错， 跳至 5；\n3. 第 $3$ 位和第 $4$ 位都按 `w`， 结束。 至多错 1 次，最终纸带为 `hawx` 或 `haxw`，得分为 $10$ 分。\n4. 后面三位依次按 `haw`， 结束。 因为不会再错， 最终纸带为 `xhaw`，得分为 $10$ 分。\n5. 后面两位依次按 `ha`， 结束。因为不会再错， 最终纸带为 `hxha`，得分为 $9$ 分。\n\n综上，最坏情况下，最高得分为 $9$ 分。\n\n【数据范围】\n\n测试点 $1,2$ 满足，$n = 1$ 或 $k = 0$；\n\n测试点 $1\\sim 6$ 满足，$n ≤ 100$，$m ≤ 500$，$∑|S| ≤ 500$，$a_i ≤1000$；\n\n测试点 $7,8$ 满足，$k = 0$，$∑|S| ≤ 200$；\n\n测试点 $9,10$ 满足，$∑|S| ≤ 50$，$a_i ≤1$。\n\n对于 $100\\%$ 的数据，$n ≤ 100$，$m ≤ 10^9$ ，$∑|S| ≤ 500$，$a_i ≤1000$，$k ≤ 5$。**请注意，每一个测试点都有相应特殊性质。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BJOI2016] 打字机", "background": "", "description": "小 J 在搬家的过程中发现了一台古老的打字机。 好奇的小 J 决定研究如何使用它。首先，需要将一条长度为 $m$ \n的纸带放入打字机。打字机上共有 26 个按键，分别是小写字母 `a` 到 `z` 。每当你按下一个按键时，打字机\n就会立即在纸带上打印出那个字符，并将纸带平移一个单位距离。聪明的小 J 很快就掌握了这款打字机的使用技巧，并想尝试新的挑战。\n\n他拿出了一本字典，挑选了 $n$ 个单词，并给每个单词设定了分数。纸带中每出现一次指定的单词，就会得到对应的分数。例如， 单词 `eye` 的分数为 $2$， `year` 的分数为 $3$，那么纸带 `eyeyeyear` 的分数为 $9$ 分。小 J 希望挑战自己，打出分数最高的纸带。\n\n特别地，小 J 偶尔会手抖，按到自己不想输入的字符。由于这台古老的打字机没有退格（删除）功能，所以小 J 只能接受按错这个事实，重新规划在按错的情况下如何得最高分。倘若小 J 有可能在任意位置按错按键，并保证整个过程中按错的次数不超过 $k$ 次，那么请你算出他在最坏情况下的最高得分是多少。", "inputFormat": "第一行包含 3 个非负整数 $n, m, k$，分别表示单词数量、纸带长度和最多按错次数。\n\n接下来 $n$ 行，每行为一个字符串 $S$ 和正整数 $a_i$，由空格隔开，描述一个单词及其得分。", "outputFormat": "仅一行，包含一个整数，表示最坏情况下的最大得分。", "hint": "【样例解释】\n\n以下是一种错误思路：\n\n\"共 $4$ 种情况，即第 $1$ 位按错、第 $2$ 位按错、第 $3$ 位按错和第 $4$ 位按错。\n1. 第 $1$ 位按错（不妨假设按成 `x`，下同），最高得分为 `xwha`，得分为 $10$。\n2. 第 $2$ 位按错，最高得分为 `wxha`，同样为 $10$ 分。\n3. 第 $3$ 位按错，最高得分为 `haxw`，同样为 $10$ 分。\n4. 第 $4$ 位按错，最高得分为 `hawx`，同样为 $10$ 分。\n\n综上，最坏情况下最高得分为 $10$ 分。\"\n\n这种思路的错误之处在于，你不能根据哪一位按错决定你第一位按哪个键。 换种说法，你在哪一位按错，是在按下那个按键之后才能知道的事情。 正确的思路如下：\n\n1. 第 $1$ 位先按 `h`，倘若按对， 跳至 2，倘若按错， 跳至 4；\n2. 第 $2$ 位按 `a`，倘若按对， 跳至 3，倘若按错， 跳至 5；\n3. 第 $3$ 位和第 $4$ 位都按 `w`， 结束。 至多错 1 次，最终纸带为 `hawx` 或 `haxw`，得分为 $10$ 分。\n4. 后面三位依次按 `haw`， 结束。 因为不会再错， 最终纸带为 `xhaw`，得分为 $10$ 分。\n5. 后面两位依次按 `ha`， 结束。因为不会再错， 最终纸带为 `hxha`，得分为 $9$ 分。\n\n综上，最坏情况下，最高得分为 $9$ 分。\n\n【数据范围】\n\n测试点 $1,2$ 满足，$n = 1$ 或 $k = 0$；\n\n测试点 $1\\sim 6$ 满足，$n ≤ 100$，$m ≤ 500$，$∑|S| ≤ 500$，$a_i ≤1000$；\n\n测试点 $7,8$ 满足，$k = 0$，$∑|S| ≤ 200$；\n\n测试点 $9,10$ 满足，$∑|S| ≤ 50$，$a_i ≤1$。\n\n对于 $100\\%$ 的数据，$n ≤ 100$，$m ≤ 10^9$ ，$∑|S| ≤ 500$，$a_i ≤1000$，$k ≤ 5$。**请注意，每一个测试点都有相应特殊性质。**", "locale": "zh-CN"}}}
{"pid": "P6840", "type": "P", "difficulty": 5, "samples": [["6 9 2.5 9\n0.0 5.0 0.0 1\n0.0 0.0 -5.0 0\n0.0 -5.0 0.0 0\n0.0 0.0 5.0 0\n3.0 4.0 0.0 0\n4.0 3.0 0.0 1\n1 2 5\n2 3 8\n1 4 5\n4 3 5\n1 5 1\n5 6 9\n5 2 1\n2 6 2\n6 4 4\n1 3", "12.5663706144"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "2009", "Special Judge", "最短路", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2009] year2012 - A New Beginning", "background": "[英文题面](/problem/U126972) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)\n\n本题官方题解最大点时间 1.56s，故本题时间限制 2s。", "description": "一次极端的太阳爆发使地球升温，造成了一场巨大的灾难。地壳板块在地幔中自由浮动；震级未知的地震正在导致大都市倒塌；山峦被巨大的海啸淹没；各国正转向熔岩和火山灰的海洋。\n\n现在是 $2012$ 年 $12$ 月 $21$ 日，你唯一能让你和你的家人免于世界末日的机会就是登上喜马拉雅山的政府船，这是拯救人类的现代方舟。你有一架匀速飞行的飞机和一张有所有固定机场的地图。不幸的是，并不是所有的机场都连接在一起——巨大的火山灰云阻塞了一些航线，而其他机场却相距太远。此外，并不是所有的机场都有燃料供应——有些机场除了光秃秃的道路什么都没有留下——而且在那里你无法给飞机加油。由于所有的导航手段都被摧毁了，两个机场之间唯一可能的路径就是最短的一条。最重要的是，由于大气不稳定和空气密度的急剧变化，发动机的燃油效率在飞行中会有所不同。因此油耗也不同。好的新情况是你知道在哪一个机场可以飞行，所需的燃料量，以及你可以在哪里加油。你所要做的就是想办法尽快从机场到喜马拉雅山的机场。编写一个 `year2012` 程序，根据每个机场的坐标、是否有燃油、飞机的油箱容量、飞机的速度、一个潜在的航班连接的几对机场以及每一次飞行需要多少燃料，计算完成这项任务所需的最短时间。", "inputFormat": "从标准输入读入。\n\n第一行四个整数（译者注：可以看到样例并没有严格遵守此规则，具体的数据范围建议以【提示说明】中的为准，下同）$N,M,V,C$，分别表示机场数量、可用航线数量、飞机恒定速度和油箱容量。\n\n接下来 $N$ 行，每行由三个实数 $X_i,Y_i,Z_i$ 和一个布尔值 $R_i$ 组成。三个实数表示 $i$ 号机场的空间坐标， $R_i=0$ 表示不能在这个机场加油，$R_i=1$ 表示可以加油。\n\n接下来 $M$ 行，每行三个整数 $A_k,B_k,F_k$，表示这条航线的两端和花费的燃油量。每条航线都是双向的。\n\n最后一行两个整数 $S,T$，表示路线上第一个和最后一个机场。", "outputFormat": "输出到标准输出。\n\n一行，一个实数，表示从 $S$ 到 $T$ 的最短时间。如果你的答案与标准答案的绝对误差不超过 $10^{-4}$，你的答案将被认为是正确的。\n\n如果你无法到达目的地，输出 $0$。", "hint": "**数据范围**\n\n- 机场数量 $N\\in\\left[2,10^3\\right]\\cap\\Z$。\n- 可用航线数量 $M\\in\\left[1,10^4\\right]\\cap\\Z$。\n- 飞机恒定速度 $V\\in\\left[1,10^3\\right]$ 为小数点后最多 $3$ 位的实数。\n- 油箱容量 $C\\in\\left[1,10^3\\right]\\cap\\Z$。\n- 机场空间坐标 $X_i, Y_i, Z_i\\in\\left[-100,100\\right]$，为小数点后最多 $18$ 位的实数。另外，保证 $X_i^2+Y_i^2+Z_i^2$ 对于所有 $i$ 均相同。换句话说，对于一个测试数据，所有的机场距离地心的距离均相同。\n- 可以加油的机场数量 $\\in\\left[1,20\\right]\\cap\\Z$。\n- 地球半径为不小于 $1$ 的整数。\n- 航线的两端 $A_k, B_k\\in\\left[1,N\\right]\\cap\\Z$ 且 $A_k\\ne B_k$。满足同一条航线只会出现一次。\n- 航线花费的油量 $F_k\\in\\left[1,C\\right]\\cap\\Z$。\n\n**备注**\n\n- 一条航线的距离为球体上最短的弧。这种弧可能有很多个，但是我们只关心距离。\n- 所有航线距离均不小于 $10^{-6}$。\n- 由于实数运算可能的精度误差，每个机场到地心的距离可能略有不同。但是数据保证所有距离的绝对误差不超过 $10^{-10}$，因此算法的正确性不受影响。\n- $R_s = 1$，这意味着飞机的油箱初始是满的。每次路过一个可以加油的机场，油箱将会再次加满。\n- 飞机降落、加油、起飞、加速的过程可以被忽略，即认为是 $0$。\n- 所有可用的航线都是彼此独立的。这意味着如果有航线从 $A$ 到 $B$，路过 $C$，这不代表有从 $A$ 到 $C$、或从 $B$ 到 $C$ 的可用航线。\n\n**部分分**\n\n对于 $40\\%$ 的数据，$N\\le 8$.\n\n---\n\n**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ae9vdygi.png)\n\n地球的半径为 $5$。飞机速度为 $2.5$，油箱容量为 $9$。我们想要从 $1$ 到 $3$。如图，黑实线代表可用的航线，机场编号在矩形的内部，油量花费在黑实线边上备注。我们可以加油的机场的点是空心的。显然，我们不能直接通过 $1\\rightarrow 2\\rightarrow 3$ 或者 $1\\rightarrow 4\\rightarrow 3$——它们的油量花费分别为 $13$ 和 $10$，超过了油箱的最大容量。事实上，所有路线都花费了大于 $9$ 的燃油，因此我们必须经过 $6$ 号机场。我们有三条可能的路线：$1\\rightarrow 2\\rightarrow 6$、$1\\rightarrow 4\\rightarrow 6$ 和 $1\\rightarrow 5\\rightarrow 2\\rightarrow 6$。前两种显然是最短的两个（航线 $1\\rightarrow 2$、$5\\rightarrow 2$、$2\\rightarrow 6$、$1\\rightarrow 4$ 和 $4\\rightarrow 6$ 花费同样长的时间）。在我们在 $6$ 号机场加满油后，如果我们前往 $2$ 号机场，我们依然不能到达目的地——我们缺少一个单位的燃油。为一可行的路线是通过 $4$，然后花光所有燃油到达 $3$。最后，我们可选的路线有 $1\\rightarrow 2\\rightarrow 6\\rightarrow 4\\rightarrow 3$ 和 $1\\rightarrow 4\\rightarrow 6\\rightarrow 4\\rightarrow 3$。他们都有四个直角弯，因此它们的总长度相等，都等于地球的赤道周长，或 $2\\pi R$。因此，花费的时间为 $\\dfrac{2\\pi R}{V}\\approx 12.566370614359172953850573533118$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalkanOI 2009] year2012 - A New Beginning", "background": "[英文题面](/problem/U126972) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)\n\n本题官方题解最大点时间 1.56s，故本题时间限制 2s。", "description": "一次极端的太阳爆发使地球升温，造成了一场巨大的灾难。地壳板块在地幔中自由浮动；震级未知的地震正在导致大都市倒塌；山峦被巨大的海啸淹没；各国正转向熔岩和火山灰的海洋。\n\n现在是 $2012$ 年 $12$ 月 $21$ 日，你唯一能让你和你的家人免于世界末日的机会就是登上喜马拉雅山的政府船，这是拯救人类的现代方舟。你有一架匀速飞行的飞机和一张有所有固定机场的地图。不幸的是，并不是所有的机场都连接在一起——巨大的火山灰云阻塞了一些航线，而其他机场却相距太远。此外，并不是所有的机场都有燃料供应——有些机场除了光秃秃的道路什么都没有留下——而且在那里你无法给飞机加油。由于所有的导航手段都被摧毁了，两个机场之间唯一可能的路径就是最短的一条。最重要的是，由于大气不稳定和空气密度的急剧变化，发动机的燃油效率在飞行中会有所不同。因此油耗也不同。好的新情况是你知道在哪一个机场可以飞行，所需的燃料量，以及你可以在哪里加油。你所要做的就是想办法尽快从机场到喜马拉雅山的机场。编写一个 `year2012` 程序，根据每个机场的坐标、是否有燃油、飞机的油箱容量、飞机的速度、一个潜在的航班连接的几对机场以及每一次飞行需要多少燃料，计算完成这项任务所需的最短时间。", "inputFormat": "从标准输入读入。\n\n第一行四个整数（译者注：可以看到样例并没有严格遵守此规则，具体的数据范围建议以【提示说明】中的为准，下同）$N,M,V,C$，分别表示机场数量、可用航线数量、飞机恒定速度和油箱容量。\n\n接下来 $N$ 行，每行由三个实数 $X_i,Y_i,Z_i$ 和一个布尔值 $R_i$ 组成。三个实数表示 $i$ 号机场的空间坐标， $R_i=0$ 表示不能在这个机场加油，$R_i=1$ 表示可以加油。\n\n接下来 $M$ 行，每行三个整数 $A_k,B_k,F_k$，表示这条航线的两端和花费的燃油量。每条航线都是双向的。\n\n最后一行两个整数 $S,T$，表示路线上第一个和最后一个机场。", "outputFormat": "输出到标准输出。\n\n一行，一个实数，表示从 $S$ 到 $T$ 的最短时间。如果你的答案与标准答案的绝对误差不超过 $10^{-4}$，你的答案将被认为是正确的。\n\n如果你无法到达目的地，输出 $0$。", "hint": "**数据范围**\n\n- 机场数量 $N\\in\\left[2,10^3\\right]\\cap\\Z$。\n- 可用航线数量 $M\\in\\left[1,10^4\\right]\\cap\\Z$。\n- 飞机恒定速度 $V\\in\\left[1,10^3\\right]$ 为小数点后最多 $3$ 位的实数。\n- 油箱容量 $C\\in\\left[1,10^3\\right]\\cap\\Z$。\n- 机场空间坐标 $X_i, Y_i, Z_i\\in\\left[-100,100\\right]$，为小数点后最多 $18$ 位的实数。另外，保证 $X_i^2+Y_i^2+Z_i^2$ 对于所有 $i$ 均相同。换句话说，对于一个测试数据，所有的机场距离地心的距离均相同。\n- 可以加油的机场数量 $\\in\\left[1,20\\right]\\cap\\Z$。\n- 地球半径为不小于 $1$ 的整数。\n- 航线的两端 $A_k, B_k\\in\\left[1,N\\right]\\cap\\Z$ 且 $A_k\\ne B_k$。满足同一条航线只会出现一次。\n- 航线花费的油量 $F_k\\in\\left[1,C\\right]\\cap\\Z$。\n\n**备注**\n\n- 一条航线的距离为球体上最短的弧。这种弧可能有很多个，但是我们只关心距离。\n- 所有航线距离均不小于 $10^{-6}$。\n- 由于实数运算可能的精度误差，每个机场到地心的距离可能略有不同。但是数据保证所有距离的绝对误差不超过 $10^{-10}$，因此算法的正确性不受影响。\n- $R_s = 1$，这意味着飞机的油箱初始是满的。每次路过一个可以加油的机场，油箱将会再次加满。\n- 飞机降落、加油、起飞、加速的过程可以被忽略，即认为是 $0$。\n- 所有可用的航线都是彼此独立的。这意味着如果有航线从 $A$ 到 $B$，路过 $C$，这不代表有从 $A$ 到 $C$、或从 $B$ 到 $C$ 的可用航线。\n\n**部分分**\n\n对于 $40\\%$ 的数据，$N\\le 8$.\n\n---\n\n**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ae9vdygi.png)\n\n地球的半径为 $5$。飞机速度为 $2.5$，油箱容量为 $9$。我们想要从 $1$ 到 $3$。如图，黑实线代表可用的航线，机场编号在矩形的内部，油量花费在黑实线边上备注。我们可以加油的机场的点是空心的。显然，我们不能直接通过 $1\\rightarrow 2\\rightarrow 3$ 或者 $1\\rightarrow 4\\rightarrow 3$——它们的油量花费分别为 $13$ 和 $10$，超过了油箱的最大容量。事实上，所有路线都花费了大于 $9$ 的燃油，因此我们必须经过 $6$ 号机场。我们有三条可能的路线：$1\\rightarrow 2\\rightarrow 6$、$1\\rightarrow 4\\rightarrow 6$ 和 $1\\rightarrow 5\\rightarrow 2\\rightarrow 6$。前两种显然是最短的两个（航线 $1\\rightarrow 2$、$5\\rightarrow 2$、$2\\rightarrow 6$、$1\\rightarrow 4$ 和 $4\\rightarrow 6$ 花费同样长的时间）。在我们在 $6$ 号机场加满油后，如果我们前往 $2$ 号机场，我们依然不能到达目的地——我们缺少一个单位的燃油。为一可行的路线是通过 $4$，然后花光所有燃油到达 $3$。最后，我们可选的路线有 $1\\rightarrow 2\\rightarrow 6\\rightarrow 4\\rightarrow 3$ 和 $1\\rightarrow 4\\rightarrow 6\\rightarrow 4\\rightarrow 3$。他们都有四个直角弯，因此它们的总长度相等，都等于地球的赤道周长，或 $2\\pi R$。因此，花费的时间为 $\\dfrac{2\\pi R}{V}\\approx 12.566370614359172953850573533118$。", "locale": "zh-CN"}}}
{"pid": "P6841", "type": "P", "difficulty": 6, "samples": [["20 10\ne l 3\ne o 1\no n 2\no r 4\nr a 4\ni n 5\ne n 2\nn t 3\nt w 3\nw i 5", "470059518"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2009", "矩阵乘法", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2009] Reading", "background": "[英文题面](/problem/U126973) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)", "description": "有一个关于人脑有趣的事实：在阅读时，它主要分析每个单词的第一个和最后一个字母，而不一定要按照正确的顺序来构造单词。因此，即使一句话基本上没有正确的单词，也可能会被正确的理解。（原文中这段文字的部分单词的字母顺序被打乱，但是译者认为这样会影响阅读，因此没有改变翻译中文字的顺序）\n\nElly 已经注意到，打乱某些字母会得到更好的结果！例如，字母 `l` 和 `i`、`a` 和 `o`、`x` 和 `m` 非常相似。于是她定义了一个字母的值，从 $1$ 到 $5$ 。其中，相似的字母的值较低，而非常不同的字母值较高。等号字母的值是 $1$。通过这种方式，每个单词可以被赋予一个值——相邻字母之间所有值的总和。\n\n想象一下，她把 `e` 和 `l` 的值定义为 $3$，`l` 和 `y` 的值定义为 $2$，`i` 和 `l` 的值定义为 $1$。那么单词 `elly` 的值是 $3+1+2=6$（记住，相邻的相等字母的距离是 $1$）。单词 `lily` 的值为 $4$，而 `i` 的值为 $0$）。长单词的价值不一定比短单词大——比如 `lilii`（保加利亚语中`lily` 的复数形式）——它的值只有 $4$，但 `elle`（法语中的意思是 `she`）的价值是 $7$。但是，每增加一个字母，至少会增加一个单词的值。\n\nEllenora 希望构建一种即使有大量混乱的字母也很容易阅读的语言。求出值不大于 $N$ 的所有非空单词数目。", "inputFormat": "从标准输入读入。\n\n第一行两个整数 $N$ 和 $M$，表示单词的值的最大值（$1\\le N\\le 10^9$）和字符对的数量。Elly 已经定义了一个值。所有未提及的字母对的距离都等于 $1$。接下来的 $M$ 行中的每一行都包含一个三元组 $L_1\\,L_2\\,F$，这意味着字母 $a\\le L_1,L_2\\le z$ 之间的距离为 $1\\le F\\le 5$。从 $L_1$ 到 $L_2$ 的距离与从 $L_2$ 到 $L_1$ 的距离相同，即距离是无序的。", "outputFormat": "输出到标准输出。\n\n一行，一个整数，表示由小写英文字母组成的单词数，满足它的值不大于 $N$。因为这个数量可能非常大，所以你只需要输出它对 $10^9+7$ 取模后的结果。", "hint": "**数据范围**\n\n对于 $50\\%$ 的数据，$N\\le 10^6$。\n\n对于全部数据，$1\\le N\\le 10^9$，每一对字母最多只会出现一次。\n\n---\n\n**样例解释**\n\n一些可行的单词有：`elleonora`、`entwine`、`aaaaaaaaaaaaaaaaaaaaa`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalkanOI 2009] Reading", "background": "[英文题面](/problem/U126973) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)", "description": "有一个关于人脑有趣的事实：在阅读时，它主要分析每个单词的第一个和最后一个字母，而不一定要按照正确的顺序来构造单词。因此，即使一句话基本上没有正确的单词，也可能会被正确的理解。（原文中这段文字的部分单词的字母顺序被打乱，但是译者认为这样会影响阅读，因此没有改变翻译中文字的顺序）\n\nElly 已经注意到，打乱某些字母会得到更好的结果！例如，字母 `l` 和 `i`、`a` 和 `o`、`x` 和 `m` 非常相似。于是她定义了一个字母的值，从 $1$ 到 $5$ 。其中，相似的字母的值较低，而非常不同的字母值较高。等号字母的值是 $1$。通过这种方式，每个单词可以被赋予一个值——相邻字母之间所有值的总和。\n\n想象一下，她把 `e` 和 `l` 的值定义为 $3$，`l` 和 `y` 的值定义为 $2$，`i` 和 `l` 的值定义为 $1$。那么单词 `elly` 的值是 $3+1+2=6$（记住，相邻的相等字母的距离是 $1$）。单词 `lily` 的值为 $4$，而 `i` 的值为 $0$）。长单词的价值不一定比短单词大——比如 `lilii`（保加利亚语中`lily` 的复数形式）——它的值只有 $4$，但 `elle`（法语中的意思是 `she`）的价值是 $7$。但是，每增加一个字母，至少会增加一个单词的值。\n\nEllenora 希望构建一种即使有大量混乱的字母也很容易阅读的语言。求出值不大于 $N$ 的所有非空单词数目。", "inputFormat": "从标准输入读入。\n\n第一行两个整数 $N$ 和 $M$，表示单词的值的最大值（$1\\le N\\le 10^9$）和字符对的数量。Elly 已经定义了一个值。所有未提及的字母对的距离都等于 $1$。接下来的 $M$ 行中的每一行都包含一个三元组 $L_1\\,L_2\\,F$，这意味着字母 $a\\le L_1,L_2\\le z$ 之间的距离为 $1\\le F\\le 5$。从 $L_1$ 到 $L_2$ 的距离与从 $L_2$ 到 $L_1$ 的距离相同，即距离是无序的。", "outputFormat": "输出到标准输出。\n\n一行，一个整数，表示由小写英文字母组成的单词数，满足它的值不大于 $N$。因为这个数量可能非常大，所以你只需要输出它对 $10^9+7$ 取模后的结果。", "hint": "**数据范围**\n\n对于 $50\\%$ 的数据，$N\\le 10^6$。\n\n对于全部数据，$1\\le N\\le 10^9$，每一对字母最多只会出现一次。\n\n---\n\n**样例解释**\n\n一些可行的单词有：`elleonora`、`entwine`、`aaaaaaaaaaaaaaaaaaaaa`。", "locale": "zh-CN"}}}
{"pid": "P6842", "type": "P", "difficulty": 0, "samples": [["7 2\n3 2", "3"], ["9 5\n5 9 2 8 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "数学", "2009", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2009] Strip", "background": "[英文题面](/problem/U126974) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)", "description": "让我们考虑一条宽度为 $1$、长度为 $n$、厚度为可忽略的条带，由单位正方形组成。如图所示（其中 $n=7$），从它的左边开始，我们使用从 $0$ 到 $n$ 的非负整数命名每个垂直的线。我们只能沿着这些垂直线折叠长方形条带，并且在这之后两个部分被粘在一起，不再会被拉直。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j9hdlgas.png)\n\n自然地，在折叠之后，一些编号会重叠在一起，形成一个有更多编号的垂直线。图中显示了沿垂直线 $3$ 折叠后的情况。在此操作之后，有一些线会有两个编号。例如，我们同样可以说 $1$ 或 $5$，他们代表的是同一条垂直线。再沿着 $2$ 折叠（我们也可以说 $4$，都是一样的），就会有一条垂直线有甚至三个名称，正如我们所看到的：$(1;3;5)$。举个例子，如果我们沿着段 $3$ 对长方形条带进行折叠，我们只需旋转条带，而不改变其名称或长度。我们把这样的折叠称为“空的”：它**不是**非法的，只是没有做任何重大的改变。\n\n按照这种方式，一组长度为 $k$ 的整数数列（每个整数从 $0$ 到 $n$）唯一地定义了条带的折叠方法。编写一个程序，找出折叠完成后该条带的长度。", "inputFormat": "从标准输入读入。\n- 第一行两个正整数 $n,k$，表示条带长度和折叠次数。\n- 第二行 $k$ 个非负整数，表示折叠的顺序，每个数都在 $\\left[0,n\\right]$ 的范围内。", "outputFormat": "输出到标准输出。\n\n一行，一个整数，表示折叠后的长度。", "hint": "**数据范围**\n\n$n$ 有不超过 $18$ 个整数位，$k\\le 10000$。\n\n---\n\n**样例 $2$ 解释**\n\n折叠步骤如图：\n\n初始情况：$\\{0\\,1\\,2\\,3\\,4\\,5\\,6\\,7\\,8\\,9\\}$。\n\n折叠步骤：$\\rightarrow \\{0\\,(1;9)\\,(2;8)\\,(3;7)\\,(4;6)\\,5\\}\\rightarrow \\{(1;9)\\,(0;2;8)\\,(3;7)\\,(4;6)\\,5\\}\\rightarrow \\{(0;2;8)\\,(1;3;7;9)\\,(4;6)\\,5\\}\\rightarrow \\{(1;3;7;9)\\,(0;2;4;6;8)\\,5\\}$。\n\n（备注：样例 $1$ 与图片相同）", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalkanOI 2009] Strip", "background": "[英文题面](/problem/U126974) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)", "description": "让我们考虑一条宽度为 $1$、长度为 $n$、厚度为可忽略的条带，由单位正方形组成。如图所示（其中 $n=7$），从它的左边开始，我们使用从 $0$ 到 $n$ 的非负整数命名每个垂直的线。我们只能沿着这些垂直线折叠长方形条带，并且在这之后两个部分被粘在一起，不再会被拉直。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j9hdlgas.png)\n\n自然地，在折叠之后，一些编号会重叠在一起，形成一个有更多编号的垂直线。图中显示了沿垂直线 $3$ 折叠后的情况。在此操作之后，有一些线会有两个编号。例如，我们同样可以说 $1$ 或 $5$，他们代表的是同一条垂直线。再沿着 $2$ 折叠（我们也可以说 $4$，都是一样的），就会有一条垂直线有甚至三个名称，正如我们所看到的：$(1;3;5)$。举个例子，如果我们沿着段 $3$ 对长方形条带进行折叠，我们只需旋转条带，而不改变其名称或长度。我们把这样的折叠称为“空的”：它**不是**非法的，只是没有做任何重大的改变。\n\n按照这种方式，一组长度为 $k$ 的整数数列（每个整数从 $0$ 到 $n$）唯一地定义了条带的折叠方法。编写一个程序，找出折叠完成后该条带的长度。", "inputFormat": "从标准输入读入。\n- 第一行两个正整数 $n,k$，表示条带长度和折叠次数。\n- 第二行 $k$ 个非负整数，表示折叠的顺序，每个数都在 $\\left[0,n\\right]$ 的范围内。", "outputFormat": "输出到标准输出。\n\n一行，一个整数，表示折叠后的长度。", "hint": "**数据范围**\n\n$n$ 有不超过 $18$ 个整数位，$k\\le 10000$。\n\n---\n\n**样例 $2$ 解释**\n\n折叠步骤如图：\n\n初始情况：$\\{0\\,1\\,2\\,3\\,4\\,5\\,6\\,7\\,8\\,9\\}$。\n\n折叠步骤：$\\rightarrow \\{0\\,(1;9)\\,(2;8)\\,(3;7)\\,(4;6)\\,5\\}\\rightarrow \\{(1;9)\\,(0;2;8)\\,(3;7)\\,(4;6)\\,5\\}\\rightarrow \\{(0;2;8)\\,(1;3;7;9)\\,(4;6)\\,5\\}\\rightarrow \\{(1;3;7;9)\\,(0;2;4;6;8)\\,5\\}$。\n\n（备注：样例 $1$ 与图片相同）", "locale": "zh-CN"}}}
{"pid": "P6843", "type": "P", "difficulty": 5, "samples": [["2 4 22\n2\n0 1\n1 5\n2 13\n2 10\n1 4\n0 7", "YES\nYES\nYES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2015", "深度优先搜索 DFS", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] File Paths", "background": "", "description": "一个文件 $\\tt file$ 都需要在一个包含很多文件 $\\tt dir1,dir2,\\cdots,dirj$ 的目录中，这个文件的 absolute file path 为 $\\tt/dir1/dir2/\\cdots/dirj/file$，根目录用 $\\tt /$ 表示，每一个放在根目录下的文件的 absolute file path 的形式为 $\\tt /file$。\n\n符号链接指向一个已被命名的目录，可以看作一个快捷方式，他可以放置在任意目录下，注意，符号链接不能指向文件。比如，我们在 $\\tt /$ 下放一个指向 $\\tt /$ 的符号链接 $\\tt hello$，那么，$\\tt /dir/file$，$\\tt /hello/dir/file$，$\\tt /hello/hello/dir/dile$ 都指向同一个文件 $\\tt file$。另比如，我们在 $\\tt /dir$ 下放一个指向 $\\tt /$ 的符号链接 $\\tt hi$，那么，$\\tt /dir/file$，$\\tt /dir/hi/dir/file$，$\\tt /dir/hi/dir/hi/dir/file$ 都指向同一个文件 $\\tt file$。符号链接指向上一层，下一层，甚至同层都可以，但是不允许 $\\tt ./$，$\\tt ../$，$\\tt //$ 之类的操作。\n\n现在想问，是否能通过引入一个长为 $s$ 的符号链接使得找到一个文件的 absolute file path 长度恰好为 $k$？", "inputFormat": "第一行三个整数 $n,m,k$ 代表除根目录之外的目录数，文件数和要求等于的路径长度。        \n第二行一个整数 $s$ 代表符号链接长。       \n接下来 $n$ 行每行两个整数 $p_i,l_i$ 描述一个目录，这个目录编号为 $l_i$，父目录编号为 $p_i$。        \n接下来 $m$ 行每行两个整数 $p_j,l_j$，描述一个文件，这个文件的长度为 $l_j$，父目录编号为 $p_j$。", "outputFormat": "$m$ 行每行一个字符串代表是否能通过引入一个长为 $s$ 的符号链接使得找到编号为 $j$ 的文件的 absolute file path 长度恰好为 $k$，如果是的话输出 $\\tt YES$，否则输出 $\\tt NO$。", "hint": "#### 样例 1 解释\n\n假设符号链接名字为 $\\tt LL$，目录名字为 $\\tt a$，$\\tt bbbbb$，文件名字为 $\\tt ccccccccccccc$，$\\tt dddddddddd$，$\\tt eee$，$\\tt fffffff$，根目录下包含目录 $\\tt a$ 和文件 $\\tt fffffff$，目录 $\\tt a$ 下包含目录 $\\tt bbbbb$ 和文件 $\\tt eee$，目录 $\\tt bbbbb$ 包含文件 $\\tt ccccccccccccc$ 和 $\\tt dddddddddd$。下面是形象化的表述：\n\n```plain\n/\n|-- a\n| |-- bbbbb\n| | |-- ccccccccccccc\n| | +-- dddddddddd\n| +-- eeee\n+-- fffffff\n```\n\n- 对于第 $1$ 个文件，满足条件的路径为 $\\tt /a/bbbbb/ccccccccccccc$。\n- 对于第 $2$ 个文件，满足条件的路径为 $\\tt /a/LL/bbbbb/dddddddddd$。\n- 对于第 $3$ 个文件，满足条件的路径为 $\\tt /a/LL/a/LL/a/LL/a/eeee$。\n- 对于第 $4$ 个文件，无满足条件的路径。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（33 pts）：$n,m \\le 500$。\n- Subtask 2（33 pts）：$n,m \\le 3 \\times 10^3$，符号链接最多被调用一次。\n- Subtask 3（34 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le k,s \\le 10^6$，$1\\le m,n\\le 3\\times 10^3$。\n\n#### 说明\n\n翻译自 [BalticOI 2015 Day2 A File Paths](https://boi.cses.fi/files/boi2015_day2.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2015] File Paths", "background": "", "description": "一个文件 $\\tt file$ 都需要在一个包含很多文件 $\\tt dir1,dir2,\\cdots,dirj$ 的目录中，这个文件的 absolute file path 为 $\\tt/dir1/dir2/\\cdots/dirj/file$，根目录用 $\\tt /$ 表示，每一个放在根目录下的文件的 absolute file path 的形式为 $\\tt /file$。\n\n符号链接指向一个已被命名的目录，可以看作一个快捷方式，他可以放置在任意目录下，注意，符号链接不能指向文件。比如，我们在 $\\tt /$ 下放一个指向 $\\tt /$ 的符号链接 $\\tt hello$，那么，$\\tt /dir/file$，$\\tt /hello/dir/file$，$\\tt /hello/hello/dir/dile$ 都指向同一个文件 $\\tt file$。另比如，我们在 $\\tt /dir$ 下放一个指向 $\\tt /$ 的符号链接 $\\tt hi$，那么，$\\tt /dir/file$，$\\tt /dir/hi/dir/file$，$\\tt /dir/hi/dir/hi/dir/file$ 都指向同一个文件 $\\tt file$。符号链接指向上一层，下一层，甚至同层都可以，但是不允许 $\\tt ./$，$\\tt ../$，$\\tt //$ 之类的操作。\n\n现在想问，是否能通过引入一个长为 $s$ 的符号链接使得找到一个文件的 absolute file path 长度恰好为 $k$？", "inputFormat": "第一行三个整数 $n,m,k$ 代表除根目录之外的目录数，文件数和要求等于的路径长度。        \n第二行一个整数 $s$ 代表符号链接长。       \n接下来 $n$ 行每行两个整数 $p_i,l_i$ 描述一个目录，这个目录编号为 $l_i$，父目录编号为 $p_i$。        \n接下来 $m$ 行每行两个整数 $p_j,l_j$，描述一个文件，这个文件的长度为 $l_j$，父目录编号为 $p_j$。", "outputFormat": "$m$ 行每行一个字符串代表是否能通过引入一个长为 $s$ 的符号链接使得找到编号为 $j$ 的文件的 absolute file path 长度恰好为 $k$，如果是的话输出 $\\tt YES$，否则输出 $\\tt NO$。", "hint": "#### 样例 1 解释\n\n假设符号链接名字为 $\\tt LL$，目录名字为 $\\tt a$，$\\tt bbbbb$，文件名字为 $\\tt ccccccccccccc$，$\\tt dddddddddd$，$\\tt eee$，$\\tt fffffff$，根目录下包含目录 $\\tt a$ 和文件 $\\tt fffffff$，目录 $\\tt a$ 下包含目录 $\\tt bbbbb$ 和文件 $\\tt eee$，目录 $\\tt bbbbb$ 包含文件 $\\tt ccccccccccccc$ 和 $\\tt dddddddddd$。下面是形象化的表述：\n\n```plain\n/\n|-- a\n| |-- bbbbb\n| | |-- ccccccccccccc\n| | +-- dddddddddd\n| +-- eeee\n+-- fffffff\n```\n\n- 对于第 $1$ 个文件，满足条件的路径为 $\\tt /a/bbbbb/ccccccccccccc$。\n- 对于第 $2$ 个文件，满足条件的路径为 $\\tt /a/LL/bbbbb/dddddddddd$。\n- 对于第 $3$ 个文件，满足条件的路径为 $\\tt /a/LL/a/LL/a/LL/a/eeee$。\n- 对于第 $4$ 个文件，无满足条件的路径。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（33 pts）：$n,m \\le 500$。\n- Subtask 2（33 pts）：$n,m \\le 3 \\times 10^3$，符号链接最多被调用一次。\n- Subtask 3（34 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le k,s \\le 10^6$，$1\\le m,n\\le 3\\times 10^3$。\n\n#### 说明\n\n翻译自 [BalticOI 2015 Day2 A File Paths](https://boi.cses.fi/files/boi2015_day2.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6844", "type": "P", "difficulty": 7, "samples": [["3\n2\n0 0\n0 1\n0 2", "YES\n1\n2\n3\n"], ["3\n1\n0 0\n1 1\n2 2", "YES\n2\n3\n1"], ["2\n1\n0 0\n0 2\n", "NO"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2019] Building Skyscrapers", "background": "", "description": "在 2D 平面上，有 $n$ 个计划建摩天楼的格子，第 $i$ 座计划建的摩天楼的格子位于 $(r_i,c_i)$。\n\n您可以选择任意一种建摩天楼的顺序，但是要满足如下设定：\n\n- 设建摩天楼的顺序为 $s$。\n- 对于任意 $2\\le i\\le n$，都要保证，第 $s_i$ 座至少和前面任意一座摩天楼有公共边或公共角。\n- 对于任意 $1\\le i\\le n$，都要保证，从第 $s_i$ 座计划建摩天楼的格子到 2D 平面的边界，有路径相连（从一个格子只能走到与其有公共边的格子），且路径上除第 $s_i$ 座摩天楼无其他摩天楼。\n\n同时会输入一个 $t$，表示输出的类别：\n\n- 若 $t=1$，您需要构造任意一种建造的顺序。\n- 若 $t=2$，您需要构造 $(s_n, s_{n - 1}, \\dots, s_1)$ 字典序最大的建造顺序。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个整数 $t$。\n\n接下来 $n$ 行，每行两个整数 $r_i,c_i$，第 $i$ 行表示第 $i$ 座计划建的摩天楼的坐标为 $(r_i,c_i)$。", "outputFormat": "第一行为一个字符串 `YES` 或者 `NO`，表示是否有一种可行的方案。\n\n若有一种可行的方案，接下来输出 $n$ 行，一行一个整数表示您构造的方案。\n\n- 若 $t=1$，您需要构造任意一种建造的顺序。\n- 若 $t=2$，您需要构造 $(s_n, s_{n - 1}, \\dots, s_1)$ 字典序最大的建造顺序。", "hint": "#### 样例解释\n\n#### 样例 1 解释\n\n这是三个摩天楼连成一行，自然有如下几种解：\n\n- $1,2,3$\n- $2,1,3$\n- $2,3,1$\n- $3,2,1$\n\n因为 $t=2$，所以输出第一种。\n\n#### 样例 2 解释\n\n和样例 1 的区别只是三个摩天楼连成一条对角线，与样例 1 的解一致，又因为 $t=1$，随便输出一组即可。\n\n#### 样例 3 解释\n\n两个摩天楼无相交部分，自然无法建立。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 1.5\\times 10^5$，$1\\le t\\le 2$，$\\lvert r_i \\rvert,\\lvert c_i \\rvert\\le 10^9$。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $t=1$ 且 $n\\le 10$ | $8$ | \n| 2 | $t=1$ 且 $n\\le 200$ | $14$ | \n| 3 | $t=1$ 且 $n\\le 2\\times 10^3$ | $12$ | \n| 4 | $t=2$ 且 $n\\le 2\\times 10^3$ | $17$ | \n| 5 | $t=1$ | $20$ | \n| 6 | $t=2$，$n\\le 7\\times 10^4$ 且 $\\lvert r_i \\rvert,\\lvert c_i \\rvert\\le 900$ | $10$ | \n| 7 | $t=2$ | $19$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 1](https://ceoi.sk/tasks/) [T1 Building Skyscrapers](https://ceoi.sk/static/statements/skyscrapers-ENG.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2019] Building Skyscrapers", "background": "", "description": "在 2D 平面上，有 $n$ 个计划建摩天楼的格子，第 $i$ 座计划建的摩天楼的格子位于 $(r_i,c_i)$。\n\n您可以选择任意一种建摩天楼的顺序，但是要满足如下设定：\n\n- 设建摩天楼的顺序为 $s$。\n- 对于任意 $2\\le i\\le n$，都要保证，第 $s_i$ 座至少和前面任意一座摩天楼有公共边或公共角。\n- 对于任意 $1\\le i\\le n$，都要保证，从第 $s_i$ 座计划建摩天楼的格子到 2D 平面的边界，有路径相连（从一个格子只能走到与其有公共边的格子），且路径上除第 $s_i$ 座摩天楼无其他摩天楼。\n\n同时会输入一个 $t$，表示输出的类别：\n\n- 若 $t=1$，您需要构造任意一种建造的顺序。\n- 若 $t=2$，您需要构造 $(s_n, s_{n - 1}, \\dots, s_1)$ 字典序最大的建造顺序。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个整数 $t$。\n\n接下来 $n$ 行，每行两个整数 $r_i,c_i$，第 $i$ 行表示第 $i$ 座计划建的摩天楼的坐标为 $(r_i,c_i)$。", "outputFormat": "第一行为一个字符串 `YES` 或者 `NO`，表示是否有一种可行的方案。\n\n若有一种可行的方案，接下来输出 $n$ 行，一行一个整数表示您构造的方案。\n\n- 若 $t=1$，您需要构造任意一种建造的顺序。\n- 若 $t=2$，您需要构造 $(s_n, s_{n - 1}, \\dots, s_1)$ 字典序最大的建造顺序。", "hint": "#### 样例解释\n\n#### 样例 1 解释\n\n这是三个摩天楼连成一行，自然有如下几种解：\n\n- $1,2,3$\n- $2,1,3$\n- $2,3,1$\n- $3,2,1$\n\n因为 $t=2$，所以输出第一种。\n\n#### 样例 2 解释\n\n和样例 1 的区别只是三个摩天楼连成一条对角线，与样例 1 的解一致，又因为 $t=1$，随便输出一组即可。\n\n#### 样例 3 解释\n\n两个摩天楼无相交部分，自然无法建立。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 1.5\\times 10^5$，$1\\le t\\le 2$，$\\lvert r_i \\rvert,\\lvert c_i \\rvert\\le 10^9$。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $t=1$ 且 $n\\le 10$ | $8$ | \n| 2 | $t=1$ 且 $n\\le 200$ | $14$ | \n| 3 | $t=1$ 且 $n\\le 2\\times 10^3$ | $12$ | \n| 4 | $t=2$ 且 $n\\le 2\\times 10^3$ | $17$ | \n| 5 | $t=1$ | $20$ | \n| 6 | $t=2$，$n\\le 7\\times 10^4$ 且 $\\lvert r_i \\rvert,\\lvert c_i \\rvert\\le 900$ | $10$ | \n| 7 | $t=2$ | $19$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 1](https://ceoi.sk/tasks/) [T1 Building Skyscrapers](https://ceoi.sk/static/statements/skyscrapers-ENG.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6845", "type": "P", "difficulty": 6, "samples": [["4 3 2000\n1 2 100\n2 3 1000\n2 4 1000\n2 1030\n1 1020\n1 890", "2030\n2080\n2050\n"], ["10 10 10000\n1 9 1241\n5 6 1630\n10 5 1630\n2 6 853\n10 1 511\n5 3 760\n8 3 1076\n4 10 1483\n7 10 40\n8 2051\n5 6294\n5 4168\n7 1861\n0 5244\n6 5156\n3 3001\n8 5267\n5 3102\n8 3623", "6164\n7812\n8385\n6737\n6738\n7205\n6641\n7062\n6581\n5155"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "线段树", "点分治", "CEOI（中欧）", "深度优先搜索 DFS", "树的遍历", "树的直径", "树链剖分", "动态树分治", "动态 DP"], "title": "[CEOI 2019] Dynamic Diameter", "background": "", "description": "有一棵树，含 $n$ 个节点，边带权。\n\n会有 $q$ 次修改，每次会将树上的一条边的边权进行修改，在每次修改后，您需要求出每次修改后，这棵树的直径上的边权和。\n\n**本题强制在线。**", "inputFormat": "第一行为三个整数 $n,q,w$，分别表示点的个数，询问的个数和边权的上限。\n\n接下来 $n-1$ 行，每一行为三个整数 $a_i,b_i,c_i$，表示 $a_i$ 到 $b_i$ 有一条边权为 $c_i$ 的边。\n\n接下来 $q$ 行，每行两个经过加密的整数 $d_j,e_j$。\n\n解密方式如下：\n- $d_j'=(d_j+\\text{last})\\bmod(n-1)$\n- $e_j'=(e_j+\\text{last})\\bmod w$\n\n其中 $\\text{last}$ 表示上一个询问的答案，初值为 $0$。\n\n表示将第 $d_j'+1$ 条边的边权改为 $e_j'$。", "outputFormat": "共输出 $q$ 行，一行一个整数，第 $i$ 行的整数表示在第 $i$ 次修改后的直径上的权值总和。", "hint": "#### 样例 1 解释\n\n解密后的修改如下：\n```\n2 1030\n0 1050\n2 970\n```\n如图为树的边权变化过程，红边代表树的直径：\n![](https://cdn.luogu.com.cn/upload/image_hosting/sswn0icz.png)\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 10^5$，$1\\le q\\le 10^5$，$1\\le w\\le 2\\times 10^{13}$，$1\\le a_i,b_i\\le n$，$0\\le c_i,e_j<w$，$0\\le d_j<n-1$。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n,q\\le 100$ 且 $w\\le 10^4$ | $11$ | \n| 2 | $n,q\\le 5\\times 10^3$ 且 $w\\le 10^4$ | $13$ | \n| 3 | $w\\le 10^4$ 且边的形式均为 $(1,i)$ | $7$ | \n| 4 | $w\\le 10^4$ 且边的形式均为 $(i,2\\times i)$ 或 $(i,2\\times i+1)$ | $18$ | \n| 5 | 保证有一条直径经过 $1$ 号节点 | $24$ | \n| 6 | 无特殊限制 | $27$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 1](https://ceoi.sk/tasks/) [T2 Dynamic Diameter](https://ceoi.sk/static/statements/diameter-ENG.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2019] Dynamic Diameter", "background": "", "description": "有一棵树，含 $n$ 个节点，边带权。\n\n会有 $q$ 次修改，每次会将树上的一条边的边权进行修改，在每次修改后，您需要求出每次修改后，这棵树的直径上的边权和。\n\n**本题强制在线。**", "inputFormat": "第一行为三个整数 $n,q,w$，分别表示点的个数，询问的个数和边权的上限。\n\n接下来 $n-1$ 行，每一行为三个整数 $a_i,b_i,c_i$，表示 $a_i$ 到 $b_i$ 有一条边权为 $c_i$ 的边。\n\n接下来 $q$ 行，每行两个经过加密的整数 $d_j,e_j$。\n\n解密方式如下：\n- $d_j'=(d_j+\\text{last})\\bmod(n-1)$\n- $e_j'=(e_j+\\text{last})\\bmod w$\n\n其中 $\\text{last}$ 表示上一个询问的答案，初值为 $0$。\n\n表示将第 $d_j'+1$ 条边的边权改为 $e_j'$。", "outputFormat": "共输出 $q$ 行，一行一个整数，第 $i$ 行的整数表示在第 $i$ 次修改后的直径上的权值总和。", "hint": "#### 样例 1 解释\n\n解密后的修改如下：\n```\n2 1030\n0 1050\n2 970\n```\n如图为树的边权变化过程，红边代表树的直径：\n![](https://cdn.luogu.com.cn/upload/image_hosting/sswn0icz.png)\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 10^5$，$1\\le q\\le 10^5$，$1\\le w\\le 2\\times 10^{13}$，$1\\le a_i,b_i\\le n$，$0\\le c_i,e_j<w$，$0\\le d_j<n-1$。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n,q\\le 100$ 且 $w\\le 10^4$ | $11$ | \n| 2 | $n,q\\le 5\\times 10^3$ 且 $w\\le 10^4$ | $13$ | \n| 3 | $w\\le 10^4$ 且边的形式均为 $(1,i)$ | $7$ | \n| 4 | $w\\le 10^4$ 且边的形式均为 $(i,2\\times i)$ 或 $(i,2\\times i+1)$ | $18$ | \n| 5 | 保证有一条直径经过 $1$ 号节点 | $24$ | \n| 6 | 无特殊限制 | $27$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 1](https://ceoi.sk/tasks/) [T2 Dynamic Diameter](https://ceoi.sk/static/statements/diameter-ENG.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6846", "type": "P", "difficulty": 6, "samples": [["2 1\n1 2\n", "1\n"], ["3 3\n1 2\n2 3\n1 3", "9"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "CEOI（中欧）"], "title": "[CEOI 2019] Amusement Park", "background": "", "description": "有一个含 $n$ 个点，$m$ 条边的有向图，图无重边，无自环，两点之间不成环。\n\n现在我们想改变一些边的方向，使得该有向图无环。\n\n您需要求出，每一种改变方向后使得该有向图无环的方案的需改变边的数量之和 $\\bmod\\ 998244353$ 之后的答案。", "inputFormat": "第一行为两个整数 $n,m$。\n\n接下来 $m$ 行，一行两个整数 $a_i,b_i$，表示有一条起点为 $a_i$，终点为 $b_i$ 的有向边。", "outputFormat": "仅一行一个整数，表示每一种改变方向后使得该有向图无环的方案的需改变边的数量之和 $\\bmod\\ 998244353$ 之后的答案。", "hint": "#### 样例解释\n#### 样例 1 解释\n有如下两种方案：\n- 改变方向。\n- 不改变方向。\n\n所以输出 $1+0=1$。\n#### 样例 2 解释\n共有六种可行的方案：\n- $1\\to2,2\\to3,1\\to3$\n- $1\\to2,3\\to2,1\\to3$\n- $1\\to2,3\\to2,3\\to1$\n- $2\\to1,2\\to3,1\\to3$\n- $2\\to1,2\\to3,3\\to1$\n- $2\\to1,3\\to2,3\\to1$\n\n所以输出 $0+1+2+1+2+3=9$。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 18$，$0\\le m\\le \\frac{n\\times (n-1)}{2}$，$1\\le a_i,b_i\\le n$，$a_i\\not=b_i$，对于 $i\\not=j$，均有 $a_i\\not=a_j$ 或者 $b_i\\not=b_j$，无序数对 $\\{a_i,b_i\\}$ 互不相同。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n\\le 3$ | $7$ | \n| 2 | $n\\le 6$ | $12$ | \n| 3 | $n\\le 10$ | $23$ | \n| 4 | $n\\le 15$ | $21$ | \n| 5 | 无特殊限制 | $37$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T1 Amusement Park](https://ceoi.sk/static/statements/amusementpark-ENG.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2019] Amusement Park", "background": "", "description": "有一个含 $n$ 个点，$m$ 条边的有向图，图无重边，无自环，两点之间不成环。\n\n现在我们想改变一些边的方向，使得该有向图无环。\n\n您需要求出，每一种改变方向后使得该有向图无环的方案的需改变边的数量之和 $\\bmod\\ 998244353$ 之后的答案。", "inputFormat": "第一行为两个整数 $n,m$。\n\n接下来 $m$ 行，一行两个整数 $a_i,b_i$，表示有一条起点为 $a_i$，终点为 $b_i$ 的有向边。", "outputFormat": "仅一行一个整数，表示每一种改变方向后使得该有向图无环的方案的需改变边的数量之和 $\\bmod\\ 998244353$ 之后的答案。", "hint": "#### 样例解释\n#### 样例 1 解释\n有如下两种方案：\n- 改变方向。\n- 不改变方向。\n\n所以输出 $1+0=1$。\n#### 样例 2 解释\n共有六种可行的方案：\n- $1\\to2,2\\to3,1\\to3$\n- $1\\to2,3\\to2,1\\to3$\n- $1\\to2,3\\to2,3\\to1$\n- $2\\to1,2\\to3,1\\to3$\n- $2\\to1,2\\to3,3\\to1$\n- $2\\to1,3\\to2,3\\to1$\n\n所以输出 $0+1+2+1+2+3=9$。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 18$，$0\\le m\\le \\frac{n\\times (n-1)}{2}$，$1\\le a_i,b_i\\le n$，$a_i\\not=b_i$，对于 $i\\not=j$，均有 $a_i\\not=a_j$ 或者 $b_i\\not=b_j$，无序数对 $\\{a_i,b_i\\}$ 互不相同。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n\\le 3$ | $7$ | \n| 2 | $n\\le 6$ | $12$ | \n| 3 | $n\\le 10$ | $23$ | \n| 4 | $n\\le 15$ | $21$ | \n| 5 | 无特殊限制 | $37$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T1 Amusement Park](https://ceoi.sk/static/statements/amusementpark-ENG.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6847", "type": "P", "difficulty": 6, "samples": [["6 4 10\n1\n2\n1\n4\n4\n3 4 5\n4 7 2\n5 4 1\n6 9 3\n", "9\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "CEOI（中欧）"], "title": "[CEOI 2019] Magic Tree", "background": null, "description": "有一棵以 $1$ 为根，节点从 $1$ 到 $n$ 编号的树。\n\n在这棵树上有许多果实，第 $j$ 个果实会于第 $d_j$ 天在节点 $v_j$ 成熟，并且在收获后可获得 $w_j$ 的果汁。\n\n第 $j$ 个果实仅能在第 $d_j$ 天收获。\n\n收获的方式是断掉这棵树的一条边，这会获得在这条边上作为儿子的那个点的子树上的当天成熟的果实的果汁。\n\n同时，以您砍掉那条边的儿子为根的那个子树会掉在地上，所有掉在地上的未成熟水果都会被丢弃，无法收集它们的果汁。\n\n您要求出最多可以获得多少果汁。", "inputFormat": "第一行为三个整数 $n,m,k$，分别表示节点的个数，果实的个数和果实可能成熟天数的最大值。\n\n接下来 $n-1$ 行，一行一个整数 $p_i$，表示 $i+1$ 号节点的父亲是 $p_i$。\n\n接下来 $m$ 行一行三个整数 $v_j,d_j,w_j$。", "outputFormat": "一行一个数，表示最多可以获得多少果汁。", "hint": "#### 样例解释\n最优方案如下：\n- 在第四天，断掉 $(4,5)$ 和 $(1,2)$，获得第一个和第三个果实，获得的果汁数量累计为 $6$。\n- 在第七天，虽然我们有一个果实成熟，但是我们最好什么都不干。\n- 在第九天，断掉 $(1,4)$，获得最后一个果实，获得的果汁数量累计为 $9$。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 10^5$，$1\\le m\\le n-1$，$1\\le k\\le 10^5$，$1\\le p_i\\le i-1$，$2\\le v_j\\le n$，$1\\le d_j\\le k$，$1\\le w_j\\le 10^9$，$v_j$ 互不相同。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n,k\\le 20$ 且 $w_j=1$ | $6$ | \n| 2 | $v_j\\in $ 叶子节点 | $3$ | \n| 3 | 图是一条链且 $w_j=1$ | $11$ | \n| 4 | $k\\le 2$ | $12$ | \n| 5 | $k\\le 20$ 且 $w_j=1$ | $16$ | \n| 6 | $m\\le 10^3$ | $13$ | \n| 7 | $w_j=1$ | $22$ | \n| 8 | 无特殊性质 | $17$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T2 Magic Tree](https://ceoi.sk/static/statements/magictree-ENG.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2019] Magic Tree", "background": null, "description": "We have a magic tree: a rooted tree on $n$ vertices. The vertices are numbered $1$ through $n$. Vertex $1$ is the root.\n\nThe magic tree gives us magic fruit. The fruit only grows in vertices of the tree other than the root. Each vertex contains at most one piece of fruit.\n\nIt is now day $0$ and no fruit is ripe yet. Each fruit will only be ripe for a single day. For each fruit, we are given the vertex $v_j$ where it grows, the day $d_j$ on which it will be ripe, and the amount $w_j$ of magic juice we can extract from it if we harvest it when it is ripe.\n\nThe fruits have to be harvested by cutting some branches of the tree. On each day, you may cut as many branches of the tree as you like. The parts of the tree you cut off will fall to the ground and you can collect all the ripe fruits they contain. All fruits that fall to the ground when they are not ripe are discarded and no magic juice is collected from them.\n\nFormally, on each day, you may erase some edges of the tree. Whenever you do so, the tree will split into multiple connected components. You then erase all components that do not contain the root and you harvest all ripe fruits those components contained.\n\nGiven is a description of the tree together with the locations, ripening days and juiciness of all $m$ fruits. Calculate the maximum total amount of magic juice we can harvest from the tree.", "inputFormat": "The first line contains three space-separated integers $n$ ($2 \\leq n \\leq 10^5$), $m$ ($1 \\leq m \\leq n − 1$) and $k$ ($1 \\leq k \\leq10^5$)– the number of vertices, the number of fruits, and the maximum day on which a fruit may become ripe.\n\nThe following $n−1$ lines contain the integers $p_2,...,p_n$, one per line.For each $i$ (from $2$ to $n$, inclusive), vertex $p_i$($1 \\leq p_i \\leq i−1$) is the parent of vertex $i$.\n\nEach of the last m lines describes one fruit. The $\\text{j-th}$ of these lines has the form $“v_j\\; d_j\\;w_j”$ ($2 \\leq v_j \\leq n, 1 \\leq d_j \\leq k, 1 \\leq w_j ≤10^9$).\n\nIt is guaranteed that no vertex contains more than one fruit ($\\text{i.e.}$, the values $v_j$ are distinct).", "outputFormat": "Output a single line with a single integer, the maximum amount of magic juice we can harvest from the tree.", "hint": "Subtask 1 (6 points): $n,k \\leq 20$, and $w_j = 1$ for all $j$\n\nSubtask 2 (3 points): fruits only grow in the leaves of the tree\n\nSubtask 3 (11 points): $p_i = i −1$ for each $i$, and $w_j = 1$ for all $j$\n\nSubtask 4 (12 points): $k \\leq 2$\n\nSubtask 5 (16 points): $k \\leq 20$, and $w_j = 1$ for all $j$\n\nSubtask 6 (13 points): $m \\leq 10^3$\n\nSubtask 7 (22 points): $w_j = 1$ for all $j$\n\nSubtask 8 (17 points): no additional constraints", "locale": "en"}, "zh-CN": {"title": "[CEOI 2019] Magic Tree", "background": null, "description": "有一棵以 $1$ 为根，节点从 $1$ 到 $n$ 编号的树。\n\n在这棵树上有许多果实，第 $j$ 个果实会于第 $d_j$ 天在节点 $v_j$ 成熟，并且在收获后可获得 $w_j$ 的果汁。\n\n第 $j$ 个果实仅能在第 $d_j$ 天收获。\n\n收获的方式是断掉这棵树的一条边，这会获得在这条边上作为儿子的那个点的子树上的当天成熟的果实的果汁。\n\n同时，以您砍掉那条边的儿子为根的那个子树会掉在地上，所有掉在地上的未成熟水果都会被丢弃，无法收集它们的果汁。\n\n您要求出最多可以获得多少果汁。", "inputFormat": "第一行为三个整数 $n,m,k$，分别表示节点的个数，果实的个数和果实可能成熟天数的最大值。\n\n接下来 $n-1$ 行，一行一个整数 $p_i$，表示 $i+1$ 号节点的父亲是 $p_i$。\n\n接下来 $m$ 行一行三个整数 $v_j,d_j,w_j$。", "outputFormat": "一行一个数，表示最多可以获得多少果汁。", "hint": "#### 样例解释\n最优方案如下：\n- 在第四天，断掉 $(4,5)$ 和 $(1,2)$，获得第一个和第三个果实，获得的果汁数量累计为 $6$。\n- 在第七天，虽然我们有一个果实成熟，但是我们最好什么都不干。\n- 在第九天，断掉 $(1,4)$，获得最后一个果实，获得的果汁数量累计为 $9$。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 10^5$，$1\\le m\\le n-1$，$1\\le k\\le 10^5$，$1\\le p_i\\le i-1$，$2\\le v_j\\le n$，$1\\le d_j\\le k$，$1\\le w_j\\le 10^9$，$v_j$ 互不相同。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n,k\\le 20$ 且 $w_j=1$ | $6$ | \n| 2 | $v_j\\in $ 叶子节点 | $3$ | \n| 3 | 图是一条链且 $w_j=1$ | $11$ | \n| 4 | $k\\le 2$ | $12$ | \n| 5 | $k\\le 20$ 且 $w_j=1$ | $16$ | \n| 6 | $m\\le 10^3$ | $13$ | \n| 7 | $w_j=1$ | $22$ | \n| 8 | 无特殊性质 | $17$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T2 Magic Tree](https://ceoi.sk/static/statements/magictree-ENG.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6848", "type": "P", "difficulty": 7, "samples": [["6 0 0 6 0 6 4 5 4 5 9 0 9\n4 0 0 7 0 7 7 0 7\n", "scissors\n0 5\n3 0 0 3 0 3 4\n3 3 4 0 4 0 0\n3 3 0 6 0 6 4\n3 6 4 3 4 3 0\n4 0 4 5 4 5 9 0 9\ntape\n5 1 2 5 3 4\n3 0 3 0 0 4 0\n3 4 0 7 0 7 4\n4 0 3 4 0 7 4 3 7\n3 7 4 7 7 3 7\n3 3 7 0 7 0 3\n4 0 0 7 0 7 7 0 7"], ["4 0 0 3 0 3 3 0 3\n4 7 -1 10 -1 11 2 8 2\n", "scissors\n0 2\n3 0 0 1 3 0 3\n4 1 3 0 0 3 0 3 3\ntape\n2 1 2\n3 110 -1 111 2 110 2\n4 108 2 107 -1 110 -1 110 2\n4 107 -1 110 -1 111 2 108 2\n"], ["4 0 0 9 0 9 1 0 1\n4 0 0 3 0 3 3 0 3\n", "scissors\n0 2\n4 1.47000000000 0 9 0 9 1 1.470000000 1\n4 0 0 1.470000000 0 1.470000000 1 0 1\nscissors\n1 2\n4 1.470000000 0 6 0 6 1 1.470000000 1\n4 9 0 9 1 6 1 6 0\ntape\n2 4 3\n4 3 2 3 1 6 1 6 2\n4 6 1 1.470000000 1 1.470000000 0 6 0\n6 1.470000000 0 6 0 6 2 3 2 3 1 1.47 1\nscissors\n5 4\n4 1.470000000 0 3 0 3 1 1.470000000 1\n4 3 0 4 0 4 2 3 2\n4 4 2 4 0 5 0 5 2\n4 5 0 6 0 6 2 5 2\ntape\n5 2 6 7 8 9\n4 0 0 1.470000000 0 1.470000000 1 0 1\n4 1.470000000 0 3 0 3 1 1.470000000 1\n4 0 2 0 1 2 1 2 2\n4 0 2 2 2 2 3 0 3\n4 3 3 2 3 2 1 3 1\n4 0 0 3 0 3 3 0 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2019] Scissors and Tape", "background": "", "description": "您有一个简单多边形 $S$，现在您想将其变成与其面积相等的简单多边形 $T$。\n\n您可以使用两种工具：剪刀和胶带。剪刀可将任何多边形切割成较小的多边形。胶带可将较小的多边形组合成较大的多边形。您可以按任何顺序多次使用每个工具。\n\n输入中的多边形的顶点坐标均为整数，但您的方案允许产生顶点坐标不为整数的多边形。\n\n任务的形式化定义如下：\n\n一个形状 $Q=(Q_0,\\ldots Q_{n-1})$ 是平面中三个点及以上的序列，满足：\n\n- 闭合折线 $Q_0,Q_1,Q_2,\\ldots Q_{n-1},Q_0$ 不相交。\n- 这段折线以逆时针围绕多边形的边界。\n\n以形状 $Q$ 为边界的多边形为 $P(Q)$。\n\n两个形状等效当且仅当一个形状经过平移或旋转之后与另一个形状相同。\n\n不允许对形状进行对称，且点的顺序与形状有关：$(Q_0,Q_1\\ldots Q_{n-1})$ 不一定等价于 $(Q_1\\ldots Q_{n-1},Q_0)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ttm5ro7.png)\n\n在上图中，形状 $U$ 和 $V$ 是等价的，但形状 $W$ 与他们不等价，原因是给出的点的顺序不同，无论如何，第四个形状都不与前三个形状相同，因为不允许对称形状。\n\n每一个形状的表示由 $2\\times n+1$ 个数组成，第一个数为 $n$，表示形状的点数，接下来 $2\\times n$ 个数 $Q_{0,x},Q_{0,y},Q_{1,x},\\ldots,Q_{n-1,x},Q_{n-1,y}$，每两个数均表示形状里一个点的坐标，如 $(Q_{0,x},Q_{0,y})$ 为 $Q_0$ 的坐标。\n\n形状 $B_1,B_2,\\ldots B_k$ 被称为形状 $A$ 的划分，当且仅当：\n\n- 所有 $P(B_i)$ 的并集为 $P(A)$。\n- 对于所有的 $i\\not=j$，$P(B_i)$ 与 $P(B_j)$ 无交。\n\n形状是有 ID 的，$S$ 的 ID 为 $0$，您在解决方案中生成的 ID 为 $1,2,3,\\ldots$。\n\n剪刀将会剪开一个现有的形状 $A$，并产生 $A$ 的一个划分 $B_1,B_2,\\ldots B_k$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dz34b81y.png)\n\n在上图中，形状 $A$ 被划分成了 $B_1,B_2,B_3$ 三个三角形。其中描述红色三角形的一种方式为 `3 3 1 6 1 5.1 4`。\n\n胶带可以粘合存在的形状 $A_1,\\ldots A_k$ 并使其变成形状 $B$，要执行这个操作，需要给定 $C_1,\\ldots,C_k$ 和最终形状 $B$ 并满足如下要求：\n\n- $C_i$ 等价于 $A_i$。\n- $C_1,\\ldots,C_k$ 是 $B$ 的划分。\n\n通俗地说，你选择了形状 $B$，然后展示如何把每个存在的 $A_i$ 移动到构成 $B$ 的正确的位置 $C_I$。注意形状 $B$ 需要分配一个新 ID，但 $C_i$ 不需要。", "inputFormat": "第一行为形状 $S$。\n\n第二行为形状 $T$。", "outputFormat": "每当使用剪刀时，按如下格式输出：\n```\nscissors\nid(A) k\nB_1\nB_2\n...\nB_k\n```\n每当使用胶布时，按如下格式输出：\n```\ntape\nk id(A_1) ... id(A_k)\nC_1\nC_2\n...\nC_k\nB\n```\n您的输出需要保证以下限制：\n- 输出的所有点坐标在 $[-10^7,10^7]$ 之内。\n- 输出的每个形状最多能有 $100$ 个点。\n- 每次操作中，$1\\le k\\le 100$。\n- 操作数不多于 $2\\times 10^3$。\n- 输出中所有形状的总点数不超过 $2\\times 10^4$。\n- 最后必须只剩下一个形状，且这个形状等价于 $T$。", "hint": "#### 样例解释\n#### 样例 1 解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/nn0psa1v.png)\n\n上左图是使用剪刀操作后的原始图形，右侧是使用胶带后对应 $C_i$。\n#### 样例 2 解释\n请注意，目标和您的最后达成的多边形只需等价即可，不需完全相同。\n#### 样例 3 解释\n下图显示了这个样例输出的三个阶段：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bk5bbncz.png)\n#### 数据范围及限制\n对于 $100\\%$ 的数据，保证 $S$ 与 $T$ 的点数 $\\le 10$ 且 $\\ge 3$，输入的所有点坐标在 $[-10^6,10^6]$ 之内，无三点共线的情况，$P(S)$ 与 $P(T)$ 的面积相等。\n\n如果一个形状的顶点分别为 $(0,0),(x,0),(0,y),(x,y)$ 且 $x,y$ 为正整数，则称它为好矩形。\n\n如果一个形状是好矩形且 $x=y$，则称它为好正方形。\n\n如果多边形 $P(A)$ 的每个内角都小于 $180$ 度，则称形状 $A$ 为严格凸多边形。\n\n详细子任务限制如下：\n| 子任务编号 | 限制 | 分数 |\n| :-: | :-: | :-: |\n| 1 | $S$ 和 $T$ 是好矩形且输入的所有点坐标在 $[1,10]$ 之内 | $5$ | \n| 2 | $S$ 是好矩形且 $x>y$，$T$ 是好正方形 | $13$ |\n| 3 | $S,T$ 是好矩形 | $12$ |\n| 4 | $S$ 是三角形，$T$ 是好正方形 | $14$ |\n| 5 | $S,T$ 均是三角形 | $10$ |\n| 6 | $S$ 是严格凸多边形，$T$ 是好矩形 | $16$ |\n| 7 | $T$ 是好矩形 | $11$ |\n| 8 | 无特殊限制 | $19$ |\n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T3 Scissors and Tape](https://ceoi.sk/static/statements/scissors-ENG.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2019] Scissors and Tape", "background": "", "description": "您有一个简单多边形 $S$，现在您想将其变成与其面积相等的简单多边形 $T$。\n\n您可以使用两种工具：剪刀和胶带。剪刀可将任何多边形切割成较小的多边形。胶带可将较小的多边形组合成较大的多边形。您可以按任何顺序多次使用每个工具。\n\n输入中的多边形的顶点坐标均为整数，但您的方案允许产生顶点坐标不为整数的多边形。\n\n任务的形式化定义如下：\n\n一个形状 $Q=(Q_0,\\ldots Q_{n-1})$ 是平面中三个点及以上的序列，满足：\n\n- 闭合折线 $Q_0,Q_1,Q_2,\\ldots Q_{n-1},Q_0$ 不相交。\n- 这段折线以逆时针围绕多边形的边界。\n\n以形状 $Q$ 为边界的多边形为 $P(Q)$。\n\n两个形状等效当且仅当一个形状经过平移或旋转之后与另一个形状相同。\n\n不允许对形状进行对称，且点的顺序与形状有关：$(Q_0,Q_1\\ldots Q_{n-1})$ 不一定等价于 $(Q_1\\ldots Q_{n-1},Q_0)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ttm5ro7.png)\n\n在上图中，形状 $U$ 和 $V$ 是等价的，但形状 $W$ 与他们不等价，原因是给出的点的顺序不同，无论如何，第四个形状都不与前三个形状相同，因为不允许对称形状。\n\n每一个形状的表示由 $2\\times n+1$ 个数组成，第一个数为 $n$，表示形状的点数，接下来 $2\\times n$ 个数 $Q_{0,x},Q_{0,y},Q_{1,x},\\ldots,Q_{n-1,x},Q_{n-1,y}$，每两个数均表示形状里一个点的坐标，如 $(Q_{0,x},Q_{0,y})$ 为 $Q_0$ 的坐标。\n\n形状 $B_1,B_2,\\ldots B_k$ 被称为形状 $A$ 的划分，当且仅当：\n\n- 所有 $P(B_i)$ 的并集为 $P(A)$。\n- 对于所有的 $i\\not=j$，$P(B_i)$ 与 $P(B_j)$ 无交。\n\n形状是有 ID 的，$S$ 的 ID 为 $0$，您在解决方案中生成的 ID 为 $1,2,3,\\ldots$。\n\n剪刀将会剪开一个现有的形状 $A$，并产生 $A$ 的一个划分 $B_1,B_2,\\ldots B_k$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dz34b81y.png)\n\n在上图中，形状 $A$ 被划分成了 $B_1,B_2,B_3$ 三个三角形。其中描述红色三角形的一种方式为 `3 3 1 6 1 5.1 4`。\n\n胶带可以粘合存在的形状 $A_1,\\ldots A_k$ 并使其变成形状 $B$，要执行这个操作，需要给定 $C_1,\\ldots,C_k$ 和最终形状 $B$ 并满足如下要求：\n\n- $C_i$ 等价于 $A_i$。\n- $C_1,\\ldots,C_k$ 是 $B$ 的划分。\n\n通俗地说，你选择了形状 $B$，然后展示如何把每个存在的 $A_i$ 移动到构成 $B$ 的正确的位置 $C_I$。注意形状 $B$ 需要分配一个新 ID，但 $C_i$ 不需要。", "inputFormat": "第一行为形状 $S$。\n\n第二行为形状 $T$。", "outputFormat": "每当使用剪刀时，按如下格式输出：\n```\nscissors\nid(A) k\nB_1\nB_2\n...\nB_k\n```\n每当使用胶布时，按如下格式输出：\n```\ntape\nk id(A_1) ... id(A_k)\nC_1\nC_2\n...\nC_k\nB\n```\n您的输出需要保证以下限制：\n- 输出的所有点坐标在 $[-10^7,10^7]$ 之内。\n- 输出的每个形状最多能有 $100$ 个点。\n- 每次操作中，$1\\le k\\le 100$。\n- 操作数不多于 $2\\times 10^3$。\n- 输出中所有形状的总点数不超过 $2\\times 10^4$。\n- 最后必须只剩下一个形状，且这个形状等价于 $T$。", "hint": "#### 样例解释\n#### 样例 1 解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/nn0psa1v.png)\n\n上左图是使用剪刀操作后的原始图形，右侧是使用胶带后对应 $C_i$。\n#### 样例 2 解释\n请注意，目标和您的最后达成的多边形只需等价即可，不需完全相同。\n#### 样例 3 解释\n下图显示了这个样例输出的三个阶段：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bk5bbncz.png)\n#### 数据范围及限制\n对于 $100\\%$ 的数据，保证 $S$ 与 $T$ 的点数 $\\le 10$ 且 $\\ge 3$，输入的所有点坐标在 $[-10^6,10^6]$ 之内，无三点共线的情况，$P(S)$ 与 $P(T)$ 的面积相等。\n\n如果一个形状的顶点分别为 $(0,0),(x,0),(0,y),(x,y)$ 且 $x,y$ 为正整数，则称它为好矩形。\n\n如果一个形状是好矩形且 $x=y$，则称它为好正方形。\n\n如果多边形 $P(A)$ 的每个内角都小于 $180$ 度，则称形状 $A$ 为严格凸多边形。\n\n详细子任务限制如下：\n| 子任务编号 | 限制 | 分数 |\n| :-: | :-: | :-: |\n| 1 | $S$ 和 $T$ 是好矩形且输入的所有点坐标在 $[1,10]$ 之内 | $5$ | \n| 2 | $S$ 是好矩形且 $x>y$，$T$ 是好正方形 | $13$ |\n| 3 | $S,T$ 是好矩形 | $12$ |\n| 4 | $S$ 是三角形，$T$ 是好正方形 | $14$ |\n| 5 | $S,T$ 均是三角形 | $10$ |\n| 6 | $S$ 是严格凸多边形，$T$ 是好矩形 | $16$ |\n| 7 | $T$ 是好矩形 | $11$ |\n| 8 | 无特殊限制 | $19$ |\n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T3 Scissors and Tape](https://ceoi.sk/static/statements/scissors-ENG.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6849", "type": "P", "difficulty": 7, "samples": [["3 4\n1 1 2\n2 1 2 3\n1 2 1 1\n2 1 2 1\n3 1 0 1", "2\n0\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "搜索", "2017", "提交答案", "Special Judge", "剪枝", "模拟退火", "背包 DP", "费用流", "随机化", "THUWC"], "title": "[THUWC 2017] 大葱的神力", "background": "**本题为提交答案题。**\n\n大葱是我国自古以来的美食，像我国传统美食北京烤鸭，用鸭子点缀出大葱的香味，令人赞不绝口。民间也流传着有「每天一棵葱，不当单身狗」的说法。\n\n然而，大葱要发挥出独属于自己的神力，也是有条件的。", "description": "现在小葱同学有 $N$ 棵大葱和 $M$ 个抽屉，将第 $i$ 棵大葱放到第 $j$ 个抽屉里面会产生 $w_{i,j}$ 的神力。自然小葱同学希望获得尽量多的神力，但是抽屉有着容积的限制，大葱也有着自己的体积。第 $i$ 棵大葱的体积为 $a_i$，第 $j$ 个抽屉的容积为 $b_j$。一个抽屉里面装着的大葱的体积之和不能超过这个抽屉的容积，一棵大葱不能拆分放到两个抽屉中。\n\n小葱同学现在想知道，在这样的条件下，这些大葱最多会产生多少的神力？", "inputFormat": "**本题为提交答案题**，输入文件为 `drawer1.in ~ drawer10.in`，详见附加文件。\n\n第一行两个整数 $N,M$，代表大葱的个数和抽屉的个数。\n\n接下来一行 $N$ 个整数，代表每棵大葱的体积。\n\n接下来一行 $M$ 个整数，代表每个抽屉的容积。\n\n接下来 $N$ 行每行 $M$ 个整数，第 $i$ 行第 $j$ 个数代表第 $i$ 棵大葱放到第 $j$ 个抽屉中会产生的神力。", "outputFormat": "输出文件为 `drawer1.out ~ drawer10.out`，分别对应相应的输入文件。\n\n对于每组输入数据，输出 $N$ 行每行一个整数，第 $i$ 个数代表第 $i$ 棵大葱被放到了哪个抽屉里面。如果第 $i$ 棵大葱没有被放到任何一个抽屉里面，则输出 $0$。", "hint": "#### 样例说明\n\n样例只是一种合法情况，获得的总神力值为 $2+3=5$。\n\n#### 评分方式\n\n**本题使用 Special Judge**，对于每个测试点，我们都有 $10$ 个参数 $a_1,a_2,\\cdots,a_{10}$，如果你的输出所产生的的神力 $v$ 满足 $v \\ge a_i$，则我们保证该测试点你至少会得到 $i$ 分。\n\n#### 如何测试你的输出\n\n在附加文件中，我们提供了 `scorer.cpp`，请自行编译来测试输出，这个程序将用于评判你的输出能够产生多少的神力。\n\n若编译后文件名称为 `scorer`，在终端（Linux）中，输入以下命令：\n\n```plain\n./scorer <input_name> <output_name>\n```\n\n或在命令提示符（Windows）中，输入以下命令：\n```plain\nscorer <input_name> <output_name>\n```\n来对你的输出进行评判。其中 `<input_name>` 为输入文件名称，`<output_name>` 为输出文件名称。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUWC 2017] 大葱的神力", "background": "**本题为提交答案题。**\n\n大葱是我国自古以来的美食，像我国传统美食北京烤鸭，用鸭子点缀出大葱的香味，令人赞不绝口。民间也流传着有「每天一棵葱，不当单身狗」的说法。\n\n然而，大葱要发挥出独属于自己的神力，也是有条件的。", "description": "现在小葱同学有 $N$ 棵大葱和 $M$ 个抽屉，将第 $i$ 棵大葱放到第 $j$ 个抽屉里面会产生 $w_{i,j}$ 的神力。自然小葱同学希望获得尽量多的神力，但是抽屉有着容积的限制，大葱也有着自己的体积。第 $i$ 棵大葱的体积为 $a_i$，第 $j$ 个抽屉的容积为 $b_j$。一个抽屉里面装着的大葱的体积之和不能超过这个抽屉的容积，一棵大葱不能拆分放到两个抽屉中。\n\n小葱同学现在想知道，在这样的条件下，这些大葱最多会产生多少的神力？", "inputFormat": "**本题为提交答案题**，输入文件为 `drawer1.in ~ drawer10.in`，详见附加文件。\n\n第一行两个整数 $N,M$，代表大葱的个数和抽屉的个数。\n\n接下来一行 $N$ 个整数，代表每棵大葱的体积。\n\n接下来一行 $M$ 个整数，代表每个抽屉的容积。\n\n接下来 $N$ 行每行 $M$ 个整数，第 $i$ 行第 $j$ 个数代表第 $i$ 棵大葱放到第 $j$ 个抽屉中会产生的神力。", "outputFormat": "输出文件为 `drawer1.out ~ drawer10.out`，分别对应相应的输入文件。\n\n对于每组输入数据，输出 $N$ 行每行一个整数，第 $i$ 个数代表第 $i$ 棵大葱被放到了哪个抽屉里面。如果第 $i$ 棵大葱没有被放到任何一个抽屉里面，则输出 $0$。", "hint": "#### 样例说明\n\n样例只是一种合法情况，获得的总神力值为 $2+3=5$。\n\n#### 评分方式\n\n**本题使用 Special Judge**，对于每个测试点，我们都有 $10$ 个参数 $a_1,a_2,\\cdots,a_{10}$，如果你的输出所产生的的神力 $v$ 满足 $v \\ge a_i$，则我们保证该测试点你至少会得到 $i$ 分。\n\n#### 如何测试你的输出\n\n在附加文件中，我们提供了 `scorer.cpp`，请自行编译来测试输出，这个程序将用于评判你的输出能够产生多少的神力。\n\n若编译后文件名称为 `scorer`，在终端（Linux）中，输入以下命令：\n\n```plain\n./scorer <input_name> <output_name>\n```\n\n或在命令提示符（Windows）中，输入以下命令：\n```plain\nscorer <input_name> <output_name>\n```\n来对你的输出进行评判。其中 `<input_name>` 为输入文件名称，`<output_name>` 为输出文件名称。", "locale": "zh-CN"}}}
