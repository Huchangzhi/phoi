{"pid": "P13255", "type": "P", "difficulty": 6, "samples": [["2\n4 5 8\n3 5 11", "Case #1: 6\nCase #2: 8"]], "limits": {"time": [3000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2014", "Google Code Jam"], "title": "[GCJ 2014 #1C] Enclosure", "background": "", "description": "Your task in this problem is to find out the minimum number of stones needed to place on an $N$-by-$M$ rectangular grid ($N$ horizontal line segments and $M$ vertical line segments) to enclose at least $K$ intersection points. An intersection point is enclosed if either of the following conditions is true:\n\n1. A stone is placed at the point.\n2. Starting from the point, we cannot trace a path along grid lines to reach an empty point on the grid border through empty intersection points only.\n\nFor example, to enclose $8$ points on a $4\\times 5$ grid, we need at least $6$ stones. One of many valid stone layouts is shown below. Enclosed points are marked with an \"x\".\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6lj78yrh.png)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each test case is a line of three integers: $N$ $M$ $K$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum number of stones needed.", "hint": "**Sample Explanation**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N$.\n- $1 \\leq M$.\n- $1 \\leq K \\leq N \\times M$.\n\n**Small dataset(15 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $N \\times M \\leq 20$.\n\n**Large dataset(30 Pts)**\n\n- Time limit: ~~120~~ 10 seconds.\n- $N \\times M \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #1C] Enclosure", "background": "", "description": "Your task in this problem is to find out the minimum number of stones needed to place on an $N$-by-$M$ rectangular grid ($N$ horizontal line segments and $M$ vertical line segments) to enclose at least $K$ intersection points. An intersection point is enclosed if either of the following conditions is true:\n\n1. A stone is placed at the point.\n2. Starting from the point, we cannot trace a path along grid lines to reach an empty point on the grid border through empty intersection points only.\n\nFor example, to enclose $8$ points on a $4\\times 5$ grid, we need at least $6$ stones. One of many valid stone layouts is shown below. Enclosed points are marked with an \"x\".\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6lj78yrh.png)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each test case is a line of three integers: $N$ $M$ $K$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum number of stones needed.", "hint": "**Sample Explanation**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N$.\n- $1 \\leq M$.\n- $1 \\leq K \\leq N \\times M$.\n\n**Small dataset(15 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $N \\times M \\leq 20$.\n\n**Large dataset(30 Pts)**\n\n- Time limit: ~~120~~ 10 seconds.\n- $N \\times M \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #1C] Enclosure", "background": "", "description": "本题中，你的任务是在一个 $N \\times M$ 的矩形网格上放置尽可能少的石头，以便**围住至少 $K$ 个交叉点**。这个网格由 $N$ 条水平线段和 $M$ 条垂直线段组成，它们的交点构成了交叉点。\n\n某个交叉点被认为是“被围住”的，当且仅当以下两种情况之一成立：\n\n1. 在该点上放置了一个石头；\n2. 从该点出发，无法仅沿网格线，经过空交叉点，到达网格边缘上的空交叉点。\n\n例如，要在一个 $4 \\times 5$ 的网格中围住 $8$ 个交叉点，至少需要放置 $6$ 个石头。下面展示了一个合法的石头放置方案。被围住的交叉点用 \"x\" 标记。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6lj78yrh.png)\n", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来的 $T$ 行，每行包含三个整数：$N$、$M$ 和 $K$，分别表示网格的行数、列数以及需要被围住的交叉点数量。", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是围住至少 $K$ 个交叉点所需的最少石头数。\n", "hint": "**样例说明**\n\n- 在第一个样例中，需要在 $4 \\times 5$ 的网格中围住至少 $8$ 个交叉点，最少需要放置 $6$ 个石头。\n- 在第二个样例中，要围住 $11$ 个交叉点，最少需要放置 $8$ 个石头。\n\n## 限制条件\n\n- $1 \\leq T \\leq 100$\n- $1 \\leq N$\n- $1 \\leq M$\n- $1 \\leq K \\leq N \\times M$\n\n### Small 数据集（15 分）\n\n- 时间限制：~~60~~ 3 秒。\n- $N \\times M \\leq 20$\n\n### Large 数据集（30 分）\n\n- 时间限制：~~120~~ 10 秒。\n- $N \\times M \\leq 1000$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13256", "type": "P", "difficulty": 2, "samples": [["3\n3 100\n10 20 70\n4 100\n30 40 60 70\n5 100\n10 20 30 40 60", "Case #1: 2\nCase #2: 2\nCase #3: 3"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2014", "双指针 two-pointer", "Google Code Jam"], "title": "[GCJ 2014 #2] Data Packing", "background": "", "description": "Adam, being a well-organized man, has always been keenly interested in organizing all his stuff. In particular, he fondly remembers the many hours of his youth that were spent moving files from his computer onto Compact Discs.\n\nThere were two very important rules involved in this procedure. First, in order to ensure that all discs could be labeled clearly, Adam would never place more than two files on the same disc. Second, he would never divide a single file over multiple discs. Happily, the discs he was using were always large enough to make this possible.\n\nThinking back, Adam is now wondering whether he arranged his files in the best way, or whether he ended up wasting some Compact Discs. He will provide you with the capacity of the discs he used (all his discs had the same capacity) as well as a list of the sizes of the files that he stored. Please help Adam out by determining the minimum number of discs needed to store all his files—following the two very important rules, of course.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing two integers: the number of files to be stored $N$, and the capacity of the discs to be used $X$ (in MBs). The next line contains the $N$ integers representing the sizes of the files $S_i$ (in MBs), separated by single spaces.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of discs needed to store the given files.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq X \\leq 700$.\n- $1 \\leq S_i \\leq X$.\n\n**Small dataset(5 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq N \\leq 10$.\n\n**Large dataset(8 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq N \\leq 10^4$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #2] Data Packing", "background": "", "description": "Adam, being a well-organized man, has always been keenly interested in organizing all his stuff. In particular, he fondly remembers the many hours of his youth that were spent moving files from his computer onto Compact Discs.\n\nThere were two very important rules involved in this procedure. First, in order to ensure that all discs could be labeled clearly, Adam would never place more than two files on the same disc. Second, he would never divide a single file over multiple discs. Happily, the discs he was using were always large enough to make this possible.\n\nThinking back, Adam is now wondering whether he arranged his files in the best way, or whether he ended up wasting some Compact Discs. He will provide you with the capacity of the discs he used (all his discs had the same capacity) as well as a list of the sizes of the files that he stored. Please help Adam out by determining the minimum number of discs needed to store all his files—following the two very important rules, of course.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing two integers: the number of files to be stored $N$, and the capacity of the discs to be used $X$ (in MBs). The next line contains the $N$ integers representing the sizes of the files $S_i$ (in MBs), separated by single spaces.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of discs needed to store the given files.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq X \\leq 700$.\n- $1 \\leq S_i \\leq X$.\n\n**Small dataset(5 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq N \\leq 10$.\n\n**Large dataset(8 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq N \\leq 10^4$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #2] Data Packing", "background": "", "description": "Adam 是个非常有条理的人，他一直热衷于整理自己的各种物品。特别是，他至今仍清晰地记得年轻时花了许多小时将电脑中的文件刻录到光盘上的情景。\n\n在这个过程中，有两个非常重要的规则。首先，为了确保每张光盘上的标签都清晰明了，Adam 从不在同一张光盘上存放超过两个文件。其次，他绝不会将一个文件拆分到多张光盘中。当然，幸运的是，他使用的光盘容量总是足够大，能满足这两个规则。\n\n回想往事，Adam 不禁开始思考：当时自己整理文件的方式是否最优？是否可能在不违反规则的前提下使用更少的光盘？他现在会提供一张光盘的容量（所有光盘容量相同），以及他曾经存储的文件大小列表。请你帮助 Adam 计算，遵守上述两个重要规则的前提下，最少需要多少张光盘才能存储所有文件。\n", "inputFormat": "输入的第一行是测试用例数量 $T$。接下来的 $T$ 个测试用例，每个测试用例的第一行包含两个整数：要存储的文件数 $N$，以及光盘容量 $X$（单位：MB）。下一行包含 $N$ 个用空格分隔的整数，表示每个文件的大小 $S_i$（单位：MB）。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是存储所有文件所需的最小光盘数。\n", "hint": "## 限制条件\n\n- $1 \\leq T \\leq 100$\n- $1 \\leq X \\leq 700$\n- $1 \\leq S_i \\leq X$\n\n### Small 数据集（5 分）\n\n- 时间限制：~~60~~ 3 秒。\n- $1 \\leq N \\leq 10$\n\n### Large 数据集（8 分）\n\n- 时间限制：~~120~~ 5 秒。\n- $1 \\leq N \\leq 10^4$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13257", "type": "P", "difficulty": 3, "samples": [["2\n3\n1 2 3\n5\n1 8 10 3 7", "Case #1: 0\nCase #2: 1"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2014", "Google Code Jam"], "title": "[GCJ 2014 #2] Up and Down", "background": "", "description": "You are given a sequence of distinct integers $A = [A_1, A_2, ..., A_N]$, and would like to rearrange it into an up and down sequence (one where $A_1 < A_2 < ... < A_m > A_{m+1} > ... > A_N$ for some index $m$, with $m$ between 1 and $N$ inclusive).\n\nThe rearrangement is accomplished by swapping two adjacent elements of the sequence at a time. Predictably, you are particularly interested in the minimum number of such swaps needed to reach an up and down sequence.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing a single integer: $N$. The next line contains $N$ distinct integers: $A_1, ..., A_N$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum number of swaps required to rearrange $A$ into an up and down sequence.", "hint": "**Sample Explanation**\n\nIn the first case, the sequence is already in the desired form (with $m=N=3$) so no swaps are required.\n\nIn the second case, swapping $3$ and $7$ produces an up and down sequence (with $m=3$).\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq A_i \\leq 10^9$.\n- The $A_i$ will be pairwise distinct.\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq N \\leq 10$.\n\n**Large dataset(11 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq N \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #2] Up and Down", "background": "", "description": "You are given a sequence of distinct integers $A = [A_1, A_2, ..., A_N]$, and would like to rearrange it into an up and down sequence (one where $A_1 < A_2 < ... < A_m > A_{m+1} > ... > A_N$ for some index $m$, with $m$ between 1 and $N$ inclusive).\n\nThe rearrangement is accomplished by swapping two adjacent elements of the sequence at a time. Predictably, you are particularly interested in the minimum number of such swaps needed to reach an up and down sequence.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing a single integer: $N$. The next line contains $N$ distinct integers: $A_1, ..., A_N$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum number of swaps required to rearrange $A$ into an up and down sequence.", "hint": "**Sample Explanation**\n\nIn the first case, the sequence is already in the desired form (with $m=N=3$) so no swaps are required.\n\nIn the second case, swapping $3$ and $7$ produces an up and down sequence (with $m=3$).\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq A_i \\leq 10^9$.\n- The $A_i$ will be pairwise distinct.\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq N \\leq 10$.\n\n**Large dataset(11 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq N \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #2] Up and Down", "background": "", "description": "给定一个由互不相同的整数构成的序列 $A = [A_1, A_2, \\dots, A_N]$，你希望将其重新排列成一个“先升后降”的序列（即存在某个下标 $m$，满足 $1 \\leq m \\leq N$，使得 $A_1 < A_2 < \\dots < A_m > A_{m+1} > \\dots > A_N$）。\n\n你只能通过每次交换两个相邻元素的方式来进行重排。你特别感兴趣的是：将序列 $A$ 排列成一个“先升后降”序列所需的**最小交换次数**。\n", "inputFormat": "输入的第一行是测试用例数量 $T$。接下来是 $T$ 个测试用例。\n\n每个测试用例的第一行是一个整数 $N$，表示序列中元素的个数。\n\n下一行是 $N$ 个互不相同的整数，依次为 $A_1, A_2, \\dots, A_N$。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是将序列 $A$ 排列成“先升后降”序列所需的最小交换次数。", "hint": "**样例解释**\n\n- 在第一个样例中，原序列已经是目标形式（此处 $m=N=3$），无需进行任何交换，答案为 $0$。\n- 在第二个样例中，将 $3$ 与 $7$ 交换即可构成“先升后降”序列（此时 $m=3$），因此最小交换次数为 $1$。\n\n## 限制条件\n\n- $1 \\leq T \\leq 100$\n- $1 \\leq A_i \\leq 10^9$\n- 所有 $A_i$ 均互不相同\n\n### Small 数据集（7 分）\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq N \\leq 10$\n\n### Large 数据集（11 分）\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq N \\leq 1000$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13258", "type": "P", "difficulty": 6, "samples": [["2\n3 3 2\n2 0 2 0\n0 2 0 2\n5 6 4\n1 0 1 0\n3 1 3 3\n0 2 1 3\n1 5 2 5", "Case #1: 1\nCase #2: 2"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["2014", "最短路", "最大流最小割定理", "Google Code Jam"], "title": "[GCJ 2014 #2] Don't Break The Nile", "background": "", "description": "Aliens have landed. These aliens find our Earth's rivers intriguing because their home planet has no flowing water at all, and now they want to construct their alien buildings in some of Earth's rivers. You have been tasked with making sure their buildings do not obstruct the flow of these rivers too much, which would cause serious problems. In particular, you need to determine what the maximum flow that the river can sustain is, given the placement of buildings.\n\nThe aliens prefer to construct their buildings on stretches of river that are straight and have uniform width. Thus you decide to model the river as a rectangular grid, where each cell has integer coordinates $(X, Y; 0 \\leq X < W$ and $0 \\leq Y < H)$. Each cell can sustain a flow of 1 unit through it, and the water can flow between edge-adjacent cells. All the cells on the south side of the river (that is with y-coordinate equal to 0) have an implicit incoming flow of 1. All buildings are rectangular and are grid-aligned. The cells that lie under a building cannot sustain any flow. Given these constraints, determine the maximum amount of flow that can reach the cells on the north side of the river (that is with y-coordinate equal to $H-1$).", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case will begin with a single line containing three integers, $W$, the width of the river, $H$, the height of the river, and $B$, the number of buildings being placed in the river. The next $B$ lines will each contain four integers, $X_0$, $Y_0$, $X_1$, and $Y_1$. $X_0$, $Y_0$ are the coordinates of the lower-left corner of the building, and $X_1$, $Y_1$ are the coordinates of the upper-right corner of the building. Buildings will not overlap, although two buildings can share an edge.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $m$\", where $x$ is the test case number (starting from 1) and $m$ is the maximum flow that can pass through the river.", "hint": "**Sample Explanation**\n\nHere are visual representations of the two test cases in the sample input:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hwtuxcp6.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uogniqfm.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq X_0 \\leq X_1 < W$.\n- $0 \\leq Y_0 \\leq Y_1 < H$.\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $3 \\leq W \\leq 100$.\n- $3 \\leq H \\leq 500$.\n- $0 \\leq B \\leq 10$.\n\n**Large dataset(20 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $3 \\leq W \\leq 1000$.\n- $3 \\leq H \\leq 10^8$.\n- $0 \\leq B \\leq 1000$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #2] Don't Break The Nile", "background": "", "description": "Aliens have landed. These aliens find our Earth's rivers intriguing because their home planet has no flowing water at all, and now they want to construct their alien buildings in some of Earth's rivers. You have been tasked with making sure their buildings do not obstruct the flow of these rivers too much, which would cause serious problems. In particular, you need to determine what the maximum flow that the river can sustain is, given the placement of buildings.\n\nThe aliens prefer to construct their buildings on stretches of river that are straight and have uniform width. Thus you decide to model the river as a rectangular grid, where each cell has integer coordinates $(X, Y; 0 \\leq X < W$ and $0 \\leq Y < H)$. Each cell can sustain a flow of 1 unit through it, and the water can flow between edge-adjacent cells. All the cells on the south side of the river (that is with y-coordinate equal to 0) have an implicit incoming flow of 1. All buildings are rectangular and are grid-aligned. The cells that lie under a building cannot sustain any flow. Given these constraints, determine the maximum amount of flow that can reach the cells on the north side of the river (that is with y-coordinate equal to $H-1$).", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case will begin with a single line containing three integers, $W$, the width of the river, $H$, the height of the river, and $B$, the number of buildings being placed in the river. The next $B$ lines will each contain four integers, $X_0$, $Y_0$, $X_1$, and $Y_1$. $X_0$, $Y_0$ are the coordinates of the lower-left corner of the building, and $X_1$, $Y_1$ are the coordinates of the upper-right corner of the building. Buildings will not overlap, although two buildings can share an edge.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $m$\", where $x$ is the test case number (starting from 1) and $m$ is the maximum flow that can pass through the river.", "hint": "**Sample Explanation**\n\nHere are visual representations of the two test cases in the sample input:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hwtuxcp6.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uogniqfm.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq X_0 \\leq X_1 < W$.\n- $0 \\leq Y_0 \\leq Y_1 < H$.\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $3 \\leq W \\leq 100$.\n- $3 \\leq H \\leq 500$.\n- $0 \\leq B \\leq 10$.\n\n**Large dataset(20 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $3 \\leq W \\leq 1000$.\n- $3 \\leq H \\leq 10^8$.\n- $0 \\leq B \\leq 1000$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #2] Don't Break The Nile", "background": "", "description": "外星人已经降临地球。他们对地球上的河流感到非常着迷，因为他们的母星上完全没有流动的水。如今，他们想在地球的某些河流中建造外星建筑。\n\n你的任务是确保这些建筑不会过度阻碍河流的流动，否则将会造成严重后果。特别地，你需要判断在建筑布置完成之后，该河流仍然能够承受的**最大水流量**。\n\n这些外星人倾向于在**笔直且宽度一致**的河道段落上建造建筑。因此，你决定将河流建模为一个**矩形网格**，网格中的每个单元格都有整数坐标 $(X, Y)$，其中 $0 \\leq X < W$ 且 $0 \\leq Y < H$。每个单元格最多只能承载 $1$ 单位的水流，水只能在边相邻的格子之间流动。\n\n所有在河流**南侧**（即 $y$ 坐标为 $0$）的格子默认拥有 $1$ 单位的入流量。\n\n建筑均为矩形，且与网格对齐。位于建筑下方的单元格将无法承载任何水流。给定这些限制条件，请你计算出**最多有多少单位的水流可以到达河流的北侧**（即 $y$ 坐标为 $H - 1$ 的格子）。\n", "inputFormat": "输入的第一行是测试用例数量 $T$。接下来是 $T$ 个测试用例。\n\n每个测试用例第一行包含三个整数：河流的宽度 $W$，高度 $H$，以及要在河流中建造的建筑数量 $B$。\n\n接下来的 $B$ 行中，每行包含四个整数：$X_0$、$Y_0$、$X_1$ 和 $Y_1$，表示建筑的左下角坐标为 $(X_0, Y_0)$，右上角坐标为 $(X_1, Y_1)$。\n\n建筑之间不会重叠，但可以共边相接。", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: m\"`，其中 $x$ 是测试用例编号（从 1 开始），$m$ 是该河流中最多可以通过的水流量。\n", "hint": "**样例解释**\n\n以下是两个样例中河流与建筑布置的可视化图示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hwtuxcp6.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uogniqfm.png)\n\n## 限制条件\n\n- $1 \\leq T \\leq 100$\n- $0 \\leq X_0 \\leq X_1 < W$\n- $0 \\leq Y_0 \\leq Y_1 < H$\n\n### Small 数据集（10 分）\n\n- 时间限制：~~60~~ 3 秒\n- $3 \\leq W \\leq 100$\n- $3 \\leq H \\leq 500$\n- $0 \\leq B \\leq 10$\n\n### Large 数据集（20 分）\n\n- 时间限制：~~120~~ 5 秒\n- $3 \\leq W \\leq 1000$\n- $3 \\leq H \\leq 10^8$\n- $0 \\leq B \\leq 1000$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13259", "type": "P", "difficulty": 6, "samples": [["2\n4 2\nAAA\nAAB\nAB\nB\n5 2\nA\nB\nC\nD\nE", "Case #1: 10 8\nCase #2: 7 30"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["2014", "树形 DP", "组合数学", "字典树 Trie", "Google Code Jam"], "title": "[GCJ 2014 #2] Trie Sharding", "background": "", "description": "A set of strings $\\mathbf{S}$ can be stored efficiently in a trie. A trie is a rooted tree that has one node for every prefix of every string in $\\mathbf{S}$, without duplicates.\n\nFor example, if $\\mathbf{S}$ were \"AAA\", \"AAB\", \"AB\", \"B\", the corresponding trie would contain 7 nodes corresponding to the prefixes \"\", \"A\", \"AA\", AAA\", \"AAB\", \"AB\", and \"B\".\n\nI have a server that contains $\\mathbf{S}$ in one big trie. Unfortunately, $\\mathbf{S}$ has become very large, and I am having trouble fitting everything in memory on one server. To solve this problem, I want to switch to storing $\\mathbf{S}$ across $\\mathbf{N}$ separate servers. Specifically, $\\mathbf{S}$ will be divided up into disjoint, non-empty subsets $\\mathbf{T}_{1}, \\mathbf{T}_{2}, \\ldots, \\mathbf{T}_{\\mathbf{N}}$, and on each server i, I will build a trie containing just the strings in $\\mathbf{T}_{\\mathbf{i}}$. The downside of this approach is the total number of nodes across all $\\mathbf{N}$ tries may go up. To make things worse, I can't control how the set of strings is divided up!\n\nFor example, suppose \"AAA\", \"AAB\", \"AB\", \"B\" are split into two servers, one containing \"AAA\" and \"B\", and the other containing \"AAB\", \"AB\". Then the trie on the first server would need 5 nodes (\"\", \"A\", \"AA\", \"AAA\", \"B\"), and the trie on the second server would also need 5 nodes (\"\", \"A\", \"AA\", \"AAB\", \"AB\"). In this case, I will need 10 nodes altogether across the two servers, as opposed to the 7 nodes I would need if I could put everything on just one server.\n\nGiven an assignment of strings to $\\mathbf{N}$ servers, I want to compute the worst-case total number of nodes across all servers, and how likely it is to happen. I can then decide if my plan is good or too risky.\n\nGiven $\\mathbf{S}$ and $\\mathbf{N}$, what is the largest number of nodes that I might end up with? Additionally, how many ways are there of choosing $\\mathbf{T}_{1}, \\mathbf{T}_{2}, \\ldots, \\mathbf{T}_{\\mathbf{N}}$ for which the number of nodes is maximum? Note that the $\\mathbf{N}$ servers are different -- if a string appears in $\\mathbf{T}_{\\mathbf{i}}$ in one arrangement and in $\\mathbf{T}_{\\mathbf{j}}$ ($i \\neq j$) in another arrangement, then the two arrangements are considered different. Print the remainder of the number of possible arrangements after division by 1,000,000,007.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two space-separated integers: $\\mathbf{M}$ and $\\mathbf{N}$. $\\mathbf{M}$ lines follow, each containing one string in $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing \"Case #i: $\\mathbf{X} \\mathbf{Y}$\", where i is the case number (starting from 1), $\\mathbf{X}$ is the worst-case number of nodes in all the tries combined, and $\\mathbf{Y}$ is the number of ways (modulo 1,000,000,007) to assign strings to servers such that the number of nodes in all $\\mathbf{N}$ servers are $\\mathbf{X}$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- Strings in $\\mathbf{S}$ will contain only upper case English letters.\n- The strings in $\\mathbf{S}$ will all be distinct.\n- $\\mathrm{N} \\leq \\mathrm{M}$\n\n**Small dataset(9 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq M \\leq 8$\n- $1 \\leq N \\leq 4$\n- Each string in $\\mathbf{S}$ will have between 1 and 10 characters, inclusive.\n\n**Large dataset(30 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq M \\leq 1000$\n- $1 \\leq N \\leq 100$\n- Each string in $\\mathbf{S}$ will have between 1 and 100 characters, inclusive.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #2] Trie Sharding", "background": "", "description": "A set of strings $\\mathbf{S}$ can be stored efficiently in a trie. A trie is a rooted tree that has one node for every prefix of every string in $\\mathbf{S}$, without duplicates.\n\nFor example, if $\\mathbf{S}$ were \"AAA\", \"AAB\", \"AB\", \"B\", the corresponding trie would contain 7 nodes corresponding to the prefixes \"\", \"A\", \"AA\", AAA\", \"AAB\", \"AB\", and \"B\".\n\nI have a server that contains $\\mathbf{S}$ in one big trie. Unfortunately, $\\mathbf{S}$ has become very large, and I am having trouble fitting everything in memory on one server. To solve this problem, I want to switch to storing $\\mathbf{S}$ across $\\mathbf{N}$ separate servers. Specifically, $\\mathbf{S}$ will be divided up into disjoint, non-empty subsets $\\mathbf{T}_{1}, \\mathbf{T}_{2}, \\ldots, \\mathbf{T}_{\\mathbf{N}}$, and on each server i, I will build a trie containing just the strings in $\\mathbf{T}_{\\mathbf{i}}$. The downside of this approach is the total number of nodes across all $\\mathbf{N}$ tries may go up. To make things worse, I can't control how the set of strings is divided up!\n\nFor example, suppose \"AAA\", \"AAB\", \"AB\", \"B\" are split into two servers, one containing \"AAA\" and \"B\", and the other containing \"AAB\", \"AB\". Then the trie on the first server would need 5 nodes (\"\", \"A\", \"AA\", \"AAA\", \"B\"), and the trie on the second server would also need 5 nodes (\"\", \"A\", \"AA\", \"AAB\", \"AB\"). In this case, I will need 10 nodes altogether across the two servers, as opposed to the 7 nodes I would need if I could put everything on just one server.\n\nGiven an assignment of strings to $\\mathbf{N}$ servers, I want to compute the worst-case total number of nodes across all servers, and how likely it is to happen. I can then decide if my plan is good or too risky.\n\nGiven $\\mathbf{S}$ and $\\mathbf{N}$, what is the largest number of nodes that I might end up with? Additionally, how many ways are there of choosing $\\mathbf{T}_{1}, \\mathbf{T}_{2}, \\ldots, \\mathbf{T}_{\\mathbf{N}}$ for which the number of nodes is maximum? Note that the $\\mathbf{N}$ servers are different -- if a string appears in $\\mathbf{T}_{\\mathbf{i}}$ in one arrangement and in $\\mathbf{T}_{\\mathbf{j}}$ ($i \\neq j$) in another arrangement, then the two arrangements are considered different. Print the remainder of the number of possible arrangements after division by 1,000,000,007.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two space-separated integers: $\\mathbf{M}$ and $\\mathbf{N}$. $\\mathbf{M}$ lines follow, each containing one string in $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing \"Case #i: $\\mathbf{X} \\mathbf{Y}$\", where i is the case number (starting from 1), $\\mathbf{X}$ is the worst-case number of nodes in all the tries combined, and $\\mathbf{Y}$ is the number of ways (modulo 1,000,000,007) to assign strings to servers such that the number of nodes in all $\\mathbf{N}$ servers are $\\mathbf{X}$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- Strings in $\\mathbf{S}$ will contain only upper case English letters.\n- The strings in $\\mathbf{S}$ will all be distinct.\n- $\\mathrm{N} \\leq \\mathrm{M}$\n\n**Small dataset(9 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq M \\leq 8$\n- $1 \\leq N \\leq 4$\n- Each string in $\\mathbf{S}$ will have between 1 and 10 characters, inclusive.\n\n**Large dataset(30 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq M \\leq 1000$\n- $1 \\leq N \\leq 100$\n- Each string in $\\mathbf{S}$ will have between 1 and 100 characters, inclusive.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #2] Trie Sharding", "background": "", "description": "一组字符串 $\\mathbf{S}$ 可以被高效地存储在一个字典树（trie）中。字典树是一棵有根树，其中每个节点代表 $\\mathbf{S}$ 中某个字符串的一个前缀，且不重复。\n\n例如，如果 $\\mathbf{S}$ 为 \"AAA\"、\"AAB\"、\"AB\" 和 \"B\"，那么对应的字典树将包含 $7$ 个节点，分别对应前缀：\"\"、\"A\"、\"AA\"、\"AAA\"、\"AAB\"、\"AB\" 和 \"B\"。\n\n我现在有一台服务器，用一个大的字典树来存储 $\\mathbf{S}$。不幸的是，随着 $\\mathbf{S}$ 的不断增大，我发现很难再将它完整地装进单台服务器的内存中。为了解决这个问题，我打算将 $\\mathbf{S}$ 拆分并存储在 $\\mathbf{N}$ 台不同的服务器上。具体来说，$\\mathbf{S}$ 将被划分成若干个不相交的非空子集 $\\mathbf{T}_1, \\mathbf{T}_2, \\ldots, \\mathbf{T}_\\mathbf{N}$，然后在每台服务器 $i$ 上构建仅包含 $\\mathbf{T}_i$ 中字符串的字典树。\n\n这种方式的缺点是：所有 $\\mathbf{N}$ 个字典树中的节点总数可能会变多。更糟的是，我无法控制字符串是如何被划分到各个服务器上的！\n\n例如，如果 \"AAA\"、\"AAB\"、\"AB\" 和 \"B\" 被分配到两台服务器，其中一台存储 \"AAA\" 和 \"B\"，另一台存储 \"AAB\" 和 \"AB\"，那么第一台服务器的字典树需要 $5$ 个节点（\"\"、\"A\"、\"AA\"、\"AAA\"、\"B\"），第二台服务器也需要 $5$ 个节点（\"\"、\"A\"、\"AA\"、\"AAB\"、\"AB\"），总共就是 $10$ 个节点。而如果将所有字符串放到一台服务器上，只需要 $7$ 个节点。\n\n现在，给定字符串集 $\\mathbf{S}$ 和服务器数 $\\mathbf{N}$，我希望你帮我计算以下两个问题：\n\n1. 在最坏的划分方案下，所有服务器上字典树节点数的总和最多是多少？\n2. 有多少种划分方式能导致上述最大节点数？由于这个数可能非常大，请输出其对 $1,\\!000,\\!000,\\!007$ 取模的结果。\n\n注意：$\\mathbf{N}$ 台服务器是有区别的——如果某种方案中一个字符串出现在 $\\mathbf{T}_i$ 中，而另一种方案中它出现在 $\\mathbf{T}_j$ 中（$i \\neq j$），则这两种划分方式被认为是不同的。\n", "inputFormat": "输入的第一行是测试用例数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例第一行包含两个用空格分隔的整数：字符串数量 $\\mathbf{M}$ 和服务器数量 $\\mathbf{N}$。接下来的 $\\mathbf{M}$ 行，每行包含一个字符串，表示集合 $\\mathbf{S}$ 中的一个元素。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #i: X Y\"`，其中 $i$ 是测试用例编号（从 1 开始），$X$ 是最坏情况下所有服务器上的节点总数，$Y$ 是使得总节点数为 $X$ 的划分方案数量，模 $1,\\!000,\\!000,\\!007$ 之后的结果。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 100$\n- 字符串集 $\\mathbf{S}$ 中的字符串只包含大写英文字符\n- $\\mathbf{S}$ 中所有字符串互不相同\n- $\\mathbf{N} \\leq \\mathbf{M}$\n\n### Small 数据集（9 分）\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq M \\leq 8$\n- $1 \\leq N \\leq 4$\n- 每个字符串长度在 $1$ 到 $10$ 之间\n\n### Large 数据集（30 分）\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq M \\leq 1000$\n- $1 \\leq N \\leq 100$\n- 每个字符串长度在 $1$ 到 $100$ 之间\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13260", "type": "P", "difficulty": 4, "samples": [["8\n1 1 1 1 1\n10 17 1 7 1\n2 100 100 200 1\n20 17 3 23 100\n10 999999 999999 1000000 1000000\n2 1 1 1 1\n3 1 99 100 1\n999999 1000000 999999 1000000 1000000", "Case #1: 0.0000000000\nCase #2: 0.6111111111\nCase #3: 0.0098039216\nCase #4: 0.6471920290\nCase #5: 0.6000006000\nCase #6: 0.5000000000\nCase #7: 0.0291262136\nCase #8: 0.6666666667"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["2014", "二分", "Special Judge", "前缀和", "双指针 two-pointer", "Google Code Jam"], "title": "[GCJ 2014 #3] Magical, Marvelous Tour", "background": "", "description": "The mysterious owner of an electronics factory has decided to do something very intriguing. She has hidden golden transistors inside seven electronic devices, and the people who buy those devices will be invited to a magical, marvelous tour of the factory.\n\nArnar and Solveig have received a tip that there is a golden transistor hidden inside one device in their local electronics store. First they pooled their money together and bought all the devices, then placed them in a straight line, numbering the devices $0$ to $\\mathbf{N}-1$. Each device has some number of transistors in it. Then they agreed on a strategy to decide who gets the golden transistor:\n\nFirst, Arnar will select a range $[a, b]$ (inclusive) of the devices, where $0 \\leq a \\leq b < \\mathbf{N}$. Next, Solveig will choose which one set of devices she wants to take:\n\n* If $a > 0$, she may take all the devices in the range $[0, a-1]$.\n* If $b < N-1$, she may take all the devices in the range $[b+1, N-1]$.\n* She may always choose to take all the devices in the range $[a, b]$.\n\nOnce Solveig has chosen one of the sets of devices, Arnar takes all the devices she did not take.\n\nFor example, if there are 3 devices and Arnar selects the range $[1, 1]$, Solveig may choose to take the range $[0, 0]$, the range $[1, 1]$ or the range $[2, 2]$. On the other hand, if Arnar selects the range $[1, 2]$, then Solveig may choose to take the range $[0, 0]$ or the range $[1, 2]$.\n\nGiven how many transistors are in each device, and that Arnar and Solveig will each try to maximize their probability of getting the golden transistor (which is maximized by taking electronics with the maximum number of transistors), what is Arnar's probability of getting the golden transistor and thus winning the magical, marvelous tour?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains five numbers: $\\mathbf{N}$, $\\mathbf{p}$, $\\mathbf{q}$, $\\mathbf{r}$ and $\\mathbf{s}$. This indicates that there are $\\mathbf{N}$ devices, and the $i^{\\text {th }}$ device contains $((i \\times \\mathbf{p} + \\mathbf{q}) \\bmod \\mathbf{r} + \\mathbf{s})$ transistors. Remember that the devices are numbered from 0 to $\\mathbf{N}-1$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is Arnar's probability of winning the magical, marvelous tour.\n\n$y$ will be considered correct if it is within an absolute or relative error of $10^{-9}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn the first sample case, there is one electronic device with one transistor. Arnar must select the range $[0, 0]$, and Solveig must choose to take all the devices in the range $[0, 0]$. Arnar can't possibly win the magical, marvelous tour.\n\nIn the second sample case, there are ten electronic devices, with the following numbers of transistors: $[2, 5, 1, 4, 7, 3, 6, 2, 5, 1]$. Arnar will choose the range $[4, 5]$, which contains the devices with 7 and 3 transistors. Solveig will choose the range $[6, 9]$, which contains the devices with 6, 2, 5 and 1 transistors, leaving Arnar with the first six devices, and a probability of $22/36$ of winning the tour.\n\nIn the third sample case, the devices have 101 and 1 transistors.\n\nIn the fourth sample case, the devices have the following numbers of transistors: $[103, 120, 114, 108, 102, 119, 113, 107, 101, 118, 112, 106, 100, 117, 111, 105, 122, 116, 110, 104]$.\n\nIn the fifth sample case, the devices have the following numbers of transistors: $[1999999, 1999998, 1999997, 1999996, 1999995, 1999994, 1999993, 1999992, 1999991, 1999990]$.\n\nIn the sixth sample case, the devices both have 1 transistor.\n\nIn the seventh sample case, the devices have the following numbers of transistors: $[100, 1, 2]$.\n\nNote that the last sample case does not meet the limits for the Small dataset. You could have a correct solution for the Small dataset that returns the wrong answer, or runs for a very long time, on the last sample case.\n\n**Sample Explanation**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq \\mathbf{p} \\leq 10^{6}$.\n- $1 \\leq \\mathbf{q} \\leq 10^{6}$.\n- $1 \\leq \\mathbf{r} \\leq 10^{6}$.\n- $1 \\leq \\mathbf{s} \\leq 10^{6}$.\n\n**Small dataset(5 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Large dataset(8 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 10^{6}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #3] Magical, Marvelous Tour", "background": "", "description": "The mysterious owner of an electronics factory has decided to do something very intriguing. She has hidden golden transistors inside seven electronic devices, and the people who buy those devices will be invited to a magical, marvelous tour of the factory.\n\nArnar and Solveig have received a tip that there is a golden transistor hidden inside one device in their local electronics store. First they pooled their money together and bought all the devices, then placed them in a straight line, numbering the devices $0$ to $\\mathbf{N}-1$. Each device has some number of transistors in it. Then they agreed on a strategy to decide who gets the golden transistor:\n\nFirst, Arnar will select a range $[a, b]$ (inclusive) of the devices, where $0 \\leq a \\leq b < \\mathbf{N}$. Next, Solveig will choose which one set of devices she wants to take:\n\n* If $a > 0$, she may take all the devices in the range $[0, a-1]$.\n* If $b < N-1$, she may take all the devices in the range $[b+1, N-1]$.\n* She may always choose to take all the devices in the range $[a, b]$.\n\nOnce Solveig has chosen one of the sets of devices, Arnar takes all the devices she did not take.\n\nFor example, if there are 3 devices and Arnar selects the range $[1, 1]$, Solveig may choose to take the range $[0, 0]$, the range $[1, 1]$ or the range $[2, 2]$. On the other hand, if Arnar selects the range $[1, 2]$, then Solveig may choose to take the range $[0, 0]$ or the range $[1, 2]$.\n\nGiven how many transistors are in each device, and that Arnar and Solveig will each try to maximize their probability of getting the golden transistor (which is maximized by taking electronics with the maximum number of transistors), what is Arnar's probability of getting the golden transistor and thus winning the magical, marvelous tour?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains five numbers: $\\mathbf{N}$, $\\mathbf{p}$, $\\mathbf{q}$, $\\mathbf{r}$ and $\\mathbf{s}$. This indicates that there are $\\mathbf{N}$ devices, and the $i^{\\text {th }}$ device contains $((i \\times \\mathbf{p} + \\mathbf{q}) \\bmod \\mathbf{r} + \\mathbf{s})$ transistors. Remember that the devices are numbered from 0 to $\\mathbf{N}-1$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is Arnar's probability of winning the magical, marvelous tour.\n\n$y$ will be considered correct if it is within an absolute or relative error of $10^{-9}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn the first sample case, there is one electronic device with one transistor. Arnar must select the range $[0, 0]$, and Solveig must choose to take all the devices in the range $[0, 0]$. Arnar can't possibly win the magical, marvelous tour.\n\nIn the second sample case, there are ten electronic devices, with the following numbers of transistors: $[2, 5, 1, 4, 7, 3, 6, 2, 5, 1]$. Arnar will choose the range $[4, 5]$, which contains the devices with 7 and 3 transistors. Solveig will choose the range $[6, 9]$, which contains the devices with 6, 2, 5 and 1 transistors, leaving Arnar with the first six devices, and a probability of $22/36$ of winning the tour.\n\nIn the third sample case, the devices have 101 and 1 transistors.\n\nIn the fourth sample case, the devices have the following numbers of transistors: $[103, 120, 114, 108, 102, 119, 113, 107, 101, 118, 112, 106, 100, 117, 111, 105, 122, 116, 110, 104]$.\n\nIn the fifth sample case, the devices have the following numbers of transistors: $[1999999, 1999998, 1999997, 1999996, 1999995, 1999994, 1999993, 1999992, 1999991, 1999990]$.\n\nIn the sixth sample case, the devices both have 1 transistor.\n\nIn the seventh sample case, the devices have the following numbers of transistors: $[100, 1, 2]$.\n\nNote that the last sample case does not meet the limits for the Small dataset. You could have a correct solution for the Small dataset that returns the wrong answer, or runs for a very long time, on the last sample case.\n\n**Sample Explanation**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq \\mathbf{p} \\leq 10^{6}$.\n- $1 \\leq \\mathbf{q} \\leq 10^{6}$.\n- $1 \\leq \\mathbf{r} \\leq 10^{6}$.\n- $1 \\leq \\mathbf{s} \\leq 10^{6}$.\n\n**Small dataset(5 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Large dataset(8 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 10^{6}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #3] Magical, Marvelous Tour", "background": "", "description": "一位神秘的电子工厂老板做了一件十分吸引人的事：她在七台电子设备中藏了金色晶体管，而购买到这些设备的人将被邀请参加一次神奇而奇妙的工厂之旅。\n\nArnar 和 Solveig 得到线报，说他们本地的电子商店中某台设备里藏有一个金色晶体管。于是他们凑钱买下了所有的设备，并将设备排成一排，从 $0$ 到 $\\mathbf{N} - 1$ 编号。每台设备中都含有若干个晶体管。他们商定了一个决定谁获得金色晶体管的策略：\n\n首先，Arnar 选择一个区间 $[a, b]$（闭区间），其中 $0 \\leq a \\leq b < \\mathbf{N}$，表示选中这段设备。\n\n接下来，Solveig 可以从以下选项中选择她要的设备集：\n\n- 如果 $a > 0$，她可以选择 $[0, a-1]$ 这一段；\n- 如果 $b < N - 1$，她可以选择 $[b+1, N-1]$ 这一段；\n- 她始终可以选择 $[a, b]$ 这一段。\n\nSolveig 选择完毕后，Arnar 拿走剩下的所有设备。\n\n例如，若设备总数为 $3$，Arnar 选择区间 $[1, 1]$，那么 Solveig 可以选择的设备段包括 $[0, 0]$、$[1, 1]$ 或 $[2, 2]$；但如果 Arnar 选择的是 $[1, 2]$，那么 Solveig 只能选择 $[0, 0]$ 或 $[1, 2]$。\n\n在知道每台设备中晶体管数量的前提下，假设 Arnar 和 Solveig 都会选择最大化自己获得金色晶体管概率的方案（即尽可能拿晶体管总数多的设备），那么 Arnar 最终获得金色晶体管的概率是多少？\n", "inputFormat": "输入的第一行是测试用例数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 行，每行包含五个整数：$\\mathbf{N}$、$\\mathbf{p}$、$\\mathbf{q}$、$\\mathbf{r}$ 和 $\\mathbf{s}$。表示有 $\\mathbf{N}$ 台设备，其中第 $i$ 台设备含有 $((i \\times \\mathbf{p} + \\mathbf{q}) \\bmod \\mathbf{r} + \\mathbf{s})$ 个晶体管。设备编号为 $0$ 到 $\\mathbf{N}-1$。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是 Arnar 获得金色晶体管的概率。\n\n你的输出将被认为是正确的，只要绝对误差或相对误差在 $10^{-9}$ 以内。\n", "hint": "**样例解释**\n\n- 在第一个样例中，只有一台设备且含有一个晶体管。Arnar 只能选择区间 $[0, 0]$，Solveig 也只能选择这一段，因此 Arnar 不可能获得金色晶体管，概率为 $0$。\n- 在第二个样例中，共 $10$ 台设备，晶体管数为：$[2, 5, 1, 4, 7, 3, 6, 2, 5, 1]$。Arnar 若选择区间 $[4, 5]$，包含晶体管为 $7$ 和 $3$ 的设备。Solveig 会选择 $[6, 9]$（总数为 $14$）而非 $[4, 5]$（总数为 $10$），那么 Arnar 将获得 $[0, 5]$，总数为 $22$，整列设备总数为 $36$，所以 Arnar 获胜概率为 $22 / 36 = 0.6111111111$。\n- 在第三个样例中，两台设备分别有 $101$ 和 $1$ 个晶体管。\n- 第五个样例中设备数为 $10$，晶体管数从 $1999999$ 递减到 $1999990$。\n\n**限制条件**\n\n- $1 \\leq T \\leq 100$\n- $1 \\leq \\mathbf{p}, \\mathbf{q}, \\mathbf{r}, \\mathbf{s} \\leq 10^6$\n\n### Small 数据集（5 分）\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq \\mathbf{N} \\leq 1000$\n\n### Large 数据集（8 分）\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq \\mathbf{N} \\leq 10^6$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13261", "type": "P", "difficulty": 5, "samples": [["2\n20 40 3\n100 100\n20 100\n60 100\n20 60 3\n80 100\n80 200\n120 300", "Case #1: 300\nCase #2: 500"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2014", "记忆化搜索", "Google Code Jam"], "title": "[GCJ 2014 #3] Last Hit", "background": "", "description": "Diana needs your help maximizing her gold while playing her favorite game. She is often faced with a scenario where she is standing close to her tower and is facing $\\mathbf{N}$ monsters. When that happens, Diana and the tower take turns shooting the monsters, and she goes first. During her turn, Diana may choose a monster to shoot at (this means Diana may choose to skip a turn). During its turn, the tower shoots the monster closest to it. Diana and the tower can not shoot dead monsters.\n\nIf Diana shoots at a monster, its hit points are reduced by $\\mathbf{P}$. If the tower shoots at a monster, its hit points are reduced by $\\mathbf{Q}$. If a monster's hit points are reduced below 1, it is killed. The $i^{\\text {th }}$ monster starts with $\\mathbf{H}_{\\mathrm{i}}$ hit points. Diana is awarded $\\mathbf{G}_{\\mathrm{i}}$ gold if her shot kills the $i^{\\text {th }}$ monster, but none if the tower's shot kills it. What is the maximum amount of gold Diana can obtain?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing three space-separated integers representing $\\mathbf{P}, \\mathbf{Q}$ and $\\mathbf{N}$. $\\mathbf{N}$ lines then follow, with the $i^{\\text {th }}$ line containing two space-separated integers representing $\\mathbf{H}_{\\mathrm{i}}$ and $\\mathbf{G}_{\\mathrm{i}}$.\n\nThe monsters are given in the order of their distance from the tower. In other words, the tower will shoot at the $i^{\\text {th }}$ monster only if all monsters $<i$ are dead.", "outputFormat": "For each test case, output one line containing \"Case #x: $y$\", where x is the case number (starting from 1) and $y$ is the maximum amount of gold that Diana can obtain.", "hint": "**Sample Explanation**\n\nIn the second example, Diana should give up the first monster. During her first two turns she should soften up the third monster bringing it down to 80 hp, allowing her to easily get the last shot on the second and the third monsters.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$\n- $20 \\leq \\mathbf{P} \\leq 200$\n- $20 \\leq \\mathbf{Q} \\leq 200$\n- $1 \\leq \\mathbf{H}_{\\mathrm{i}} \\leq 200$\n- $0 \\leq \\mathbf{G}_{\\mathrm{i}} \\leq 10^{6}$\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\mathbf{N} \\leq 4$\n\n**Large dataset(14 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 100$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #3] Last Hit", "background": "", "description": "Diana needs your help maximizing her gold while playing her favorite game. She is often faced with a scenario where she is standing close to her tower and is facing $\\mathbf{N}$ monsters. When that happens, Diana and the tower take turns shooting the monsters, and she goes first. During her turn, Diana may choose a monster to shoot at (this means Diana may choose to skip a turn). During its turn, the tower shoots the monster closest to it. Diana and the tower can not shoot dead monsters.\n\nIf Diana shoots at a monster, its hit points are reduced by $\\mathbf{P}$. If the tower shoots at a monster, its hit points are reduced by $\\mathbf{Q}$. If a monster's hit points are reduced below 1, it is killed. The $i^{\\text {th }}$ monster starts with $\\mathbf{H}_{\\mathrm{i}}$ hit points. Diana is awarded $\\mathbf{G}_{\\mathrm{i}}$ gold if her shot kills the $i^{\\text {th }}$ monster, but none if the tower's shot kills it. What is the maximum amount of gold Diana can obtain?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing three space-separated integers representing $\\mathbf{P}, \\mathbf{Q}$ and $\\mathbf{N}$. $\\mathbf{N}$ lines then follow, with the $i^{\\text {th }}$ line containing two space-separated integers representing $\\mathbf{H}_{\\mathrm{i}}$ and $\\mathbf{G}_{\\mathrm{i}}$.\n\nThe monsters are given in the order of their distance from the tower. In other words, the tower will shoot at the $i^{\\text {th }}$ monster only if all monsters $<i$ are dead.", "outputFormat": "For each test case, output one line containing \"Case #x: $y$\", where x is the case number (starting from 1) and $y$ is the maximum amount of gold that Diana can obtain.", "hint": "**Sample Explanation**\n\nIn the second example, Diana should give up the first monster. During her first two turns she should soften up the third monster bringing it down to 80 hp, allowing her to easily get the last shot on the second and the third monsters.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$\n- $20 \\leq \\mathbf{P} \\leq 200$\n- $20 \\leq \\mathbf{Q} \\leq 200$\n- $1 \\leq \\mathbf{H}_{\\mathrm{i}} \\leq 200$\n- $0 \\leq \\mathbf{G}_{\\mathrm{i}} \\leq 10^{6}$\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\mathbf{N} \\leq 4$\n\n**Large dataset(14 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 100$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #3] Last Hit", "background": "", "description": "Diana 需要你的帮助，在她最喜欢的游戏中尽可能赚取更多金币。她经常会遇到这样一种情况：她站在自己的防御塔附近，面对着 $\\mathbf{N}$ 个怪物。在这种情况下，Diana 和防御塔轮流攻击怪物，且 Diana 先手。在她的回合中，Diana 可以选择攻击任意一个怪物（也可以选择跳过回合）；在塔的回合中，塔会攻击距离它最近的存活怪物。\n\nDiana 和塔都不能攻击已经死亡的怪物。\n\n如果 Diana 攻击了某个怪物，则该怪物的生命值会减少 $\\mathbf{P}$；如果塔攻击怪物，该怪物的生命值会减少 $\\mathbf{Q}$。当怪物的生命值降到小于 1 时，它会被击杀。如果是 Diana 击杀了第 $i$ 个怪物，她将获得 $\\mathbf{G}_{\\mathrm{i}}$ 金币；如果是塔击杀了怪物，Diana 不会获得金币。\n\n第 $i$ 个怪物初始生命值为 $\\mathbf{H}_{\\mathrm{i}}$。\n\n怪物按照它们距离防御塔的远近顺序给出，也就是说，塔只有在编号小于 $i$ 的怪物都死亡之后，才会攻击第 $i$ 个怪物。\n\n请你计算，Diana 最多可以获得多少金币？", "inputFormat": "输入的第一行是测试用例数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例第一行包含三个用空格分隔的整数，分别表示 $\\mathbf{P}$、$\\mathbf{Q}$ 和 $\\mathbf{N}$。\n\n接下来的 $\\mathbf{N}$ 行中，第 $i$ 行包含两个用空格分隔的整数，分别表示第 $i$ 个怪物的生命值 $\\mathbf{H}_{\\mathrm{i}}$ 和金币奖励 $\\mathbf{G}_{\\mathrm{i}}$。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Diana 最多可以获得的金币数。\n", "hint": "**样例说明**\n\n在第二个样例中，Diana 应该放弃第一个怪物。她应在前两个回合中攻击第三个怪物，将其生命值削减至 80 点，然后她就可以轻松地拿到对第二个和第三个怪物的最后一击，从而获得两者的金币奖励。\n\n## 限制条件\n\n- $1 \\leq T \\leq 100$\n- $20 \\leq \\mathbf{P} \\leq 200$\n- $20 \\leq \\mathbf{Q} \\leq 200$\n- $1 \\leq \\mathbf{H}_{\\mathrm{i}} \\leq 200$\n- $0 \\leq \\mathbf{G}_{\\mathrm{i}} \\leq 10^6$\n\n### Small 数据集（10 分）\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq \\mathbf{N} \\leq 4$\n\n### Large 数据集（14 分）\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq \\mathbf{N} \\leq 100$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13262", "type": "P", "difficulty": 6, "samples": [["5\n3\nE 5\nL 0\nE 5\n2\nL 1\nL 1\n4\nL 1\nE 0\nE 0\nL 1\n7\nL 2\nE 0\nE 1\nE 2\nE 0\nE 3\nL 4\n13\nL 4\nL 1\nL 2\nE 0\nL 1\nE 0\nL 2\nE 0\nL 2\nE 0\nE 0\nL 1\nL 4", "Case #1: 1\nCase #2: CRIME TIME\nCase #3: 1\nCase #4: 4\nCase #5: 0"]], "limits": {"time": [3000, 10000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2014", "二分", "分类讨论", "Google Code Jam"], "title": "[GCJ 2014 #3] Crime House", "background": "", "description": "While working for the police, you've identified a house where people go to commit crimes, called Crime House. One day, you set up a camera over the door of the house and record a video.\n\nYou don't know how many people were in Crime House at the start of the day, but you can see people enter and leave through the front door. Unfortunately, because the people entering and leaving Crime House are criminals, sometimes they wear masks; and you aren't quite sure if the front door is the only way in or out.\n\nSometimes you can guess who was wearing a mask. If criminal #5 entered the house, then someone wearing a mask left, then criminal #5 entered the house again, then either the person wearing the mask was criminal #5, or there is another way out of Crime House.\n\nAt the end of the day, when Crime House has closed its doors for the night, you watch your video. Because you're an optimist, you want to figure out if it's possible that there are no other entrances or exits from crime house; and if so, you want to figure out the minimum number of people who could be in Crime House at the end of the day.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing a single integer $\\mathbf{N}$, the number of times people pass through the front door of Crime House in the day. Next follows $\\mathbf{N}$ lines, each of which contains information about one person entering or leaving Crime House through the front door.\n\nThat information consists of a single character, $\\mathbf{E}$ or $\\mathbf{L}$, followed by a space and then an integer $\\mathbf{i d}$. If the first character is $\\mathbf{E}$, that indicates someone entered Crime House through the front door; if it's $\\mathbf{L}$, someone left through the front door. If $\\mathbf{i d}$ is greater than zero, the person with that identifier entered or left Crime House. If $\\mathbf{i d}$ is zero, then the person who entered or left Crime House was wearing a mask, and we don't know who he or she was.\n", "outputFormat": "For each test case, output one line containing \"Case #x: $y$\", where $\\mathrm{x}$ is the test case number (starting from 1). If it's possible that there are no other entrances or exits from Crime House, then $y$ should be the minimum number of people who could be in Crime House at the end of the day. If that's impossible, $y$ should be \"CRIME TIME\".", "hint": "**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100 .$\n- $0 \\leq \\text {id} \\leq 2000 .$\n\n**Small dataset(12 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\mathbf{N} \\leq 15 .$\n\n**Large dataset(22 Pts)**\n\n- Time limit: ~~120~~ 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #3] Crime House", "background": "", "description": "While working for the police, you've identified a house where people go to commit crimes, called Crime House. One day, you set up a camera over the door of the house and record a video.\n\nYou don't know how many people were in Crime House at the start of the day, but you can see people enter and leave through the front door. Unfortunately, because the people entering and leaving Crime House are criminals, sometimes they wear masks; and you aren't quite sure if the front door is the only way in or out.\n\nSometimes you can guess who was wearing a mask. If criminal #5 entered the house, then someone wearing a mask left, then criminal #5 entered the house again, then either the person wearing the mask was criminal #5, or there is another way out of Crime House.\n\nAt the end of the day, when Crime House has closed its doors for the night, you watch your video. Because you're an optimist, you want to figure out if it's possible that there are no other entrances or exits from crime house; and if so, you want to figure out the minimum number of people who could be in Crime House at the end of the day.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing a single integer $\\mathbf{N}$, the number of times people pass through the front door of Crime House in the day. Next follows $\\mathbf{N}$ lines, each of which contains information about one person entering or leaving Crime House through the front door.\n\nThat information consists of a single character, $\\mathbf{E}$ or $\\mathbf{L}$, followed by a space and then an integer $\\mathbf{i d}$. If the first character is $\\mathbf{E}$, that indicates someone entered Crime House through the front door; if it's $\\mathbf{L}$, someone left through the front door. If $\\mathbf{i d}$ is greater than zero, the person with that identifier entered or left Crime House. If $\\mathbf{i d}$ is zero, then the person who entered or left Crime House was wearing a mask, and we don't know who he or she was.\n", "outputFormat": "For each test case, output one line containing \"Case #x: $y$\", where $\\mathrm{x}$ is the test case number (starting from 1). If it's possible that there are no other entrances or exits from Crime House, then $y$ should be the minimum number of people who could be in Crime House at the end of the day. If that's impossible, $y$ should be \"CRIME TIME\".", "hint": "**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100 .$\n- $0 \\leq \\text {id} \\leq 2000 .$\n\n**Small dataset(12 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\mathbf{N} \\leq 15 .$\n\n**Large dataset(22 Pts)**\n\n- Time limit: ~~120~~ 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #3] Crime House", "background": "", "description": "你作为警方的一员，发现了一栋人们会前往犯罪的房子，称作 Crime House。某一天，你在这栋房子的前门上安装了一个摄像头并开始录像。\n\n你不知道这一天开始时 Crime House 里有多少人，但你能看到有人从前门进入和离开。不幸的是，由于这些进出 Crime House 的人都是罪犯，他们有时会戴着面具；而你也无法确定前门是否是唯一的出入口。\n\n有时候你可以猜出谁戴了面具。例如，如果罪犯编号为 5 的人进入了房子，然后一个戴着面具的人离开了，然后编号 5 又进入了一次，那么这个戴面具离开的要么就是罪犯 5，要么就是还有其他出入口存在。\n\n在一天结束，Crime House 关门之后，你回看了录像。作为一名乐观主义者，你想知道：是否有可能 Crime House 并没有其他出入口？如果有这种可能，你还希望知道：**在这种前提下，Crime House 最后最少可能还有多少人留在里面**。", "inputFormat": "输入的第一行是测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例以一个整数 $\\mathbf{N}$ 开头，表示当天录像中人们经过前门的事件总数。接下来的 $\\mathbf{N}$ 行中，每行描述一次进入或离开：\n\n- 每行的格式为一个字符 $\\mathbf{E}$ 或 $\\mathbf{L}$ 加一个空格，再加一个整数 $\\mathbf{id}$。\n- 如果是 $\\mathbf{E}$，表示某人从前门进入 Crime House；\n- 如果是 $\\mathbf{L}$，表示某人从前门离开；\n- 如果 $\\mathbf{id} > 0$，表示该编号的罪犯进出；\n- 如果 $\\mathbf{id} = 0$，表示该人戴着面具，无法识别身份。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是以下二者之一：\n\n- 如果有可能 Crime House 没有其他出入口，则输出 Crime House 可能最后剩下的人数最小值；\n- 如果不可能，则输出字符串 `\"CRIME TIME\"`（不带引号）。\n", "hint": "## 限制条件\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $0 \\leq \\mathbf{id} \\leq 2000$\n\n### Small 数据集（12 分）\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq \\mathbf{N} \\leq 15$\n\n### Large 数据集（22 分）\n\n- 时间限制：~~120~~ 10 秒\n- $1 \\leq \\mathbf{N} \\leq 1000$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13263", "type": "P", "difficulty": 7, "samples": [["3\n3\n1000\n200\n1000\n2\n3\n8\n8\n0\n8\n0\n0\n0\n0\n10\n2\n5\n4\n5\n6\n7\n8\n10\n150\n200\n0\n5000\n0\n100\n0\n0\n0\n10000\n10\n3\n8\n5\n8\n7\n8\n9\n10", "Case #1: 200\nCase #2: -2\nCase #3: 5100"]], "limits": {"time": [30000, 30000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "博弈论", "2014", "记忆化搜索", "树形 DP", "Google Code Jam"], "title": "[GCJ 2014 #3] Willow", "background": "", "description": "Hanaa and Sherine are playing Willow, a game that is played on a board containing $\\mathbf{N}$ cities. The $\\mathrm{i}^{\\text {th }}$ city contains $\\mathbf{C}_{\\mathrm{i}}$ coins, and there are $\\mathbf{N}-1$ bidirectional roads running between the cities. All cities are reachable from one another. The game is played as follows:\n\nFirst Hanaa chooses one of the cities as her starting location, then Sherine chooses one of the cities (possibly the same one Hanaa chose) as her starting location. Afterwards, they take turns playing the game, with Hanaa going first.\n\nOn a player's turn, that player must take all the coins on the city where she currently is, if there are any; there might be none if the city starts with no coins, or if one of the players has already started a turn in that city. Then, if possible, the player must travel to an adjacent city on a road. It might not be possible, because each road can be used at most once. This means that after one player has used a road, neither player is allowed to use the same road later. The game ends when neither Hanaa nor Sherine can make a move.\n\nAfter the game ends, each player's score is equal to the difference between the number of coins she has and the number of coins her opponent has. If her opponent has more coins, this means that her score will be negative. Both players are trying to maximize their scores. Assuming that they are both using the best possible strategy to maximize their scores, what is the highest score that Hanaa can obtain?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing one integer $\\mathbf{N}$, the number of cities on the board. $\\mathbf{N}$ lines then follow, with the $\\mathrm{i}^{\\text {th }}$ line containing an integer $\\mathbf{C}_{\\mathrm{i}}$, the number of coins in city $\\mathrm{i}$.\n\nFinally there will be another $\\mathbf{N}-1$ lines, with the $\\mathrm{i}^{\\text {th }}$ line $(\\mathrm{i}$ starts from 1$)$ containing a single integer $\\mathrm{j}(\\mathrm{i}<\\mathrm{j} \\leq \\mathbf{N})$ indicating that there is a road between city $\\mathrm{i}$ and city $\\mathrm{j}$. All cities are guaranteed to be reachable from one another at the start of the game.\n", "outputFormat": "For each test case, output one line containing \"Case #x: $y$\", where $\\mathrm{x}$ is the case number (starting from 1) and $y$ is the highest score that Hanaa can obtain.", "hint": "**Limits**\n\n- Memory limit: 1 GB.\n- $1 \\leq \\mathbf{T} \\leq 50 .$\n- $0 \\leq \\mathbf{C}_{\\mathrm{i}} \\leq 10000 .$\n\n**Small dataset(15 Pts)**\n\n- Time limit: ~~60~~ 30 seconds.\n- $2 \\leq \\mathbf{N} \\leq 80 .$\n\n**Large dataset(24 Pts)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $2 \\leq \\mathbf{N} \\leq 500 .$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #3] Willow", "background": "", "description": "Hanaa and Sherine are playing Willow, a game that is played on a board containing $\\mathbf{N}$ cities. The $\\mathrm{i}^{\\text {th }}$ city contains $\\mathbf{C}_{\\mathrm{i}}$ coins, and there are $\\mathbf{N}-1$ bidirectional roads running between the cities. All cities are reachable from one another. The game is played as follows:\n\nFirst Hanaa chooses one of the cities as her starting location, then Sherine chooses one of the cities (possibly the same one Hanaa chose) as her starting location. Afterwards, they take turns playing the game, with Hanaa going first.\n\nOn a player's turn, that player must take all the coins on the city where she currently is, if there are any; there might be none if the city starts with no coins, or if one of the players has already started a turn in that city. Then, if possible, the player must travel to an adjacent city on a road. It might not be possible, because each road can be used at most once. This means that after one player has used a road, neither player is allowed to use the same road later. The game ends when neither Hanaa nor Sherine can make a move.\n\nAfter the game ends, each player's score is equal to the difference between the number of coins she has and the number of coins her opponent has. If her opponent has more coins, this means that her score will be negative. Both players are trying to maximize their scores. Assuming that they are both using the best possible strategy to maximize their scores, what is the highest score that Hanaa can obtain?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing one integer $\\mathbf{N}$, the number of cities on the board. $\\mathbf{N}$ lines then follow, with the $\\mathrm{i}^{\\text {th }}$ line containing an integer $\\mathbf{C}_{\\mathrm{i}}$, the number of coins in city $\\mathrm{i}$.\n\nFinally there will be another $\\mathbf{N}-1$ lines, with the $\\mathrm{i}^{\\text {th }}$ line $(\\mathrm{i}$ starts from 1$)$ containing a single integer $\\mathrm{j}(\\mathrm{i}<\\mathrm{j} \\leq \\mathbf{N})$ indicating that there is a road between city $\\mathrm{i}$ and city $\\mathrm{j}$. All cities are guaranteed to be reachable from one another at the start of the game.\n", "outputFormat": "For each test case, output one line containing \"Case #x: $y$\", where $\\mathrm{x}$ is the case number (starting from 1) and $y$ is the highest score that Hanaa can obtain.", "hint": "**Limits**\n\n- Memory limit: 1 GB.\n- $1 \\leq \\mathbf{T} \\leq 50 .$\n- $0 \\leq \\mathbf{C}_{\\mathrm{i}} \\leq 10000 .$\n\n**Small dataset(15 Pts)**\n\n- Time limit: ~~60~~ 30 seconds.\n- $2 \\leq \\mathbf{N} \\leq 80 .$\n\n**Large dataset(24 Pts)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $2 \\leq \\mathbf{N} \\leq 500 .$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #3] Willow", "background": "", "description": "Hanaa 和 Sherine 正在玩一款叫做 Willow 的游戏，这个游戏在一张包含 $\\mathbf{N}$ 座城市的地图上进行。第 $\\mathrm{i}$ 座城市中含有 $\\mathbf{C}_{\\mathrm{i}}$ 枚金币，城市之间通过 $\\mathbf{N} - 1$ 条双向道路连接，保证任意两座城市之间都可以互相到达。\n\n游戏规则如下：\n\n首先，Hanaa 选择一座城市作为她的起始位置。接着，Sherine 也选择一座城市作为她的起始位置（可以选择与 Hanaa 相同的城市）。之后，她们轮流行动，由 Hanaa 先开始。\n\n在每个玩家的回合中，她必须收走当前所在城市的所有金币（如果还有的话）；如果这座城市本来没有金币，或者金币已经在先前被某个玩家起始回合收走了，那么这一回合就不会获得金币。然后，如果可能的话，玩家必须沿着一条道路移动到相邻的城市。但要注意：**每条道路最多只能使用一次**，即一旦某条道路被任何一个玩家使用过，之后两人都不能再走这条路。若某位玩家无法移动，她的回合立即结束。\n\n当 Hanaa 和 Sherine 都无法再行动时，游戏结束。\n\n每位玩家的得分为自己获得的金币数减去对手获得的金币数。如果对手获得的金币更多，该玩家得分则为负数。两人都采用最优策略，目的是**最大化自己的得分**。\n\n请你计算：在双方都采取最优策略的前提下，Hanaa 最多能获得多少分？\n", "inputFormat": "输入的第一行是测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示地图上的城市数量。\n\n接下来的 $\\mathbf{N}$ 行中，第 $i$ 行包含一个整数 $\\mathbf{C}_{\\mathrm{i}}$，表示第 $i$ 座城市的金币数。\n\n之后是 $\\mathbf{N} - 1$ 行，第 $i$ 行（$i$ 从 1 开始）包含一个整数 $j$，表示城市 $i$ 与城市 $j$ 之间有一条道路。保证图中所有城市最开始是连通的。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Hanaa 在最优对局中最多可以获得的分数。\n", "hint": "## 限制条件\n\n- 内存限制：1 GB\n- $1 \\leq \\mathbf{T} \\leq 50$\n- $0 \\leq \\mathbf{C}_{\\mathrm{i}} \\leq 10000$\n\n### Small 数据集（15 分）\n\n- 时间限制：~~60~~ 30 秒\n- $2 \\leq \\mathbf{N} \\leq 80$\n\n### Large 数据集（24 分）\n\n- 时间限制：~~120~~ 30 秒\n- $2 \\leq \\mathbf{N} \\leq 500$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13264", "type": "P", "difficulty": 5, "samples": [["3\n1\n01\n10\n2\n1001\n0110\n0110\n1001\n1\n00\n00", "Case #1: 0\nCase #2: 2\nCase #3: IMPOSSIBLE"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2014", "Google Code Jam"], "title": "[GCJ 2014 Finals] Checkerboard Matrix", "background": "", "description": "When she is bored, Mija sometimes likes to play a game with matrices. She tries to transform one matrix into another with the fewest moves. For Mija, one move is swapping any two rows of the matrix or any two columns of the matrix.\n\nToday, Mija has a very special matrix $\\mathbf{M}$. $\\mathbf{M}$ is a $2 \\mathrm{~N}$ by $2 \\mathrm{~N}$ matrix where every entry is either a 0 or a 1 . Mija decides to try and transform $\\mathbf{M}$ into a checkerboard matrix where the entries alternate between 0 and 1 along each row and column. Can you help Mija find the minimum number of moves to transform $\\mathbf{M}$ into a checkerboard matrix?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing a single integer: $\\mathbf{N}$. The next $2 \\mathrm{~N}$ lines each contain $2 \\mathrm{~N}$ characters which are the rows of $\\mathbf{M}$; each character is a 0 or 1 .\n", "outputFormat": "For each test case, output one line containing \"Case #x: $y$\", where $\\mathrm{x}$ is the test case number (starting from 1) and $y$ is the minimum number of row swaps and column swaps required to turn $\\mathbf{M}$ into a checkerboard matrix. If it is impossible to turn $\\mathbf{M}$ into a checkerboard matrix, $y$ should be \"IMPOSSIBLE\".", "hint": "**Sample Explanation**\n\nIn the first sample case, $\\mathbf{M}$ is already a checkerboard matrix.\n\nIn the second sample case, Mija can turn $\\mathbf{M}$ into a checkerboard matrix by swapping columns 1 and 2 and then swapping rows 1 and 2.\n\nIn the third sample case, Mija can never turn $\\mathbf{M}$ into a checkerboard matrix; it doesn't have enough $1 \\mathrm{~s}$.\n\n**Limits**\n\n- $1 \\leq \\mathrm{T} \\leq 100$.\n\n**Small dataset(4 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\mathrm{N} \\leq 10$.\n\n**Large dataset(9 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq \\mathrm{N} \\leq 10^{3}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 Finals] Checkerboard Matrix", "background": "", "description": "When she is bored, Mija sometimes likes to play a game with matrices. She tries to transform one matrix into another with the fewest moves. For Mija, one move is swapping any two rows of the matrix or any two columns of the matrix.\n\nToday, Mija has a very special matrix $\\mathbf{M}$. $\\mathbf{M}$ is a $2 \\mathrm{~N}$ by $2 \\mathrm{~N}$ matrix where every entry is either a 0 or a 1 . Mija decides to try and transform $\\mathbf{M}$ into a checkerboard matrix where the entries alternate between 0 and 1 along each row and column. Can you help Mija find the minimum number of moves to transform $\\mathbf{M}$ into a checkerboard matrix?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing a single integer: $\\mathbf{N}$. The next $2 \\mathrm{~N}$ lines each contain $2 \\mathrm{~N}$ characters which are the rows of $\\mathbf{M}$; each character is a 0 or 1 .\n", "outputFormat": "For each test case, output one line containing \"Case #x: $y$\", where $\\mathrm{x}$ is the test case number (starting from 1) and $y$ is the minimum number of row swaps and column swaps required to turn $\\mathbf{M}$ into a checkerboard matrix. If it is impossible to turn $\\mathbf{M}$ into a checkerboard matrix, $y$ should be \"IMPOSSIBLE\".", "hint": "**Sample Explanation**\n\nIn the first sample case, $\\mathbf{M}$ is already a checkerboard matrix.\n\nIn the second sample case, Mija can turn $\\mathbf{M}$ into a checkerboard matrix by swapping columns 1 and 2 and then swapping rows 1 and 2.\n\nIn the third sample case, Mija can never turn $\\mathbf{M}$ into a checkerboard matrix; it doesn't have enough $1 \\mathrm{~s}$.\n\n**Limits**\n\n- $1 \\leq \\mathrm{T} \\leq 100$.\n\n**Small dataset(4 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\mathrm{N} \\leq 10$.\n\n**Large dataset(9 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq \\mathrm{N} \\leq 10^{3}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 Finals] Checkerboard Matrix", "background": "", "description": "当感到无聊时，Mija 有时会玩一个关于矩阵的游戏。她尝试用尽可能少的操作次数将一个矩阵变换成另一个矩阵。对 Mija 来说，一次操作是指交换任意两行，或交换任意两列。\n\n今天，Mija 有一个特别的矩阵 $\\mathbf{M}$。这是一个 $2\\mathbf{N} \\times 2\\mathbf{N}$ 的矩阵，其中每个元素都是 $0$ 或 $1$。Mija 决定尝试将 $\\mathbf{M}$ 转换成一个**棋盘矩阵**，即矩阵中每一行与每一列的元素都按照 $0$ 和 $1$ 交替出现。\n\n你能帮助 Mija 找出将 $\\mathbf{M}$ 转换为棋盘矩阵所需的**最少交换次数**吗？如果无法转换成棋盘矩阵，请输出 `\"IMPOSSIBLE\"`。", "inputFormat": "第一行是测试用例数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例的第一行包含一个整数 $\\mathbf{N}$。接下来的 $2\\mathbf{N}$ 行，每行包含 $2\\mathbf{N}$ 个字符（仅由 `'0'` 和 `'1'` 组成），表示矩阵 $\\mathbf{M}$ 的一行。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是最少的行交换与列交换次数之和；若无法转换成棋盘矩阵，输出 `\"IMPOSSIBLE\"`。\n", "hint": "**样例解释**\n\n- 样例 1 中，矩阵本身已经是棋盘矩阵，无需任何操作。\n- 样例 2 中，Mija 可以先交换第 1 列和第 2 列，再交换第 1 行和第 2 行，即可得到棋盘矩阵，总共 2 次操作。\n- 样例 3 中，矩阵中的 $1$ 数量不够，无法排成棋盘矩阵，因而输出为 `\"IMPOSSIBLE\"`。\n\n## 限制条件\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n\n### Small 数据集（4 分）\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq \\mathbf{N} \\leq 10$\n\n### Large 数据集（9 分）\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq \\mathbf{N} \\leq 10^3$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13265", "type": "P", "difficulty": 5, "samples": [["4\n1\n2 1\n2\n1 4 3 2\n3\n7 8 5 6 1 2 4 3\n2\n4 3 2 1", "Case #1: 1\nCase #2: 3\nCase #3: 6\nCase #4: 0"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["2014", "分治", "Google Code Jam"], "title": "[GCJ 2014 Finals] Power Swapper", "background": "", "description": "In a parallel universe, people are crazy about using numbers that are powers of two, and they have defined an exciting sorting strategy for permutations of the numbers from 1 to $2^{\\mathrm{N}}$. They have defined a swapping operation in the following way:\n\n* A range of numbers to be swapped is valid if and only if it is a range of adjacent numbers of size $2^{k}$, and its starting position (position of the first element in the range) is a multiple of $2^{k}$ (where positions are 0 -indexed).\n* A valid swap operation of size- $k$ is defined by swapping two distinct, valid ranges of numbers, each of size $2^{k}$.\n\nTo sort the given permutation, you are allowed to use at most one swap operation of each size $\\mathrm{k}$, for $\\mathrm{k}$ in $[0, \\mathrm{~N})$. Also, note that swapping a range with itself is not allowed.\n\nFor example, given the permutation $[3,6,1,2,7,8,5,4]$ (a permutation of the numbers from 1 to $2^{3}$ ), the permutation can be sorted as follows:\n\n* $[3,6,1,2,7,8,5,4]$: make a size-2 swap of the ranges $[3,6,1,2]$ and $[7,8,5,4]$.\n* $[7,8,5,4,3,6,1,2]$: make a size-0 swap of $[5]$ and $[3]$.\n* $[7,8,3,4,5,6,1,2]$: make a size-1 swap of $[7,8]$ and $[1,2]$.\n* $[1,2,3,4,5,6,7,8]$: done.\n\nThe previous steps used every swap size (0,1 , and 2) at most once. Also, notice that all the swaps were valid because both ranges for each size $\\mathrm{k}$ started at indices that were multiples of $2^{\\mathrm{k}}$.\n\nCount how many ways there are to sort the given permutation by using the rules above. A way is an ordered sequence of swaps, and two ways are the same only if the sequences are identical.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. The first line of each test case contains a single integer $\\mathrm{N}$. The following line contains $2^{\\mathrm{N}}$ space-separated integers: a permutation of the numbers $1,2, \\ldots, 2^{\\mathrm{N}}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the number of ways to sort the given permutation using the rules above.", "hint": "**Limits**\n\n- $1 \\leq \\mathrm{T} \\leq 200$.\n\n**Small dataset(4 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\mathrm{N} \\leq 4$.\n\n**Large dataset(12 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq \\mathrm{N} \\leq 12$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 Finals] Power Swapper", "background": "", "description": "In a parallel universe, people are crazy about using numbers that are powers of two, and they have defined an exciting sorting strategy for permutations of the numbers from 1 to $2^{\\mathrm{N}}$. They have defined a swapping operation in the following way:\n\n* A range of numbers to be swapped is valid if and only if it is a range of adjacent numbers of size $2^{k}$, and its starting position (position of the first element in the range) is a multiple of $2^{k}$ (where positions are 0 -indexed).\n* A valid swap operation of size- $k$ is defined by swapping two distinct, valid ranges of numbers, each of size $2^{k}$.\n\nTo sort the given permutation, you are allowed to use at most one swap operation of each size $\\mathrm{k}$, for $\\mathrm{k}$ in $[0, \\mathrm{~N})$. Also, note that swapping a range with itself is not allowed.\n\nFor example, given the permutation $[3,6,1,2,7,8,5,4]$ (a permutation of the numbers from 1 to $2^{3}$ ), the permutation can be sorted as follows:\n\n* $[3,6,1,2,7,8,5,4]$: make a size-2 swap of the ranges $[3,6,1,2]$ and $[7,8,5,4]$.\n* $[7,8,5,4,3,6,1,2]$: make a size-0 swap of $[5]$ and $[3]$.\n* $[7,8,3,4,5,6,1,2]$: make a size-1 swap of $[7,8]$ and $[1,2]$.\n* $[1,2,3,4,5,6,7,8]$: done.\n\nThe previous steps used every swap size (0,1 , and 2) at most once. Also, notice that all the swaps were valid because both ranges for each size $\\mathrm{k}$ started at indices that were multiples of $2^{\\mathrm{k}}$.\n\nCount how many ways there are to sort the given permutation by using the rules above. A way is an ordered sequence of swaps, and two ways are the same only if the sequences are identical.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. The first line of each test case contains a single integer $\\mathrm{N}$. The following line contains $2^{\\mathrm{N}}$ space-separated integers: a permutation of the numbers $1,2, \\ldots, 2^{\\mathrm{N}}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the number of ways to sort the given permutation using the rules above.", "hint": "**Limits**\n\n- $1 \\leq \\mathrm{T} \\leq 200$.\n\n**Small dataset(4 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\mathrm{N} \\leq 4$.\n\n**Large dataset(12 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq \\mathrm{N} \\leq 12$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 Finals] Power Swapper", "background": "", "description": "在一个平行宇宙里，人们痴迷于使用 $2$ 的幂次方，并且他们为从 $1$ 到 $2^{\\mathrm{N}}$ 的数列定义了一种激动人心的排序方式。这里定义的交换操作如下：\n\n- 一段可交换的区间是指一个**长度为 $2^{k}$ 的连续区间**，并且其起始位置（从 $0$ 开始计数）必须是 $2^{k}$ 的倍数。\n- 一次合法的 $k$ 级交换操作是指交换两个不同的、各自合法的长度为 $2^{k}$ 的区间。\n\n为了将一个给定的排列排序为升序排列，你最多可以对每个 $k \\in [0, N)$ 使用一次这样的交换操作。注意，不允许交换一个区间与其自身。\n\n例如，对于排列 $[3,6,1,2,7,8,5,4]$（即 $1$ 到 $2^3=8$ 的一个排列），可以按如下步骤排序：\n\n1. $[3,6,1,2,7,8,5,4]$：执行一次 size-2 的交换，交换区间 $[3,6,1,2]$ 与 $[7,8,5,4]$。\n2. $[7,8,5,4,3,6,1,2]$：执行一次 size-0 的交换，交换 $[5]$ 和 $[3]$。\n3. $[7,8,3,4,5,6,1,2]$：执行一次 size-1 的交换，交换 $[7,8]$ 与 $[1,2]$。\n4. $[1,2,3,4,5,6,7,8]$：排序完成。\n\n上面每一种 size 的交换操作最多只使用了一次。同时，每次交换都满足合法性：两个长度为 $2^k$ 的区间起始位置均为 $2^k$ 的倍数。\n\n现在请你计算，将给定排列按上述规则排序，有多少种不同的方式？每一种方式是一个有序的交换序列，只有当两种方式的交换序列完全一致时，才认为它们相同。\n", "inputFormat": "输入的第一行是测试用例数 $\\mathrm{T}$。接下来是 $\\mathrm{T}$ 个测试用例。\n\n每个测试用例的第一行是一个整数 $\\mathrm{N}$，表示排列的大小为 $2^{\\mathrm{N}}$。\n\n下一行是 $2^{\\mathrm{N}}$ 个用空格分隔的整数，表示一个 $1$ 到 $2^{\\mathrm{N}}$ 的排列。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是将给定排列按题目要求排序的不同方法数。\n", "hint": "## 限制条件\n\n- $1 \\leq \\mathrm{T} \\leq 200$\n\n### Small 数据集（4 分）\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq \\mathrm{N} \\leq 4$\n\n### Large 数据集（12 分）\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq \\mathrm{N} \\leq 12$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13266", "type": "P", "difficulty": 6, "samples": [["3\n4\nR\nG\nB\nB\n1 2\n2 3\n2 4\n4\nR\nG\nB\nY\n1 2\n2 3\n2 4\n12\nY\nB\nY\nG\nR\nG\nY\nY\nB\nB\nB\nR\n1 3\n1 9\n1 10\n2 3\n3 7\n3 8\n3 11\n4 8\n5 7\n6 7\n8 12", "Case #1: SYMMETRIC\nCase #2: NOT SYMMETRIC\nCase #3: SYMMETRIC"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2014", "树形 DP", "哈希 hashing", "Google Code Jam"], "title": "[GCJ 2014 Finals] Symmetric Trees", "background": "", "description": "Given a vertex-colored tree with $\\mathrm{N}$ nodes, can it be drawn in a 2D plane with a line of symmetry?\n\nFormally, a tree is line-symmetric if each vertex can be assigned a location in the 2D plane such that:\n\n* All locations are distinct.\n* If vertex $\\mathbf{v}_{\\mathrm{i}}$ has color $\\mathbf{C}$ and coordinates $\\left(\\mathrm{x}_{\\mathrm{i}}, \\mathrm{y}_{\\mathrm{i}}\\right)$, there must also be a vertex $\\mathbf{v}_{\\mathrm{i}}^{\\prime}$ of color $\\mathbf{C}$ located at $\\left(-\\mathrm{x}_{\\mathrm{i}}, \\mathrm{y}_{\\mathrm{i}}\\right)$ -- Note if $\\mathrm{x}_{\\mathrm{i}}$ is 0, $\\mathbf{v}_{\\mathrm{i}}$ and $\\mathbf{v}_{\\mathrm{i}}^{\\prime}$ are the same vertex.\n* For each edge $\\left(\\mathbf{v}_{\\mathrm{i}}, \\mathbf{v}_{\\mathrm{j}}\\right)$, there must also exist an edge $\\left(\\mathbf{v}_{\\mathrm{i}}^{\\prime}, \\mathbf{v}_{\\mathrm{j}}^{\\prime}\\right)$.\n* If edges were represented by straight lines between their end vertices, no two edges would share any points except where adjacent edges touch at their endpoints.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow.\n\nEach test case starts with a line containing a single integer $\\mathrm{N}$, the number of vertices in the tree.\n\n$\\mathrm{N}$ lines then follow, each containing a single uppercase letter. The $\\mathrm{i}$-th line represents the color of the $\\mathrm{i}$-th node.\n\n$\\mathrm{N}-1$ lines then follow, each line containing two integers $\\mathrm{i}$ and $\\mathrm{j}(1 \\leq \\mathrm{i}<\\mathrm{j} \\leq \\mathrm{N})$. This denotes that the tree has an edge from the $\\mathrm{i}$-th vertex to the $\\mathrm{j}$-th vertex. The edges will describe a connected tree.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the case number (starting from 1) and $\\mathrm{y}$ is \"SYMMETRIC\" if the tree is line-symmetric by the definition above or \"NOT SYMMETRIC\" if it isn't.", "hint": "**Sample Explanation**\n\nThe first case can be drawn as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ithqougs.png)\n\nNo arrangement of the second case has a line of symmetry:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0kmct7ap.png)\n\nOne way of drawing the third case with a symmetry line is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9yzlvp9q.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$\n\n**Small dataset(7 Pts)**\n\n- Time Limit: ~~60~~ 3 seconds\n- $2 \\leq N \\leq 12$\n\n**Large dataset(18 Pts)**\n\n- Time Limit: ~~120~~ 5 seconds\n- $2 \\leq N \\leq 10000$", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 Finals] Symmetric Trees", "background": "", "description": "Given a vertex-colored tree with $\\mathrm{N}$ nodes, can it be drawn in a 2D plane with a line of symmetry?\n\nFormally, a tree is line-symmetric if each vertex can be assigned a location in the 2D plane such that:\n\n* All locations are distinct.\n* If vertex $\\mathbf{v}_{\\mathrm{i}}$ has color $\\mathbf{C}$ and coordinates $\\left(\\mathrm{x}_{\\mathrm{i}}, \\mathrm{y}_{\\mathrm{i}}\\right)$, there must also be a vertex $\\mathbf{v}_{\\mathrm{i}}^{\\prime}$ of color $\\mathbf{C}$ located at $\\left(-\\mathrm{x}_{\\mathrm{i}}, \\mathrm{y}_{\\mathrm{i}}\\right)$ -- Note if $\\mathrm{x}_{\\mathrm{i}}$ is 0, $\\mathbf{v}_{\\mathrm{i}}$ and $\\mathbf{v}_{\\mathrm{i}}^{\\prime}$ are the same vertex.\n* For each edge $\\left(\\mathbf{v}_{\\mathrm{i}}, \\mathbf{v}_{\\mathrm{j}}\\right)$, there must also exist an edge $\\left(\\mathbf{v}_{\\mathrm{i}}^{\\prime}, \\mathbf{v}_{\\mathrm{j}}^{\\prime}\\right)$.\n* If edges were represented by straight lines between their end vertices, no two edges would share any points except where adjacent edges touch at their endpoints.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow.\n\nEach test case starts with a line containing a single integer $\\mathrm{N}$, the number of vertices in the tree.\n\n$\\mathrm{N}$ lines then follow, each containing a single uppercase letter. The $\\mathrm{i}$-th line represents the color of the $\\mathrm{i}$-th node.\n\n$\\mathrm{N}-1$ lines then follow, each line containing two integers $\\mathrm{i}$ and $\\mathrm{j}(1 \\leq \\mathrm{i}<\\mathrm{j} \\leq \\mathrm{N})$. This denotes that the tree has an edge from the $\\mathrm{i}$-th vertex to the $\\mathrm{j}$-th vertex. The edges will describe a connected tree.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the case number (starting from 1) and $\\mathrm{y}$ is \"SYMMETRIC\" if the tree is line-symmetric by the definition above or \"NOT SYMMETRIC\" if it isn't.", "hint": "**Sample Explanation**\n\nThe first case can be drawn as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ithqougs.png)\n\nNo arrangement of the second case has a line of symmetry:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0kmct7ap.png)\n\nOne way of drawing the third case with a symmetry line is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9yzlvp9q.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$\n\n**Small dataset(7 Pts)**\n\n- Time Limit: ~~60~~ 3 seconds\n- $2 \\leq N \\leq 12$\n\n**Large dataset(18 Pts)**\n\n- Time Limit: ~~120~~ 5 seconds\n- $2 \\leq N \\leq 10000$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 Finals] Symmetric Trees", "background": "", "description": "给定一棵**顶点有颜色**的树，判断它能否在二维平面中绘制成具有**对称轴**的图形。\n\n更正式地说，一棵树被称为“轴对称”的，当且仅当存在一种顶点在二维平面中的坐标分配方式，使得：\n\n- 所有顶点的坐标都互不相同；\n- 如果某个顶点 $\\mathbf{v}_i$ 的颜色为 $\\mathbf{C}$，坐标为 $(x_i, y_i)$，那么必须存在另一个顶点 $\\mathbf{v}_i'$，其颜色也为 $\\mathbf{C}$，坐标为 $(-x_i, y_i)$。特别注意：如果 $x_i = 0$，那么 $\\mathbf{v}_i$ 自身就是它的对称点；\n- 对于任意一条边 $(\\mathbf{v}_i, \\mathbf{v}_j)$，也必须存在一条边 $(\\mathbf{v}_i', \\mathbf{v}_j')$；\n- 如果我们将边绘制为直线段，则任意两条边**只能在公共端点处重合**，不能在其他地方相交。\n\n现在请你判断，给定的每棵树是否满足上述“轴对称”条件。\n", "inputFormat": "第一行是测试用例数量 $\\mathrm{T}$。\n\n接下来是 $\\mathrm{T}$ 个测试用例。\n\n每个测试用例格式如下：\n\n- 第一行一个整数 $\\mathrm{N}$，表示树中顶点数量；\n- 接下来 $\\mathrm{N}$ 行中，每行一个大写字母，表示第 $i$ 个顶点的颜色；\n- 然后是 $\\mathrm{N} - 1$ 行，每行两个整数 $i, j$（$1 \\leq i < j \\leq N$），表示树中存在一条从节点 $i$ 到节点 $j$ 的无向边。所有边构成一棵连通树。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为：\n\n- `\"SYMMETRIC\"` 表示这棵树可以绘制成具有对称轴的图；\n- `\"NOT SYMMETRIC\"` 表示不可能具有对称轴。", "hint": "**样例解释**\n\n第一个样例可以按照如下方式绘制，满足对称轴条件：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ithqougs.png)\n\n第二个样例无法找到任何符合对称要求的排列方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0kmct7ap.png)\n\n第三个样例中，有一种绘制方式满足关于一条垂直对称轴的对称关系：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9yzlvp9q.png)\n\n## 限制条件\n\n- $1 \\leq T \\leq 100$\n\n### Small 数据集（7 分）\n\n- 时间限制：~~60~~ 3 秒\n- $2 \\leq N \\leq 12$\n\n### Large 数据集（18 分）\n\n- 时间限制：~~120~~ 5 秒\n- $2 \\leq N \\leq 10000$", "locale": "zh-CN"}}}
{"pid": "P13267", "type": "P", "difficulty": 6, "samples": [["3\n2 0\n-Y\nN-\n2 0\n-N\nY-\n4 3\n-YNN\nN-YY\nYN-Y\nYNN-", "Case #1: 0 1\nCase #2: IMPOSSIBLE\nCase #3: 1 2 0 3"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2014", "深度优先搜索 DFS", "Google Code Jam"], "title": "[GCJ 2014 Finals] Paradox Sort", "background": "", "description": "Vlad likes candies. You have a bag of different candies, and you're going to let Vlad keep one of them. You choose an order for the candies, then give them to Vlad one at a time. For each candy Vlad receives (after the first one), he compares the candy he had to the one he was just given, keeps the one he likes more, and throws the other one away.\n\nYou would expect that for any order you choose, Vlad will always end up with his favorite candy. But this is not the case! He does not necessarily have a favorite candy. We know for any pair of candies which one he will prefer, but his choices do not necessarily correspond to a simple ranking. He may choose Orange when offered Orange and Lemon, Banana when offered Orange and Banana, and Lemon when offered Lemon and Banana!\n\nThere is a particular candy you want Vlad to end up with. Given Vlad's preferences for each pair of candies, determine if there is an ordering such that Vlad will end up with the right candy. If there is, find the lexicographically-smallest such ordering.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case will start with a line containing the integers $\\mathrm{N}$ and $\\mathrm{A}$, separated by a space. $\\mathrm{N}$ is the number of candies, and $\\mathrm{A}$ is the number of the candy we want Vlad to finish with. The candies are numbered from 0 to $\\mathrm{N}-1$. The next $\\mathrm{N}$ lines each contains $\\mathrm{N}$ characters. Character $\\mathrm{j}$ of line $\\mathrm{i}$ will be 'Y' if Vlad prefers candy $\\mathrm{i}$ to candy $\\mathrm{j}$, 'N' if Vlad prefers candy $\\mathrm{j}$ to candy $\\mathrm{i}$, and '-' if $\\mathrm{i}=\\mathrm{j}$. Note that if $\\mathrm{i} \\neq \\mathrm{j}$, the $\\mathrm{j}$ th character of the $\\mathrm{i}$ th row must be different from the $\\mathrm{i}$ th character of the $\\mathrm{j}$ th row.\n", "outputFormat": "For each test case output \"Case #x: \", where $\\mathrm{x}$ is the case number, followed by either \"IMPOSSIBLE\" or a space-separated list of the lexicographically-smallest ordering of candies that leaves Vlad with $\\mathrm{A}$.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Small dataset(4 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leqslant \\mathrm{N} \\leqslant 10$.\n\n**Large dataset(28 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leqslant \\mathrm{N} \\leqslant 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 Finals] Paradox Sort", "background": "", "description": "Vlad likes candies. You have a bag of different candies, and you're going to let Vlad keep one of them. You choose an order for the candies, then give them to Vlad one at a time. For each candy Vlad receives (after the first one), he compares the candy he had to the one he was just given, keeps the one he likes more, and throws the other one away.\n\nYou would expect that for any order you choose, Vlad will always end up with his favorite candy. But this is not the case! He does not necessarily have a favorite candy. We know for any pair of candies which one he will prefer, but his choices do not necessarily correspond to a simple ranking. He may choose Orange when offered Orange and Lemon, Banana when offered Orange and Banana, and Lemon when offered Lemon and Banana!\n\nThere is a particular candy you want Vlad to end up with. Given Vlad's preferences for each pair of candies, determine if there is an ordering such that Vlad will end up with the right candy. If there is, find the lexicographically-smallest such ordering.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case will start with a line containing the integers $\\mathrm{N}$ and $\\mathrm{A}$, separated by a space. $\\mathrm{N}$ is the number of candies, and $\\mathrm{A}$ is the number of the candy we want Vlad to finish with. The candies are numbered from 0 to $\\mathrm{N}-1$. The next $\\mathrm{N}$ lines each contains $\\mathrm{N}$ characters. Character $\\mathrm{j}$ of line $\\mathrm{i}$ will be 'Y' if Vlad prefers candy $\\mathrm{i}$ to candy $\\mathrm{j}$, 'N' if Vlad prefers candy $\\mathrm{j}$ to candy $\\mathrm{i}$, and '-' if $\\mathrm{i}=\\mathrm{j}$. Note that if $\\mathrm{i} \\neq \\mathrm{j}$, the $\\mathrm{j}$ th character of the $\\mathrm{i}$ th row must be different from the $\\mathrm{i}$ th character of the $\\mathrm{j}$ th row.\n", "outputFormat": "For each test case output \"Case #x: \", where $\\mathrm{x}$ is the case number, followed by either \"IMPOSSIBLE\" or a space-separated list of the lexicographically-smallest ordering of candies that leaves Vlad with $\\mathrm{A}$.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Small dataset(4 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leqslant \\mathrm{N} \\leqslant 10$.\n\n**Large dataset(28 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leqslant \\mathrm{N} \\leqslant 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 Finals] Paradox Sort", "background": "", "description": "Vlad 喜欢糖果。你有一袋不同种类的糖果，你打算让 Vlad 最后保留其中一颗。你会为这批糖果指定一个出场顺序，然后依次将糖果一个接一个地递给 Vlad。Vlad 每次收到糖果时（第一颗除外），会将当前手里的糖果与新收到的糖果进行比较，保留他更喜欢的那一颗，把另一颗丢掉。\n\n你可能会以为，无论你选择怎样的顺序，Vlad 最终都会留下他最喜欢的糖果。但事实并非如此！Vlad 不一定有明确的“最喜欢”糖果。我们知道，对于任意一对糖果，他总能做出选择，但这种偏好关系不一定构成一个一致的排名结构。比如：他可能在橘子和柠檬之间选择橘子，在香蕉和橘子之间选择香蕉，但又在柠檬和香蕉之间选择柠檬！\n\n现在你有一个特别想让 Vlad 最后留下的糖果。已知 Vlad 对每对糖果的偏好，请你判断是否存在一种糖果顺序，使得 Vlad 最终会留下你指定的那一颗。如果存在，请找出按字典序排列的最小的那一种顺序。", "inputFormat": "输入的第一行为测试用例个数 $\\mathrm{T}$。\n\n接下来是 $\\mathrm{T}$ 个测试用例，每个测试用例包含如下内容：\n\n- 第一行包含两个整数 $\\mathrm{N}$ 和 $\\mathrm{A}$，中间以空格分隔。$\\mathrm{N}$ 表示糖果的总数，$\\mathrm{A}$ 表示你希望 Vlad 最终留下的糖果编号（糖果从 $0$ 到 $\\mathrm{N}-1$ 编号）。\n- 接下来 $\\mathrm{N}$ 行，每行包含 $\\mathrm{N}$ 个字符。第 $i$ 行第 $j$ 个字符表示 Vlad 对第 $i$ 颗和第 $j$ 颗糖果的偏好：\n  - 若为 `'Y'`，表示 Vlad 更喜欢糖果 $i$；\n  - 若为 `'N'`，表示 Vlad 更喜欢糖果 $j$；\n  - 若为 `'-'`，表示 $i = j$，即同一颗糖果自身，无需比较。\n  \n保证当 $i \\neq j$ 时，第 $i$ 行第 $j$ 个字符与第 $j$ 行第 $i$ 个字符不同。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: \"`（$x$ 为测试用例编号，从 $1$ 开始），后接：\n\n- 若不存在一种顺序能让 Vlad 最终保留糖果 $\\mathrm{A}$，输出 `\"IMPOSSIBLE\"`；\n- 否则，输出一个以空格分隔的糖果编号序列（表示字典序最小的有效顺序）。\n", "hint": "## 限制条件\n\n- $1 \\leq \\mathrm{T} \\leq 100$\n\n### Small 数据集（4 分）\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq \\mathrm{N} \\leq 10$\n\n### Large 数据集（28 分）\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq \\mathrm{N} \\leq 100$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13268", "type": "P", "difficulty": 6, "samples": [["3\n4 5 7\n8 1 1\n1 23 32", "Case #1: 12\nCase #2: 3\nCase #3: 0"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2014", "二分", "矩阵加速", "组合数学", "Google Code Jam"], "title": "[GCJ 2014 Finals] Allergy Testing", "background": "", "description": "Kelly is allergic to exactly one of $\\mathrm{N}$ foods, but she isn't sure which one. So she decides to undergo some experiments to find out.\n\nIn each experiment, Kelly picks several foods and eats them all. She waits $\\mathrm{A}$ days to see if she gets any allergic reactions. If she doesn't, she knows she isn't allergic to any of the foods she ate. If she does get a reaction, she has to wait for it to go away: this takes a total of $\\mathrm{B}$ days (measured from the moment when she ate the foods).\n\nTo simplify her experimentation, Kelly decides to wait until each experiment is finished (after $\\mathrm{A}$ or $\\mathrm{B}$ days) before starting the next one. At the start of each experiment, she can choose the set of foods she wants to eat based on the results of previous experiments.\n\nKelly chooses what foods to eat for each experiment to minimize the worst-case number of days before she knows which of the $\\mathrm{N}$ foods she is allergic to. How long does it take her in the worst case?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case on a single line, containing three space-separated integers: $\\mathrm{N}, \\mathrm{A}$ and $\\mathrm{B}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the number of days it will take for Kelly to find out which food she is allergic to, in the worst case.", "hint": "In the first sample case:\n- First, Kelly eats foods #1 and #2.\n- If she gets no reaction after 5 days, she eats food #3. 5 days after that, she will know whether she is allergic to food #3 or food #4.\n- If she does get a reaction to the first experiment, then 7 days after the first experiment, she eats food #1. 5 days after that, she will know whether she is allergic to food #1 or food #2.\n\n**Limits**\n\n- $1 \\leq T \\leq 200$\n\n**Small dataset(15 Pts)**\n- Time Limit: ~~60~~ 3 seconds\n- $1 \\leq N \\leq 10^{15}$\n- $1 \\leq A\\leq B \\leq 100$\n\n**Large dataset(35 Pts)**\n- Time Limit: ~~120~~ 5 seconds\n- $1 \\leq N \\leq 10^{15}$\n- $1 \\leq A\\leq B \\leq 10^{12}$", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 Finals] Allergy Testing", "background": "", "description": "Kelly is allergic to exactly one of $\\mathrm{N}$ foods, but she isn't sure which one. So she decides to undergo some experiments to find out.\n\nIn each experiment, Kelly picks several foods and eats them all. She waits $\\mathrm{A}$ days to see if she gets any allergic reactions. If she doesn't, she knows she isn't allergic to any of the foods she ate. If she does get a reaction, she has to wait for it to go away: this takes a total of $\\mathrm{B}$ days (measured from the moment when she ate the foods).\n\nTo simplify her experimentation, Kelly decides to wait until each experiment is finished (after $\\mathrm{A}$ or $\\mathrm{B}$ days) before starting the next one. At the start of each experiment, she can choose the set of foods she wants to eat based on the results of previous experiments.\n\nKelly chooses what foods to eat for each experiment to minimize the worst-case number of days before she knows which of the $\\mathrm{N}$ foods she is allergic to. How long does it take her in the worst case?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case on a single line, containing three space-separated integers: $\\mathrm{N}, \\mathrm{A}$ and $\\mathrm{B}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the number of days it will take for Kelly to find out which food she is allergic to, in the worst case.", "hint": "In the first sample case:\n- First, Kelly eats foods #1 and #2.\n- If she gets no reaction after 5 days, she eats food #3. 5 days after that, she will know whether she is allergic to food #3 or food #4.\n- If she does get a reaction to the first experiment, then 7 days after the first experiment, she eats food #1. 5 days after that, she will know whether she is allergic to food #1 or food #2.\n\n**Limits**\n\n- $1 \\leq T \\leq 200$\n\n**Small dataset(15 Pts)**\n- Time Limit: ~~60~~ 3 seconds\n- $1 \\leq N \\leq 10^{15}$\n- $1 \\leq A\\leq B \\leq 100$\n\n**Large dataset(35 Pts)**\n- Time Limit: ~~120~~ 5 seconds\n- $1 \\leq N \\leq 10^{15}$\n- $1 \\leq A\\leq B \\leq 10^{12}$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 Finals] Allergy Testing", "background": null, "description": "Kelly 对某种食物过敏，但她不确定是哪一种。在她面前有 $\\mathrm{N}$ 种不同的食物，而她恰好只对其中一种过敏。为了找出是哪一种，她决定进行一系列实验。\n\n在每次实验中，Kelly 会选择若干种食物一起食用。然后她会等待 $\\mathrm{A}$ 天，以观察自己是否会出现过敏反应：\n\n- 如果没有反应，她就可以确定自己**不对**这些食物中的任意一种过敏；\n- 如果出现了反应，她就必须等待反应完全消退，整个过程总共需要 $\\mathrm{B}$ 天（从食用食物的那一刻算起）。\n\n为简化实验安排，Kelly 决定：**每次实验必须在上一次实验完全结束（无论是等待 $\\mathrm{A}$ 天或 $\\mathrm{B}$ 天）后才能进行**。\n\n在每次实验开始前，Kelly 可以根据之前实验的结果自由选择这一次要食用的食物集合。\n\n她希望设计一套实验策略，在最坏情况下，也能尽可能快地确定自己对哪一种食物过敏。\n\n请你计算：在最坏情况下，Kelly 最少需要多少天才能确定她对哪一种食物过敏？", "inputFormat": "第一行是测试用例个数 $\\mathrm{T}$。接下来是 $\\mathrm{T}$ 个测试用例。\n\n每个测试用例占一行，包含三个用空格分隔的整数 $\\mathrm{N}, \\mathrm{A}, \\mathrm{B}$，分别表示食物总数、无过敏反应等待天数、以及有过敏反应时总的等待天数。", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Kelly 在最坏情况下确定过敏源所需的总天数。", "hint": "在第一个样例中：\n\n- 第一次实验：吃食物 #1 和 #2；\n- 如果 5 天后无反应，则进行第二次实验，吃食物 #3；\n  - 再等 5 天后，如果无反应，则说明过敏的是食物 #4；\n  - 如果有反应，则在第 10 天得知自己过敏于食物 #3；\n- 如果第一次实验后出现过敏反应，那么在第 7 天（反应消退）后进行第二次实验，吃食物 #1；\n  - 再过 5 天，无反应说明是食物 #2 过敏，有反应说明是食物 #1；\n- 因此，最坏情况下是第 12 天得出结论。\n\n## 限制条件\n\n- $1 \\leq T \\leq 200$\n\n### Small 数据集（15 分）\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq N \\leq 10^{15}$\n- $1 \\leq A \\leq B \\leq 100$\n\n### Large 数据集（35 分）\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq N \\leq 10^{15}$\n- $1 \\leq A \\leq B \\leq 10^{12}$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13269", "type": "P", "difficulty": 7, "samples": [["3\n2 1 1\n1.0000 0.0000\n3 1 1\n1.0000 0.0000 0.5000\n6 2 3\n0.9000 0.6000 0.5000 0.1000 0.2000 0.8000", "Case #1: 0.750000000000\nCase #2: 0.666666666667\nCase #3: 0.618728522337"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["2014", "Special Judge", "概率论", "期望", "随机游走 Markov Chain", "Google Code Jam"], "title": "[GCJ 2014 Finals] ARAM", "background": "League of Legends is a trademark of Riot Games. Riot Games does not endorse and has no involvement with Google Code Jam.", "description": "In the game League of Legends ${ }^{\\mathrm{TM}}$, you can play a type of game called \"ARAM\", which is short for \"All Random, All Mid\". This problem uses a similar idea, but doesn't require you to have played League of Legends to understand it.\n\nEvery time you start playing an ARAM game, you're assigned one of $\\mathrm{N}$ \"champions\", uniformly at random. You're more likely to win with some champions than with others, so if you get unlucky then you might wish you'd been given a different champion. Luckily for you, the game includes a \"Reroll\" function.\n\nRerolling randomly reassigns you a champion in a way that will be described below; but you can't reroll whenever you want to. The ability to reroll works like a kind of money. Before you play your first ARAM game, you begin with $\\mathrm{R}$ RD (\"reroll dollars\"). You can only reroll if you have at least 1 RD, and you must spend 1 RD to reroll. After every game, you gain $1 / \\mathrm{G}$ RD (where $\\mathrm{G}$ is an integer), but you can never have more than $\\mathrm{R}$ RD: if you have $\\mathrm{R}$ RD and then play a game, you'll still have $\\mathrm{R}$ RD after that game.\n\nIf you have at least $1 \\mathrm{RD}$, and you choose to reroll, you will spend $1 \\mathrm{RD}$ and be re-assigned one of the $\\mathrm{N}$ champions, uniformly at random. There's some chance you might get the same champion you had at first. If you don't like the champion you rerolled, and you still have at least $1 \\mathrm{RD}$ left, you can reroll again. As long as you have at least $1 \\mathrm{RD}$ left, you can keep rerolling.\n\nFor example, if $\\mathrm{R}=2$ and $\\mathrm{G}=2$, and you use a reroll in your first game, then after your first game you will have $1.5 \\mathrm{RD}$. If you play another game, this time without using a reroll, you will have $2.0 \\mathrm{RD}$. If you play another game without using a reroll, you will still have $2.0 \\mathrm{RD}$ (because you can never have more than $\\mathrm{R}=2$ ). If you use two rerolls in your next game, then after that game you will have $0.5$ $\\mathrm{RD}$.\n\nYou will be given the list of champions, and how likely you are to win a game if you play each of them. If you play $10^{100}$ games and choose your strategy optimally, what fraction of the games do you expect to win?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each starts with a line containing three space-separated integers: $\\mathrm{N}, \\mathrm{R}$ and $\\mathrm{G}$. The next line contains $\\mathrm{N}$ space-separated, real-valued numbers $\\mathrm{P}_{\\mathrm{i}}$, indicating the probability that you will win if you play champion $\\mathrm{i}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the proportion of games you will win if you play $10^{100}$ games.\n\n$\\mathrm{y}$ will be considered correct if it is within an absolute or relative error of $10^{-10}$ of the correct answer.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $0.0 \\leqslant \\mathrm{P}_{\\mathrm{i}} \\leqslant 1.0$.\n- $\\mathrm{P}_{\\mathrm{i}}$ will be expressed as a single digit, followed by a decimal point, followed by 4 digits.\n\n**Small dataset(22 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leqslant \\mathrm{N} \\leqslant 1000$.\n- $1 \\leqslant \\mathrm{R} \\leqslant 2$.\n- $1 \\leqslant \\mathrm{G} \\leqslant 3$.\n\n**Large dataset(42 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leqslant \\mathrm{N} \\leqslant 1000$.\n- $1 \\leqslant \\mathrm{R} \\leqslant 20$.\n- $1 \\leqslant \\mathrm{G} \\leqslant 20$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 Finals] ARAM", "background": "League of Legends is a trademark of Riot Games. Riot Games does not endorse and has no involvement with Google Code Jam.", "description": "In the game League of Legends ${ }^{\\mathrm{TM}}$, you can play a type of game called \"ARAM\", which is short for \"All Random, All Mid\". This problem uses a similar idea, but doesn't require you to have played League of Legends to understand it.\n\nEvery time you start playing an ARAM game, you're assigned one of $\\mathrm{N}$ \"champions\", uniformly at random. You're more likely to win with some champions than with others, so if you get unlucky then you might wish you'd been given a different champion. Luckily for you, the game includes a \"Reroll\" function.\n\nRerolling randomly reassigns you a champion in a way that will be described below; but you can't reroll whenever you want to. The ability to reroll works like a kind of money. Before you play your first ARAM game, you begin with $\\mathrm{R}$ RD (\"reroll dollars\"). You can only reroll if you have at least 1 RD, and you must spend 1 RD to reroll. After every game, you gain $1 / \\mathrm{G}$ RD (where $\\mathrm{G}$ is an integer), but you can never have more than $\\mathrm{R}$ RD: if you have $\\mathrm{R}$ RD and then play a game, you'll still have $\\mathrm{R}$ RD after that game.\n\nIf you have at least $1 \\mathrm{RD}$, and you choose to reroll, you will spend $1 \\mathrm{RD}$ and be re-assigned one of the $\\mathrm{N}$ champions, uniformly at random. There's some chance you might get the same champion you had at first. If you don't like the champion you rerolled, and you still have at least $1 \\mathrm{RD}$ left, you can reroll again. As long as you have at least $1 \\mathrm{RD}$ left, you can keep rerolling.\n\nFor example, if $\\mathrm{R}=2$ and $\\mathrm{G}=2$, and you use a reroll in your first game, then after your first game you will have $1.5 \\mathrm{RD}$. If you play another game, this time without using a reroll, you will have $2.0 \\mathrm{RD}$. If you play another game without using a reroll, you will still have $2.0 \\mathrm{RD}$ (because you can never have more than $\\mathrm{R}=2$ ). If you use two rerolls in your next game, then after that game you will have $0.5$ $\\mathrm{RD}$.\n\nYou will be given the list of champions, and how likely you are to win a game if you play each of them. If you play $10^{100}$ games and choose your strategy optimally, what fraction of the games do you expect to win?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each starts with a line containing three space-separated integers: $\\mathrm{N}, \\mathrm{R}$ and $\\mathrm{G}$. The next line contains $\\mathrm{N}$ space-separated, real-valued numbers $\\mathrm{P}_{\\mathrm{i}}$, indicating the probability that you will win if you play champion $\\mathrm{i}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the proportion of games you will win if you play $10^{100}$ games.\n\n$\\mathrm{y}$ will be considered correct if it is within an absolute or relative error of $10^{-10}$ of the correct answer.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $0.0 \\leqslant \\mathrm{P}_{\\mathrm{i}} \\leqslant 1.0$.\n- $\\mathrm{P}_{\\mathrm{i}}$ will be expressed as a single digit, followed by a decimal point, followed by 4 digits.\n\n**Small dataset(22 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leqslant \\mathrm{N} \\leqslant 1000$.\n- $1 \\leqslant \\mathrm{R} \\leqslant 2$.\n- $1 \\leqslant \\mathrm{G} \\leqslant 3$.\n\n**Large dataset(42 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leqslant \\mathrm{N} \\leqslant 1000$.\n- $1 \\leqslant \\mathrm{R} \\leqslant 20$.\n- $1 \\leqslant \\mathrm{G} \\leqslant 20$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 Finals] ARAM", "background": "League of Legends 是 Riot Games 的商标。Riot Games 并未参与也未支持 Google Code Jam。\n", "description": "在游戏 *League of Legends*（英雄联盟）中，有一种叫做 “ARAM”（All Random, All Mid，全随机单中路） 的游戏模式。本题借鉴了这一设定，但无需了解英雄联盟也能理解题意。\n\n每次开始 ARAM 游戏时，你会从 $\\mathrm{N}$ 个“英雄”（champions）中**等概率**地随机获得一个。你使用某些英雄时更容易获胜，因此当运气不好时，你可能希望自己能抽到另一个英雄。幸运的是，游戏中提供了“重新抽取”（Reroll）的功能。\n\n重新抽取的机制如下所述，但你不能随时使用它。重新抽取的能力可以看作是一种货币：在你开始第一个 ARAM 游戏之前，你拥有 $\\mathrm{R}$ 个“重新抽取点数”（RD，Reroll Dollars）。你只有在手上至少有 $1$ RD 时，才可以使用重新抽取，每次消耗 $1$ RD。\n\n每打完一局游戏，你会获得 $1 / \\mathrm{G}$ 个 RD（其中 $\\mathrm{G}$ 是一个整数），但你的 RD 总数永远不会超过 $\\mathrm{R}$：即使你已经拥有 $\\mathrm{R}$ 个 RD，打完一局之后你仍然只有 $\\mathrm{R}$ 个。\n\n如果你手上有至少 $1$ RD，并选择使用重新抽取，则你会消耗 $1$ RD，并重新从 $\\mathrm{N}$ 个英雄中**等概率**地抽取一个（可能会重复拿到当前的英雄）。如果你不满意新的英雄，并且还有 $1$ RD 以上，你可以继续重新抽取。只要你还剩下 RD，就可以继续抽。\n\n例如，如果 $\\mathrm{R} = 2$ 且 $\\mathrm{G} = 2$，你在第一局游戏使用了一次重新抽取，那么该局之后你将拥有 $1.5$ RD。下一局若未使用重新抽取，该局结束后你将拥有 $2.0$ RD。再下一局若也未使用，那么仍为 $2.0$（因为不能超过上限）。如果你在接下来的游戏中使用了两次重新抽取，那么该局结束后你将剩下 $0.5$ RD。\n\n你将得到一份英雄列表，以及每个英雄的胜率。如果你要打 $10^{100}$ 局游戏，并始终采用最优策略（即期望胜率最大化），那么你预期能赢下多少比例的游戏？\n", "inputFormat": "第一行是测试用例数 $\\mathrm{T}$。接下来的 $\\mathrm{T}$ 个测试用例格式如下：\n\n每个测试用例的第一行包含三个空格分隔的整数：$\\mathrm{N}, \\mathrm{R}, \\mathrm{G}$。\n\n第二行包含 $\\mathrm{N}$ 个用空格分隔的实数 $\\mathrm{P}_i$，表示使用第 $i$ 个英雄时的胜率（$0 \\leq \\mathrm{P}_i \\leq 1$）。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是你在使用最优策略、打 $10^{100}$ 局游戏后预期获胜的比例。\n\n输出结果要求与正确答案的绝对误差或相对误差不超过 $10^{-10}$。\n", "hint": "## 限制条件\n\n- $1 \\leq \\mathrm{T} \\leq 100$\n- $0.0 \\leq \\mathrm{P}_i \\leq 1.0$，每个胜率值格式为 1 位整数 + 小数点 + 4 位数字\n\n### Small 数据集（22 分）\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq \\mathrm{N} \\leq 1000$\n- $1 \\leq \\mathrm{R} \\leq 2$\n- $1 \\leq \\mathrm{G} \\leq 3$\n\n### Large 数据集（42 分）\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq \\mathrm{N} \\leq 1000$\n- $1 \\leq \\mathrm{R} \\leq 20$\n- $1 \\leq \\mathrm{G} \\leq 20$\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13270", "type": "P", "difficulty": 5, "samples": [["10\ncaacabcaab", "aabcaacabc"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "模板题"], "title": "【模板】最小表示法", "background": "原模板题：[P1368 工艺](https://www.luogu.com.cn/problem/P1368)。", "description": "若长度为 $n$ 的字符串 $s$ 中可以选择一个位置 $i$，使得 $\\overline{s_i\\cdots s_ns_1\\cdots s_{i-1}}=t$，则称 $s$ 与 $t$ **循环同构**。字符串 $s$ 的**最小表示**为与 $s$ 循环同构的所有字符串中字典序最小的字符串。\n\n给定一个长度为 $n$ 的字符串 $s$，请求出 $s$ 的最小表示。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个长度为 $n$ 的字符串 $s$。", "outputFormat": "一行，一个字符串，为 $s$ 的最小表示。", "hint": "对于全部数据，$1\\le n\\le 10^7$，字符串 $s$ 仅包含小写英文字母（ASCII $97\\sim 122$）。\n\n设置以下三档部分分，用于测试不同解法：\n\n- 对于 $20\\%$ 的数据，$n\\le 10^3$；\n- 对于 $50\\%$ 的数据，$n\\le 10^5$；\n- 对于 $100\\%$ 的数据，无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【模板】最小表示法", "background": "原模板题：[P1368 工艺](https://www.luogu.com.cn/problem/P1368)。", "description": "若长度为 $n$ 的字符串 $s$ 中可以选择一个位置 $i$，使得 $\\overline{s_i\\cdots s_ns_1\\cdots s_{i-1}}=t$，则称 $s$ 与 $t$ **循环同构**。字符串 $s$ 的**最小表示**为与 $s$ 循环同构的所有字符串中字典序最小的字符串。\n\n给定一个长度为 $n$ 的字符串 $s$，请求出 $s$ 的最小表示。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个长度为 $n$ 的字符串 $s$。", "outputFormat": "一行，一个字符串，为 $s$ 的最小表示。", "hint": "对于全部数据，$1\\le n\\le 10^7$，字符串 $s$ 仅包含小写英文字母（ASCII $97\\sim 122$）。\n\n设置以下三档部分分，用于测试不同解法：\n\n- 对于 $20\\%$ 的数据，$n\\le 10^3$；\n- 对于 $50\\%$ 的数据，$n\\le 10^5$；\n- 对于 $100\\%$ 的数据，无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P13271", "type": "P", "difficulty": 4, "samples": [["0\n5 6 3\n2 4\n1 1\n3 2 5 3 1 4 2\n1 3 2\n2 1 2 4 1\n0\n0", "0 5 3 4 -1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2025", "NOI", "图论建模", "最短路"], "title": "[NOI2025] 机器人", "background": "", "description": "NOI2025 正在绍兴举办，小 Y 为闭幕式表演制作了一个机器人并打算操控它从仓库走到礼堂。\n\n绍兴的道路系统可以简化为 $n$ 个路口以及连接这些路口的 $m$ 条 **单行道路**，且每条道路有一定的长度。为了方便将道路系统录入机器人的芯片，小 Y 对每一个路口连接的所有道路进行了编号。具体而言，若有 $d$ 条道路以路口 $x$ 为起点，则这 $d$ 条道路会被小 Y 按照某种顺序编号为 $1 \\sim d$，分别称作以 $x$ 为起点的第 $1 \\sim d$ 条道路。\n\n小 Y 的机器人内部有一个参数 $p$。给定参数 $p$ 的上限 $k$ 与修改费用 $v_1, v_2, \\ldots, v_{k-1}, w_2, w_3, \\ldots, w_k$。小 Y 将按照如下规则设置与修改机器人的参数：\n\n- 初始时，小 Y 将参数 $p$ 设置为 $1$。\n- 在 **任意时刻**，小 Y 可以远程控制机器人修改参数：\n  - 若 $p < k$，则小 Y 可以花费 $v_p$ 的费用将 $p$ 增加 $1$，即 $p \\leftarrow p + 1$；\n  - 若 $p > 1$，则小 Y 可以花费 $w_p$ 的费用将 $p$ 减少 $1$，即 $p \\leftarrow p - 1$。\n\n初始时，小 Y 的机器人位于机器人仓库，即路口 $1$。当机器人位于路口 $x$ 时，记以路口 $x$ 为起点的第 $p$ 条道路的终点为 $y$，道路长度为 $z$，则小 Y 可以花费 $z$ 的费用操控机器人从 $x$ 走到 $y$。特别地，若以路口 $x$ 为起点的道路不足 $p$ 条，则小 Y 无法操控机器人走动。\n\n小 Y 并不知道闭幕式表演所在的礼堂位于哪个路口，因此他需要对每个路口都做好准备。请你帮助他求出将机器人从仓库移动到每个路口所需费用的最小值。", "inputFormat": "输入的第一行包含一个非负整数 $c$，表示测试点编号。$c = 0$ 表示该测试点为样例。\n\n输入的第二行包含三个正整数 $n, m, k$，分别表示路口数量、道路数量与参数 $p$ 的上限。\n\n输入的第三行包含 $k - 1$ 个非负整数 $v_1, \\ldots, v_{k-1}$，表示增加参数 $p$ 的费用。\n\n输入的第四行包含 $k - 1$ 个非负整数 $w_2, \\ldots, w_k$，表示减少参数 $p$ 的费用。\n\n输入的第 $i + 4$（$1 \\leq i \\leq n$）行包含若干个正整数，其中第一个非负整数 $d_i$ 表示以路口 $i$ 为起点的道路数量，接下来 $2d_i$ 个正整数 $y_{i,1}, z_{i,1}, y_{i,2}, z_{i,2}, \\ldots, y_{i,d_i}, z_{i,d_i}$，表示以路口 $i$ 为起点的道路，其中 $y_{i,j}, z_{i,j}$（$1 \\leq j \\leq d_i$）分别表示编号为 $j$ 的道路的终点与长度。", "outputFormat": "输出一行 $n$ 个整数，其中第 $i$（$1 \\leq i \\leq n$）个数表示小 Y 将机器人从仓库移动到路口 $i$ 所需费用的最小值。特别地，若小 Y 无法将机器人从仓库移动到该路口，则输出 $-1$。", "hint": "### 样例 1 解释\n\n小 Y 可以按照以下方案将机器人分别从仓库移动到路口 $1 \\sim 4$：\n\n- 对于路口 $1$：小 Y 的机器人初始时即位于路口 $1$，因此所需费用为 $0$。\n- 对于路口 $2$：小 Y 操控机器人沿以路口 $1$ 为起点的第 $1$ 条道路走到路口 $2$，所需费用为 $5$。\n- 对于路口 $3$：小 Y 将参数 $p$ 增加 $1$，然后操控机器人沿以路口 $1$ 为起点的第 $2$ 条道路走到路口 $3$，所需费用为 $2 + 1 = 3$。\n- 对于路口 $4$：小 Y 将参数 $p$ 增加 $1$，然后操控机器人沿以路口 $1$ 为起点的第 $2$ 条道路走到路口 $3$，再操控机器人沿以路口 $3$ 为起点的第 $2$ 条道路走到路口 $4$，所需费用为 $2 + 1 + 1 = 4$。\n\n可以证明，上述移动方案的所需费用均为最小值。\n\n- 对于路口 $5$：由于小 Y 无法将机器人移动到路口 $5$，因此输出 $-1$。\n\n### 样例 2\n\n见选手目录下的 `robot/robot2.in` 与 `robot/robot2.ans`。\n\n该样例满足测试点 $3 \\sim 5$ 的约束条件。\n\n### 样例 3\n\n见选手目录下的 `robot/robot3.in` 与 `robot/robot3.ans`。\n\n该样例满足测试点 $6 \\sim 8$ 的约束条件。\n\n### 样例 4\n\n见选手目录下的 `robot/robot4.in` 与 `robot/robot4.ans`。\n\n该样例满足测试点 $9, 10$ 的约束条件。\n\n### 样例 5\n\n见选手目录下的 `robot/robot5.in` 与 `robot/robot5.ans`。\n\n该样例满足测试点 $16 \\sim 18$ 的约束条件。\n\n### 数据范围\n\n对于所有测试数据，保证：\n\n- $1 \\leq n, m \\leq 3 \\times 10^5$，$1 \\leq k \\leq 2.5 \\times 10^5$；\n- 对于所有 $1 \\leq i \\leq k - 1$，均有 $0 \\leq v_i \\leq 10^9$；\n- 对于所有 $2 \\leq i \\leq k$，均有 $0 \\leq w_i \\leq 10^9$；\n- 对于所有 $1 \\leq i \\leq n$，均有 $0 \\leq d_i \\leq k$，且 $\\sum_{i=1}^{n} d_i = m$；\n- 对于所有 $1 \\leq i \\leq n$，$1 \\leq j \\leq d_i$，均有 $1 \\leq y_{i,j} \\leq n$，$1 \\leq z_{i,j} \\leq 10^9$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n, m \\leq$ | $k \\leq$ | 特殊性质 |\n| :-: | :-: | :-: | :-: |\n| $1, 2$ | $6$ | $6$ | C |\n| $3 \\sim 5$ | $10^3$ | $10^3$ | ^ |\n| $6 \\sim 8$ | $5 \\times 10^4$ | $10^2$ | 无 |\n| $9, 10$ | $10^5$ | $10^5$ | AB |\n| $11, 12$ | ^ | ^ | A |\n| $13 \\sim 15$ | ^ | ^ | C |\n| $16 \\sim 18$ | ^ | ^ | 无 |\n| $19, 20$ | $3 \\times 10^5$ | $2.5 \\times 10^5$ | ^ |\n\n- 特殊性质 A：保证 $v_1 = v_2 = \\cdots = v_{k-1} = 0$ 且 $w_2 = w_3 = \\cdots = w_k = 0$。\n- 特殊性质 B：保证对于所有 $1 \\leq i \\leq n$，$1 \\leq j \\leq d_i$，均有 $z_{i,j} = 1$。\n- 特殊性质 C：保证至多存在 10 个 $i$ 满足 $d_i \\geq 10$。\n\n附加文件来自于 [QOJ](https://qoj.ac/contest/2315/problem/13079)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI2025] 机器人", "background": "", "description": "NOI2025 正在绍兴举办，小 Y 为闭幕式表演制作了一个机器人并打算操控它从仓库走到礼堂。\n\n绍兴的道路系统可以简化为 $n$ 个路口以及连接这些路口的 $m$ 条 **单行道路**，且每条道路有一定的长度。为了方便将道路系统录入机器人的芯片，小 Y 对每一个路口连接的所有道路进行了编号。具体而言，若有 $d$ 条道路以路口 $x$ 为起点，则这 $d$ 条道路会被小 Y 按照某种顺序编号为 $1 \\sim d$，分别称作以 $x$ 为起点的第 $1 \\sim d$ 条道路。\n\n小 Y 的机器人内部有一个参数 $p$。给定参数 $p$ 的上限 $k$ 与修改费用 $v_1, v_2, \\ldots, v_{k-1}, w_2, w_3, \\ldots, w_k$。小 Y 将按照如下规则设置与修改机器人的参数：\n\n- 初始时，小 Y 将参数 $p$ 设置为 $1$。\n- 在 **任意时刻**，小 Y 可以远程控制机器人修改参数：\n  - 若 $p < k$，则小 Y 可以花费 $v_p$ 的费用将 $p$ 增加 $1$，即 $p \\leftarrow p + 1$；\n  - 若 $p > 1$，则小 Y 可以花费 $w_p$ 的费用将 $p$ 减少 $1$，即 $p \\leftarrow p - 1$。\n\n初始时，小 Y 的机器人位于机器人仓库，即路口 $1$。当机器人位于路口 $x$ 时，记以路口 $x$ 为起点的第 $p$ 条道路的终点为 $y$，道路长度为 $z$，则小 Y 可以花费 $z$ 的费用操控机器人从 $x$ 走到 $y$。特别地，若以路口 $x$ 为起点的道路不足 $p$ 条，则小 Y 无法操控机器人走动。\n\n小 Y 并不知道闭幕式表演所在的礼堂位于哪个路口，因此他需要对每个路口都做好准备。请你帮助他求出将机器人从仓库移动到每个路口所需费用的最小值。", "inputFormat": "输入的第一行包含一个非负整数 $c$，表示测试点编号。$c = 0$ 表示该测试点为样例。\n\n输入的第二行包含三个正整数 $n, m, k$，分别表示路口数量、道路数量与参数 $p$ 的上限。\n\n输入的第三行包含 $k - 1$ 个非负整数 $v_1, \\ldots, v_{k-1}$，表示增加参数 $p$ 的费用。\n\n输入的第四行包含 $k - 1$ 个非负整数 $w_2, \\ldots, w_k$，表示减少参数 $p$ 的费用。\n\n输入的第 $i + 4$（$1 \\leq i \\leq n$）行包含若干个正整数，其中第一个非负整数 $d_i$ 表示以路口 $i$ 为起点的道路数量，接下来 $2d_i$ 个正整数 $y_{i,1}, z_{i,1}, y_{i,2}, z_{i,2}, \\ldots, y_{i,d_i}, z_{i,d_i}$，表示以路口 $i$ 为起点的道路，其中 $y_{i,j}, z_{i,j}$（$1 \\leq j \\leq d_i$）分别表示编号为 $j$ 的道路的终点与长度。", "outputFormat": "输出一行 $n$ 个整数，其中第 $i$（$1 \\leq i \\leq n$）个数表示小 Y 将机器人从仓库移动到路口 $i$ 所需费用的最小值。特别地，若小 Y 无法将机器人从仓库移动到该路口，则输出 $-1$。", "hint": "### 样例 1 解释\n\n小 Y 可以按照以下方案将机器人分别从仓库移动到路口 $1 \\sim 4$：\n\n- 对于路口 $1$：小 Y 的机器人初始时即位于路口 $1$，因此所需费用为 $0$。\n- 对于路口 $2$：小 Y 操控机器人沿以路口 $1$ 为起点的第 $1$ 条道路走到路口 $2$，所需费用为 $5$。\n- 对于路口 $3$：小 Y 将参数 $p$ 增加 $1$，然后操控机器人沿以路口 $1$ 为起点的第 $2$ 条道路走到路口 $3$，所需费用为 $2 + 1 = 3$。\n- 对于路口 $4$：小 Y 将参数 $p$ 增加 $1$，然后操控机器人沿以路口 $1$ 为起点的第 $2$ 条道路走到路口 $3$，再操控机器人沿以路口 $3$ 为起点的第 $2$ 条道路走到路口 $4$，所需费用为 $2 + 1 + 1 = 4$。\n\n可以证明，上述移动方案的所需费用均为最小值。\n\n- 对于路口 $5$：由于小 Y 无法将机器人移动到路口 $5$，因此输出 $-1$。\n\n### 样例 2\n\n见选手目录下的 `robot/robot2.in` 与 `robot/robot2.ans`。\n\n该样例满足测试点 $3 \\sim 5$ 的约束条件。\n\n### 样例 3\n\n见选手目录下的 `robot/robot3.in` 与 `robot/robot3.ans`。\n\n该样例满足测试点 $6 \\sim 8$ 的约束条件。\n\n### 样例 4\n\n见选手目录下的 `robot/robot4.in` 与 `robot/robot4.ans`。\n\n该样例满足测试点 $9, 10$ 的约束条件。\n\n### 样例 5\n\n见选手目录下的 `robot/robot5.in` 与 `robot/robot5.ans`。\n\n该样例满足测试点 $16 \\sim 18$ 的约束条件。\n\n### 数据范围\n\n对于所有测试数据，保证：\n\n- $1 \\leq n, m \\leq 3 \\times 10^5$，$1 \\leq k \\leq 2.5 \\times 10^5$；\n- 对于所有 $1 \\leq i \\leq k - 1$，均有 $0 \\leq v_i \\leq 10^9$；\n- 对于所有 $2 \\leq i \\leq k$，均有 $0 \\leq w_i \\leq 10^9$；\n- 对于所有 $1 \\leq i \\leq n$，均有 $0 \\leq d_i \\leq k$，且 $\\sum_{i=1}^{n} d_i = m$；\n- 对于所有 $1 \\leq i \\leq n$，$1 \\leq j \\leq d_i$，均有 $1 \\leq y_{i,j} \\leq n$，$1 \\leq z_{i,j} \\leq 10^9$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n, m \\leq$ | $k \\leq$ | 特殊性质 |\n| :-: | :-: | :-: | :-: |\n| $1, 2$ | $6$ | $6$ | C |\n| $3 \\sim 5$ | $10^3$ | $10^3$ | ^ |\n| $6 \\sim 8$ | $5 \\times 10^4$ | $10^2$ | 无 |\n| $9, 10$ | $10^5$ | $10^5$ | AB |\n| $11, 12$ | ^ | ^ | A |\n| $13 \\sim 15$ | ^ | ^ | C |\n| $16 \\sim 18$ | ^ | ^ | 无 |\n| $19, 20$ | $3 \\times 10^5$ | $2.5 \\times 10^5$ | ^ |\n\n- 特殊性质 A：保证 $v_1 = v_2 = \\cdots = v_{k-1} = 0$ 且 $w_2 = w_3 = \\cdots = w_k = 0$。\n- 特殊性质 B：保证对于所有 $1 \\leq i \\leq n$，$1 \\leq j \\leq d_i$，均有 $z_{i,j} = 1$。\n- 特殊性质 C：保证至多存在 10 个 $i$ 满足 $d_i \\geq 10$。\n\n附加文件来自于 [QOJ](https://qoj.ac/contest/2315/problem/13079)。", "locale": "zh-CN"}}}
{"pid": "P13272", "type": "P", "difficulty": 7, "samples": [["0 3\n3\n5 6 6\n3 6 9\n1 2 3\n6\n1 1 4 5 1 4\n-1 1 -1 1 -2 2\n1 1 1 1 1 1\n8\n4 2 4 2 2 2 4 4\n-2 4 9 -3 4 8 7 8\n1 1 1 1 1 1 1 1", "15 10\n1 18\n37 48"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2025", "NOI", "Special Judge", "动态规划优化"], "title": "[NOI2025] 序列变换", "background": "", "description": "给定两个长度为 $n$ 的整数序列 $B = [b_1, \\ldots, b_n]$，$C = [c_1, \\ldots, c_n]$。对于长度为 $n$ 的非负整数序列 $D = [d_1, \\ldots, d_n]$，设 $S(D)$ 为所有满足 $d_i = 0$ 的下标 $i$ 的集合，定义 $f(D) = \\sum_{i \\in S(D)} b_i$，$g(D) = \\prod_{i \\in S(D)} c_i$。特别地，若 $S(D)$ 为空，则 $f(D) = 0$，$g(D) = 1$。\n\n小 L 有一个长度为 $n$ 的 **正整数序列** $A = [a_1, \\ldots, a_n]$。小 L 可以对序列 $A$ 做如下修改：\n\n- 选择序列 $A$ 的两个 **相邻** 的下标 $i, j$（即 $1 \\leq i, j \\leq n$ 且 $|i - j| = 1$），若 $a_i \\leq a_j$，则将 $a_j$ 改为 $a_j - a_i$，同时将 $a_i$ 改为 $0$。\n\n小 L 可以进行任意多次修改操作，也可以不进行任何修改。对于所有序列 $A$ 通过以上修改操作可以得到的序列 $D$，小 L 想求出 $f(D)$ 的最大值以及 $g(D)$ 之和，请你帮助他求出这两个值。形式化地，记 $T(A)$ 为序列 $A$ 通过以上修改操作可以得到的 **所有序列的集合**，你需要求出 $\\max_{D \\in T(A)} f(D)$ 以及 $\\sum_{D \\in T(A)} g(D)$。其中，由于 $\\sum_{D \\in T(A)} g(D)$ 可能较大，你只需要求出其对 $1,000,000,007$ 取模后的结果。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含两个非负整数 $c, t$，分别表示测试点编号与测试数据组数。$c = 0$ 表示该测试点为样例。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n\n- 第一行包含一个正整数 $n$，表示序列长度。\n- 第二行包含 $n$ 个正整数 $a_1, \\ldots, a_n$，表示序列 $A$。\n- 第三行包含 $n$ 个整数 $b_1, \\ldots, b_n$，表示序列 $B$。\n- 第四行包含 $n$ 个正整数 $c_1, \\ldots, c_n$，表示序列 $C$。", "outputFormat": "对于每组测试数据，仅输出一行，其中包含两个整数，分别表示 $\\max_{D \\in T(A)} f(D)$ 以及 $\\sum_{D \\in T(A)} g(D)$ 对 $1,000,000,007$ 取模后的结果。**注意：$\\max_{D \\in T(A)} f(D)$ 不需要对 $1,000,000,007$ 取模。**\n\n本题包含两个小问，正确回答其中任意一个小问均可获得部分分数。具体评分规则请参见【评分方式】。", "hint": "### 样例 1 解释\n\n该样例共包含三组测试数据。\n\n对于第一组测试数据，可以得到以下 4 个序列：\n\n- $D = [5, 6, 6]$，$f(D) = 0$，$g(D) = 1$；\n- $D = [0, 1, 6]$，$f(D) = 3$，$g(D) = 1$；\n- $D = [5, 0, 0]$，$f(D) = 6 + 9 = 15$，$g(D) = 2 \\times 3 = 6$；\n- $D = [0, 0, 5]$，$f(D) = 3 + 6 = 9$，$g(D) = 1 \\times 2 = 2$。\n\n故 $\\max_{D \\in T(A)} f(D) = \\max\\{0, 3, 15, 9\\} = 15$，$\\sum_{D \\in T(A)} g(D) = 1 + 1 + 6 + 2 = 10$。\n\n### 样例 2\n\n见选手目录下的 `sequence/sequence2.in` 与 `sequence/sequence2.ans`。\n\n该样例满足测试点 3、4 的约束条件。\n\n### 样例 3\n\n见选手目录下的 `sequence/sequence3.in` 与 `sequence/sequence3.ans`。\n\n该样例满足测试点 5、6 的约束条件。\n\n### 样例 4\n\n见选手目录下的 `sequence/sequence4.in` 与 `sequence/sequence4.ans`。\n\n该样例满足测试点 7 的约束条件。\n\n### 样例 5\n\n见选手目录下的 `sequence/sequence5.in` 与 `sequence/sequence5.ans`。\n\n该样例满足测试点 11、12 的约束条件。\n\n### 样例 6\n\n见选手目录下的 `sequence/sequence6.in` 与 `sequence/sequence6.ans`。\n\n该样例满足测试点 $16\\sim 18$ 的约束条件。\n\n设 $N$ 为单个测试点内所有测试数据的 $n$ 的和。对于所有测试数据，保证：\n\n- $1 \\leq t \\leq 20$；\n- $1 \\leq n \\leq 5,000$，$N \\leq 4 \\times 10^4$；\n- 对于所有 $1 \\leq i \\leq n$，均有 $1 \\leq A_i \\leq 10^9$；\n- 对于所有 $1 \\leq i \\leq n$，均有 $-10^9 \\leq B_i \\leq 10^9$；\n- 对于所有 $1 \\leq i \\leq n$，均有 $1 \\leq C_i \\leq 10^9$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $N \\leq$ | 特殊性质 |\n| :-: | :-: | :-: | :-: |\n| $1, 2$ | $8$ | $10^2$ | 无 |\n| $3, 4$ | $200$ | $400$ | B |\n| $5, 6$ | ^ | ^ | 无 |\n| $7$ | $500$ | $10^3$ | A |\n| $8 \\sim 10$ | ^ | ^ | B |\n| $11, 12$ | ^ | ^ | 无 |\n| $13$ | $3\\,500$ | $3 \\times 10^4$ | A |\n| $14, 15$ | ^ | ^ | B |\n| $16 \\sim 18$ | ^ | ^ | 无 |\n| $19, 20$ | $5\\,000$ | $4 \\times 10^4$ | ^ |\n\n- **特殊性质 A**：保证 $A_1 = A_2 = \\cdots = A_n = 1$。\n- **特殊性质 B**：保证对于所有 $1 \\leq i \\leq n$，$A_i$ 均在 $[1, 10^9]$ 中 **独立均匀随机** 生成。\n\n### 评分方式\n\n对于每个测试点：\n\n- 正确回答所有测试数据的 $\\max_{D \\in T(A)} f(D)$，可获得该测试点 $40\\%$ 的分数；\n- 正确回答所有测试数据的 $\\sum_{D \\in T(A)} g(D)$ 对 $1,000,000,007$ 取模后的结果，可获得该测试点 $60\\%$ 的分数。\n\n**注意：即使选手仅回答了其中一个问题，也需要按照输出格式输出两个整数，分别对应两个问题的答案。**\n\n附加文件来自于 [QOJ](https://qoj.ac/contest/2315/problem/13080)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI2025] 序列变换", "background": "", "description": "给定两个长度为 $n$ 的整数序列 $B = [b_1, \\ldots, b_n]$，$C = [c_1, \\ldots, c_n]$。对于长度为 $n$ 的非负整数序列 $D = [d_1, \\ldots, d_n]$，设 $S(D)$ 为所有满足 $d_i = 0$ 的下标 $i$ 的集合，定义 $f(D) = \\sum_{i \\in S(D)} b_i$，$g(D) = \\prod_{i \\in S(D)} c_i$。特别地，若 $S(D)$ 为空，则 $f(D) = 0$，$g(D) = 1$。\n\n小 L 有一个长度为 $n$ 的 **正整数序列** $A = [a_1, \\ldots, a_n]$。小 L 可以对序列 $A$ 做如下修改：\n\n- 选择序列 $A$ 的两个 **相邻** 的下标 $i, j$（即 $1 \\leq i, j \\leq n$ 且 $|i - j| = 1$），若 $a_i \\leq a_j$，则将 $a_j$ 改为 $a_j - a_i$，同时将 $a_i$ 改为 $0$。\n\n小 L 可以进行任意多次修改操作，也可以不进行任何修改。对于所有序列 $A$ 通过以上修改操作可以得到的序列 $D$，小 L 想求出 $f(D)$ 的最大值以及 $g(D)$ 之和，请你帮助他求出这两个值。形式化地，记 $T(A)$ 为序列 $A$ 通过以上修改操作可以得到的 **所有序列的集合**，你需要求出 $\\max_{D \\in T(A)} f(D)$ 以及 $\\sum_{D \\in T(A)} g(D)$。其中，由于 $\\sum_{D \\in T(A)} g(D)$ 可能较大，你只需要求出其对 $1,000,000,007$ 取模后的结果。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含两个非负整数 $c, t$，分别表示测试点编号与测试数据组数。$c = 0$ 表示该测试点为样例。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n\n- 第一行包含一个正整数 $n$，表示序列长度。\n- 第二行包含 $n$ 个正整数 $a_1, \\ldots, a_n$，表示序列 $A$。\n- 第三行包含 $n$ 个整数 $b_1, \\ldots, b_n$，表示序列 $B$。\n- 第四行包含 $n$ 个正整数 $c_1, \\ldots, c_n$，表示序列 $C$。", "outputFormat": "对于每组测试数据，仅输出一行，其中包含两个整数，分别表示 $\\max_{D \\in T(A)} f(D)$ 以及 $\\sum_{D \\in T(A)} g(D)$ 对 $1,000,000,007$ 取模后的结果。**注意：$\\max_{D \\in T(A)} f(D)$ 不需要对 $1,000,000,007$ 取模。**\n\n本题包含两个小问，正确回答其中任意一个小问均可获得部分分数。具体评分规则请参见【评分方式】。", "hint": "### 样例 1 解释\n\n该样例共包含三组测试数据。\n\n对于第一组测试数据，可以得到以下 4 个序列：\n\n- $D = [5, 6, 6]$，$f(D) = 0$，$g(D) = 1$；\n- $D = [0, 1, 6]$，$f(D) = 3$，$g(D) = 1$；\n- $D = [5, 0, 0]$，$f(D) = 6 + 9 = 15$，$g(D) = 2 \\times 3 = 6$；\n- $D = [0, 0, 5]$，$f(D) = 3 + 6 = 9$，$g(D) = 1 \\times 2 = 2$。\n\n故 $\\max_{D \\in T(A)} f(D) = \\max\\{0, 3, 15, 9\\} = 15$，$\\sum_{D \\in T(A)} g(D) = 1 + 1 + 6 + 2 = 10$。\n\n### 样例 2\n\n见选手目录下的 `sequence/sequence2.in` 与 `sequence/sequence2.ans`。\n\n该样例满足测试点 3、4 的约束条件。\n\n### 样例 3\n\n见选手目录下的 `sequence/sequence3.in` 与 `sequence/sequence3.ans`。\n\n该样例满足测试点 5、6 的约束条件。\n\n### 样例 4\n\n见选手目录下的 `sequence/sequence4.in` 与 `sequence/sequence4.ans`。\n\n该样例满足测试点 7 的约束条件。\n\n### 样例 5\n\n见选手目录下的 `sequence/sequence5.in` 与 `sequence/sequence5.ans`。\n\n该样例满足测试点 11、12 的约束条件。\n\n### 样例 6\n\n见选手目录下的 `sequence/sequence6.in` 与 `sequence/sequence6.ans`。\n\n该样例满足测试点 $16\\sim 18$ 的约束条件。\n\n设 $N$ 为单个测试点内所有测试数据的 $n$ 的和。对于所有测试数据，保证：\n\n- $1 \\leq t \\leq 20$；\n- $1 \\leq n \\leq 5,000$，$N \\leq 4 \\times 10^4$；\n- 对于所有 $1 \\leq i \\leq n$，均有 $1 \\leq A_i \\leq 10^9$；\n- 对于所有 $1 \\leq i \\leq n$，均有 $-10^9 \\leq B_i \\leq 10^9$；\n- 对于所有 $1 \\leq i \\leq n$，均有 $1 \\leq C_i \\leq 10^9$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $N \\leq$ | 特殊性质 |\n| :-: | :-: | :-: | :-: |\n| $1, 2$ | $8$ | $10^2$ | 无 |\n| $3, 4$ | $200$ | $400$ | B |\n| $5, 6$ | ^ | ^ | 无 |\n| $7$ | $500$ | $10^3$ | A |\n| $8 \\sim 10$ | ^ | ^ | B |\n| $11, 12$ | ^ | ^ | 无 |\n| $13$ | $3\\,500$ | $3 \\times 10^4$ | A |\n| $14, 15$ | ^ | ^ | B |\n| $16 \\sim 18$ | ^ | ^ | 无 |\n| $19, 20$ | $5\\,000$ | $4 \\times 10^4$ | ^ |\n\n- **特殊性质 A**：保证 $A_1 = A_2 = \\cdots = A_n = 1$。\n- **特殊性质 B**：保证对于所有 $1 \\leq i \\leq n$，$A_i$ 均在 $[1, 10^9]$ 中 **独立均匀随机** 生成。\n\n### 评分方式\n\n对于每个测试点：\n\n- 正确回答所有测试数据的 $\\max_{D \\in T(A)} f(D)$，可获得该测试点 $40\\%$ 的分数；\n- 正确回答所有测试数据的 $\\sum_{D \\in T(A)} g(D)$ 对 $1,000,000,007$ 取模后的结果，可获得该测试点 $60\\%$ 的分数。\n\n**注意：即使选手仅回答了其中一个问题，也需要按照输出格式输出两个整数，分别对应两个问题的答案。**\n\n附加文件来自于 [QOJ](https://qoj.ac/contest/2315/problem/13080)。", "locale": "zh-CN"}}}
{"pid": "P13273", "type": "P", "difficulty": 7, "samples": [["0\n2\n4 2\n3 7\n5 6\n4 6\n5 7", "8\n4\n\n"], ["0\n6\n2 3\n4 21\n22 23\n5 11\n6 8\n7 9\n12 13\n10 18\n14 15\n16 17\n19 20\n12 13\n14 15\n16 19\n17 18\n20 21\n22 23", "2048\n2048\n2048\n1024\n512\n512"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "NOI"], "title": "[NOI2025] 数字树", "background": "", "description": "给定一棵 $4n - 1$ 个结点的二叉树，其中每个非叶结点都有 **恰好** 两个子结点。非叶结点编号为 $1$ 到 $2n - 1$，叶子结点编号为 $2n$ 到 $4n - 1$。初始时，每个叶子结点上都没有数字。\n\n定义一个 DFS 序是 **优美的**，当且仅当按该 DFS 序将 **所有标有数字的叶子结点** 上的数字拼成一个序列时，该序列可以通过若干次 **消除相邻相同数字** 的方式得到空序列。例如，在下图中，若叶子结点 $4, 6$ 上标有数字 $1$，叶子结点 $5, 7$ 上标有数字 $2$，则按 DFS 序 $[1, 4, 2, 7, 3, 5, 6]$ 将所有标有数字的叶子结点上的数字拼成的序列为 $[1, 2, 2, 1]$，可以通过消除相邻的 $2$ 的方式得到 $[1, 1]$，再通过消除相邻的 $1$ 的方式得到空序列，因此该 DFS 序是优美的；而按 DFS 序 $[1, 4, 2, 3, 5, 6, 7]$ 将所有标有数字的叶子结点上的数字拼成的序列为 $[1, 2, 1, 2]$，无法通过若干次消除相邻相同数字的方式得到空序列，因此该 DFS 序不是优美的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p4thcg8c.png)\n\n给定 $n$ 次操作，第 $i$ ($1 \\leq i \\leq n$) 次操作会选择两个 **没有数字** 的叶子结点，然后将这两个结点标上数字 $i$。**保证在每次操作后，存在至少一个优美的 DFS 序**。你需要求出每次操作后的优美的 DFS 序的数量。由于答案可能较大，你只需要求出答案对 $1,000,000,007$ 取模后的结果。", "inputFormat": "输入的第一行包含一个非负整数 $c$，表示测试点编号。$c = 0$ 表示该测试点为样例。\n\n输入的第二行包含一个正整数 $n$，表示二叉树的结点个数为 $4n - 1$。\n\n输入的第 $i + 2$ ($1 \\leq i \\leq 2n - 1$) 行包含两个正整数 $l_i$ 和 $r_i$，分别表示结点 $i$ 的左右子结点。保证 $i < l_i, r_i \\leq 4n - 1$，且所有的 $l_i, r_i$ 互不相同。\n\n输入的第 $i + 2n + 1$ ($1 \\leq i \\leq n$) 行包含两个正整数 $a_i, b_i$，表示第 $i$ 次操作选择的叶子结点的编号。保证 $2n \\leq a_i, b_i \\leq 4n - 1$，且所有的 $a_i, b_i$ 互不相同。", "outputFormat": "输出 $n$ 行，其中第 $i$ ($1 \\leq i \\leq n$) 行包含一个非负整数，表示第 $i$ 次操作后的优美的 DFS 序的数量对 $1,000,000,007$ 取模后的结果。", "hint": "### 样例 1 解释\n\n该样例即【题目描述】中所示的例子。\n- 第一次操作后，叶子结点 $4$ 和 $6$ 上标有数字 $1$，叶子结点 $5$ 和 $7$ 上没有数字，因此按任意 DFS 序拼成的序列均为 $[1, 1]$，即所有的 $2^3 = 8$ 个 DFS 序都是优美的。\n- 第二次操作后，叶子结点 $4 \\sim 7$ 上分别标有数字 $1, 2, 1, 2$，因此共有 $4$ 个优美的 DFS 序，分别为 $[1, 4, 2, 3, 6, 5, 7], [1, 4, 2, 7, 3, 5, 6], [1, 2, 3, 6, 5, 7, 4], [1, 2, 7, 3, 5, 6, 4]$。\n\n### 样例 3\n\n见选手目录下的 `tree/tree3.in` 与 `tree/tree3.ans`。\n\n该样例满足测试点 $6 \\sim 10$ 的约束条件。\n\n### 样例 4\n\n见选手目录下的 `tree/tree4.in` 与 `tree/tree4.ans`。\n\n该样例满足测试点 $11, 12$ 的约束条件。\n\n### 样例 5\n\n见选手目录下的 `tree/tree5.in` 与 `tree/tree5.ans`。\n\n该样例满足测试点 $17 \\sim 20$ 的约束条件。\n\n### 样例 6\n\n见选手目录下的 `tree/tree6.in` 与 `tree/tree6.ans`。\n\n该样例满足测试点 $24, 25$ 的约束条件。\n\n### 数据范围\n\n对于所有测试数据，保证：\n- $1 \\leq n \\leq 2 \\times 10^5$；\n- 对于所有 $1 \\leq i \\leq 2n - 1$，均有 $i < l_i, r_i \\leq 4n - 1$，且所有的 $l_i, r_i$ 互不相同；\n- 对于所有 $1 \\leq i \\leq n$，均有 $2n \\leq a_i, b_i \\leq 4n - 1$，且所有的 $a_i, b_i$ 互不相同；\n- 在每次操作后，存在至少一个优美的 DFS 序。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | 特殊性质 |\n|:----------:|:--------:|:--------:|\n| $1, 2$       | $10$       | 无       |\n| $3 \\sim 5$      | $10^2$   | A        |\n| $6 \\sim 10$     | ^   | 无       |\n| $11, 12$     | $10^3$   | A        |\n| $13, 14$     | ^   | 无       |\n| $15, 16$     | $5 \\times 10^4$ | AB      |\n| $17 \\sim 20$    | ^ | B       |\n| $21, 22$     | ^ | 无       |\n| $23$         | $2 \\times 10^5$ | A       |\n| $24, 25$     | ^ | 无       |\n\n特殊性质 A：保证每次操作选择的两个叶子结点位于结点 1 的不同子树内。\n\n特殊性质 B：保证存在非负整数 $m$ 满足 $n = 2^m$，且对于所有 $1 \\leq i \\leq 2n - 1$，均有 $l_i = 2i, r_i = 2i + 1$。\n\n附加文件来自于 [QOJ](https://qoj.ac/contest/2315/problem/13081)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI2025] 数字树", "background": "", "description": "给定一棵 $4n - 1$ 个结点的二叉树，其中每个非叶结点都有 **恰好** 两个子结点。非叶结点编号为 $1$ 到 $2n - 1$，叶子结点编号为 $2n$ 到 $4n - 1$。初始时，每个叶子结点上都没有数字。\n\n定义一个 DFS 序是 **优美的**，当且仅当按该 DFS 序将 **所有标有数字的叶子结点** 上的数字拼成一个序列时，该序列可以通过若干次 **消除相邻相同数字** 的方式得到空序列。例如，在下图中，若叶子结点 $4, 6$ 上标有数字 $1$，叶子结点 $5, 7$ 上标有数字 $2$，则按 DFS 序 $[1, 4, 2, 7, 3, 5, 6]$ 将所有标有数字的叶子结点上的数字拼成的序列为 $[1, 2, 2, 1]$，可以通过消除相邻的 $2$ 的方式得到 $[1, 1]$，再通过消除相邻的 $1$ 的方式得到空序列，因此该 DFS 序是优美的；而按 DFS 序 $[1, 4, 2, 3, 5, 6, 7]$ 将所有标有数字的叶子结点上的数字拼成的序列为 $[1, 2, 1, 2]$，无法通过若干次消除相邻相同数字的方式得到空序列，因此该 DFS 序不是优美的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p4thcg8c.png)\n\n给定 $n$ 次操作，第 $i$ ($1 \\leq i \\leq n$) 次操作会选择两个 **没有数字** 的叶子结点，然后将这两个结点标上数字 $i$。**保证在每次操作后，存在至少一个优美的 DFS 序**。你需要求出每次操作后的优美的 DFS 序的数量。由于答案可能较大，你只需要求出答案对 $1,000,000,007$ 取模后的结果。", "inputFormat": "输入的第一行包含一个非负整数 $c$，表示测试点编号。$c = 0$ 表示该测试点为样例。\n\n输入的第二行包含一个正整数 $n$，表示二叉树的结点个数为 $4n - 1$。\n\n输入的第 $i + 2$ ($1 \\leq i \\leq 2n - 1$) 行包含两个正整数 $l_i$ 和 $r_i$，分别表示结点 $i$ 的左右子结点。保证 $i < l_i, r_i \\leq 4n - 1$，且所有的 $l_i, r_i$ 互不相同。\n\n输入的第 $i + 2n + 1$ ($1 \\leq i \\leq n$) 行包含两个正整数 $a_i, b_i$，表示第 $i$ 次操作选择的叶子结点的编号。保证 $2n \\leq a_i, b_i \\leq 4n - 1$，且所有的 $a_i, b_i$ 互不相同。", "outputFormat": "输出 $n$ 行，其中第 $i$ ($1 \\leq i \\leq n$) 行包含一个非负整数，表示第 $i$ 次操作后的优美的 DFS 序的数量对 $1,000,000,007$ 取模后的结果。", "hint": "### 样例 1 解释\n\n该样例即【题目描述】中所示的例子。\n- 第一次操作后，叶子结点 $4$ 和 $6$ 上标有数字 $1$，叶子结点 $5$ 和 $7$ 上没有数字，因此按任意 DFS 序拼成的序列均为 $[1, 1]$，即所有的 $2^3 = 8$ 个 DFS 序都是优美的。\n- 第二次操作后，叶子结点 $4 \\sim 7$ 上分别标有数字 $1, 2, 1, 2$，因此共有 $4$ 个优美的 DFS 序，分别为 $[1, 4, 2, 3, 6, 5, 7], [1, 4, 2, 7, 3, 5, 6], [1, 2, 3, 6, 5, 7, 4], [1, 2, 7, 3, 5, 6, 4]$。\n\n### 样例 3\n\n见选手目录下的 `tree/tree3.in` 与 `tree/tree3.ans`。\n\n该样例满足测试点 $6 \\sim 10$ 的约束条件。\n\n### 样例 4\n\n见选手目录下的 `tree/tree4.in` 与 `tree/tree4.ans`。\n\n该样例满足测试点 $11, 12$ 的约束条件。\n\n### 样例 5\n\n见选手目录下的 `tree/tree5.in` 与 `tree/tree5.ans`。\n\n该样例满足测试点 $17 \\sim 20$ 的约束条件。\n\n### 样例 6\n\n见选手目录下的 `tree/tree6.in` 与 `tree/tree6.ans`。\n\n该样例满足测试点 $24, 25$ 的约束条件。\n\n### 数据范围\n\n对于所有测试数据，保证：\n- $1 \\leq n \\leq 2 \\times 10^5$；\n- 对于所有 $1 \\leq i \\leq 2n - 1$，均有 $i < l_i, r_i \\leq 4n - 1$，且所有的 $l_i, r_i$ 互不相同；\n- 对于所有 $1 \\leq i \\leq n$，均有 $2n \\leq a_i, b_i \\leq 4n - 1$，且所有的 $a_i, b_i$ 互不相同；\n- 在每次操作后，存在至少一个优美的 DFS 序。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | 特殊性质 |\n|:----------:|:--------:|:--------:|\n| $1, 2$       | $10$       | 无       |\n| $3 \\sim 5$      | $10^2$   | A        |\n| $6 \\sim 10$     | ^   | 无       |\n| $11, 12$     | $10^3$   | A        |\n| $13, 14$     | ^   | 无       |\n| $15, 16$     | $5 \\times 10^4$ | AB      |\n| $17 \\sim 20$    | ^ | B       |\n| $21, 22$     | ^ | 无       |\n| $23$         | $2 \\times 10^5$ | A       |\n| $24, 25$     | ^ | 无       |\n\n特殊性质 A：保证每次操作选择的两个叶子结点位于结点 1 的不同子树内。\n\n特殊性质 B：保证存在非负整数 $m$ 满足 $n = 2^m$，且对于所有 $1 \\leq i \\leq 2n - 1$，均有 $l_i = 2i, r_i = 2i + 1$。\n\n附加文件来自于 [QOJ](https://qoj.ac/contest/2315/problem/13081)。", "locale": "zh-CN"}}}
{"pid": "P13274", "type": "P", "difficulty": 5, "samples": [["0 2\n5 2\n11010\n3 3\n2 2\n7 3\n1010100\n7 7\n2 4\n1 2", "2\n4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "2025", "NOI"], "title": "[NOI2025] 三目运算符", "background": "ternary.cpp / 2 s / 512 MiB", "description": "对于一个长度为 $n$ ($n \\geq 3$) 的 01 串 $S = s_1 \\ldots s_n$，定义变换 $T = f(S) = t_1 \\ldots t_n$ 如下：\n\n$$t_i = \\begin{cases} \ns_i, & i \\leq 2, \\\\\ns_i, & i \\geq 3 \\text{ 且 } s_{i-2} = 0, \\\\\ns_{i-1}, & i \\geq 3 \\text{ 且 } s_{i-2} = 1.\n\\end{cases}$$\n\n定义变换 $f$ 的 **不动点** 如下：若 01 串 $T$ 满足 $f(T) = T$，则称 $T$ 为变换 $f$ 的不动点。\n\n记 $f^k(S)$ 为 $S$ 经过 $k$ 次变换得到的串。特别地，记 $f^0(S) = S$。求最小的自然数 $k$，使得 $f^k(S)$ 为变换 $f$ 的不动点，即满足 $f^{k+1}(S) = f^k(S)$ 的最小的自然数 $k$。可以证明，一定存在自然数 $k$ 使得 $f^k(S)$ 为变换 $f$ 的不动点。\n\n小 Z 觉得这个问题过于简单，因此他增加了 $q$ 次修改操作。第 $i$ ($1 \\leq i \\leq q$) 次修改会给定两个正整数 $l_i, r_i$ ($1 \\leq l_i \\leq r_i \\leq n$)，然后将区间 $[l_i, r_i]$ 内的所有原有的 0 替换为 1，所有原有的 1 替换为 0。你需要对初始时及每次修改后的字符串 $S$，求出最小的自然数 $k$，使得 $f^k(S)$ 为变换 $f$ 的不动点。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含两个非负整数 $c, t$，分别表示测试点编号与测试数据组数。$c = 0$ 表示该测试点为样例。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n\n第一行包含两个正整数 $n, q$，分别表示 $S$ 的长度和修改次数。\n\n第二行包含一个长度为 $n$ 的 01 串 $S = s_1 \\ldots s_n$，表示初始时的字符串。\n\n第 $i + 2$ ($1 \\leq i \\leq q$) 行包含两个正整数 $l_i, r_i$，表示一次修改操作。", "outputFormat": "对于每组测试数据，设初始时的答案为 $k_0$，第 $i$ ($1 \\leq i \\leq q$) 次修改后的答案为 $k_i$，输出一行一个正整数，表示 $\\oplus_{i=0}^{q} ((i + 1) \\times k_i)$，其中 $\\oplus$ 表示 **二进制按位异或**。", "hint": "该样例共包含两组测试数据。\n\n对于第一组测试数据：\n- 初始时，$S = 11010$，$f(S) = 11100$，$f^2(S) = 11110$，$f^3(S) = f^4(S) = 11111$，因此 $k_0 = 3$；\n- 第一次操作后，$S = 11110$，$f(S) = f^2(S) = 11111$，因此 $k_1 = 1$；\n- 第二次操作后，$S = 10110$，$f(S) = f^2(S) = 10011$，因此 $k_2 = 1$。\n\n故答案为 $\\bigoplus_{i=0}^{q} ((i+1) \\times k_i) = (1 \\times 3) \\oplus (2 \\times 1) \\oplus (3 \\times 1) = 3 \\oplus 2 \\oplus 3 = 2$。\n\n对于第二组测试数据：\n- 初始时，$S = 1010100$，$k_0 = 1$；\n- 第一次操作后，$S = 1010101$，$k_1 = 1$；\n- 第二次操作后，$S = 1101101$，$k_2 = 5$；\n- 第三次操作后，$S = 0001101$，$k_3 = 2$。\n\n故答案为 $\\bigoplus_{i=0}^{q} ((i+1) \\times k_i) = (1 \\times 1) \\oplus (2 \\times 1) \\oplus (3 \\times 5) \\oplus (4 \\times 2) = 4$。\n\n**【样例 2】**\n\n见选手目录下的 ternary/ternary2.in 与 ternary/ternary2.ans。\n\n该样例满足测试点 1 ~ 3 的约束条件。\n\n**【样例 3】**\n\n见选手目录下的 ternary/ternary3.in 与 ternary/ternary3.ans。\n\n该样例满足测试点 4 ~ 6 的约束条件。\n\n**【样例 4】**\n\n见选手目录下的 ternary/ternary4.in 与 ternary/ternary4.ans。\n\n该样例满足测试点 13、14 的约束条件。\n\n**【样例 5】**\n\n见选手目录下的 ternary/ternary5.in 与 ternary/ternary5.ans。\n\n该样例满足测试点 17 ~ 19 的约束条件。\n\n**【数据范围】**\n\n设 $N, Q$ 分别为单个测试点内所有测试数据的 $n, q$ 的和。对于所有测试数据，保证：\n- $1 \\leq t \\leq 5$;\n- $3 \\leq n \\leq 4 \\times 10^5$, $N \\leq 8 \\times 10^5$;\n- $1 \\leq q \\leq 4 \\times 10^5$, $Q \\leq 8 \\times 10^5$;\n- 对于所有 $1 \\leq i \\leq n$, 均有 $s_i \\in \\{0, 1\\}$;\n- 对于所有 $1 \\leq i \\leq q$, 均有 $1 \\leq l_i \\leq r_i \\leq n$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n, q \\leq$ | $N, Q \\leq$ | 特殊性质 |\n| :-: | :-: | :-: | :-: |\n| $1 \\sim 3$ | $200$ | $10^3$ | A |\n| $4 \\sim 6$ | ^ | ^ | 无 |\n| $7, 8$ | $5,000$ | $10^4$ | A |\n| $9 \\sim 11$ | ^ | ^ | 无 |\n| $12$ | $10^5$ | $2 \\times 10^5$ | A |\n| $13, 14$ | ^ | ^ | B |\n| $15, 16$ | ^ | ^ | 无 |\n| $17 \\sim 19$ | $4 \\times 10^5$ | $8 \\times 10^5$ | C |\n| $20$ | ^ | ^ | 无 |\n\n特殊性质 A: 保证初始时及每次修改后，存在整数 $p \\in [2, n]$ 满足 $s_1 = s_2 = \\cdots = s_p = 1$ 且 $s_{p+1} = \\cdots = s_n = 0$。\n\n特殊性质 B: 保证对于所有 $1 \\leq i \\leq q$, 均有 $l_i = 1$, $r_i = n$。\n\n特殊性质 C: 保证对于所有 $1 \\leq i \\leq q$, 均有 $l_i = 1$, 且 $r_1 \\leq r_2 \\leq \\cdots \\leq r_q$。\n\n附加文件来自于 [QOJ](https://qoj.ac/contest/2316/problem/13082)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI2025] 三目运算符", "background": "ternary.cpp / 2 s / 512 MiB", "description": "对于一个长度为 $n$ ($n \\geq 3$) 的 01 串 $S = s_1 \\ldots s_n$，定义变换 $T = f(S) = t_1 \\ldots t_n$ 如下：\n\n$$t_i = \\begin{cases} \ns_i, & i \\leq 2, \\\\\ns_i, & i \\geq 3 \\text{ 且 } s_{i-2} = 0, \\\\\ns_{i-1}, & i \\geq 3 \\text{ 且 } s_{i-2} = 1.\n\\end{cases}$$\n\n定义变换 $f$ 的 **不动点** 如下：若 01 串 $T$ 满足 $f(T) = T$，则称 $T$ 为变换 $f$ 的不动点。\n\n记 $f^k(S)$ 为 $S$ 经过 $k$ 次变换得到的串。特别地，记 $f^0(S) = S$。求最小的自然数 $k$，使得 $f^k(S)$ 为变换 $f$ 的不动点，即满足 $f^{k+1}(S) = f^k(S)$ 的最小的自然数 $k$。可以证明，一定存在自然数 $k$ 使得 $f^k(S)$ 为变换 $f$ 的不动点。\n\n小 Z 觉得这个问题过于简单，因此他增加了 $q$ 次修改操作。第 $i$ ($1 \\leq i \\leq q$) 次修改会给定两个正整数 $l_i, r_i$ ($1 \\leq l_i \\leq r_i \\leq n$)，然后将区间 $[l_i, r_i]$ 内的所有原有的 0 替换为 1，所有原有的 1 替换为 0。你需要对初始时及每次修改后的字符串 $S$，求出最小的自然数 $k$，使得 $f^k(S)$ 为变换 $f$ 的不动点。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含两个非负整数 $c, t$，分别表示测试点编号与测试数据组数。$c = 0$ 表示该测试点为样例。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n\n第一行包含两个正整数 $n, q$，分别表示 $S$ 的长度和修改次数。\n\n第二行包含一个长度为 $n$ 的 01 串 $S = s_1 \\ldots s_n$，表示初始时的字符串。\n\n第 $i + 2$ ($1 \\leq i \\leq q$) 行包含两个正整数 $l_i, r_i$，表示一次修改操作。", "outputFormat": "对于每组测试数据，设初始时的答案为 $k_0$，第 $i$ ($1 \\leq i \\leq q$) 次修改后的答案为 $k_i$，输出一行一个正整数，表示 $\\oplus_{i=0}^{q} ((i + 1) \\times k_i)$，其中 $\\oplus$ 表示 **二进制按位异或**。", "hint": "该样例共包含两组测试数据。\n\n对于第一组测试数据：\n- 初始时，$S = 11010$，$f(S) = 11100$，$f^2(S) = 11110$，$f^3(S) = f^4(S) = 11111$，因此 $k_0 = 3$；\n- 第一次操作后，$S = 11110$，$f(S) = f^2(S) = 11111$，因此 $k_1 = 1$；\n- 第二次操作后，$S = 10110$，$f(S) = f^2(S) = 10011$，因此 $k_2 = 1$。\n\n故答案为 $\\bigoplus_{i=0}^{q} ((i+1) \\times k_i) = (1 \\times 3) \\oplus (2 \\times 1) \\oplus (3 \\times 1) = 3 \\oplus 2 \\oplus 3 = 2$。\n\n对于第二组测试数据：\n- 初始时，$S = 1010100$，$k_0 = 1$；\n- 第一次操作后，$S = 1010101$，$k_1 = 1$；\n- 第二次操作后，$S = 1101101$，$k_2 = 5$；\n- 第三次操作后，$S = 0001101$，$k_3 = 2$。\n\n故答案为 $\\bigoplus_{i=0}^{q} ((i+1) \\times k_i) = (1 \\times 1) \\oplus (2 \\times 1) \\oplus (3 \\times 5) \\oplus (4 \\times 2) = 4$。\n\n**【样例 2】**\n\n见选手目录下的 ternary/ternary2.in 与 ternary/ternary2.ans。\n\n该样例满足测试点 1 ~ 3 的约束条件。\n\n**【样例 3】**\n\n见选手目录下的 ternary/ternary3.in 与 ternary/ternary3.ans。\n\n该样例满足测试点 4 ~ 6 的约束条件。\n\n**【样例 4】**\n\n见选手目录下的 ternary/ternary4.in 与 ternary/ternary4.ans。\n\n该样例满足测试点 13、14 的约束条件。\n\n**【样例 5】**\n\n见选手目录下的 ternary/ternary5.in 与 ternary/ternary5.ans。\n\n该样例满足测试点 17 ~ 19 的约束条件。\n\n**【数据范围】**\n\n设 $N, Q$ 分别为单个测试点内所有测试数据的 $n, q$ 的和。对于所有测试数据，保证：\n- $1 \\leq t \\leq 5$;\n- $3 \\leq n \\leq 4 \\times 10^5$, $N \\leq 8 \\times 10^5$;\n- $1 \\leq q \\leq 4 \\times 10^5$, $Q \\leq 8 \\times 10^5$;\n- 对于所有 $1 \\leq i \\leq n$, 均有 $s_i \\in \\{0, 1\\}$;\n- 对于所有 $1 \\leq i \\leq q$, 均有 $1 \\leq l_i \\leq r_i \\leq n$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n, q \\leq$ | $N, Q \\leq$ | 特殊性质 |\n| :-: | :-: | :-: | :-: |\n| $1 \\sim 3$ | $200$ | $10^3$ | A |\n| $4 \\sim 6$ | ^ | ^ | 无 |\n| $7, 8$ | $5,000$ | $10^4$ | A |\n| $9 \\sim 11$ | ^ | ^ | 无 |\n| $12$ | $10^5$ | $2 \\times 10^5$ | A |\n| $13, 14$ | ^ | ^ | B |\n| $15, 16$ | ^ | ^ | 无 |\n| $17 \\sim 19$ | $4 \\times 10^5$ | $8 \\times 10^5$ | C |\n| $20$ | ^ | ^ | 无 |\n\n特殊性质 A: 保证初始时及每次修改后，存在整数 $p \\in [2, n]$ 满足 $s_1 = s_2 = \\cdots = s_p = 1$ 且 $s_{p+1} = \\cdots = s_n = 0$。\n\n特殊性质 B: 保证对于所有 $1 \\leq i \\leq q$, 均有 $l_i = 1$, $r_i = n$。\n\n特殊性质 C: 保证对于所有 $1 \\leq i \\leq q$, 均有 $l_i = 1$, 且 $r_1 \\leq r_2 \\leq \\cdots \\leq r_q$。\n\n附加文件来自于 [QOJ](https://qoj.ac/contest/2316/problem/13082)。", "locale": "zh-CN"}}}
