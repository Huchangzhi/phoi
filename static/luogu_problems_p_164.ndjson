{"pid": "P4319", "type": "P", "difficulty": 6, "samples": [["4\n1 3 3\n3 4 4\n2 4 5\n3\n1 2 1 1 2\n2 3 8 2 3\n3 4 2 1 1", "7\n9\n13\n由于版面原因，仅显示三行，接下来32763行都是13"]], "limits": {"time": [1000, 1000, 1000, 1000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "O2优化", "生成树", "动态树 LCT", "可持久化"], "title": "变化的道路", "background": null, "description": "小 w 和小 c 在 H 国，近年来，随着 H 国的发展，H 国的道路也在不断变化着。\n\n根据 H 国的道路法，H 国道路都有一个值 $w$，表示如果小 w 和小 c 通过这条道路，那么他们的 $L$ 值会减少 $w$，但是如果小 w 和小 c 在之前已经经过了这条路，那么他们的 $L$ 值不会减少。\n\nH 国有 $N$ 个国家，最开始 H 国有 $N-1$ 条道路，这 $N-1$ 条道路刚好构成一棵树。\n\n小 w 将和小 c 从 H 国的城市 $1$ 出发，游览 H 国的所有城市，总共游览 $32766$ 天，对于每一天，他们都希望游览结束后 $L$ 值还是一个正数，求他们出发时 $L$ 值至少为多少。\n\nH 国的所有边都是无向边，没有一条道路连接相同的一个城市。", "inputFormat": "输入第 1 行，一个整数 $N$。\n\n输入第 2 至第 $N$ 行，每行三个正整数 $u, v, w$，表示城市 $u$ 与城市 $v$ 有一条值为 $w$ 道路。\n\t\n输入第 $N+1$ 行，一个整数 $M$，表示 H 国有 $M$ 条正在变化的道路。\n\n输入第 $N+2$ 行到第 $N+M+1$ 行，每行 5 个整数 $u, v, w, l, r$，表示城市 $u$ 到城市 $v$ 有一条值为 $w$ 的道路，这条道路存在于第 $l$ 天到第 $r$ 天。", "outputFormat": "输出共 $32766$ 行，第 $i$ 行表示第 $i$ 天游览的 $L$ 值至少为多少。", "hint": "第一天，选择 $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{2} 4$，$L$ 值总共减少了 $6$，所以 $L$ 值至少为 $7$。\n\n第二天，选择 $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{4} 4$，$L$ 值总共减少了 $8$，所以 $L$ 值至少为 $9$。\n\n第三天及之后，选择 $1 \\xrightarrow{3} 3 \\xrightarrow{4} 4 \\xrightarrow{5} 2$，$L$ 值总共减少了 $12$，所以 $L$ 值至少为 $13$。\n\nsubtask1 : 15分，$N = 100, rm = 233$。\n\nsubtask2 : 15分，$N = 1000, rm = 2333$。\n\nsubtask3 : 20分，$N = 49998, rm = 32766, l = r$。\n\nsubtask4：20分，$N = 49999, rm = 32766, r = rm$。\n\nsubtask5：30分，$N = 50000, rm = 32766$。\n\n对于 subtask3，$M = rm$；对于其他 subtask，$M=3\\times rm$。\n\n对于所有数据 : $1\\leq N\\leq 50000, 1\\leq l\\leq r\\leq rm\\leq 32766, 1\\leq w\\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Changing Roads", "background": "", "description": "Xiao w and Xiao c are in Country H. In recent years, as Country H has developed, its roads have been constantly changing.\n\nAccording to Country H’s road law, every road has a value $w$, meaning that if Xiao w and Xiao c pass through this road, their $L$ value will decrease by $w$. However, if Xiao w and Xiao c have already passed this road before, their $L$ value will not decrease.\n\nCountry H has $N$ cities. Initially, Country H has $N-1$ roads, and these $N-1$ roads form a tree.\n\nXiao w and Xiao c will start from city $1$ and visit all cities of Country H. They will travel for 32766 days in total. For each day, they want the $L$ value to still be positive after finishing the tour. Find the minimum initial $L$ they need at departure for each day.\n\nAll edges in Country H are undirected. No road connects a city to itself.", "inputFormat": "Line 1: an integer $N$.\n\nLines 2 to $N$: each line contains three positive integers $u, v, w$, meaning there is a road of value $w$ between cities $u$ and $v$.\n\nLine $N+1$: an integer $M$, meaning Country H has $M$ roads that are changing.\n\nLines $N+2$ to $N+M+1$: each line contains $5$ integers $u, v, w, l, r$, meaning there is a road of value $w$ from city $u$ to city $v$, and this road exists from day $l$ to day $r$.", "outputFormat": "Output $32766$ lines. The $i$-th line is the minimum $L$ required on day $i$.", "hint": "On day 1, choose $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{2} 4$. The $L$ value decreases by $6$ in total, so the minimum $L$ is $7$.\n\nOn day 2, choose $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{4} 4$. The $L$ value decreases by $8$ in total, so the minimum $L$ is $9$.\n\nFrom day 3 onward, choose $1 \\xrightarrow{3} 3 \\xrightarrow{4} 4 \\xrightarrow{5} 2$. The $L$ value decreases by $12$ in total, so the minimum $L$ is $13$.\n\nSubtask 1: 15 points, $N = 100$, rm = 233.\n\nSubtask 2: 15 points, $N = 1000$, rm = 2333.\n\nSubtask 3: 20 points, $N = 49998$, rm = 32766, $l = r$.\n\nSubtask 4: 20 points, $N = 49999$, rm = 32766, $r = rm$.\n\nSubtask 5: 30 points, $N = 50000$, rm = 32766.\n\nFor subtask 3, $M = rm$; for other subtasks, $M = 3 \\times rm$.\n\nConstraints for all testdata: $1 \\leq N \\leq 50000$, $1 \\leq l \\leq r \\leq rm \\leq 32766$, $1 \\leq w \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "变化的道路", "background": null, "description": "小 w 和小 c 在 H 国，近年来，随着 H 国的发展，H 国的道路也在不断变化着。\n\n根据 H 国的道路法，H 国道路都有一个值 $w$，表示如果小 w 和小 c 通过这条道路，那么他们的 $L$ 值会减少 $w$，但是如果小 w 和小 c 在之前已经经过了这条路，那么他们的 $L$ 值不会减少。\n\nH 国有 $N$ 个国家，最开始 H 国有 $N-1$ 条道路，这 $N-1$ 条道路刚好构成一棵树。\n\n小 w 将和小 c 从 H 国的城市 $1$ 出发，游览 H 国的所有城市，总共游览 $32766$ 天，对于每一天，他们都希望游览结束后 $L$ 值还是一个正数，求他们出发时 $L$ 值至少为多少。\n\nH 国的所有边都是无向边，没有一条道路连接相同的一个城市。", "inputFormat": "输入第 1 行，一个整数 $N$。\n\n输入第 2 至第 $N$ 行，每行三个正整数 $u, v, w$，表示城市 $u$ 与城市 $v$ 有一条值为 $w$ 道路。\n\t\n输入第 $N+1$ 行，一个整数 $M$，表示 H 国有 $M$ 条正在变化的道路。\n\n输入第 $N+2$ 行到第 $N+M+1$ 行，每行 5 个整数 $u, v, w, l, r$，表示城市 $u$ 到城市 $v$ 有一条值为 $w$ 的道路，这条道路存在于第 $l$ 天到第 $r$ 天。", "outputFormat": "输出共 $32766$ 行，第 $i$ 行表示第 $i$ 天游览的 $L$ 值至少为多少。", "hint": "第一天，选择 $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{2} 4$，$L$ 值总共减少了 $6$，所以 $L$ 值至少为 $7$。\n\n第二天，选择 $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{4} 4$，$L$ 值总共减少了 $8$，所以 $L$ 值至少为 $9$。\n\n第三天及之后，选择 $1 \\xrightarrow{3} 3 \\xrightarrow{4} 4 \\xrightarrow{5} 2$，$L$ 值总共减少了 $12$，所以 $L$ 值至少为 $13$。\n\nsubtask1 : 15分，$N = 100, rm = 233$。\n\nsubtask2 : 15分，$N = 1000, rm = 2333$。\n\nsubtask3 : 20分，$N = 49998, rm = 32766, l = r$。\n\nsubtask4：20分，$N = 49999, rm = 32766, r = rm$。\n\nsubtask5：30分，$N = 50000, rm = 32766$。\n\n对于 subtask3，$M = rm$；对于其他 subtask，$M=3\\times rm$。\n\n对于所有数据 : $1\\leq N\\leq 50000, 1\\leq l\\leq r\\leq rm\\leq 32766, 1\\leq w\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4320", "type": "P", "difficulty": 6, "samples": [["5 6\n1 2\n1 3\n2 3\n3 4\n4 5\n3 5\n1\n1 5", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "倍增", "O2优化", "树链剖分", "圆方树"], "title": "道路相遇", "background": "", "description": "在 H 国的小 w 决定到从城市 $u$ 到城市 $v$ 旅行，但是此时小 c 由于各种原因不在城市 $u$，但是小 c 决定到在中途与小 w 相遇\n\n由于 H 国道路的原因，小 w 从城市 $u$ 到城市 $v$ 的路线不是固定的，为了合理分配时间，小 c 想知道从城市 $u$ 到城市 $v$ 有多少个城市小 w 一定会经过，特别地，$u, v$ 也必须被算进去，也就是说无论如何答案不会小于 2\n\n由于各种特殊的原因，小 c 并不知道小 w 的起点和终点，但是小 c 知道小 w 的起点和终点只有 $q$ 种可能，所以对于这 $q$ 种可能，小 c 都想知道小 w 一定会经过的城市数\n\nH 国所有的边都是无向边，两个城市之间最多只有一条道路直接相连，没有一条道路连接相同的一个城市\n\n任何时候，H 国不存在城市 $u$ 和城市 $v$ 满足从 $u$ 无法到达 $v$", "inputFormat": "第一行两个正整数 $n,m$，表示 H 国的城市数，以及道路数。\n\n下面 $m$ 行，每行两个不同的正整数 $u, v$，表示城市 $u$ 到城市 $v$ 之间有一条边。\n\n然后一行一个正整数 $q$。\n接下来 $q$ 行，每行两个正整数 $u, v$ 表示小 w 旅行的一种可能的路线", "outputFormat": "输出共 $q$ 行，每行一个正整数", "hint": "从城市 $1$ 到城市 $5$ 总共有 $4$ 种可能 : \n\n$1 \\to 2 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 2 \\to 3 \\to 5$\n\n$1 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 3 \\to 5$\n\n可以发现小 w 总会经过城市 $1,3,5$，所以答案为 $3$\n\n你可以认为小 w 不会经过相同的城市两次，当然，如果你认为可以经过相同的城市两次也不会影响答案\n\nsubtask1 : 15分，$n = 5, q = 50$\n\nsubtask2 : 15分，$n = 100, q = 5000$\n\nsubtask3 : 20分，$n = 3000, q = 5\\times 10^5$\n\nsubtask4 : 20分，$n = 499999, q = 5 \\times 10^5, m = n-1$\n\nsubtask5 : 30分，$n = q = 5 \\times 10^5$\n\n对于所有数据 : $1\\leq n\\leq 5 \\times 10^5, 1\\leq q\\leq 5\\times 10^5, 1\\leq m\\leq \\min(\\frac{n(n-1)}{2}, 10^6)$", "locale": "zh-CN", "translations": {"en": {"title": "Road Encounter", "background": "# Description\n\nIn country H, Xiao w decides to travel from city $u$ to city $v$. However, for various reasons, Xiao c is not in city $u$, but Xiao c decides to meet Xiao w somewhere along the way.\n\nBecause of the road network in country H, the route Xiao w takes from city $u$ to city $v$ is not fixed. To plan time reasonably, Xiao c wants to know how many cities Xiao w will definitely pass through on all possible routes from city $u$ to city $v$. In particular, $u$ and $v$ must also be counted, which means the answer is never less than $2$.\n\nFor various reasons, Xiao c does not know Xiao w’s exact start and end cities, but Xiao c knows there are only $q$ possible pairs of start and end cities. For each of these $q$ possibilities, Xiao c wants to know the number of cities that Xiao w will definitely pass through.\n\nAll edges in country H are undirected. Between any two cities, there is at most one direct road. There is no road that connects a city to itself.\n\nAt all times, the graph is connected.", "description": "", "inputFormat": "", "outputFormat": "Output $q$ lines, each containing a single positive integer.", "hint": "From city $1$ to city $5$ there are $4$ possible routes:\n\n$1 \\to 2 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 2 \\to 3 \\to 5$\n\n$1 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 3 \\to 5$\n\nIt can be seen that Xiao w will always pass through cities $1, 3, 5$, so the answer is $3$.\n\nYou may assume Xiao w will not visit the same city twice. Of course, even if you think revisiting cities is allowed, it does not affect the answer.\n\nSubtask 1: 15 points, $n = 5, q = 50$.\n\nSubtask 2: 15 points, $n = 100, q = 5000$.\n\nSubtask 3: 20 points, $n = 3000, q = 5 \\times 10^5$.\n\nSubtask 4: 20 points, $n = 499999, q = 5 \\times 10^5, m = n - 1$.\n\nSubtask 5: 30 points, $n = q = 5 \\times 10^5$.\n\nConstraints:\nFor all testdata: $1 \\leq n \\leq 5 \\times 10^5, 1 \\leq q \\leq 5 \\times 10^5, 1 \\leq m \\leq \\min(\\frac{n(n-1)}{2}, 10^6)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "道路相遇", "background": "", "description": "在 H 国的小 w 决定到从城市 $u$ 到城市 $v$ 旅行，但是此时小 c 由于各种原因不在城市 $u$，但是小 c 决定到在中途与小 w 相遇\n\n由于 H 国道路的原因，小 w 从城市 $u$ 到城市 $v$ 的路线不是固定的，为了合理分配时间，小 c 想知道从城市 $u$ 到城市 $v$ 有多少个城市小 w 一定会经过，特别地，$u, v$ 也必须被算进去，也就是说无论如何答案不会小于 2\n\n由于各种特殊的原因，小 c 并不知道小 w 的起点和终点，但是小 c 知道小 w 的起点和终点只有 $q$ 种可能，所以对于这 $q$ 种可能，小 c 都想知道小 w 一定会经过的城市数\n\nH 国所有的边都是无向边，两个城市之间最多只有一条道路直接相连，没有一条道路连接相同的一个城市\n\n任何时候，H 国不存在城市 $u$ 和城市 $v$ 满足从 $u$ 无法到达 $v$", "inputFormat": "第一行两个正整数 $n,m$，表示 H 国的城市数，以及道路数。\n\n下面 $m$ 行，每行两个不同的正整数 $u, v$，表示城市 $u$ 到城市 $v$ 之间有一条边。\n\n然后一行一个正整数 $q$。\n接下来 $q$ 行，每行两个正整数 $u, v$ 表示小 w 旅行的一种可能的路线", "outputFormat": "输出共 $q$ 行，每行一个正整数", "hint": "从城市 $1$ 到城市 $5$ 总共有 $4$ 种可能 : \n\n$1 \\to 2 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 2 \\to 3 \\to 5$\n\n$1 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 3 \\to 5$\n\n可以发现小 w 总会经过城市 $1,3,5$，所以答案为 $3$\n\n你可以认为小 w 不会经过相同的城市两次，当然，如果你认为可以经过相同的城市两次也不会影响答案\n\nsubtask1 : 15分，$n = 5, q = 50$\n\nsubtask2 : 15分，$n = 100, q = 5000$\n\nsubtask3 : 20分，$n = 3000, q = 5\\times 10^5$\n\nsubtask4 : 20分，$n = 499999, q = 5 \\times 10^5, m = n-1$\n\nsubtask5 : 30分，$n = q = 5 \\times 10^5$\n\n对于所有数据 : $1\\leq n\\leq 5 \\times 10^5, 1\\leq q\\leq 5\\times 10^5, 1\\leq m\\leq \\min(\\frac{n(n-1)}{2}, 10^6)$", "locale": "zh-CN"}}}
{"pid": "P4321", "type": "P", "difficulty": 7, "samples": [["3 2\n1 2\n2 3\n3\n2 1 2 1\t\t\n3 1 2 3 1\n1 3 1", "1\n4\n4"]], "limits": {"time": [2000, 2000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "图论", "O2优化", "期望", "高斯消元"], "title": "随机漫游", "background": "", "description": "H 国有 $N$ 个城市\n\n在接下来的 $M$ 天，小 c 都会去找小 w，但是小 c 不知道小 w 的具体位置，所以小 c 决定每次随机找一条路走，直到遇到了小 w 为止\n\n小 c 知道小 w 只有可能是在 $c_1, c_2.. c_n$ 这 $n$ 个城市中的一个，小 c 想知道在最坏情况下，小 c 遇到小 w 期望要经过多少条道路\n\nH 国所有的边都是无向边，两个城市之间最多只有一条道路直接相连，没有一条道路连接相同的一个城市\n\n任何时候，H 国不存在城市 $u$ 和城市 $v$ 满足从 $u$ 无法到达 $v$", "inputFormat": "输入第 1 行一个正整数$N, E$，分别表示 H 国的城市数与边的数量\n\n输入第 2 行至第 $E+1$ 行，每行两个正整数 $u, v$，分别表示城市 $u$ 到城市 $v$ 有一条道路\n\n输入第 $E+2$ 行一个正整数 $M$\n\n输入第 $E+3$ 行至第 $E+M+2$ 行每行 $n+2$ 个正整数，第一个正整数为 $n$，接下来 $n$ 个互不相同的正整数 $c_i$，最后一个正整数 $s$ 表示小 c 所在的城市", "outputFormat": "输出共 $M$ 行，每行一个正整数 $r$ 表示答案\n\n如果你计算出来的期望为 $\\frac{q}{p}$，其中$p, q$互质，那么你输出的 $r$ 满足 $r\\times p \\equiv q(\\mathrm{mod}\\ 998244353)$，\n且$0\\leq r < 998244353$，可以证明这样的 $r$是唯一的", "hint": "$H$ 国的道路构成一条链，所以最坏情况下就是小 w 在深度最大的点上(以小 c 所在的城市为根)\n\n对于第一天，小 c 所在的城市为 1，深度最大的点为 2，城市 1 只能到达城市 2，期望经过 1 条道路到达\n\n对于第二天，小 c 所在的城市为 1，深度最大的点为 3，计算的期望经过 4 条道路到达\n\n第三天同第二天\n\n最坏情况也就是说经过所有 $n$ 个可能的城市至少一遍\n\nsubtask1 : 10分，$N = 4, M = 12$\n\nsubtask2 : 15分，$N =10, M = 100000$\n\nsubtask3 : 15分，$N = 18, M = 1$\n\nsubtask4 : 10分，$N = 18, M = 99995$，图是一条链\n\nsubtask5 : 10分，$N = 18, M = 99996$，所有的 $s$ 都相同\n\nsubtask6 : 15分，$N = 18, M = 99997$，$E = N-1$\n\nsubtask7 : 15分，$N = 18, M = 99998$，所有的 $s$ 都相同\n\nsubtask8 : 10分，$N = 18, M = 99999$\n\n对于所有数据 : $1\\leq N\\leq 18, 1\\leq M\\leq 100000, 1\\leq E\\leq \\frac{N(N-1)}{2}$", "locale": "zh-CN", "translations": {"en": {"title": "Random Walk", "background": "", "description": "Country H has $N$ cities.\n\nIn the next $M$ days, Xiao c will go to look for Xiao w, but Xiao c does not know the exact location of Xiao w, so Xiao c decides to randomly choose one road to walk each time until meeting Xiao w.\n\nXiao c knows that Xiao w can only be in one of the $n$ cities $c_1, c_2.. c_n$. Xiao c wants to know, in the worst case, the expected number of roads Xiao c needs to traverse before meeting Xiao w.\n\nAll edges in country H are undirected. Between any two cities, there is at most one road directly connecting them, and no road connects the same city to itself.\n\nAt any time, in country H there do not exist cities $u$ and $v$ such that $v$ cannot be reached from $u$.", "inputFormat": "The first line contains two positive integers $N, E$, representing the number of cities and the number of edges in country H.\n\nLines 2 to $E+1$ each contain two positive integers $u, v$, indicating there is a road between city $u$ and city $v$.\n\nLine $E+2$ contains one positive integer $M$.\n\nLines $E+3$ to $E+M+2$ each contain $n+2$ positive integers: the first integer is $n$, followed by $n$ distinct integers $c_i$, and the last integer $s$ indicates the city where Xiao c is located.", "outputFormat": "Output $M$ lines, each containing a single integer $r$ representing the answer.\n\nIf the expected value you compute is $\\frac{q}{p}$, where $p, q$ are coprime, then you should output an $r$ such that $r\\times p \\equiv q(\\mathrm{mod}\\ 998244353)$ and $0\\leq r < 998244353$. It can be proved that such an $r$ is unique.", "hint": "The roads of country H form a chain, so in the worst case Xiao w is at the deepest node (taking Xiao c’s city as the root).\n\nFor the first day, Xiao c is in city 1, the deepest node is 2, city 1 can only reach city 2, and the expected number of roads to reach it is 1.\n\nFor the second day, Xiao c is in city 1, the deepest node is 3, and the computed expectation is 4 roads to reach it.\n\nThe third day is the same as the second day.\n\nThe worst case means going through all $n$ possible cities at least once.\n\nSubtask 1: 10 points, $N = 4, M = 12$.\n\nSubtask 2: 15 points, $N =10, M = 100000$.\n\nSubtask 3: 15 points, $N = 18, M = 1$.\n\nSubtask 4: 10 points, $N = 18, M = 99995$, the graph is a chain.\n\nSubtask 5: 10 points, $N = 18, M = 99996$, all $s$ are the same.\n\nSubtask 6: 15 points, $N = 18, M = 99997$, $E = N-1$.\n\nSubtask 7: 15 points, $N = 18, M = 99998$, all $s$ are the same.\n\nSubtask 8: 10 points, $N = 18, M = 99999$.\n\nConstraints for all testdata: $1\\leq N\\leq 18, 1\\leq M\\leq 100000, 1\\leq E\\leq \\frac{N(N-1)}{2}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "随机漫游", "background": "", "description": "H 国有 $N$ 个城市\n\n在接下来的 $M$ 天，小 c 都会去找小 w，但是小 c 不知道小 w 的具体位置，所以小 c 决定每次随机找一条路走，直到遇到了小 w 为止\n\n小 c 知道小 w 只有可能是在 $c_1, c_2.. c_n$ 这 $n$ 个城市中的一个，小 c 想知道在最坏情况下，小 c 遇到小 w 期望要经过多少条道路\n\nH 国所有的边都是无向边，两个城市之间最多只有一条道路直接相连，没有一条道路连接相同的一个城市\n\n任何时候，H 国不存在城市 $u$ 和城市 $v$ 满足从 $u$ 无法到达 $v$", "inputFormat": "输入第 1 行一个正整数$N, E$，分别表示 H 国的城市数与边的数量\n\n输入第 2 行至第 $E+1$ 行，每行两个正整数 $u, v$，分别表示城市 $u$ 到城市 $v$ 有一条道路\n\n输入第 $E+2$ 行一个正整数 $M$\n\n输入第 $E+3$ 行至第 $E+M+2$ 行每行 $n+2$ 个正整数，第一个正整数为 $n$，接下来 $n$ 个互不相同的正整数 $c_i$，最后一个正整数 $s$ 表示小 c 所在的城市", "outputFormat": "输出共 $M$ 行，每行一个正整数 $r$ 表示答案\n\n如果你计算出来的期望为 $\\frac{q}{p}$，其中$p, q$互质，那么你输出的 $r$ 满足 $r\\times p \\equiv q(\\mathrm{mod}\\ 998244353)$，\n且$0\\leq r < 998244353$，可以证明这样的 $r$是唯一的", "hint": "$H$ 国的道路构成一条链，所以最坏情况下就是小 w 在深度最大的点上(以小 c 所在的城市为根)\n\n对于第一天，小 c 所在的城市为 1，深度最大的点为 2，城市 1 只能到达城市 2，期望经过 1 条道路到达\n\n对于第二天，小 c 所在的城市为 1，深度最大的点为 3，计算的期望经过 4 条道路到达\n\n第三天同第二天\n\n最坏情况也就是说经过所有 $n$ 个可能的城市至少一遍\n\nsubtask1 : 10分，$N = 4, M = 12$\n\nsubtask2 : 15分，$N =10, M = 100000$\n\nsubtask3 : 15分，$N = 18, M = 1$\n\nsubtask4 : 10分，$N = 18, M = 99995$，图是一条链\n\nsubtask5 : 10分，$N = 18, M = 99996$，所有的 $s$ 都相同\n\nsubtask6 : 15分，$N = 18, M = 99997$，$E = N-1$\n\nsubtask7 : 15分，$N = 18, M = 99998$，所有的 $s$ 都相同\n\nsubtask8 : 10分，$N = 18, M = 99999$\n\n对于所有数据 : $1\\leq N\\leq 18, 1\\leq M\\leq 100000, 1\\leq E\\leq \\frac{N(N-1)}{2}$", "locale": "zh-CN"}}}
{"pid": "P4322", "type": "P", "difficulty": 5, "samples": [["1 2\n1000 1 0\n1 1000 1", "0.001"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "二分", "各省省选", "江苏", "背包 DP", "分数规划"], "title": "[JSOI2016] 最佳团体", "background": null, "description": "JSOI 信息学代表队一共有 $N$ 名候选人，这些候选人从 $1$ 到 $N$ 编号。方便起见，JYY 的编号是 $0$ 号。每个候选人都由一位编号比他小的候选人 $R_i$ 推荐。如果 $R_i = 0$，则说明这个候选人是 JYY 自己看上的。\n\n为了保证团队的和谐，JYY 需要保证，如果招募了候选人 $i$，那么候选人 $R_i$ 也一定需要在团队中。当然了，JYY 自己总是在团队里的。每一个候选人都有一个战斗值 $P_i$ ，也有一个招募费用 $S_i$ 。JYY 希望招募 $K$ 个候选人（JYY 自己不算），组成一个性价比最高的团队。也就是，这 $K$ 个被 JYY 选择的候选人的总战斗值与总招募费用的比值最大。", "inputFormat": "输入一行包含两个正整数 $K$ 和 $N$ 。\n\n接下来 $N$ 行，其中第 $i$ 行包含三个整数 $S_i$ , $P_i$ , $R_i$ ,\n表示候选人 $i$ 的招募费用，战斗值和推荐人编号。", "outputFormat": "输出一行一个实数，表示最佳比值。答案保留三位小数。", "hint": "对于 $100\\%$ 的数据满足 $1 \\le K \\le N \\le 2500$，$0 < S_i,P_i \\le 10^4$，$0 \\le R_i < i$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Best Team", "background": "", "description": "There are $N$ candidates in the JSOI informatics team, numbered from $1$ to $N$. For convenience, JYY is numbered $0$. Each candidate $i$ is recommended by a candidate with a smaller number $R_i$. If $R_i = 0$, it means this candidate was picked by JYY himself.\n\nTo ensure team harmony, JYY requires that if candidate $i$ is recruited, then candidate $R_i$ must also be in the team. JYY is always in the team. Each candidate has a combat power $P_i$ and a recruitment cost $S_i$. JYY wants to recruit $K$ candidates (excluding JYY) to form the team with the best ratio; that is, maximize the ratio of the total combat power to the total recruitment cost of these $K$ selected candidates.", "inputFormat": "The first line contains two positive integers $K$ and $N$.\n\nThe $i$-th of the next $N$ lines contains three integers $S_i$, $P_i$, $R_i$, indicating candidate $i$’s recruitment cost, combat power, and recommender number.", "outputFormat": "Print one real number, the best ratio. The answer should be rounded to three decimal places.", "hint": "For $100\\%$ of the testdata, $1 \\le K \\le N \\le 2500$, $0 < S_i, P_i \\le 10^4$, $0 \\le R_i < i$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 最佳团体", "background": null, "description": "JSOI 信息学代表队一共有 $N$ 名候选人，这些候选人从 $1$ 到 $N$ 编号。方便起见，JYY 的编号是 $0$ 号。每个候选人都由一位编号比他小的候选人 $R_i$ 推荐。如果 $R_i = 0$，则说明这个候选人是 JYY 自己看上的。\n\n为了保证团队的和谐，JYY 需要保证，如果招募了候选人 $i$，那么候选人 $R_i$ 也一定需要在团队中。当然了，JYY 自己总是在团队里的。每一个候选人都有一个战斗值 $P_i$ ，也有一个招募费用 $S_i$ 。JYY 希望招募 $K$ 个候选人（JYY 自己不算），组成一个性价比最高的团队。也就是，这 $K$ 个被 JYY 选择的候选人的总战斗值与总招募费用的比值最大。", "inputFormat": "输入一行包含两个正整数 $K$ 和 $N$ 。\n\n接下来 $N$ 行，其中第 $i$ 行包含三个整数 $S_i$ , $P_i$ , $R_i$ ,\n表示候选人 $i$ 的招募费用，战斗值和推荐人编号。", "outputFormat": "输出一行一个实数，表示最佳比值。答案保留三位小数。", "hint": "对于 $100\\%$ 的数据满足 $1 \\le K \\le N \\le 2500$，$0 < S_i,P_i \\le 10^4$，$0 \\le R_i < i$。", "locale": "zh-CN"}}}
{"pid": "P4323", "type": "P", "difficulty": 6, "samples": [["5\n1 2\n2 3\n1 4\n1 5\n1 2\n2 3\n3 4\n4 5\n3 6", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "各省省选", "江苏", "深度优先搜索 DFS", "哈希 hashing"], "title": "[JSOI2016] 独特的树叶", "background": null, "description": "JYY 有两棵树 $A$ 和 $B$：树 $A$ 有 $N$ 个点，编号为 $1$ 到 $N$；树 $B$ 有 $N + 1$ 个节点，编号为 $1$ 到 $N + 1$。\n\nJYY 知道树 $B$ 恰好是由树 $A$ 加上一个叶节点，然后将节点的编号打乱后得到的。他想知道，这个多余的叶子到底是树 $B$ 中的哪一个叶节点呢？", "inputFormat": "输入一行包含一个正整数 $N$。接下来 $N - 1$ 行，描述树 $A$，每行包含两个整数表示树 $A$ 中的一条边；接下来 $N$ 行，描述树 $B$，每行包含两个整数表示树 $B$ 中的一条边。", "outputFormat": "输出一行一个整数，表示树 $B$ 中相比树 $A$ 多余的那个叶子的编号。如果有多个符合要求的叶子，输出 $B$ 中编号最小的那一个的编号。", "hint": "对于所有数据，$1 \\leq n \\leq 10 ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Unique Leaf", "background": "", "description": "JYY has two trees $A$ and $B$: tree $A$ has $N$ nodes labeled from $1$ to $N$; tree $B$ has $N + 1$ nodes labeled from $1$ to $N + 1$.\n\nJYY knows that tree $B$ is obtained from tree $A$ by adding one leaf node and then shuffling the node labels. He wants to determine which leaf node in tree $B$ is the extra one.", "inputFormat": "The first line contains a positive integer $N$.  \nThe next $N - 1$ lines describe tree $A$, each containing two integers that represent an edge of tree $A$.  \nThe next $N$ lines describe tree $B$, each containing two integers that represent an edge of tree $B$.", "outputFormat": "Output a single integer: the label in tree $B$ of the extra leaf compared to tree $A$. If multiple leaves satisfy the condition, output the smallest label among them.", "hint": "For all testdata, $1 \\leq N \\leq 10^{5}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 独特的树叶", "background": null, "description": "JYY 有两棵树 $A$ 和 $B$：树 $A$ 有 $N$ 个点，编号为 $1$ 到 $N$；树 $B$ 有 $N + 1$ 个节点，编号为 $1$ 到 $N + 1$。\n\nJYY 知道树 $B$ 恰好是由树 $A$ 加上一个叶节点，然后将节点的编号打乱后得到的。他想知道，这个多余的叶子到底是树 $B$ 中的哪一个叶节点呢？", "inputFormat": "输入一行包含一个正整数 $N$。接下来 $N - 1$ 行，描述树 $A$，每行包含两个整数表示树 $A$ 中的一条边；接下来 $N$ 行，描述树 $B$，每行包含两个整数表示树 $B$ 中的一条边。", "outputFormat": "输出一行一个整数，表示树 $B$ 中相比树 $A$ 多余的那个叶子的编号。如果有多个符合要求的叶子，输出 $B$ 中编号最小的那一个的编号。", "hint": "对于所有数据，$1 \\leq n \\leq 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P4324", "type": "P", "difficulty": 5, "samples": [["5\nABCDE\nBAECB", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "动态规划 DP", "2016", "二分", "各省省选", "江苏", "枚举", "哈希 hashing"], "title": "[JSOI2016] 扭动的回文串", "background": null, "description": "JYY 有两个长度均为 $N$ 的字符串 $A$ 和 $B$。\n\n一个扭动字符串 $S(i,j,k)$ 由 $A$ 中的第 $i$ 个字符到第 $j$ 个字符组成的子串与 $B$ 中的第 $j$ 个字符到第 $k$ 个字符组成的子串拼接而成。\n\n比如，若 $A= \\mathtt{XYZ}$，$B= \\mathtt{UVW}$，则扭动字符串 $S(1,2,3)=\\mathtt{XYVW}$。\n\nJYY 定义一个扭动的回文串为如下情况中的一个：\n\n- $A$ 中的一个回文串；\n- $B$ 中的一个回文串；\n- 或者某一个回文的扭动字符串 $S(i,j,k)$。\n\n现在 JYY 希望找出最长的扭动回文串。", "inputFormat": "第一行包含一个正整数 $N$。\n第二行包含一个长度为 $N$ 的由大写字母组成的字符串 $A$。\n第三行包含一个长度为 $N$ 的由大写字母组成的字符串 $B$。", "outputFormat": "输出的第一行一个整数，表示最长的扭动回文串。", "hint": "**样例解释**\n最佳方案中的扭动回文串如下所示（不在回文串中的字符用 `.` 表示）：\n\n```pain\n.BC..\n..ECB\n```\n\n对于所有的数据，$1 \\leq n \\leq 10 ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Twisted Palindrome String", "background": "", "description": "JYY has two strings $A$ and $B$, both of length $N$.\n\nA \"twisted string\" $S(i,j,k)$ is formed by concatenating the substring of $A$ from the $i$-th character to the $j$-th character and the substring of $B$ from the $j$-th character to the $k$-th character.\n\nFor example, if $A=\\mathtt{XYZ}$ and $B=\\mathtt{UVW}$, then the twisted string $S(1,2,3)=\\mathtt{XYVW}$.\n\nJYY defines a \"twisted palindrome\" as one of the following:\n- A palindrome in $A$;\n- A palindrome in $B$;\n- Or a twisted string $S(i,j,k)$ that is a palindrome.\n\nNow JYY wants to find the longest twisted palindrome.", "inputFormat": "The first line contains a positive integer $N$.\nThe second line contains a string $A$ of length $N$ consisting of uppercase letters.\nThe third line contains a string $B$ of length $N$ consisting of uppercase letters.", "outputFormat": "Output a single integer on the first line, the length of the longest twisted palindrome.", "hint": "Sample explanation:\nThe twisted palindrome in the best solution is shown below (characters not in the palindrome are marked with `.`):\n\n```pain\n.BC..\n..ECB\n```\n\nConstraints: For all testdata, $1 \\leq N \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 扭动的回文串", "background": null, "description": "JYY 有两个长度均为 $N$ 的字符串 $A$ 和 $B$。\n\n一个扭动字符串 $S(i,j,k)$ 由 $A$ 中的第 $i$ 个字符到第 $j$ 个字符组成的子串与 $B$ 中的第 $j$ 个字符到第 $k$ 个字符组成的子串拼接而成。\n\n比如，若 $A= \\mathtt{XYZ}$，$B= \\mathtt{UVW}$，则扭动字符串 $S(1,2,3)=\\mathtt{XYVW}$。\n\nJYY 定义一个扭动的回文串为如下情况中的一个：\n\n- $A$ 中的一个回文串；\n- $B$ 中的一个回文串；\n- 或者某一个回文的扭动字符串 $S(i,j,k)$。\n\n现在 JYY 希望找出最长的扭动回文串。", "inputFormat": "第一行包含一个正整数 $N$。\n第二行包含一个长度为 $N$ 的由大写字母组成的字符串 $A$。\n第三行包含一个长度为 $N$ 的由大写字母组成的字符串 $B$。", "outputFormat": "输出的第一行一个整数，表示最长的扭动回文串。", "hint": "**样例解释**\n最佳方案中的扭动回文串如下所示（不在回文串中的字符用 `.` 表示）：\n\n```pain\n.BC..\n..ECB\n```\n\n对于所有的数据，$1 \\leq n \\leq 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P4325", "type": "P", "difficulty": 1, "samples": [["1\n2\n3\n4\n5\n6\n7\n8\n9\n10", "10"], ["42\n84\n252\n420\n840\n126\n42\n84\n420\n126", "1"], ["39\n40\n41\n42\n43\n44\n82\n83\n84\n85", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2006", "枚举", "排序", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #1] Modulo", "background": "", "description": "Given two integers A and B, A modulo B is the remainder when dividing A by B. For example, the numbers 7, 14, 27 and 38 become 1, 2, 0 and 2, modulo 3. Write a program that accepts 10 numbers as input and outputs the number of distinct numbers in the input, if the numbers are considered modulo 42.", "inputFormat": "The input will contain 10 non-negative integers, each smaller than 1000, one per line.", "outputFormat": "Output the number of distinct values when considered modulo 42 on a single line.", "hint": "In the first example, the numbers modulo 42 are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10.\nIn the second example all numbers modulo 42 are 0.\nIn the third example, the numbers modulo 42 are 39, 40, 41, 0, 1, 2, 40, 41, 0 and 1. There are 6 distinct numbers.", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Modulo", "background": "", "description": "Given two integers A and B, A modulo B is the remainder when dividing A by B. For example, the numbers 7, 14, 27 and 38 become 1, 2, 0 and 2, modulo 3. Write a program that accepts 10 numbers as input and outputs the number of distinct numbers in the input, if the numbers are considered modulo 42.", "inputFormat": "The input will contain 10 non-negative integers, each smaller than 1000, one per line.", "outputFormat": "Output the number of distinct values when considered modulo 42 on a single line.", "hint": "In the first example, the numbers modulo 42 are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10.\nIn the second example all numbers modulo 42 are 0.\nIn the third example, the numbers modulo 42 are 39, 40, 41, 0, 1, 2, 40, 41, 0 and 1. There are 6 distinct numbers.", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Modulo", "background": "", "description": "给定两个整数 A 和 B，A 模 B 是 A 除以 B 的余数。例如，数字 7、14、27 和 38 模 3 后分别为 1、2、0 和 2。编写一个程序，接受 10 个数字作为输入，并输出这些数字模 42 后的不同数字的个数。", "inputFormat": "输入将包含 10 个非负整数，每个整数小于 1000，每行一个。", "outputFormat": "输出这些数字模 42 后的不同值的个数，输出为一行。", "hint": "在第一个例子中，数字模 42 后为 1、2、3、4、5、6、7、8、9 和 10。  \n在第二个例子中，所有数字模 42 后为 0。  \n在第三个例子中，数字模 42 后为 39、40、41、0、1、2、40、41、0 和 1。有 6 个不同的数字。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4326", "type": "P", "difficulty": 1, "samples": [["1", "3.141593\n2.000000"], ["21", "1385.442360\n882.000000"], ["42", "5541.769441\n3528.000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["数学", "2006", "Special Judge", "COCI（克罗地亚）", "平面几何"], "title": "[COCI 2006/2007 #1] Herman", "background": "", "description": "The 19th century German mathematician Hermann Minkowski investigated a non-Euclidian geometry, called the taxicab geometry. In taxicab geometry the distance between two points T1(x1, y1) and T2(x2, y2) is defined as:\nD(T1,T2) = |x1 - x2| + |y1 - y2|\nAll other definitions are the same as in Euclidian geometry, including that of a circle:\nA circle is the set of all points in a plane at a fixed distance (the radius) from a fixed point (the centre of the circle).\nWe are interested in the difference of the areas of two circles with radius R, one of which is in normal (Euclidian) geometry, and the other in taxicab geometry. The burden of solving this difficult problem has fallen onto you.", "inputFormat": "The first and only line of input will contain the radius R, an integer smaller than or equal to 10000.", "outputFormat": "On the first line you should output the area of a circle with radius R in normal (Euclidian) geometry.\nOn the second line you should output the area of a circle with radius R in taxicab geometry.\nNote: Outputs within ±0.0001 of the official solution will be accepted.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Herman", "background": "", "description": "The 19th century German mathematician Hermann Minkowski investigated a non-Euclidian geometry, called the taxicab geometry. In taxicab geometry the distance between two points T1(x1, y1) and T2(x2, y2) is defined as:\nD(T1,T2) = |x1 - x2| + |y1 - y2|\nAll other definitions are the same as in Euclidian geometry, including that of a circle:\nA circle is the set of all points in a plane at a fixed distance (the radius) from a fixed point (the centre of the circle).\nWe are interested in the difference of the areas of two circles with radius R, one of which is in normal (Euclidian) geometry, and the other in taxicab geometry. The burden of solving this difficult problem has fallen onto you.", "inputFormat": "The first and only line of input will contain the radius R, an integer smaller than or equal to 10000.", "outputFormat": "On the first line you should output the area of a circle with radius R in normal (Euclidian) geometry.\nOn the second line you should output the area of a circle with radius R in taxicab geometry.\nNote: Outputs within ±0.0001 of the official solution will be accepted.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Herman", "background": "", "description": "19世纪的德国数学家赫尔曼·闵可夫斯基(Hermann Minkowski)研究了一种名为出租车几何学的非欧几何。\n在出租车几何里$T_1(x_1,y_1)$ $T_2(x_2,y_2)$两点之间的距离被定义为$dis(T_1,T_2)=|x_1-x_2|+|y_1-y_2|$(曼哈顿距离)。\n其他定义均与欧几里得几何相同。  \n例如圆的定义：在同一平面内，到定点(圆心)的距离等于定长(半径)的点的集合。\n\n我们对欧几里得几何与出租车几何两种定义下半径为$R$的圆的面积很感兴趣。解决这个问题的重担就落在你身上了。", "inputFormat": "仅有一行为圆的半径$R$。 $(R \\leq 10000)$", "outputFormat": "第一行输出欧几里得几何下半径为$R$的圆的面积，第二行输出出租车几何下半径为$R$的圆的面积。\n\n注意：你的输出与标准答案绝对误差不超过$0.0001$将会被认为正确", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4327", "type": "P", "difficulty": 1, "samples": [["A", "..#..\n.#.#.\n#.A.#\n.#.#.\n..#.."], ["DOG", "..#...#...*..\n.#.#.#.#.*.*.\n#.D.#.O.*.G.*\n.#.#.#.#.*.*.\n..#...#...*.."], ["ABCD", "..#...#...*...#..\n.#.#.#.#.*.*.#.#.\n#.A.#.B.*.C.*.D.#\n.#.#.#.#.*.*.#.#.\n..#...#...*...#.."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["模拟", "字符串", "2006", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #1] Okviri", "background": "", "description": "“Peter Pan frames” are a way of decorating text in which every character is framed by a diamond shaped frame, with frames of neigbhouring characters interleaving. A Peter Pan frame for one letter looks like this ('X' is the letter we are framing):\n```\n..#..\n.#.#.\n#.X.#\n.#.#.\n..#..\n```\nHowever, such a framing would be somewhat dull so we'll frame every third letter using a “Wendyframe”. A Wendy frame looks like this:\n\n```\n..*..\n.*.*.\n*.X.*\n.*.*.\n..*..\n```\nWhen a Wendy frame interleaves with a Peter Pan frame, the Wendy frame (being much nicer) is put on top. For an example of the interleaving check the sample cases.", "inputFormat": "The first and only line of input will contain at most 15 capital letters of the English alphabet.", "outputFormat": "Output the word written using Peter Pan and Wendy frames on 5 lines.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Okviri", "background": "", "description": "“Peter Pan frames” are a way of decorating text in which every character is framed by a diamond shaped frame, with frames of neigbhouring characters interleaving. A Peter Pan frame for one letter looks like this ('X' is the letter we are framing):\n```\n..#..\n.#.#.\n#.X.#\n.#.#.\n..#..\n```\nHowever, such a framing would be somewhat dull so we'll frame every third letter using a “Wendyframe”. A Wendy frame looks like this:\n\n```\n..*..\n.*.*.\n*.X.*\n.*.*.\n..*..\n```\nWhen a Wendy frame interleaves with a Peter Pan frame, the Wendy frame (being much nicer) is put on top. For an example of the interleaving check the sample cases.", "inputFormat": "The first and only line of input will contain at most 15 capital letters of the English alphabet.", "outputFormat": "Output the word written using Peter Pan and Wendy frames on 5 lines.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Okviri", "background": null, "description": "“彼得·潘框架”是一种装饰文字，每一个字母都是由一个菱形框架。一个彼得·潘框架看起来像这样（`x` 是字母，`#` 是框架）：\n```\n..#..\n.#.#.\n#.X.#\n.#.#.\n..#..\n```\n然而，只是一个框架会有些沉闷，所以我们每遇到三个字母会把第三个字母用温迪框架把它框起来。温迪框架看起来像这样：\n```\n..*..\n.*.*.\n*.X.*\n.*.*.\n..*..\n```\n当温迪和彼得·潘的框架重叠时，温迪框架覆盖在上面。 （见样例 3）", "inputFormat": "一行由英文大写字母组成的长度不超过 15 字符的字符串。", "outputFormat": "输出使用彼得·潘和温迪框架写成的 5 行字符串。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4328", "type": "P", "difficulty": 3, "samples": [["3 3\nD.*\n...\n.S.", "3"], ["3 3\nD.*\n...\n..S", "KAKTUS"], ["3 6\nD...*.\n.X.X..\n....S.", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2006", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #1] Slikar", "background": "", "description": "The evil emperor Cactus has in his possession the Magic Keg and has flooded the Enchanted Forest! The Painter and the three little hedgehogs now have to return to the Beaver's den where they will be safe from the water as quickly as possible!\nThe map of the Enchanted Forest consists of R rows and C columns. Empty fields are represented by '.' characters, flooded fields by '*' and rocks by 'X'. Additionally, the Beaver's den is represented by 'D' and the Painter and the three little hedgehogs are shown as 'S'.\nEvery minute the Painter and the three little hedgehogs can move to 4 neighbouring fields (up, down, left or right). Every minute the flood expands as well so that all empty fields that have at least one common side with a flooded field become flooded as well. Neither water nor the Painter and the three little hedgehogs can pass through rocks. Naturally, the Painter and the three little hedgehogs cannot pass through flooded fields, and water cannot flood the Beaver's den.\nWrite a program that will, given a map of the Enchanted Forest, output the shortest time needed for the Painter and the three little hedgehogs to safely reach the Beaver's den.\nNote: The Painter and the three little hedgehogs cannot move into a field that is about to be flooded (in the same minute).", "inputFormat": "The first line of input will contain two integers, R and C, smaller than or equal to 50.\nThe following R lines will each contain C characters ('.', '*', 'X', 'D' or 'S'). The map will contain exactly one 'D' character and exactly one 'S' character.", "outputFormat": "Output the shortest possible time needed for the Painter and the three little hedgehogs to safely reach the Beaver's den. If this is impossible output the word “KAKTUS” on a line by itself.", "hint": "Clarification of the second sample test: The best they can do is to go along the lower border and then the left border, and get flooded one minute before reaching the den.", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Slikar", "background": "", "description": "The evil emperor Cactus has in his possession the Magic Keg and has flooded the Enchanted Forest! The Painter and the three little hedgehogs now have to return to the Beaver's den where they will be safe from the water as quickly as possible!\nThe map of the Enchanted Forest consists of R rows and C columns. Empty fields are represented by '.' characters, flooded fields by '*' and rocks by 'X'. Additionally, the Beaver's den is represented by 'D' and the Painter and the three little hedgehogs are shown as 'S'.\nEvery minute the Painter and the three little hedgehogs can move to 4 neighbouring fields (up, down, left or right). Every minute the flood expands as well so that all empty fields that have at least one common side with a flooded field become flooded as well. Neither water nor the Painter and the three little hedgehogs can pass through rocks. Naturally, the Painter and the three little hedgehogs cannot pass through flooded fields, and water cannot flood the Beaver's den.\nWrite a program that will, given a map of the Enchanted Forest, output the shortest time needed for the Painter and the three little hedgehogs to safely reach the Beaver's den.\nNote: The Painter and the three little hedgehogs cannot move into a field that is about to be flooded (in the same minute).", "inputFormat": "The first line of input will contain two integers, R and C, smaller than or equal to 50.\nThe following R lines will each contain C characters ('.', '*', 'X', 'D' or 'S'). The map will contain exactly one 'D' character and exactly one 'S' character.", "outputFormat": "Output the shortest possible time needed for the Painter and the three little hedgehogs to safely reach the Beaver's den. If this is impossible output the word “KAKTUS” on a line by itself.", "hint": "Clarification of the second sample test: The best they can do is to go along the lower border and then the left border, and get flooded one minute before reaching the den.", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Slikar", "background": "", "description": "邪恶的皇帝 Cactus 拥有魔法酒桶，并且已经淹没了魔法森林！画家和三只小刺猬现在必须尽快返回到海狸的巢穴，以免被水淹没！魔法森林的地图由 R 行 C 列组成。空地用字符 '.' 表示，淹没的区域用 '*' 表示，岩石用 'X' 表示。此外，海狸的巢穴用 'D' 表示，画家和三只小刺猬用 'S' 表示。每分钟，画家和三只小刺猬可以移动到四个相邻的区域（上、下、左或右）。每分钟，洪水也会扩散，使得所有与淹没区域至少有一个公共边的空地也被淹没。水和画家及三只小刺猬都不能穿过岩石。当然，画家和三只小刺猬不能穿过淹没的区域，水也不能淹没海狸的巢穴。编写一个程序，给定魔法森林的地图，输出画家和三只小刺猬安全到达海狸巢穴所需的最短时间。注意：画家和三只小刺猬不能移动到即将在同一分钟被淹没的区域。", "inputFormat": "输入的第一行包含两个整数 R 和 C，均小于或等于 50。接下来的 R 行每行包含 C 个字符（'.'，'*'，'X'，'D' 或 'S'）。地图将包含恰好一个 'D' 字符和恰好一个 'S' 字符。", "outputFormat": "输出画家和三只小刺猬安全到达海狸巢穴所需的最短时间。如果这不可能，输出单独一行“KAKTUS”。", "hint": "对第二个样例测试的说明：他们能做的最好就是沿着下边界走，然后沿着左边界走，并在到达巢穴前一分钟被淹没。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4329", "type": "P", "difficulty": 4, "samples": [["2\n100 100\n50 50", "50.000000"], ["2\n0 50\n50 0", "25.00000"], ["3\n25 60 100\n13 0 50\n12 70 90", "9.10000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["搜索", "2006", "Special Judge", "图论建模", "二分图", "费用流", "COCI（克罗地亚）", "状压 DP"], "title": "[COCI 2006/2007 #1] Bond", "background": "", "description": "Everyone knows of the secret agent double-oh-seven, the popular Bond (James Bond). A lesser known fact is that he actually did not perform most of his missions by himself; they were instead done by his cousins, Jimmy Bonds. Bond (James Bond) has grown weary of having to distribute assign missions to Jimmy Bonds every time he gets new missions so he has asked you to help him out.\nEvery month Bond (James Bond) receives a list of missions. Using his detailed intelligence from past missions, for every mission and for every Jimmy Bond he calculates the probability of that particular mission being successfully completed by that particular Jimmy Bond. Your program should process that data and find the arrangement that will result in the greatest probability that all missions are completed successfully.\nNote: the probability of all missions being completed successfully is equal to the product of the probabilities of the single missions being completed successfully.", "inputFormat": "The first line will contain an integer N, the number of Jimmy Bonds and missions (1 ≤ N ≤ 20).\nThe following N lines will contain N integers between 0 and 100, inclusive. The j-th integer on the ith line is the probability that Jimmy Bond i would successfully complete mission j, given as a percentage.", "outputFormat": "Output the maximum probability of Jimmy Bonds successfully completing all the missions, as a percentage.", "hint": "Clarification of the third example: If Jimmy bond 1 is assigned the 3rd mission, Jimmy Bond 2 the 1st mission and Jimmy Bond 3 the 2nd mission the probability is: 1.0 * 0.13 * 0.7 = 0.091 = 9.1%. All other arrangements give a smaller probability of success.\nNote: Outputs within ±0.000001 of the official solution will be accepted.", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Bond", "background": "", "description": "Everyone knows of the secret agent double-oh-seven, the popular Bond (James Bond). A lesser known fact is that he actually did not perform most of his missions by himself; they were instead done by his cousins, Jimmy Bonds. Bond (James Bond) has grown weary of having to distribute assign missions to Jimmy Bonds every time he gets new missions so he has asked you to help him out.\nEvery month Bond (James Bond) receives a list of missions. Using his detailed intelligence from past missions, for every mission and for every Jimmy Bond he calculates the probability of that particular mission being successfully completed by that particular Jimmy Bond. Your program should process that data and find the arrangement that will result in the greatest probability that all missions are completed successfully.\nNote: the probability of all missions being completed successfully is equal to the product of the probabilities of the single missions being completed successfully.", "inputFormat": "The first line will contain an integer N, the number of Jimmy Bonds and missions (1 ≤ N ≤ 20).\nThe following N lines will contain N integers between 0 and 100, inclusive. The j-th integer on the ith line is the probability that Jimmy Bond i would successfully complete mission j, given as a percentage.", "outputFormat": "Output the maximum probability of Jimmy Bonds successfully completing all the missions, as a percentage.", "hint": "Clarification of the third example: If Jimmy bond 1 is assigned the 3rd mission, Jimmy Bond 2 the 1st mission and Jimmy Bond 3 the 2nd mission the probability is: 1.0 * 0.13 * 0.7 = 0.091 = 9.1%. All other arrangements give a smaller probability of success.\nNote: Outputs within ±0.000001 of the official solution will be accepted.", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Bond", "background": null, "description": "每个人都知道特工 007，著名的邦德（詹姆斯·邦德）。一个鲜为人知的事实是，他实际上并没有亲自完成大多数任务；这些任务是由他的表亲，吉米·邦德们完成的。邦德（詹姆斯·邦德）已经厌倦了每次接到新任务时都要分配任务给吉米·邦德们，所以他请求你帮助他。每个月，邦德（詹姆斯·邦德）都会收到一份任务清单。利用他从过去任务中获得的详细情报，对于每个任务和每个吉米·邦德，他计算出该吉米·邦德成功完成该任务的概率。你的程序应该处理这些数据，并找到一种安排，使得所有任务成功完成的概率最大化。注意：所有任务成功完成的概率等于单个任务成功完成的概率的乘积。", "inputFormat": "第一行包含一个整数 $N$，表示吉米·邦德和任务的数量（$1 \\le N \\le 20$）。接下来的 $N$ 行将包含 $N$ 个介于 $0$ 和 $100$ 之间的整数（包括 $0$ 和 $100$）。第 $i$ 行的第 $j$ 个整数表示吉米·邦德 $i$ 成功完成任务 $j$ 的概率，以百分比表示。", "outputFormat": "输出吉米·邦德成功完成所有任务的最大概率，以百分比表示。", "hint": "第三个例子的说明：如果吉米·邦德 $1$ 被分配第 $3$ 个任务，吉米·邦德 $2$ 被分配第 $1$ 个任务，吉米·邦德 $3$ 被分配第 $2$ 个任务，则概率为：$1.0 \\times 0.13 \\times 0.7 = 0.091 = 9.1\\%$。所有其他安排的成功概率都较小。注意：与官方答案相差不超过 $\\pm 10^{-6}$ 的输出将被接受。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4330", "type": "P", "difficulty": 5, "samples": [["3 6\n101010\n111001\n101001", "3"], ["4 5\n10010\n01010\n10101\n01001", "3"], ["3 3\n101\n111\n100", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2006", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #1] Debug", "background": "", "description": "While debugging a program Mirko noticed that a bug in the program may be linked with the existence of so called square killers in the program memory. The program memory is a matrix composed of R rows and C columns consisting only of zeroes and ones. A square killer is a square submatrix in memory, consisting of more than one character, that, when rotated 180 degrees looks exactly the same. For example, the following matrix contains 3 square killers:\n\n![](https://cdn.luogu.com.cn/upload/pic/15764.png)\n\nMirko is wondering if there is a connection between the size of the largest square killer and the bug in the program. Help Mirko by writing a program that, given the layout of the memory, outputs the size of the largest square killer. The size of the square killer is the number of rows (or columns) that the killer consists of. In the example above the killer sizes are 2, 2 and 3, respectively.", "inputFormat": "The first will contain two integers, R and C, smaller than or equal to 300.\nThe next R lines will each contain C characters ('0' or '1') with no spaces.", "outputFormat": "Output the size of the largest killer on a single line, or output -1 if there are no square killers.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Debug", "background": "", "description": "While debugging a program Mirko noticed that a bug in the program may be linked with the existence of so called square killers in the program memory. The program memory is a matrix composed of R rows and C columns consisting only of zeroes and ones. A square killer is a square submatrix in memory, consisting of more than one character, that, when rotated 180 degrees looks exactly the same. For example, the following matrix contains 3 square killers:\n\n![](https://cdn.luogu.com.cn/upload/pic/15764.png)\n\nMirko is wondering if there is a connection between the size of the largest square killer and the bug in the program. Help Mirko by writing a program that, given the layout of the memory, outputs the size of the largest square killer. The size of the square killer is the number of rows (or columns) that the killer consists of. In the example above the killer sizes are 2, 2 and 3, respectively.", "inputFormat": "The first will contain two integers, R and C, smaller than or equal to 300.\nThe next R lines will each contain C characters ('0' or '1') with no spaces.", "outputFormat": "Output the size of the largest killer on a single line, or output -1 if there are no square killers.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Debug", "background": "", "description": "在调试程序时，Mirko 注意到程序中的一个错误可能与程序内存中存在的所谓“方形杀手”有关。程序内存是一个由 R 行 C 列组成的矩阵，仅包含 0 和 1。一个“方形杀手”是内存中的一个方形子矩阵，由多个字符组成，当旋转 180 度时看起来完全相同。例如，下面的矩阵包含 3 个“方形杀手”：\n\n![](https://cdn.luogu.com.cn/upload/pic/15764.png)\n\nMirko 想知道最大“方形杀手”的大小与程序中的错误是否存在关联。请帮助 Mirko 编写一个程序，给定内存的布局，输出最大“方形杀手”的大小。“方形杀手”的大小是指其包含的行数（或列数）。在上面的例子中，“方形杀手”的大小分别为 2、2 和 3。", "inputFormat": "第一行包含两个整数 R 和 C，均小于或等于 300。接下来的 R 行每行包含 C 个字符（'0' 或 '1'），没有空格。", "outputFormat": "输出最大“方形杀手”的大小，单独一行；如果没有“方形杀手”，则输出 -1。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4331", "type": "P", "difficulty": 6, "samples": [["7\n9\n4\n8\n20\n14\n15\n18", "13\n6\n7\n8\n13\n14\n15\n18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2004", "线段树", "Special Judge", "可并堆", "BalticOI（波罗的海）", "斜率维护技巧 slope trick"], "title": "[BalticOI 2004] Sequence (Day1)", "background": "", "description": "给定一个序列 $t_1,t_2,\\dots,t_n$，求出一个递增序列 $z_1,z_2,\\dots,z_n$，使得序列 $t_i$ 和 $z_i$ 的各项之差的绝对值之和 $|t_1-z_1|+|t_2-z_2|+\\dots+|t_n-z_n|$ 最小。", "inputFormat": "输入文件的第一行包含一个整数 $n$。\n\n接下来 $n$ 行，每行包含一个整数，表示给定的序列 $t_i$。", "outputFormat": "输出文件的第一行应当包含最小的各项之差的绝对值之和。\n\n接下来 $n$ 行，每行应当包含一个整数，表示所求的序列 $z_i$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 10^6$，$0\\le t_i\\le 2\\times 10^9$。\n\n#### 说明\n\n译自 [BalticOI 2004 Day1 C Sequence](https://boi.cses.fi/files/boi2004_day1.pdf)。\n\n感谢 @TimeTraveller 提供的 SPJ！", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2004] Sequence (Day1)", "background": "", "description": "Given a sequence $t_1, t_2, \\dots, t_n$, find an increasing sequence $z_1, z_2, \\dots, z_n$ such that the sum of absolute differences $|t_1 - z_1| + |t_2 - z_2| + \\dots + |t_n - z_n|$ is minimized.", "inputFormat": "The first line contains an integer $n$.\nThe next $n$ lines each contain an integer, representing the given sequence values $t_i$.", "outputFormat": "The first line should contain the minimum sum of absolute differences.\nThe next $n$ lines should each contain an integer, representing the sequence values $z_i$.", "hint": "#### Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^6$, $0 \\le t_i \\le 2 \\times 10^9$.\n\n#### Notes\n\nTranslated from [BalticOI 2004 Day1 C Sequence](https://boi.cses.fi/files/boi2004_day1.pdf).\nThanks to @TimeTraveller for providing the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2004] Sequence (Day1)", "background": "", "description": "给定一个序列 $t_1,t_2,\\dots,t_n$，求出一个递增序列 $z_1,z_2,\\dots,z_n$，使得序列 $t_i$ 和 $z_i$ 的各项之差的绝对值之和 $|t_1-z_1|+|t_2-z_2|+\\dots+|t_n-z_n|$ 最小。", "inputFormat": "输入文件的第一行包含一个整数 $n$。\n\n接下来 $n$ 行，每行包含一个整数，表示给定的序列 $t_i$。", "outputFormat": "输出文件的第一行应当包含最小的各项之差的绝对值之和。\n\n接下来 $n$ 行，每行应当包含一个整数，表示所求的序列 $z_i$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 10^6$，$0\\le t_i\\le 2\\times 10^9$。\n\n#### 说明\n\n译自 [BalticOI 2004 Day1 C Sequence](https://boi.cses.fi/files/boi2004_day1.pdf)。\n\n感谢 @TimeTraveller 提供的 SPJ！", "locale": "zh-CN"}}}
{"pid": "P4332", "type": "P", "difficulty": 6, "samples": [["3\n2 3 4\n5 6 7\n8 9 10\n0 0 0 0 1 1 1\n5\n4\n4\n5\n6\n8\n", "1\n0\n0\n1\n1\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["模拟", "2014", "线段树", "各省省选", "上海", "O2优化", "分治", "树链剖分", "动态树 LCT"], "title": "[SHOI2014] 三叉神经树", "background": "", "description": "计算神经学作为新兴的交叉学科近些年来一直是学术界的热点。一种叫做 SHOI 的神经组织因为其和近日发现的化合物 SHTSC 的密切联系引起了人们的极大关注。\n\nSHOI 组织由若干个 SHOI 细胞构成，SHOI 细胞之间形成严密的树形结构。每个 SHOI 细胞都有且只有一个输出端,被称为轴突,除了一个特殊的、被称为根细胞的 SHOI 细胞的输出作为整个组织的输出以外,其余细胞的轴突均连向其上级 SHOI 细胞；并且有且只有三个接收端,被称为树突,从其下级细胞或者其它神经组织那里接收信息。SHOI 细胞的信号机制较为简单,仅有 $0$和 $1$ 两种。每个 SHOI 细胞根据三个输入端中 $0$和 $1$ 信号的多寡输出较多的那一种。\n\n现在给出了一段 SHOI 组织的信息，以及外部神经组织的输入变化情况。请你模拟 SHOI 组织的输出结果。", "inputFormat": "输入的第一行包含一个整数 $n$。表示 SHOI 组织的总细胞个数。SHOI 细胞由 $1\\sim n$ 编号,编号为 $1$ 的是根细胞。\n\n从第二行开始的 $n$ 行,每行三个整数 $x_1, x_2, x_3$，分别表示编号为 $1\\sim n$ 的 SHOI 细胞的树突连接。$1 < x_i \\leq n$ 表示连向编号为 $x_i$ 的细胞的轴突, $n < x_i \\leq 3n+1$ 表示连向编号为 $x_i$ 的外界输入。输入数据保证给出的 SHOI 组织是合法的，且所有的 $x_i$ 两两不同。\n\n接下来一行包含 $2n+1$ 个整数（$0$ 或者 $1$），表示初始时的外界输入。\n\n第 $n+3$ 行有一个整数 $q$，表示总操作数。\n\n之后 $q$ 行，每行一个整数 $x$，表示编号为 $x$ 的外界输入发生了变化。", "outputFormat": "输出共 $q$ 行，每行一个整数，对应第 $i$ 次外界输入变化后的根细胞的输出。", "hint": "- 对于 $10 \\%$ 的数据，满足 $1\\le n \\leq 10^3$，$ 1\\le q \\leq 10^3$。\n- 对于 $30 \\%$ 的数据，满足 $1\\le n \\leq 10^5$，$ 1\\le q \\leq 10^5$。\n- 对于 $100 \\%$ 的数据，满足 $1\\le n \\leq 5\\times 10^5$，$ 1\\le q \\leq 5\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2014] Trinary Neural Tree", "background": "", "description": "Computational neuroscience, as an emerging interdisciplinary field, has been a research hotspot in recent years. A kind of neural tissue called SHOI has attracted great attention because of its close relationship with a recently discovered compound, SHTSC.\n\nA SHOI tissue consists of several SHOI cells forming a strict tree structure. Each SHOI cell has exactly one output terminal, called an axon. Except for a special SHOI cell called the root cell whose output serves as the output of the entire tissue, the axons of all other cells connect to their parent SHOI cell. Each cell also has exactly three input terminals, called dendrites, which receive information from its child cells or from other neural tissues. The signaling mechanism of SHOI cells is simple, with only $0$ and $1$. Each SHOI cell outputs the majority value among the three input signals, i.e., whichever of $0$ or $1$ appears more times among its three inputs.\n\nYou are given the structure of a SHOI tissue and the changes of external neural inputs. Please simulate the output of the SHOI tissue.", "inputFormat": "- The first line contains an integer $n$, the total number of SHOI cells. Cells are numbered $1 \\sim n$, and cell $1$ is the root cell.\n- The next $n$ lines each contain three integers $x_1, x_2, x_3$, describing the dendrite connections of cells $1 \\sim n$, respectively. If $1 < x_i \\leq n$, it connects to the axon of cell $x_i$. If $n < x_i \\leq 3n+1$, it connects to the external input with index $x_i$. The input guarantees that the given SHOI tissue is valid, and for each cell the three $x_i$ are pairwise distinct.\n- The next line contains $2n+1$ integers (each $0$ or $1$), giving the initial values of the external inputs in the order of indices $n+1, n+2, \\dots, 3n+1$.\n- The next line contains an integer $q$, the number of operations.\n- The next $q$ lines each contain one integer $x$, indicating that the external input with index $x$ (where $n < x \\leq 3n+1$) toggles its value.", "outputFormat": "Output $q$ lines. For the $i$-th change of an external input, print one integer: the output of the root cell after this change.", "hint": "- For $10 \\%$ of the testdata, $1 \\leq n \\leq 10^3$, $1 \\leq q \\leq 10^3$.\n- For $30 \\%$ of the testdata, $1 \\leq n \\leq 10^5$, $1 \\leq q \\leq 10^5$.\n- For $100 \\%$ of the testdata, $1 \\leq n \\leq 5 \\times 10^5$, $1 \\leq q \\leq 5 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2014] 三叉神经树", "background": "", "description": "计算神经学作为新兴的交叉学科近些年来一直是学术界的热点。一种叫做 SHOI 的神经组织因为其和近日发现的化合物 SHTSC 的密切联系引起了人们的极大关注。\n\nSHOI 组织由若干个 SHOI 细胞构成，SHOI 细胞之间形成严密的树形结构。每个 SHOI 细胞都有且只有一个输出端,被称为轴突,除了一个特殊的、被称为根细胞的 SHOI 细胞的输出作为整个组织的输出以外,其余细胞的轴突均连向其上级 SHOI 细胞；并且有且只有三个接收端,被称为树突,从其下级细胞或者其它神经组织那里接收信息。SHOI 细胞的信号机制较为简单,仅有 $0$和 $1$ 两种。每个 SHOI 细胞根据三个输入端中 $0$和 $1$ 信号的多寡输出较多的那一种。\n\n现在给出了一段 SHOI 组织的信息，以及外部神经组织的输入变化情况。请你模拟 SHOI 组织的输出结果。", "inputFormat": "输入的第一行包含一个整数 $n$。表示 SHOI 组织的总细胞个数。SHOI 细胞由 $1\\sim n$ 编号,编号为 $1$ 的是根细胞。\n\n从第二行开始的 $n$ 行,每行三个整数 $x_1, x_2, x_3$，分别表示编号为 $1\\sim n$ 的 SHOI 细胞的树突连接。$1 < x_i \\leq n$ 表示连向编号为 $x_i$ 的细胞的轴突, $n < x_i \\leq 3n+1$ 表示连向编号为 $x_i$ 的外界输入。输入数据保证给出的 SHOI 组织是合法的，且所有的 $x_i$ 两两不同。\n\n接下来一行包含 $2n+1$ 个整数（$0$ 或者 $1$），表示初始时的外界输入。\n\n第 $n+3$ 行有一个整数 $q$，表示总操作数。\n\n之后 $q$ 行，每行一个整数 $x$，表示编号为 $x$ 的外界输入发生了变化。", "outputFormat": "输出共 $q$ 行，每行一个整数，对应第 $i$ 次外界输入变化后的根细胞的输出。", "hint": "- 对于 $10 \\%$ 的数据，满足 $1\\le n \\leq 10^3$，$ 1\\le q \\leq 10^3$。\n- 对于 $30 \\%$ 的数据，满足 $1\\le n \\leq 10^5$，$ 1\\le q \\leq 10^5$。\n- 对于 $100 \\%$ 的数据，满足 $1\\le n \\leq 5\\times 10^5$，$ 1\\le q \\leq 5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4333", "type": "P", "difficulty": 6, "samples": [["3\n0 3\n1 5\n1 7", "0"], ["5\n0 8626\n1 29255\n2 21486\n2 26193\n1 22439", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "各省省选", "江苏"], "title": "[JSOI2010] 游戏", "background": null, "description": "JSOI 集训队的小 L，小 H，小 X 在紧张的训练之余，总是喜欢玩一个称之为“取数”的游戏来调节自己：\n\n这是一个人玩的游戏，仅仅需要一张白纸和一支笔。玩家在纸上随机写下一行共 $n$ 个整数，形成一个数列，就可以开始游戏了。\n\n每次玩家从原数列最左端或最右端选择一个数，将它从原数列中划去，并写在下一行。当原数列的数全部被划去后，在第二行就出现了一个新的长度为 $n$ 的数列，记为 $S$。将按照如下方式计算数列 $S$ 的分数 $P$：\n\n$$P=S_1\\times 5^0+S_2\\times 5^1+\\cdots+S_n\\times 5^{n-1}$$\n\n算出分数 $P$ 后，将其转为二进制表示，如果末三位数字是  $011$ 的话，玩家就取得了游戏的胜利，否则就失败了。\n\n在玩了很多次这个游戏后，小 L，小 H，小 X 发现一个重要的事实：对于某些随机写下的数列，是无论如何也无法取得游戏胜利的，这样的数列被称为“刁列”，其它的数列则被\n称为“良列”。\n\n这个游戏虽然趣味性极强，但有一个弊端：每次游戏前需要花很多时间来写出这个随机数列，这一点一直深深困扰着小 L，小 H 和小 X。\n\n直到在今年省选前的那天晚上，小 L 想出了一个惊为天人的创意，一举攻克了这个难题：他们先在纸上画出一颗庞大的无根树（共 $m$ 个结点），每个结点上写下一个整数。当想要玩游戏时，玩家只需随便选择两个结点，通过找出连接这两个结点的那条唯一的路径，将路径上所有结点（包括两个端点）上标注的整数按路径的顺序列出来，就得到了一个数列，然后就可以在这个数列上玩游戏了。如果选择的两个端点分别是树上结点 $v_i$ 和结点 $v_j$，得到的数列就简记为 $i\\sim j$。当然，如前所述，$i\\sim j$ 这个数列也有“良列”和“刁列”两种可能。\n\n他们发现这样改进以后真的方便了很多！不仅如此，还给游戏带来了一些新的趣味。比如小 X 就声称他发现了一个重要的规律：数列的属性是具有传递性的，即：对于任意互不相同的 $i,j,k$ 有：\n\n- 如果 $i\\sim j$ 是良列，$j\\sim k$ 是良列，则 $i\\sim k$ 是良列。\n\n- 如果 $i\\sim j$ 是刁列且 $j\\sim k$ 是刁列，则 $i\\sim k$ 是刁列。\n\n这个结论出奇地优美，但很快就被小 H 找到了反例，这让小 X 心情沮丧。小 L 为了安慰小 X，说：不如我们来看看你这个结论在多少情况下是成立的吧。\n\n小 X 振作了起来，大家一起投入了繁重的工作中。他们要找出存在多少个三元组 $(i,j,k)$，其中 $i<j<k$，使得 $i,j,k$ 满足小 X 发现的传递性结论。", "inputFormat": "第一行一个整数 $m$，代表无根树的节点个数。\n\n接下来 $m$ 行，每行两个整数 $f_i,x_i$，其中 $f_i<i$。$f_i$ 表示节点 $v_i$ 的父节点编号，如果 $f_i=0$ 则该节点为根，$x_i$ 表示节点 $v_i$ 上写的数。", "outputFormat": "一行一个整数，表示答案。", "hint": "### 数据范围\n\n对于 $10\\%$ 的数据，$1\\leq m\\leq 5$。\n\n对于 $30\\%$ 的数据，$1\\leq m\\leq 100$。\n\n对于 $50\\%$ 的数据，$1\\leq m\\leq 10^3$。\n\n对于 $100\\%$ 的数据，$1\\leq m\\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2010] 游戏", "background": null, "description": "JSOI 集训队的小 L，小 H，小 X 在紧张的训练之余，总是喜欢玩一个称之为“取数”的游戏来调节自己：\n\n这是一个人玩的游戏，仅仅需要一张白纸和一支笔。玩家在纸上随机写下一行共 $n$ 个整数，形成一个数列，就可以开始游戏了。\n\n每次玩家从原数列最左端或最右端选择一个数，将它从原数列中划去，并写在下一行。当原数列的数全部被划去后，在第二行就出现了一个新的长度为 $n$ 的数列，记为 $S$。将按照如下方式计算数列 $S$ 的分数 $P$：\n\n$$P=S_1\\times 5^0+S_2\\times 5^1+\\cdots+S_n\\times 5^{n-1}$$\n\n算出分数 $P$ 后，将其转为二进制表示，如果末三位数字是  $011$ 的话，玩家就取得了游戏的胜利，否则就失败了。\n\n在玩了很多次这个游戏后，小 L，小 H，小 X 发现一个重要的事实：对于某些随机写下的数列，是无论如何也无法取得游戏胜利的，这样的数列被称为“刁列”，其它的数列则被\n称为“良列”。\n\n这个游戏虽然趣味性极强，但有一个弊端：每次游戏前需要花很多时间来写出这个随机数列，这一点一直深深困扰着小 L，小 H 和小 X。\n\n直到在今年省选前的那天晚上，小 L 想出了一个惊为天人的创意，一举攻克了这个难题：他们先在纸上画出一颗庞大的无根树（共 $m$ 个结点），每个结点上写下一个整数。当想要玩游戏时，玩家只需随便选择两个结点，通过找出连接这两个结点的那条唯一的路径，将路径上所有结点（包括两个端点）上标注的整数按路径的顺序列出来，就得到了一个数列，然后就可以在这个数列上玩游戏了。如果选择的两个端点分别是树上结点 $v_i$ 和结点 $v_j$，得到的数列就简记为 $i\\sim j$。当然，如前所述，$i\\sim j$ 这个数列也有“良列”和“刁列”两种可能。\n\n他们发现这样改进以后真的方便了很多！不仅如此，还给游戏带来了一些新的趣味。比如小 X 就声称他发现了一个重要的规律：数列的属性是具有传递性的，即：对于任意互不相同的 $i,j,k$ 有：\n\n- 如果 $i\\sim j$ 是良列，$j\\sim k$ 是良列，则 $i\\sim k$ 是良列。\n\n- 如果 $i\\sim j$ 是刁列且 $j\\sim k$ 是刁列，则 $i\\sim k$ 是刁列。\n\n这个结论出奇地优美，但很快就被小 H 找到了反例，这让小 X 心情沮丧。小 L 为了安慰小 X，说：不如我们来看看你这个结论在多少情况下是成立的吧。\n\n小 X 振作了起来，大家一起投入了繁重的工作中。他们要找出存在多少个三元组 $(i,j,k)$，其中 $i<j<k$，使得 $i,j,k$ 满足小 X 发现的传递性结论。", "inputFormat": "第一行一个整数 $m$，代表无根树的节点个数。\n\n接下来 $m$ 行，每行两个整数 $f_i,x_i$，其中 $f_i<i$。$f_i$ 表示节点 $v_i$ 的父节点编号，如果 $f_i=0$ 则该节点为根，$x_i$ 表示节点 $v_i$ 上写的数。", "outputFormat": "一行一个整数，表示答案。", "hint": "### 数据范围\n\n对于 $10\\%$ 的数据，$1\\leq m\\leq 5$。\n\n对于 $30\\%$ 的数据，$1\\leq m\\leq 100$。\n\n对于 $50\\%$ 的数据，$1\\leq m\\leq 10^3$。\n\n对于 $100\\%$ 的数据，$1\\leq m\\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4334", "type": "P", "difficulty": 6, "samples": [["13 15\n1 2\n2 3\n3 5\n2 4\n4 6\n2 6\n1 4\n1 7\n7 8\n7 9\n7 10\n8 11\n8 12\n9 12\n12 13\n5\n1 5 13 1 2\n1 6 2 1 4\n1 13 6 7 8\n2 13 6 7\n2 13 6 8", "yes\nyes\nyes\nno\nyes"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2007", "COI（克罗地亚）"], "title": "[COI 2007] Policija", "background": null, "description": "为了帮助抓捕逃犯，警方引进了一套新的电脑系统。警察的辖区包含 $N$ 座城市和 $E$ 条双向道路，城市的编号是 $1\\sim N$。\n\n警察常常要抓住那些逃往另一个城市的罪犯。侦查员看着地图，试着确定在哪里设置路障。新的计算机系统要回答以下两种问题：\n\n1. 考虑城市 $A$ 和 $B$，以及连接城市 $G_1$ 和 $G_2$ 的道路。罪犯能否在那条路不通的情况下从 $A$ 逃到 $B$？\n\n2. 考虑三个城市 $A, B, C$。罪犯能否在无法通过 $C$ 的情况下从 $A$ 逃到 $B$？\n\n写一个程序实现上述系统。", "inputFormat": "第一行两个整数 $N, E$（$2\\leq N\\leq 10 ^ 5$，$1\\leq E\\leq 5\\times 10 ^ 5$），表示城市数量和道路数量。\n\n接下来 $E$ 行，每行两个不同的数字 $u, v$，表示编号为 $u, v$ 的城市之间有一条道路。一对城市之间最多只有一条道路。\n\n接下来一行，一个整数 $Q$（$1\\leq Q\\leq 3\\times 10 ^ 5$），表示询问数量。\n\n接下来 $Q$ 行，每行四或五个整数描述一组询问。第一个数表示询问的类型 —— $1$ 或 $2$。\n\n如果询问类型为 $1$，那么在同一行还有四个整数 $A, B, G_1, G_2$。$A, B$ 不同，且 $G_1, G_2$ 之间存在道路。\n\n如果询问类型为 $2$，那么在同一行还有三个整数 $A, B, C$。$A, B, C$ 两两不同。\n\n保证图中每两个点相互连通。", "outputFormat": "对于每组询问，输出 `yes` 或 `no` 表示回答。", "hint": "翻译自 [Croatian Olympiad in Informatics 2007 B Policija](https://hsin.hr/coci/archive/2006_2007/olympiad_tasks.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[COI 2007] Policija", "background": null, "description": "To help capture criminals on the run, the police are introducing a new computer system. The area covered by the police contains $N$ cities and $E$ bidirectional roads connecting them. The cities are labelled $1$ to $N$.\n\nThe police often want to catch criminals trying to get from one city to another. Inspectors, looking at a map, try to determine where to set up barricades and roadblocks. The new computer system should answer the following two types of queries:\n\n1. Consider two cities $A$ and $B$, and a road connecting cities $G_1$ and $G_2$. Can the criminals get from city $A$ to city $B$ if that one road is blocked and the criminals can't use it?\n\n2. Consider three cities $A, B$ and $C$. Can the criminals get from city $A$ to city $B$ if the entire city $C$ is cut off and the criminals can't enter that city?\n\nWrite a program that implements the described system.", "inputFormat": "The first line contains two integers $N$ and $E\\ (2 \\le N \\le 100\\,000, 1 \\le E \\le 500\\,000)$, the number of cities and roads.\n\nEach of the following $E$ lines contains two distinct integers between $1$ and $N$ – the labels of two cities connected by a road. There will be at most one road between any pair of cities.\n\nThe following line contains the integer $Q\\ (1 \\le Q \\le 300\\,000)$, the number of queries the system is being tested on.\n\nEach of the following $Q$ lines contains either four or five integers. The first of these integers is the type of the query – $1$ or $2$.\n\nIf the query is of type $1$, then the same line contains four more integers $A, B, G_1$ and $G_2$ as described earlier. $A$ and $B$ will be different. $G_1$ and $G_2$ will represent an existing road.\n\nIf the query is of type $2$, then the same line contains three more integers $A, B$ and $C$. $A, B$ and $C$ will be distinct integers.\n\nThe test data will be such that it is initially possible to get from each city to every other city.", "outputFormat": "Output the answers to all $Q$ queries, one per line. The answer to a query can be `yes` or `no`.", "hint": "Resource: Croatian Olympiad in Informatics 2007.", "locale": "en"}, "zh-CN": {"title": "[COI 2007] Policija", "background": null, "description": "为了帮助抓捕逃犯，警方引进了一套新的电脑系统。警察的辖区包含 $N$ 座城市和 $E$ 条双向道路，城市的编号是 $1\\sim N$。\n\n警察常常要抓住那些逃往另一个城市的罪犯。侦查员看着地图，试着确定在哪里设置路障。新的计算机系统要回答以下两种问题：\n\n1. 考虑城市 $A$ 和 $B$，以及连接城市 $G_1$ 和 $G_2$ 的道路。罪犯能否在那条路不通的情况下从 $A$ 逃到 $B$？\n\n2. 考虑三个城市 $A, B, C$。罪犯能否在无法通过 $C$ 的情况下从 $A$ 逃到 $B$？\n\n写一个程序实现上述系统。", "inputFormat": "第一行两个整数 $N, E$（$2\\leq N\\leq 10 ^ 5$，$1\\leq E\\leq 5\\times 10 ^ 5$），表示城市数量和道路数量。\n\n接下来 $E$ 行，每行两个不同的数字 $u, v$，表示编号为 $u, v$ 的城市之间有一条道路。一对城市之间最多只有一条道路。\n\n接下来一行，一个整数 $Q$（$1\\leq Q\\leq 3\\times 10 ^ 5$），表示询问数量。\n\n接下来 $Q$ 行，每行四或五个整数描述一组询问。第一个数表示询问的类型 —— $1$ 或 $2$。\n\n如果询问类型为 $1$，那么在同一行还有四个整数 $A, B, G_1, G_2$。$A, B$ 不同，且 $G_1, G_2$ 之间存在道路。\n\n如果询问类型为 $2$，那么在同一行还有三个整数 $A, B, C$。$A, B, C$ 两两不同。\n\n保证图中每两个点相互连通。", "outputFormat": "对于每组询问，输出 `yes` 或 `no` 表示回答。", "hint": "翻译自 [Croatian Olympiad in Informatics 2007 B Policija](https://hsin.hr/coci/archive/2006_2007/olympiad_tasks.pdf)。", "locale": "zh-CN"}}}
{"pid": "P4335", "type": "P", "difficulty": 6, "samples": [["0 2\n", "9 4\n"], ["4 5\n-1 1\n0 -1\n0 1\n1 0\n", "10 16\n"], ["4 50000\n1 1\n-1 -1\n1 -1\n-1 1\n", "2500099997 2500000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2007", "COI（克罗地亚）"], "title": "[COI 2007] Sabor", "background": "", "description": "The president of the political party in power is holding a conference in the party headquarters. Politicians, members of the party, live in a two-dimensional grid, one member in each cell (except in cells containing obstacles). The headquarters are located in cell $(0, 0)$. This is also where the president of the party lives.\n\nPoliticians make steps in one of the four directions (up, down, left, right), moving to one of the four adjacent cells in one step. They can't enter cells with obstacles. The conference will be attended by all party members that can reach headquarters in $S$ steps or less. Each member coming to the conference will take the shortest route to headquarters (or any such route, if there is more than one).\n\nThe president has observed that politicians change their party affiliation with each step they take, becoming a member of the other party (there are only two parties on the political scene).\n\nWrite a program that determines how many politicians come to the conference as members of the party in power, and how many come as members of the opposing party.", "inputFormat": "The first line contains two integers $B$ and $S\\ (0 \\le B \\le 10\\,000, 1 \\le S \\le 10\\,000\\,000)$, the number of obstacles and the largest number of steps from the task description.\n\nEach of the following $B$ lines contains two integers, the coordinates of one obstacle. The absolute value of both coordinates will be less than $1000$.\n\nNo two obstacles will be in the same cell and there will be no obstacle in cell $(0, 0)$.", "outputFormat": "Output two integers on a single line separated by a space, the number of politicians that come to the conference as members of the party in power and the opposing party, respectively.", "hint": "Resource: Croatian Olympiad in Informatics 2007.", "locale": "en", "translations": {"en": {"title": "[COI 2007] Sabor", "background": "", "description": "The president of the political party in power is holding a conference in the party headquarters. Politicians, members of the party, live in a two-dimensional grid, one member in each cell (except in cells containing obstacles). The headquarters are located in cell $(0, 0)$. This is also where the president of the party lives.\n\nPoliticians make steps in one of the four directions (up, down, left, right), moving to one of the four adjacent cells in one step. They can't enter cells with obstacles. The conference will be attended by all party members that can reach headquarters in $S$ steps or less. Each member coming to the conference will take the shortest route to headquarters (or any such route, if there is more than one).\n\nThe president has observed that politicians change their party affiliation with each step they take, becoming a member of the other party (there are only two parties on the political scene).\n\nWrite a program that determines how many politicians come to the conference as members of the party in power, and how many come as members of the opposing party.", "inputFormat": "The first line contains two integers $B$ and $S\\ (0 \\le B \\le 10\\,000, 1 \\le S \\le 10\\,000\\,000)$, the number of obstacles and the largest number of steps from the task description.\n\nEach of the following $B$ lines contains two integers, the coordinates of one obstacle. The absolute value of both coordinates will be less than $1000$.\n\nNo two obstacles will be in the same cell and there will be no obstacle in cell $(0, 0)$.", "outputFormat": "Output two integers on a single line separated by a space, the number of politicians that come to the conference as members of the party in power and the opposing party, respectively.", "hint": "Resource: Croatian Olympiad in Informatics 2007.", "locale": "en"}, "zh-CN": {"title": "[COI 2007] Sabor", "background": "", "description": "执政党的首相正在国会大厦召开会议。议员们分布在一个二维平面的网格上（初始状态下所有议员都属于执政党，包括首相），每个格子里有一位议员（除了有障碍的格子）。国会大厦位于 $(0,0)$，即首相所在的位置。\n\n议员们可以选择上、下、左、右四个方向之一，移动到相邻的格子中。他们不能进入有障碍的格子。只有那些能在 $S$ 步以内到达国会大厦的议员，才能参加会议。每位议员都会选择最短路径前往国会大厦（如果存在多条最短路径，可以任选其一）。\n\n首相注意到，每位议员在移动的过程中，每走一步，其政治立场都会在执政党与反对党之间切换一次（该国实行两党制）。\n请编写一个程序，计算最终能参加会议的议员中，有多少人是执政党成员，有多少人是反对党成员。", "inputFormat": "第一行包含两个整数 $B$ 和 $S$（$0\\leq B\\leq 10 ^ 4$，$1\\leq S\\leq 10^7$），分别表示障碍的数量和议员能移动的最大步数。\n\n接下来 $B$ 行，每行包含两个整数，表示障碍所在格子的横纵坐标。横纵坐标的绝对值均小于 $10^3$。\n\n没有两个障碍位于同一个格子，也没有障碍位于格子 $(0,0)$。\n", "outputFormat": "输出仅一行，包含两个整数，用空格隔开，分别表示执政党议员和反对党议员的人数。", "hint": "翻译自 [Croatian Olympiad in Informatics 2007 C Sabor](https://hsin.hr/coci/archive/2006_2007/olympiad_tasks.pdf)。", "locale": "zh-CN"}}}
{"pid": "P4336", "type": "P", "difficulty": 6, "samples": [["4\n2 3 2 4 2\n5 2 1 3 1 3 2 4 1 4 3\n4 2 1 3 2 4 1 4 2", "17"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "各省省选", "矩阵树定理", "上海", "生成树", "容斥原理"], "title": "[SHOI2016] 黑暗前的幻想乡", "background": "四年一度的幻想乡大选开始了，最近幻想乡最大的问题是很多来历不明的妖怪涌入了幻想乡，扰乱了幻想乡昔日的秩序。但是幻想乡的建制派妖怪（人类）博丽灵梦和八云紫等人整日高谈所有妖怪平等，幻想乡多元化等等，对于幻想乡目前面临的种种大问题却给不出合理的解决方案。\n\n风见幽香是幻想乡里少有的意识到了问题严重性的大妖怪。她这次勇敢地站了出来参加幻想乡大选，提出包括在幻想乡边境建墙（并让人类出钱），大力开展基础设施建设挽回失业率等一系列方案，成为了大选年出人意料的黑马并顺利地当上了幻想乡的大统领。", "description": "幽香上台以后，第一项措施就是要修建幻想乡的公路。幻想乡一共有 $n$ 个城市，之前原来没有任何路。幽香向选民承诺要减税，所以她打算只修 $n-1$ 条公路将这些城市连接起来。但是幻想乡有正好 $n-1$ 个建筑公司，每个建筑公司都想在修路的过程中获得一些好处。虽然这些建筑公司在选举前没有给幽香钱，幽香还是打算和他们搞好关系，因为她还指望他们帮她建墙。所以她打算让每个建筑公司都负责一条路来修。\n\n每个建筑公司都告诉了幽香自己有能力负责修建的路是哪些城市之间的。所以幽香打算 $n - 1$ 条能够连接幻想乡所有城市的边，然后每条边都交给一个能够负责该边的建筑公司修建，并且每个建筑公司都恰好修建一条边。\n\n幽香现在想要知道一共有多少种可能的方案呢？两个方案不同当且仅当它们要么修的边的集合不同，要么边的分配方式不同。", "inputFormat": "第一行包含一个整数 $n$，表示城市个数。\n\n第 $2$ 到第 $n$ 行，第 $(i + 1)$ 行表示 第 $i$ 个建筑公司可以修建的路的列表：以一个非负整数 $m_i$ 开头，表示其可以修建条路的条数；接下来有 $m_i$ 对整数 $u, v$，每对数表示一条边的两个端点。其中不会出现重复的边，也不会出现自环。", "outputFormat": "输出一行一个整数，表示所有可能的方案数对 $10^9+7$ 取模的结果。", "hint": "#### 数据规模与约定\n\n+ 对于 $20\\%$ 的测试点，$n \\le 5$。\n+ 对于 $50\\%$ 的测试点，$n \\le 8$。\n+ 对于 $60\\%$ 的测试点，$n \\le 10$。\n+ 对于 $100\\%$ 的测试点，$2 \\leq n \\le 17$，$0 \\leq m_i \\leq \\frac{n(n - 1)}{2}$，$1 \\leq u, v \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2016] Gensokyo Before the Dark", "background": "The quadrennial Gensokyo election has begun. Recently, the biggest problem in Gensokyo is that many mysterious youkai have flooded in, disrupting its former order. However, the establishment youkai (and humans) such as Reimu Hakurei and Yukari Yakumo keep talking about equality for all youkai and diversity in Gensokyo, while offering no reasonable solutions to the pressing issues Gensokyo now faces.\n\nYuuka Kazami is one of the few great youkai in Gensokyo who realized the severity of the problem. She bravely stepped up to run in the election, proposing a series of plans such as building a wall on Gensokyo’s border (and making humans pay for it) and vigorously promoting infrastructure to reduce unemployment. She became the unexpected dark horse of the election year and successfully became the leader of Gensokyo.", "description": "After taking office, Yuuka’s first measure is to build Gensokyo’s highways. There are $n$ cities in Gensokyo, and initially there are no roads. Yuuka promised voters to cut taxes, so she plans to build only $n - 1$ roads to connect all these cities. There are exactly $n - 1$ construction companies, and each company wants to gain some benefits during road construction. Although these companies did not give Yuuka money before the election, she still intends to maintain good relations with them, since she is counting on them to help her build the wall. So she plans to have each construction company be responsible for exactly one road.\n\nEach construction company has told Yuuka between which pairs of cities it is capable of building a road. Yuuka will choose $n - 1$ edges that can connect all cities in Gensokyo, then assign each edge to a construction company that can build it, with each company building exactly one edge.\n\nYuuka now wants to know how many possible schemes there are in total. Two schemes are different if and only if either the set of edges to be built is different, or the assignment of companies to edges is different.", "inputFormat": "The first line contains an integer $n$, the number of cities.\n\nLines $2$ through $n$: line $i + 1$ describes the list of roads that the $i$-th construction company can build. It starts with a non-negative integer $m_i$, the number of roads it can build; then follow $m_i$ pairs of integers $u, v$, each pair denoting the endpoints of an edge. Within a company’s list, there are no duplicate edges and no self-loops.", "outputFormat": "Output a single integer on one line: the number of all possible schemes modulo $10^9+7$.", "hint": "Constraints\n\n- For $20\\%$ of the test points, $n \\le 5$.\n- For $50\\%$ of the test points, $n \\le 8$.\n- For $60\\%$ of the test points, $n \\le 10$.\n- For $100\\%$ of the test points, $2 \\leq n \\le 17$, $0 \\leq m_i \\leq \\frac{n(n - 1)}{2}$, $1 \\leq u, v \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2016] 黑暗前的幻想乡", "background": "四年一度的幻想乡大选开始了，最近幻想乡最大的问题是很多来历不明的妖怪涌入了幻想乡，扰乱了幻想乡昔日的秩序。但是幻想乡的建制派妖怪（人类）博丽灵梦和八云紫等人整日高谈所有妖怪平等，幻想乡多元化等等，对于幻想乡目前面临的种种大问题却给不出合理的解决方案。\n\n风见幽香是幻想乡里少有的意识到了问题严重性的大妖怪。她这次勇敢地站了出来参加幻想乡大选，提出包括在幻想乡边境建墙（并让人类出钱），大力开展基础设施建设挽回失业率等一系列方案，成为了大选年出人意料的黑马并顺利地当上了幻想乡的大统领。", "description": "幽香上台以后，第一项措施就是要修建幻想乡的公路。幻想乡一共有 $n$ 个城市，之前原来没有任何路。幽香向选民承诺要减税，所以她打算只修 $n-1$ 条公路将这些城市连接起来。但是幻想乡有正好 $n-1$ 个建筑公司，每个建筑公司都想在修路的过程中获得一些好处。虽然这些建筑公司在选举前没有给幽香钱，幽香还是打算和他们搞好关系，因为她还指望他们帮她建墙。所以她打算让每个建筑公司都负责一条路来修。\n\n每个建筑公司都告诉了幽香自己有能力负责修建的路是哪些城市之间的。所以幽香打算 $n - 1$ 条能够连接幻想乡所有城市的边，然后每条边都交给一个能够负责该边的建筑公司修建，并且每个建筑公司都恰好修建一条边。\n\n幽香现在想要知道一共有多少种可能的方案呢？两个方案不同当且仅当它们要么修的边的集合不同，要么边的分配方式不同。", "inputFormat": "第一行包含一个整数 $n$，表示城市个数。\n\n第 $2$ 到第 $n$ 行，第 $(i + 1)$ 行表示 第 $i$ 个建筑公司可以修建的路的列表：以一个非负整数 $m_i$ 开头，表示其可以修建条路的条数；接下来有 $m_i$ 对整数 $u, v$，每对数表示一条边的两个端点。其中不会出现重复的边，也不会出现自环。", "outputFormat": "输出一行一个整数，表示所有可能的方案数对 $10^9+7$ 取模的结果。", "hint": "#### 数据规模与约定\n\n+ 对于 $20\\%$ 的测试点，$n \\le 5$。\n+ 对于 $50\\%$ 的测试点，$n \\le 8$。\n+ 对于 $60\\%$ 的测试点，$n \\le 10$。\n+ 对于 $100\\%$ 的测试点，$2 \\leq n \\le 17$，$0 \\leq m_i \\leq \\frac{n(n - 1)}{2}$，$1 \\leq u, v \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4337", "type": "P", "difficulty": 7, "samples": [["5 3 \n1 2 \n2 3 \n2 5\n3 4", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "各省省选", "浙江", "枚举", "剪枝", "状压 DP"], "title": "[ZJOI2018] 线图", "background": "九条可怜是一个热爱出题的女孩子。", "description": "今天可怜想要出一道和图论相关的题。在一张无向图 $G$ 上，我们可以对它进行一些非常有趣的变换，比如说对偶，又或者说取补。这样的操作往往可以赋予一些传统的问题新的活力。例如求补图的连通性、补图的最短路等等，都是非常有趣的问题。\n\n最近可怜知道了一种新的变换：求原图的线图 (line graph)。对于无向图 $G = ⟨V, E⟩$，它的 线图 $L(G)$ 也是一个无向图：\n- 它的点集大小为 $|E|$，每个点唯一对应着原图的一条边。 \n- 两个点之间有边当且仅当这两个点对应的边在原图上有公共点（注意不会有自环）。 下图是一个简单的例子，左图是原图，右图是它对应的线图。其中点 $1$ 对应原图的边 $(1, 2)$，点 $2$ 对应 $(1, 4)$，点 $3$ 对应 $(1, 3)$，点 $4$ 对应 $(3, 4)$。\n\n![](https://cdn.luogu.com.cn/upload/pic/16013.png )\n\n经过一些初步的摸索，可怜发现线图的性质要比补图复杂很多，其中突出的一点就是补图 的补图会变回原图，而 $L(L(G))$ 在绝大部分情况下不等于 $G$，甚至在大多数情况下它的点数和边数会以很快的速度增长。\n\n因此，可怜想要从最简单的入手，即计算 $L^k(G)$ 的点数（$L^k(G)$ 表示对 $G$ 求 $k$ 次线图）。 然而遗憾的是，即使是这个问题，对可怜来说还是太困难了，因此她进行了一定的弱化。她给出了一棵 $n$ 个节点的树 $T$，现在她想让你计算一下 $L^k(T)$ 的点数。\n", "inputFormat": "第一行输入两个整数 $n, k$，表示树的点数以及连续求线图的次数。\n\n接下来 $n − 1$ 行每行两个整数 $u, v$ 表示树上的一条边。", "outputFormat": "输出一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "如下图所示，左图为原树，中图为 $L(G)$，右图为 $L^2(G)$。这儿并未画出 $L^3(G)$，但是由于 $L^2(G)$ 有 5 条边，因此 $L^3(G)$ 中有 5 个点。\n\n![](https://cdn.luogu.com.cn/upload/pic/16014.png )\n\n![](https://cdn.luogu.com.cn/upload/pic/16015.png )", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2018] Line Graph", "background": "Jiutiao Kelian is a girl who loves creating problems.", "description": "Today, Kelian wants to make a problem related to graph theory. On an undirected graph $G$, we can perform some interesting transformations, such as taking the dual or the complement. These operations often bring new life to classical problems. For example, connectivity of the complement graph and shortest paths on the complement graph are both very interesting problems.\n\nRecently, Kelian learned a new transformation: taking the line graph of the original graph. For an undirected graph $G = ⟨V, E⟩$, its line graph $L(G)$ is also an undirected graph:\n- Its vertex set has size $|E|$, and each vertex corresponds uniquely to an edge of the original graph.\n- There is an edge between two vertices if and only if the two corresponding edges in the original graph share an endpoint (note that there are no self-loops). The figure below shows a simple example: the left figure is the original graph, and the right figure is its line graph. Vertex $1$ corresponds to edge $(1, 2)$ in the original graph, vertex $2$ corresponds to $(1, 4)$, vertex $3$ corresponds to $(1, 3)$, and vertex $4$ corresponds to $(3, 4)$.\n\n![](https://cdn.luogu.com.cn/upload/pic/16013.png )\n\nAfter some initial exploration, Kelian found that the properties of line graphs are much more complicated than those of complement graphs. A notable point is that the complement of the complement returns to the original graph, while $L(L(G))$ is not equal to $G$ in most cases, and in many cases the number of vertices and edges grows rapidly.\n\nTherefore, Kelian wants to start from the simplest case, namely computing the number of vertices of $L^k(G)$ (where $L^k(G)$ means taking the line graph of $G$ $k$ times). Unfortunately, even this problem is too hard for her, so she weakens it. She gives a tree $T$ with $n$ nodes and asks you to compute the number of vertices in $L^k(T)$.", "inputFormat": "The first line contains two integers $n, k$, denoting the number of vertices in the tree and the number of times to take the line graph.\n\nThe next $n - 1$ lines each contain two integers $u, v$, representing an edge of the tree.", "outputFormat": "Output a single integer: the answer modulo $998244353$.", "hint": "As shown below, the left figure is the original tree, the middle figure is $L(G)$, and the right figure is $L^2(G)$. $L^3(G)$ is not shown here, but since $L^2(G)$ has 5 edges, $L^3(G)$ has 5 vertices.\n\n![](https://cdn.luogu.com.cn/upload/pic/16014.png )\n\n![](https://cdn.luogu.com.cn/upload/pic/16015.png )\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2018] 线图", "background": "九条可怜是一个热爱出题的女孩子。", "description": "今天可怜想要出一道和图论相关的题。在一张无向图 $G$ 上，我们可以对它进行一些非常有趣的变换，比如说对偶，又或者说取补。这样的操作往往可以赋予一些传统的问题新的活力。例如求补图的连通性、补图的最短路等等，都是非常有趣的问题。\n\n最近可怜知道了一种新的变换：求原图的线图 (line graph)。对于无向图 $G = ⟨V, E⟩$，它的 线图 $L(G)$ 也是一个无向图：\n- 它的点集大小为 $|E|$，每个点唯一对应着原图的一条边。 \n- 两个点之间有边当且仅当这两个点对应的边在原图上有公共点（注意不会有自环）。 下图是一个简单的例子，左图是原图，右图是它对应的线图。其中点 $1$ 对应原图的边 $(1, 2)$，点 $2$ 对应 $(1, 4)$，点 $3$ 对应 $(1, 3)$，点 $4$ 对应 $(3, 4)$。\n\n![](https://cdn.luogu.com.cn/upload/pic/16013.png )\n\n经过一些初步的摸索，可怜发现线图的性质要比补图复杂很多，其中突出的一点就是补图 的补图会变回原图，而 $L(L(G))$ 在绝大部分情况下不等于 $G$，甚至在大多数情况下它的点数和边数会以很快的速度增长。\n\n因此，可怜想要从最简单的入手，即计算 $L^k(G)$ 的点数（$L^k(G)$ 表示对 $G$ 求 $k$ 次线图）。 然而遗憾的是，即使是这个问题，对可怜来说还是太困难了，因此她进行了一定的弱化。她给出了一棵 $n$ 个节点的树 $T$，现在她想让你计算一下 $L^k(T)$ 的点数。\n", "inputFormat": "第一行输入两个整数 $n, k$，表示树的点数以及连续求线图的次数。\n\n接下来 $n − 1$ 行每行两个整数 $u, v$ 表示树上的一条边。", "outputFormat": "输出一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "如下图所示，左图为原树，中图为 $L(G)$，右图为 $L^2(G)$。这儿并未画出 $L^3(G)$，但是由于 $L^2(G)$ 有 5 条边，因此 $L^3(G)$ 中有 5 个点。\n\n![](https://cdn.luogu.com.cn/upload/pic/16014.png )\n\n![](https://cdn.luogu.com.cn/upload/pic/16015.png )", "locale": "zh-CN"}}}
{"pid": "P4338", "type": "P", "difficulty": 7, "samples": [["5 3 \n1 1 1 1 1 \n1 2 \n1 3 \n2 4 \n2 5 \n2 1 \n3 1\n4 1", "6 \n7 \n9\n10"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "各省省选", "浙江", "树链剖分", "动态树 LCT", "构造"], "title": "[ZJOI2018] 历史", "background": "九条可怜是一个热爱阅读的女孩子。", "description": "这个世界有 n 个城市，这 n 个城市被恰好 $n-1$ 条双向道路联通，即任意两个城市都可以 互相到达。同时城市 1 坐落在世界的中心，占领了这个城市就称霸了这个世界。\n\n在最开始，这 n 个城市都不在任何国家的控制之下，但是随着社会的发展，一些城市会崛 起形成国家并夺取世界的霸权。为了方便，我们标记第 i 个城市崛起产生的国家为第 i 个国家。 在第 i 个城市崛起的过程中，第 i 个国家会取得城市 i 到城市 1 路径上所有城市的控制权。\n\n新的城市的崛起往往意味着战争与死亡，若第 i 个国家在崛起中，需要取得一个原本被国 家 $j(j ≠ i)$ 控制的城市的控制权，那么国家 i 就必须向国家 j 宣战并进行战争。\n\n现在，可怜知道了，在历史上，第 i 个城市一共崛起了 $a_i$ 次。但是这些事件发生的相对顺 序已经无从考究了，唯一的信息是，在一个城市崛起称霸世界之前，新的城市是不会崛起的。 \n\n战争对人民来说是灾难性的。可怜定义一次崛起的灾难度为崛起的过程中会和多少不同的国家进行战争（和同一个国家进行多次战争只会被计入一次）。可怜想要知道，在所有可能的崛 起顺序中，灾难度之和最大是多少。\n\n同时，在考古学家的努力下，越来越多的历史资料被发掘了出来，根据这些新的资料，可怜会对 $a_i$ 进行一些修正。具体来说，可怜会对 $a_i$ 进行一些操作，每次会将 $a_x$ 加上 w。她希望 在每次修改之后，都能计算得到最大的灾难度。\n\n然而可怜对复杂的计算并不感兴趣，因此她想让你来帮她计算一下这些数值。\n对题面的一些补充：\n\n- 同一个城市多次崛起形成的国家是同一个国家，这意味着同一个城市连续崛起两次是不会 和任何国家开战的：因为这些城市原来就在它的控制之下。\n- 在历史的演变过程中，第 i 个国家可能会有一段时间没有任何城市的控制权。但是这并不 意味着第 i 个国家灭亡了，在城市 i 崛起的时候，第 i 个国家仍然会取得 1 到 i 路径上的城市的控制权。", "inputFormat": "第一行输入两个整数 n,m 表示城市个数和操作个数。 \n\n第二行输入 n 个整数表示 ai 的初始值。 接下来 n − 1 行，每行输入两个整数 $u_i, v_i(1\\leq ui, vi \\leq n)$ 描述了一条道路。 \n\n接下来 m 行每行输入两个整数 $x_i$, $w_i$ 表示将 $a_{x_i}$\n加上 $w_i$。", "outputFormat": "输出共 $m+1$ 行，第一行表示初始的 ai 的答案，接下来 m 行每行表示这次修正后的答案。", "hint": "在修正开始之前，如果按照所在城市 4, 1, 5, 3, 2 的顺序崛起，那么依次会和 0, 1, 2, 1, 2 个 国家进行战争。\n\n这时一共会产生 6 对敌对关系。可以证明这是所有崛起顺序中的最大值。\n\n![](https://cdn.luogu.com.cn/upload/pic/16016.png)", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2018] History", "background": "Jiutiao Kelian (pinyin) is a girl who loves reading.", "description": "There are $n$ cities in this world, connected by exactly $n - 1$ bidirectional roads, so any two cities are mutually reachable. City $1$ lies at the center of the world; whoever takes this city dominates the world.\n\nInitially, none of the $n$ cities is controlled by any country. As society develops, some cities will rise to form countries and seize world hegemony. For convenience, we label the country that rises at city $i$ as country $i$. During the rise at city $i$, country $i$ will take control of all cities on the path from city $i$ to city $1$.\n\nThe rise of a new city often means war and death. If, during the rise of country $i$, it needs to take a city that is currently controlled by another country $j$ ($j \\ne i$), then country $i$ must declare war on country $j$ and fight.\n\nNow, Kelian knows that in history, city $i$ rose exactly $a_i$ times. However, the relative order of these events is unknown. The only information is that while one city is rising to dominate the world, no new city will start rising.\n\nWar is catastrophic for the people. Kelian defines the disaster degree of a single rise as the number of distinct countries it goes to war with during that rise (multiple wars against the same country within one rise count only once). She wants to know, among all possible rise orders, what is the maximum possible sum of the disaster degrees.\n\nMeanwhile, thanks to archaeologists’ efforts, more and more historical records are being unearthed. Based on these new materials, Kelian will adjust the values of $a_i$. Specifically, she will perform operations on $a_i$, each time adding $w$ to $a_x$. She hopes that after each modification, the maximum total disaster degree can be computed.\n\nHowever, Kelian is not interested in complicated calculations, so she wants you to help her compute these values.\n\nAdditional notes:\n- Multiple rises at the same city form the same country. This means that if the same city rises twice in a row, it will not go to war with any country, because those cities are already under its control.\n- Over the course of history, country $i$ may temporarily control no city. This does not mean country $i$ is destroyed. When city $i$ rises, country $i$ will still take control of all cities on the path from $1$ to $i$.", "inputFormat": "The first line contains two integers $n$, $m$, the number of cities and the number of operations.\n\nThe second line contains $n$ integers, the initial values of $a_i$.\n\nThe next $n - 1$ lines each contain two integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$) describing a road.\n\nThe next $m$ lines each contain two integers $x_i$, $w_i$, meaning add $w_i$ to $a_{x_i}$.", "outputFormat": "Output $m + 1$ lines. The first line is the answer for the initial $a_i$. Each of the next $m$ lines is the answer after that modification.", "hint": "Before the modifications, if the cities rise in the order $4, 1, 5, 3, 2$, then they will go to war with $0, 1, 2, 1, 2$ countries, respectively.\n\nA total of $6$ pairs of hostile relationships will be produced. It can be proven that this is the maximum among all rise orders.\n\n![](https://cdn.luogu.com.cn/upload/pic/16016.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2018] 历史", "background": "九条可怜是一个热爱阅读的女孩子。", "description": "这个世界有 n 个城市，这 n 个城市被恰好 $n-1$ 条双向道路联通，即任意两个城市都可以 互相到达。同时城市 1 坐落在世界的中心，占领了这个城市就称霸了这个世界。\n\n在最开始，这 n 个城市都不在任何国家的控制之下，但是随着社会的发展，一些城市会崛 起形成国家并夺取世界的霸权。为了方便，我们标记第 i 个城市崛起产生的国家为第 i 个国家。 在第 i 个城市崛起的过程中，第 i 个国家会取得城市 i 到城市 1 路径上所有城市的控制权。\n\n新的城市的崛起往往意味着战争与死亡，若第 i 个国家在崛起中，需要取得一个原本被国 家 $j(j ≠ i)$ 控制的城市的控制权，那么国家 i 就必须向国家 j 宣战并进行战争。\n\n现在，可怜知道了，在历史上，第 i 个城市一共崛起了 $a_i$ 次。但是这些事件发生的相对顺 序已经无从考究了，唯一的信息是，在一个城市崛起称霸世界之前，新的城市是不会崛起的。 \n\n战争对人民来说是灾难性的。可怜定义一次崛起的灾难度为崛起的过程中会和多少不同的国家进行战争（和同一个国家进行多次战争只会被计入一次）。可怜想要知道，在所有可能的崛 起顺序中，灾难度之和最大是多少。\n\n同时，在考古学家的努力下，越来越多的历史资料被发掘了出来，根据这些新的资料，可怜会对 $a_i$ 进行一些修正。具体来说，可怜会对 $a_i$ 进行一些操作，每次会将 $a_x$ 加上 w。她希望 在每次修改之后，都能计算得到最大的灾难度。\n\n然而可怜对复杂的计算并不感兴趣，因此她想让你来帮她计算一下这些数值。\n对题面的一些补充：\n\n- 同一个城市多次崛起形成的国家是同一个国家，这意味着同一个城市连续崛起两次是不会 和任何国家开战的：因为这些城市原来就在它的控制之下。\n- 在历史的演变过程中，第 i 个国家可能会有一段时间没有任何城市的控制权。但是这并不 意味着第 i 个国家灭亡了，在城市 i 崛起的时候，第 i 个国家仍然会取得 1 到 i 路径上的城市的控制权。", "inputFormat": "第一行输入两个整数 n,m 表示城市个数和操作个数。 \n\n第二行输入 n 个整数表示 ai 的初始值。 接下来 n − 1 行，每行输入两个整数 $u_i, v_i(1\\leq ui, vi \\leq n)$ 描述了一条道路。 \n\n接下来 m 行每行输入两个整数 $x_i$, $w_i$ 表示将 $a_{x_i}$\n加上 $w_i$。", "outputFormat": "输出共 $m+1$ 行，第一行表示初始的 ai 的答案，接下来 m 行每行表示这次修正后的答案。", "hint": "在修正开始之前，如果按照所在城市 4, 1, 5, 3, 2 的顺序崛起，那么依次会和 0, 1, 2, 1, 2 个 国家进行战争。\n\n这时一共会产生 6 对敌对关系。可以证明这是所有崛起顺序中的最大值。\n\n![](https://cdn.luogu.com.cn/upload/pic/16016.png)", "locale": "zh-CN"}}}
