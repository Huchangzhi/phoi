{"pid": "P4289", "type": "P", "difficulty": 4, "samples": [["1111\n0000\n1110\n0010 \n\n1010\n0101\n1010\n0101", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2008", "河南", "各省省选", "哈希 hashing", "进制", "队列"], "title": "[HAOI2008] 移动玩具", "background": "", "description": "在一个 $4 \\times 4$ 的方框内摆放了若干个相同的玩具，某人想将这些玩具重新摆放成为他心中理想的状态。规定移动时只能将玩具向上下左右四个方向移动，并且移动的位置不能有玩具。请你用最少的移动次数将初始的玩具状态移动到某人心中的目标状态。", "inputFormat": "前四行表示玩具的初始状态，每行四个数字 $1$ 或 $0$，$1$ 表示方格中放置了玩具，$0$ 表示没有放置玩具。接着是一个空行。接下来四行表示玩具的目标状态，每行四个数字 $1$ 或 $0$，意义同上。", "outputFormat": "一个整数，所需要的最少移动次数。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2008] Moving Toys", "background": "", "description": "In a $4 \\times 4$ grid, several identical toys are placed. Someone wants to rearrange these toys into his ideal state. Each move can only shift a toy up, down, left, or right, and the destination position must be empty. Please transform the initial state into the target state using the fewest number of moves.", "inputFormat": "The first four lines describe the initial state of the toys, each line containing four numbers $1$ or $0$. Here, $1$ means a toy is placed in the cell, and $0$ means the cell is empty. Then there is a blank line. The next four lines describe the target state, each line containing four numbers $1$ or $0$, with the same meaning as above.", "outputFormat": "Output a single integer: the minimum number of moves required.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2008] 移动玩具", "background": "", "description": "在一个 $4 \\times 4$ 的方框内摆放了若干个相同的玩具，某人想将这些玩具重新摆放成为他心中理想的状态。规定移动时只能将玩具向上下左右四个方向移动，并且移动的位置不能有玩具。请你用最少的移动次数将初始的玩具状态移动到某人心中的目标状态。", "inputFormat": "前四行表示玩具的初始状态，每行四个数字 $1$ 或 $0$，$1$ 表示方格中放置了玩具，$0$ 表示没有放置玩具。接着是一个空行。接下来四行表示玩具的目标状态，每行四个数字 $1$ 或 $0$，意义同上。", "outputFormat": "一个整数，所需要的最少移动次数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4290", "type": "P", "difficulty": 4, "samples": [["1 1 1 1\nII\nWW\nWW\nIG\nIIII\n", "IN\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "河南", "各省省选", "枚举", "区间 DP"], "title": "[HAOI2008] 玩具取名", "background": "", "description": "某人有一套玩具，并想法给玩具命名。首先他选择 `W, I, N, G` 四个字母中的任意一个字母作为玩具的基本名字。然后他会根据自己的喜好，将名字中任意一个字母用 `W, I, N, G` 中任意两个字母代替，使得自己的名字能够扩充得很长。\n\n现在，他想请你猜猜某一个很长的名字，最初可能是由哪几个字母变形过来的。", "inputFormat": "第一行四个整数 $W, I, N, G$。表示每一个字母能由几种两个字母所替代。\n\n接下来 $W$ 行，每行两个字母,表示 `W` 可以用这两个字母替代。\n\n接下来 $I$ 行，每行两个字母，表示 `I` 可以用这两个字母替代。\n\n接下来 $N$ 行，每行两个字母，表示 `N` 可以用这两个字母替代。\n\n接下来 $G$ 行，每行两个字母，表示 `G` 可以用这两个字母替代。\n\n最后一行一个长为 $L$ 的字符串。表示这个玩具的名字。", "outputFormat": "一行字符串，该名字可能由哪些字母变形而得到。（按照 `W, I, N, G` 的顺序输出）\n\n如果给的名字不能由任何一个字母变形而得到则输出 `The name is wrong!`。", "hint": "### 数据规模与约定\n\n- $30\\%$ 数据满足 $L \\leq 20$，$W, I, N, G \\leq 6$；\n- $100\\%$ 数据满足 $L \\leq 200$，$W, I, N, G \\leq 16$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2008] Toy Naming", "background": "", "description": "Someone has a set of toys and wants to give them names. First, he chooses any one letter from `W, I, N, G` as the base name of a toy. Then, according to his preference, he can replace any letter in the current name with any allowed pair of letters from `W, I, N, G`, so that the name can grow very long.\n\nNow, given a very long name, he wants you to guess which initial letters it could have been derived from.", "inputFormat": "The first line contains four integers $W, I, N, G$, indicating how many different pairs of letters each letter can be replaced by.\n\nThe next $W$ lines each contain two letters, indicating that `W` can be replaced by these two letters.\n\nThe next $I$ lines each contain two letters, indicating that `I` can be replaced by these two letters.\n\nThe next $N$ lines each contain two letters, indicating that `N` can be replaced by these two letters.\n\nThe next $G$ lines each contain two letters, indicating that `G$ can be replaced by these two letters.\n\nThe last line contains a string of length $L$, representing the toy’s name.", "outputFormat": "Output a single line string listing the letters from which the given name could have been derived (in the order `W, I, N, G`). If the given name cannot be derived from any letter, output `The name is wrong!`.", "hint": "Constraints\n\n- $30\\%$ of the testdata satisfies $L \\leq 20$, $W, I, N, G \\leq 6$.\n- $100\\%$ of the testdata satisfies $L \\leq 200$, $W, I, N, G \\leq 16$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2008] 玩具取名", "background": "", "description": "某人有一套玩具，并想法给玩具命名。首先他选择 `W, I, N, G` 四个字母中的任意一个字母作为玩具的基本名字。然后他会根据自己的喜好，将名字中任意一个字母用 `W, I, N, G` 中任意两个字母代替，使得自己的名字能够扩充得很长。\n\n现在，他想请你猜猜某一个很长的名字，最初可能是由哪几个字母变形过来的。", "inputFormat": "第一行四个整数 $W, I, N, G$。表示每一个字母能由几种两个字母所替代。\n\n接下来 $W$ 行，每行两个字母,表示 `W` 可以用这两个字母替代。\n\n接下来 $I$ 行，每行两个字母，表示 `I` 可以用这两个字母替代。\n\n接下来 $N$ 行，每行两个字母，表示 `N` 可以用这两个字母替代。\n\n接下来 $G$ 行，每行两个字母，表示 `G` 可以用这两个字母替代。\n\n最后一行一个长为 $L$ 的字符串。表示这个玩具的名字。", "outputFormat": "一行字符串，该名字可能由哪些字母变形而得到。（按照 `W, I, N, G` 的顺序输出）\n\n如果给的名字不能由任何一个字母变形而得到则输出 `The name is wrong!`。", "hint": "### 数据规模与约定\n\n- $30\\%$ 数据满足 $L \\leq 20$，$W, I, N, G \\leq 6$；\n- $100\\%$ 数据满足 $L \\leq 200$，$W, I, N, G \\leq 16$。", "locale": "zh-CN"}}}
{"pid": "P4291", "type": "P", "difficulty": 5, "samples": [["20\n+ADAM 1000000\n+BOB 1000000\n+TOM 2000000\n+CATHY 10000000\n?TOM\n?1\n+DAM 100000\n+BOB 1200000\n+ADAM 900000\n+FRANK 12340000\n+LEO 9000000\n+KAINE 9000000\n+GRACE 8000000\n+WALT 9000000\n+SANDY 8000000\n+MICK 9000000\n+JACK 7320000\n?2\n?5\n?KAINE", "2\nCATHY TOM ADAM BOB\nCATHY LEO KAINE WALT MICK GRACE SANDY JACK TOM BOB\nWALT MICK GRACE SANDY JACK TOM BOB ADAM DAM\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2008", "河南", "各省省选", "平衡树", "哈希 hashing"], "title": "[HAOI2008] 排名系统", "background": null, "description": "排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回 $10$ 条记录。", "inputFormat": "第一行是一个整数 $n(10\\le n\\le250000)$ 表示请求总数目。接下来 $n$行，每行包含了一个请求。请求的具体格式如下：\n- `+Name Score` 上传最新得分记录。`Name` 表示玩家名字，由大写英文字母组成，不超过 $10$ 个字符。`Score` 为最多 $8$ 位的正整数。\n- `?Name` 查询玩家排名。该玩家的得分记录必定已经在前面上传。如果两个玩家的得分相同，则先得到该得分的玩家排在前面。\n- `?Index` 返回自第 `Index` 名开始的最多 $10$ 名玩家名字。`Index` 必定合法，即不小于 $1$，也不大于当前有记录的玩家总数。", "outputFormat": "- 对于 `?Name` 格式的请求，应输出一个整数表示该玩家当前的排名；\n- 对于 `?Index` 格式的请求，应在一行中依次输出从第 `Index` 名开始的最多 $10$ 名玩家姓名，用一个空格分隔。", "hint": "- 对于 $20\\%$ 的数据，$N\\le100$；\n- 对于 $100\\%$ 的数据，$N\\le2.5\\times10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2008] Ranking System", "background": "", "description": "A ranking system typically needs to handle three types of requests: uploading a new score record, querying a player's current rank, and returning the ranking records within a segment. When a player uploads their latest score record, their previous score record is deleted. To reduce server load, when returning a segment of the ranking, at most $10$ records are returned.", "inputFormat": "The first line contains an integer $n(10\\le n\\le250000)$ denoting the total number of requests. The next $n$ lines each contain one request. The specific formats are as follows:\n- `+Name Score` Upload the latest score record. `Name` denotes the player's name, consisting of uppercase English letters, no more than $10$ characters. `Score` is a positive integer with at most $8$ digits.\n- `?Name` Query the player's rank. This player's score record must have been uploaded earlier. If two players have the same score, the one who obtained that score earlier ranks ahead.\n- `?Index` Return up to $10$ player names starting from rank `Index`. `Index` is guaranteed to be valid, i.e., not less than $1$ and not greater than the current number of players with records.", "outputFormat": "- For requests of the form `?Name`, output a single integer denoting that player's current rank.\n- For requests of the form `?Index`, output in one line the names of up to $10$ players starting from rank `Index`, separated by a space.", "hint": "- For $20\\%$ of the testdata, $N\\le100$.\n- For $100\\%$ of the testdata, $N\\le2.5\\times10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2008] 排名系统", "background": null, "description": "排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回 $10$ 条记录。", "inputFormat": "第一行是一个整数 $n(10\\le n\\le250000)$ 表示请求总数目。接下来 $n$行，每行包含了一个请求。请求的具体格式如下：\n- `+Name Score` 上传最新得分记录。`Name` 表示玩家名字，由大写英文字母组成，不超过 $10$ 个字符。`Score` 为最多 $8$ 位的正整数。\n- `?Name` 查询玩家排名。该玩家的得分记录必定已经在前面上传。如果两个玩家的得分相同，则先得到该得分的玩家排在前面。\n- `?Index` 返回自第 `Index` 名开始的最多 $10$ 名玩家名字。`Index` 必定合法，即不小于 $1$，也不大于当前有记录的玩家总数。", "outputFormat": "- 对于 `?Name` 格式的请求，应输出一个整数表示该玩家当前的排名；\n- 对于 `?Index` 格式的请求，应在一行中依次输出从第 `Index` 名开始的最多 $10$ 名玩家姓名，用一个空格分隔。", "hint": "- 对于 $20\\%$ 的数据，$N\\le100$；\n- 对于 $100\\%$ 的数据，$N\\le2.5\\times10^5$。", "locale": "zh-CN"}}}
{"pid": "P4292", "type": "P", "difficulty": 7, "samples": [["4 \n2 3 \n1 2 1 \n1 3 2 \n1 4 3", "2.500"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2010", "线段树", "点分治", "单调队列", "分治", "树链剖分", "WC"], "title": "[WC2010] 重建计划", "background": "", "description": "X 国遭受了地震的重创, 导致全国的交通近乎瘫痪，重建家园的计划迫在眉睫。X 国由 $N$ 个城市组成, 重建小组提出，仅需建立 $N-1$ 条道路即可使得任意两个城市互相可达。于是，重建小组很快提出了一个包含 $N-1$ 条道路的方案，并满足城市之间两两可达，他们还计算评估了每条道路 $e$ 建设之后可以带来的价值 $v(e)$。  \n\n由于重建计划复杂而艰难，经费也有一定限制。因此，政府要求第一期重建工程修建的道路数目为 $k$ 条，但需满足 $L \\leq k \\leq U$，即不应少于$L$ 条，但不超过 $U$ 条。同时，为了最大化利用率，要求建设的这些道路恰好组成一条简单路径，即所建设的 $k$ 条路径可以构成一个排列 $e_1 = (p_1, q_1), e_2 = (p_2, q_2), \\cdots , e_k = (p_k, q_k)$， 对于 $1 \\leq i < k$， 有$(q_i = p_{i+1})$。 \n\n重建小组打算修改他们的原有方案以满足要求，即在原有的 $N-1$ 条道路中寻找一条路径 $S$ 作为新的方案，使得新方案中的道路平均价值\n\n$$AvgValue = \\frac{\\sum _{e \\in S} v(e)}{|S|}$$\n\n最大。这里 $v(e)$ 表示道路 $e$ 的价值，$|S|$ 表示新方案中道路的条数。请你帮助重建小组寻找一个最优方案。  注: 在本题中 $L$ 和 $U$ 的设置将保证有解。\n", "inputFormat": "第一行包含一个正整数 $N$ ，表示 X 国的城市个数。 \n\n第二行包含两个正整数 $L,U$，表示政府要求的第一期重建方案中修建道路数的上下限。  \n\n接下来的 $N-1$ 行描述重建小组的原有方案，每行三个正整数 $a_i, b_i, v_i$，分别表示道路 $(a_i, b_i)$，其价值为 $v_i$ 。其中城市由$1 \\cdots N$标号。", "outputFormat": "仅包含一行，为一个实数 $AvgValue$，即最大平均价值。\n\n小数点后保留三位。", "hint": "新方案中选择路径 $(3, 1), (1, 4)$ 可以得到的平均价值为 $2.5$，为最大平均价值。\n\n对于20%的数据，$N \\leq 5 000$;  \n\n另有30%的数据，$N \\leq 100 000$， 原有方案恰好为一条路径(链); \n\n对于100%的数据，$N \\leq 100 000, 1 \\leq L \\leq U \\leq N-1, v_i \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[WC2010] Reconstruction Plan", "background": "", "description": "Country X was heavily hit by an earthquake, which almost paralyzed nationwide transportation, and the reconstruction plan is urgent. Country X consists of $N$ cities. The reconstruction team proposed that building only $N - 1$ roads would make any two cities mutually reachable. Thus, they quickly proposed a plan containing $N - 1$ roads that ensures pairwise reachability between cities, and they also evaluated the value $v(e)$ that each road $e$ would bring after construction.\n\nDue to the complexity and difficulty of the reconstruction plan, and with limited funds, the government requires that the number of roads to be built in the first phase be $k$, with $L \\leq k \\leq U$, i.e., no fewer than $L$ roads and no more than $U$ roads. Meanwhile, to maximize utilization, the selected roads must form exactly one simple path, i.e., the $k$ roads can be arranged as a sequence $e_1 = (p_1, q_1), e_2 = (p_2, q_2), \\cdots, e_k = (p_k, q_k)$ such that for $1 \\leq i < k$ we have $(q_i = p_{i+1})$.\n\nThe reconstruction team plans to modify their original plan to meet the requirement, that is, find a path $S$ among the original $N - 1$ roads as the new plan, so that the average value of the new plan\n$$AvgValue = \\frac{\\sum_{e \\in S} v(e)}{|S|}$$\nis maximized. Here $v(e)$ denotes the value of road $e$, and $|S|$ is the number of roads in the new plan. Please help the reconstruction team find an optimal plan. Note: In this problem, $L$ and $U$ are set to guarantee a solution.", "inputFormat": "The first line contains a positive integer $N$, the number of cities in Country X.\n\nThe second line contains two positive integers $L, U$, the lower and upper bounds on the number of roads to be built in the first-phase plan.\n\nEach of the next $N - 1$ lines describes the original plan of the reconstruction team, with three positive integers $a_i, b_i, v_i$, indicating a road $(a_i, b_i)$ whose value is $v_i$. Cities are numbered $1 \\cdots N$.", "outputFormat": "Output a single line containing a real number AvgValue, the maximum average value.\n\nKeep three digits after the decimal point.", "hint": "In the new plan, selecting the path $(3, 1), (1, 4)$ yields an average value of $2.5$, which is the maximum average value.\n\nFor 20% of the testdata, $N \\leq 5000$.\n\nFor another 30% of the testdata, $N \\leq 100000$, and the original plan is exactly a path (chain).\n\nFor 100% of the testdata, $N \\leq 100000$, $1 \\leq L \\leq U \\leq N - 1$, and $v_i \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2010] 重建计划", "background": "", "description": "X 国遭受了地震的重创, 导致全国的交通近乎瘫痪，重建家园的计划迫在眉睫。X 国由 $N$ 个城市组成, 重建小组提出，仅需建立 $N-1$ 条道路即可使得任意两个城市互相可达。于是，重建小组很快提出了一个包含 $N-1$ 条道路的方案，并满足城市之间两两可达，他们还计算评估了每条道路 $e$ 建设之后可以带来的价值 $v(e)$。  \n\n由于重建计划复杂而艰难，经费也有一定限制。因此，政府要求第一期重建工程修建的道路数目为 $k$ 条，但需满足 $L \\leq k \\leq U$，即不应少于$L$ 条，但不超过 $U$ 条。同时，为了最大化利用率，要求建设的这些道路恰好组成一条简单路径，即所建设的 $k$ 条路径可以构成一个排列 $e_1 = (p_1, q_1), e_2 = (p_2, q_2), \\cdots , e_k = (p_k, q_k)$， 对于 $1 \\leq i < k$， 有$(q_i = p_{i+1})$。 \n\n重建小组打算修改他们的原有方案以满足要求，即在原有的 $N-1$ 条道路中寻找一条路径 $S$ 作为新的方案，使得新方案中的道路平均价值\n\n$$AvgValue = \\frac{\\sum _{e \\in S} v(e)}{|S|}$$\n\n最大。这里 $v(e)$ 表示道路 $e$ 的价值，$|S|$ 表示新方案中道路的条数。请你帮助重建小组寻找一个最优方案。  注: 在本题中 $L$ 和 $U$ 的设置将保证有解。\n", "inputFormat": "第一行包含一个正整数 $N$ ，表示 X 国的城市个数。 \n\n第二行包含两个正整数 $L,U$，表示政府要求的第一期重建方案中修建道路数的上下限。  \n\n接下来的 $N-1$ 行描述重建小组的原有方案，每行三个正整数 $a_i, b_i, v_i$，分别表示道路 $(a_i, b_i)$，其价值为 $v_i$ 。其中城市由$1 \\cdots N$标号。", "outputFormat": "仅包含一行，为一个实数 $AvgValue$，即最大平均价值。\n\n小数点后保留三位。", "hint": "新方案中选择路径 $(3, 1), (1, 4)$ 可以得到的平均价值为 $2.5$，为最大平均价值。\n\n对于20%的数据，$N \\leq 5 000$;  \n\n另有30%的数据，$N \\leq 100 000$， 原有方案恰好为一条路径(链); \n\n对于100%的数据，$N \\leq 100 000, 1 \\leq L \\leq U \\leq N-1, v_i \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4293", "type": "P", "difficulty": 6, "samples": [["4  \n1.0 2.0 \n3.0 1.0 \n5.0 4.0 \n2.0 2.0", "3 2 \n3  \n1 3 2"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["计算几何", "2010", "Special Judge", "凸包", "WC"], "title": "[WC2010] 能量场", "background": "\n官方spj：https://www.luogu.org/paste/03wjc4ne\n\nspj provider: @hehezhou ", "description": "物理学家栋栋最近在研究一个能量场。在这个能量场中有n个粒子，每个粒子都有两个属性：质量m和结合系数c。  \n\n栋栋发现，在这个能量场中，每个粒子都有两极，N极和S极。两个粒子相遇时，符合“同极相斥，异极相吸”的原则，只能是一个粒子的N极和另一个粒子的S极连接到一起。当质量为ma，结合系数为ca的粒子a的N极与另一个质量为mb，结合系数为cb的粒子b的S极直接连接时，可以产生大小为  $m_a m_b (c_a - c_b)$  的结合能量。    \n\n请解决以下两个问题：  \n1. 在能量场的n个粒子中哪两个粒子直接连接的能量最大。  \n2. 栋栋发明了一种方法，能选择其中的任意k个粒子p1, p2, …, pk，将pi的 N极与pi+1的S极连接(1 ≤ i < k)， pk的N极与p1的S极连接， 其中p1, p2, …, pk两两不同。k可以在1至n中任意取值，如使用栋栋的这种方法连接，选择哪些粒子可以得到最大的能量。", "inputFormat": "第一行包含一个整数n，表示粒子的个数。 \n\n 接下来n行，每行两个实数，第i+1行的两个实数表示第i个粒子的质量mi和结合系数ci。(0< mi, ci <10^5)", "outputFormat": "第一行包含两个整数a, b，表示将粒子a的N极与粒子b的S极连接可以得到最大的能量。  \n\n第二行包含一个整数k，表示第二问中要得到最大的能量需要多少个粒子。 第三行包含k个整数，表示p1, p2, …, pk，即第二问中的最优方案。", "hint": "【样例说明】  \n对于第一问，第三个粒子的N极与第二个粒子的S极连接，能得到的能量为$5\\times3\\times(4-1) = 45$。  \n\n对于第二问，顺次连接1, 3, 2号粒子，能量为  $1\\times5\\times(2-4) + 5\\times3\\times(4-1) + 3\\times1\\times(1-2) = 32$。 \n\n【数据规模】  \n\n10%的数据，n ≤ 8； \n\n20%的数据，n ≤ 15； \n\n40%的数据，n ≤ 1 000；\n\n50%的数据，n ≤ 5 000； \n\n100%的数据，n ≤ 50 000。 \n\n【评分标准】  \n\n此题可能有多解，如果用你的解产生的能量与参考答案的绝对误差或相对误差小于10–5，则得满分。否则不得分。  对于本题，每问的分数各占50%。如果你的输出任何一问的格式或结果不正确，则不得分；否则如果其中的一问正确，则得到该测试点50%的分数；如果两问都正确，得到该测试点100%的分数。", "locale": "zh-CN", "translations": {"en": {"title": "[WC2010] Energy Field", "background": "Official SPJ: https://www.luogu.org/paste/03wjc4ne.\n\nSPJ provider: @hehezhou.", "description": "Physicist Dongdong is studying an energy field. In this field, there are n particles, and each particle has two attributes: mass m and bonding coefficient c.\n\nDongdong discovers that each particle has two poles, an N pole and an S pole. When two particles meet, they follow the rule “like poles repel, unlike poles attract,” and only the N pole of one particle can connect to the S pole of another. When the N pole of particle a with mass $m_a$ and coefficient $c_a$ directly connects to the S pole of particle b with mass $m_b$ and coefficient $c_b$, the produced binding energy is $m_a m_b (c_a - c_b)$.\n\nPlease solve the following two problems:\n1. Among the n particles, determine which ordered pair of particles, when directly connected (N of a to S of b), yields the maximum energy.\n2. Dongdong invents a method that selects any k particles $p1, p2, \\dots, pk$, connects the N pole of $p_i$ to the S pole of $p_{i+1}$ for $1 \\le i < k$, and connects the N pole of $p_k$ to the S pole of $p1$, where $p1, p2, \\dots, pk$ are pairwise distinct. The value of k can be any integer from 1 to n. Using this method, choose the particles to obtain the maximum total energy.", "inputFormat": "The first line contains an integer n, the number of particles.\n\nThe next n lines each contain two real numbers. In line $i+1$, the two real numbers denote the mass $m_i$ and bonding coefficient $c_i$ of particle i. $(0 < m_i, c_i < 10^5)$.", "outputFormat": "The first line contains two integers a and b, indicating that connecting the N pole of particle a to the S pole of particle b yields the maximum energy.\n\nThe second line contains an integer k, the number of particles needed to achieve the maximum total energy in problem 2. The third line contains k integers, denoting $p1, p2, \\dots, pk$, i.e., the optimal sequence in problem 2.", "hint": "Sample Explanation:\n- For the first problem, connecting the N pole of the third particle to the S pole of the second particle yields energy $5\\times3\\times(4-1) = 45$.\n- For the second problem, connecting particles 1, 3, 2 in order yields energy $1\\times5\\times(2-4) + 5\\times3\\times(4-1) + 3\\times1\\times(1-2) = 32$.\n\nConstraints:\n- For 10% of the testdata, $n \\le 8$.\n- For 20% of the testdata, $n \\le 15$.\n- For 40% of the testdata, $n \\le 1000$.\n- For 50% of the testdata, $n \\le 5000$.\n- For 100% of the testdata, $n \\le 50000$.\n\nScoring:\n- This problem may have multiple correct outputs. If the absolute error or relative error of your energy compared to the reference answer is less than $10^{-5}$, you receive full score; otherwise, you receive zero.\n- Each of the two problems is worth 50%. If the format or result of any one problem is incorrect, you receive zero; otherwise, if only one problem is correct, you receive 50% of the points for that test point; if both are correct, you receive 100% of the points for that test point.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2010] 能量场", "background": "\n官方spj：https://www.luogu.org/paste/03wjc4ne\n\nspj provider: @hehezhou ", "description": "物理学家栋栋最近在研究一个能量场。在这个能量场中有n个粒子，每个粒子都有两个属性：质量m和结合系数c。  \n\n栋栋发现，在这个能量场中，每个粒子都有两极，N极和S极。两个粒子相遇时，符合“同极相斥，异极相吸”的原则，只能是一个粒子的N极和另一个粒子的S极连接到一起。当质量为ma，结合系数为ca的粒子a的N极与另一个质量为mb，结合系数为cb的粒子b的S极直接连接时，可以产生大小为  $m_a m_b (c_a - c_b)$  的结合能量。    \n\n请解决以下两个问题：  \n1. 在能量场的n个粒子中哪两个粒子直接连接的能量最大。  \n2. 栋栋发明了一种方法，能选择其中的任意k个粒子p1, p2, …, pk，将pi的 N极与pi+1的S极连接(1 ≤ i < k)， pk的N极与p1的S极连接， 其中p1, p2, …, pk两两不同。k可以在1至n中任意取值，如使用栋栋的这种方法连接，选择哪些粒子可以得到最大的能量。", "inputFormat": "第一行包含一个整数n，表示粒子的个数。 \n\n 接下来n行，每行两个实数，第i+1行的两个实数表示第i个粒子的质量mi和结合系数ci。(0< mi, ci <10^5)", "outputFormat": "第一行包含两个整数a, b，表示将粒子a的N极与粒子b的S极连接可以得到最大的能量。  \n\n第二行包含一个整数k，表示第二问中要得到最大的能量需要多少个粒子。 第三行包含k个整数，表示p1, p2, …, pk，即第二问中的最优方案。", "hint": "【样例说明】  \n对于第一问，第三个粒子的N极与第二个粒子的S极连接，能得到的能量为$5\\times3\\times(4-1) = 45$。  \n\n对于第二问，顺次连接1, 3, 2号粒子，能量为  $1\\times5\\times(2-4) + 5\\times3\\times(4-1) + 3\\times1\\times(1-2) = 32$。 \n\n【数据规模】  \n\n10%的数据，n ≤ 8； \n\n20%的数据，n ≤ 15； \n\n40%的数据，n ≤ 1 000；\n\n50%的数据，n ≤ 5 000； \n\n100%的数据，n ≤ 50 000。 \n\n【评分标准】  \n\n此题可能有多解，如果用你的解产生的能量与参考答案的绝对误差或相对误差小于10–5，则得满分。否则不得分。  对于本题，每问的分数各占50%。如果你的输出任何一问的格式或结果不正确，则不得分；否则如果其中的一问正确，则得到该测试点50%的分数；如果两问都正确，得到该测试点100%的分数。", "locale": "zh-CN"}}}
{"pid": "P4294", "type": "P", "difficulty": 6, "samples": [["4 4\n0 1 1 0\n2 5 5 1\n1 5 5 1\n0 1 1 0", "6\nxoox\n___o\n___o\nxoox"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2008", "Special Judge", "最短路", "进制", "WC", "状压 DP"], "title": "[WC2008] 游览计划", "background": "UPD：\n\n- @panda_2134 提供 Special Judge；\n\n- @yzy1 提供了[两组 hack 数据](https://www.luogu.com.cn/discuss/527294)，即不算分的 subtask1；\n\n- @kradcigam [完善](https://www.luogu.com.cn/discuss/873182)了 Special Judge。", "description": "从未来过绍兴的小 D 有幸参加了 Winter Camp 2008，他被这座历史名城的秀丽风景所吸引，强烈要求游览绍兴及其周边的所有景点。\n\n主办者将绍兴划分为 $N$ 行 $M$ 列 $(N×M)$ 个分块，如下图（$8\\times8$）：\n\n![](https://cdn.luogu.com.cn/upload/pic/15472.png)\n\n景点含于方块内，且一个方块至多有一个景点。无景点的方块视为路。\n\n为了保证安全与便利，主办方依据路况和治安状况，在非景点的一些方块内安排不同数量的志愿者；在景点内聘请导游（导游不是志愿者）。在选择旅游方案时，保证任意两个景点之间，存在一条路径，在这条路径所经过的每一个方块都有志愿者或者该方块为景点。既能满足选手们游览的需要，又能够让志愿者的总数最少。\n\n例如，在上面的例子中，在每个没有景点的方块中填入一个数字，表示控制该方块最少需要的志愿者数目：\n\n![](https://cdn.luogu.com.cn/upload/pic/15473.png)\n\n图中用深色标出的方块区域就是一种可行的志愿者安排方案，一共需要 $20$ 名志愿者。由图可见，两个相邻的景点是直接（有景点内的路）连通的（如沈园和八字桥）。\n\n现在，希望你能够帮助主办方找到一种最好的安排方案。", "inputFormat": "第一行有两个整数，$N$ 和 $M$，描述方块的数目。\n\n接下来 $N$ 行，每行有 $M$ 个非负整数，如果该整数为 $0$，则该方块为一个景点；否则表示控制该方块至少需要的志愿者数目。相邻的整数用（若干个）空格隔开，行首行末也可能有多余的空格。", "outputFormat": "由 $N+1$ 行组成。第一行为一个整数，表示你所给出的方案中安排的志愿者总数目。\n\n接下来 $N$ 行，每行 $M$ 个字符，描述方案中相应方块的情况：\n\n- `_`（下划线）表示该方块没有安排志愿者；\n- `o`（小写英文字母 o）表示该方块安排了志愿者；\n- `x`（小写英文字母 x）表示该方块是一个景点；\n\n注：请注意输出格式要求，如果缺少某一行或者某一行的字符数目和要求不一致（任何一行中，多余的空格都不允许出现），都可能导致该测试点不得分。", "hint": "所有的 $10$ 组数据中 $N,M$，以及景点数 $K$ 的范围规定如下：\n\n::cute-table{tuack}\n\n|测试点编号| $N$ | $M$ | $K$ |\n|:-:|:-:|:-:|:-:|\n| 1|$\\le  2$|$\\le  2$|$\\le  2$|\n| 2|$\\le  4$|$\\le  5$|$\\le  4$|\n| 3|$\\le  2$|$\\le 10$|$\\le  3$|\n| 4|$\\le  6$|$\\le  7$|$\\le  5$|\n| 5|$\\le  8$|$\\le  9$|$\\le  7$|\n| 6|$\\le 10$|$\\le  9$|$\\le 10$|\n| 7|$\\le  9$|$\\le 10$|$\\le 10$|\n| 8|$\\le 10$|$\\le 10$|$\\le  3$|\n| 9|$\\le 10$|$\\le 10$|$\\le 10$|\n|10|$\\le 10$|$\\le 10$|$\\le 10$| ![](https://cdn.luogu.com.cn/upload/pic/15474.png)\n\n输入文件中的所有整数均不小于 $0$ 且不超过 $2^{16}$。", "locale": "zh-CN", "translations": {"en": {"title": "[WC2008] Sightseeing Plan", "background": "UPD:\n\n- @panda_2134 provided the Special Judge.\n- @yzy1 provided [two sets of hack testdata](https://www.luogu.com.cn/discuss/527294), i.e., the non-scoring subtask1.\n- @kradcigam [improved](https://www.luogu.com.cn/discuss/873182) the Special Judge.", "description": "Little D, who has never been to Shaoxing, was lucky to attend Winter Camp 2008. He was captivated by the beautiful scenery of this historic city and strongly requested to visit all scenic spots in and around Shaoxing.\n\nThe organizers divide Shaoxing into $N$ rows and $M$ columns, i.e., an $(N \\times M)$ grid, as in the figure ($8 \\times 8$):\n\n![](https://cdn.luogu.com.cn/upload/pic/15472.png)\n\nEach scenic spot lies within a cell, and each cell contains at most one scenic spot. A cell without a scenic spot is considered a road.\n\nFor safety and convenience, based on road and security conditions, the organizers place different numbers of volunteers in some non-scenic cells; in scenic cells they hire tour guides (guides are not volunteers). When choosing a touring plan, we must ensure that between any two scenic spots there exists a path such that every cell on this path either has volunteers or is itself a scenic spot. The plan should meet contestants’ touring needs while minimizing the total number of volunteers.\n\nFor example, in the example above, each non-scenic cell is assigned a number indicating the minimum number of volunteers needed to control that cell:\n\n![](https://cdn.luogu.com.cn/upload/pic/15473.png)\n\nThe dark-shaded region shows one feasible volunteer arrangement, requiring a total of $20$ volunteers. As can be seen, two adjacent scenic spots are directly connected (via roads inside the scenic spots), e.g., 沈园 and 八字桥.\n\nNow, please help the organizers find the best arrangement.", "inputFormat": "The first line contains two integers, $N$ and $M$, describing the number of cells.\n\nThe next $N$ lines each contain $M$ nonnegative integers. If an integer is $0$, then the corresponding cell is a scenic spot; otherwise, it is the minimum number of volunteers required to control that cell. Adjacent integers are separated by one or more spaces; there may also be extra spaces at the beginning or end of a line.", "outputFormat": "Output $N+1$ lines. The first line is a single integer, the total number of volunteers in your plan.\n\nThen output $N$ lines, each containing $M$ characters, describing the status of each cell in your plan:\n- `_` (underscore) means no volunteers are placed in that cell.\n- `o` (lowercase letter o) means volunteers are placed in that cell.\n- `x` (lowercase letter x) means that cell is a scenic spot.\n\nNote: Please strictly follow the output format. If any line is missing, or if any line contains an incorrect number of characters (and no extra spaces are allowed on any line), that test point may receive no score.", "hint": "Constraints (across all $10$ groups of testdata) on $N$, $M$, and the number of scenic spots $K$ are as follows:\n\n| Test case ID | $N$        | $M$        | $K$        |\n|:-:|:-:|:-:|:-:|\n| 1  | $ \\le 2 $  | $ \\le 2 $  | $ \\le 2 $  |\n| 2  | $ \\le 4 $  | $ \\le 5 $  | $ \\le 4 $  |\n| 3  | $ \\le 2 $  | $ \\le 10 $ | $ \\le 3 $  |\n| 4  | $ \\le 6 $  | $ \\le 7 $  | $ \\le 5 $  |\n| 5  | $ \\le 8 $  | $ \\le 9 $  | $ \\le 7 $  |\n| 6  | $ \\le 10 $ | $ \\le 9 $  | $ \\le 10 $ |\n| 7  | $ \\le 9 $  | $ \\le 10 $ | $ \\le 10 $ |\n| 8  | $ \\le 10 $ | $ \\le 10 $ | $ \\le 3 $  |\n| 9  | $ \\le 10 $ | $ \\le 10 $ | $ \\le 10 $ |\n| 10 | $ \\le 10 $ | $ \\le 10 $ | $ \\le 10 $ |\n\n![](https://cdn.luogu.com.cn/upload/pic/15474.png)\n\nAll integers in the input file are between $0$ and $2^{16}$, inclusive.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2008] 游览计划", "background": "UPD：\n\n- @panda_2134 提供 Special Judge；\n\n- @yzy1 提供了[两组 hack 数据](https://www.luogu.com.cn/discuss/527294)，即不算分的 subtask1；\n\n- @kradcigam [完善](https://www.luogu.com.cn/discuss/873182)了 Special Judge。", "description": "从未来过绍兴的小 D 有幸参加了 Winter Camp 2008，他被这座历史名城的秀丽风景所吸引，强烈要求游览绍兴及其周边的所有景点。\n\n主办者将绍兴划分为 $N$ 行 $M$ 列 $(N×M)$ 个分块，如下图（$8\\times8$）：\n\n![](https://cdn.luogu.com.cn/upload/pic/15472.png)\n\n景点含于方块内，且一个方块至多有一个景点。无景点的方块视为路。\n\n为了保证安全与便利，主办方依据路况和治安状况，在非景点的一些方块内安排不同数量的志愿者；在景点内聘请导游（导游不是志愿者）。在选择旅游方案时，保证任意两个景点之间，存在一条路径，在这条路径所经过的每一个方块都有志愿者或者该方块为景点。既能满足选手们游览的需要，又能够让志愿者的总数最少。\n\n例如，在上面的例子中，在每个没有景点的方块中填入一个数字，表示控制该方块最少需要的志愿者数目：\n\n![](https://cdn.luogu.com.cn/upload/pic/15473.png)\n\n图中用深色标出的方块区域就是一种可行的志愿者安排方案，一共需要 $20$ 名志愿者。由图可见，两个相邻的景点是直接（有景点内的路）连通的（如沈园和八字桥）。\n\n现在，希望你能够帮助主办方找到一种最好的安排方案。", "inputFormat": "第一行有两个整数，$N$ 和 $M$，描述方块的数目。\n\n接下来 $N$ 行，每行有 $M$ 个非负整数，如果该整数为 $0$，则该方块为一个景点；否则表示控制该方块至少需要的志愿者数目。相邻的整数用（若干个）空格隔开，行首行末也可能有多余的空格。", "outputFormat": "由 $N+1$ 行组成。第一行为一个整数，表示你所给出的方案中安排的志愿者总数目。\n\n接下来 $N$ 行，每行 $M$ 个字符，描述方案中相应方块的情况：\n\n- `_`（下划线）表示该方块没有安排志愿者；\n- `o`（小写英文字母 o）表示该方块安排了志愿者；\n- `x`（小写英文字母 x）表示该方块是一个景点；\n\n注：请注意输出格式要求，如果缺少某一行或者某一行的字符数目和要求不一致（任何一行中，多余的空格都不允许出现），都可能导致该测试点不得分。", "hint": "所有的 $10$ 组数据中 $N,M$，以及景点数 $K$ 的范围规定如下：\n\n::cute-table{tuack}\n\n|测试点编号| $N$ | $M$ | $K$ |\n|:-:|:-:|:-:|:-:|\n| 1|$\\le  2$|$\\le  2$|$\\le  2$|\n| 2|$\\le  4$|$\\le  5$|$\\le  4$|\n| 3|$\\le  2$|$\\le 10$|$\\le  3$|\n| 4|$\\le  6$|$\\le  7$|$\\le  5$|\n| 5|$\\le  8$|$\\le  9$|$\\le  7$|\n| 6|$\\le 10$|$\\le  9$|$\\le 10$|\n| 7|$\\le  9$|$\\le 10$|$\\le 10$|\n| 8|$\\le 10$|$\\le 10$|$\\le  3$|\n| 9|$\\le 10$|$\\le 10$|$\\le 10$|\n|10|$\\le 10$|$\\le 10$|$\\le 10$| ![](https://cdn.luogu.com.cn/upload/pic/15474.png)\n\n输入文件中的所有整数均不小于 $0$ 且不超过 $2^{16}$。", "locale": "zh-CN"}}}
{"pid": "P4295", "type": "P", "difficulty": 6, "samples": [["2 2", "3"], ["2 3", "21"], ["3 5", "58871587162270592645034001\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["高精度", "2003", "四川", "各省省选", "前缀和", "差分"], "title": "[SCOI2003] 严格N元树", "background": "", "description": "如果一棵树的所有非叶节点都恰好有 $n$ 个儿子，那么我们称它为严格 $n$ 元树。如果该树中最底层的节点深度为 $d$（根的深度为 $0$），那么我们称它为一棵深度为 $d$ 的严格 $n$ 元树。例如，深度为２的严格２元树有三个，如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/um9mtoxb.png)\n \n给出 $n,d$，编程数出深度为 $d$ 的 $n$ 元树数目。", "inputFormat": "仅包含两个整数 $n,d(0<n \\le 32,0 \\le d \\le 16)$。输入数据保证你不需要考虑某一层多于 $1024$ 个节点的树（即 $nd \\le 1024$）。提示：答案保证不超过 $200$ 位十进制数。", "outputFormat": "仅包含一个数，即深度为 $d$ 的 $n$ 元树的数目。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2003] Strict N-ary Tree", "background": "", "description": "If every non-leaf node of a tree has exactly $n$ children, we call it a strict $n$-ary tree. If the deepest nodes in the tree have depth $d$ (the root has depth $0$), then we call it a strict $n$-ary tree of depth $d$. For example, there are three strict $2$-ary trees of depth $2$, as shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/um9mtoxb.png)\n\nGiven $n, d$, write a program to count the number of strict $n$-ary trees of depth $d$.", "inputFormat": "Contains only two integers $n, d$ ($0 < n \\le 32$, $0 \\le d \\le 16$). The testdata guarantees that you do not need to consider trees with more than $1024$ nodes on any level (i.e., $n^d \\le 1024$).", "outputFormat": "Contains only one number, which is the number of strict $n$-ary trees of depth $d$.", "hint": "The answer is guaranteed to be at most $200$ decimal digits.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2003] 严格N元树", "background": "", "description": "如果一棵树的所有非叶节点都恰好有 $n$ 个儿子，那么我们称它为严格 $n$ 元树。如果该树中最底层的节点深度为 $d$（根的深度为 $0$），那么我们称它为一棵深度为 $d$ 的严格 $n$ 元树。例如，深度为２的严格２元树有三个，如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/um9mtoxb.png)\n \n给出 $n,d$，编程数出深度为 $d$ 的 $n$ 元树数目。", "inputFormat": "仅包含两个整数 $n,d(0<n \\le 32,0 \\le d \\le 16)$。输入数据保证你不需要考虑某一层多于 $1024$ 个节点的树（即 $nd \\le 1024$）。提示：答案保证不超过 $200$ 位十进制数。", "outputFormat": "仅包含一个数，即深度为 $d$ 的 $n$ 元树的数目。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4296", "type": "P", "difficulty": 5, "samples": [["12", "1\n5\n7\n11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "数论", "安徽", "枚举", "优先队列"], "title": "[AHOI2007] 密码箱", "background": "", "description": "在一次偶然的情况下，小可可得到了一个密码箱，听说里面藏着一份古代流传下来的藏宝图，只要能破解密码就能打开箱子，而箱子背面刻着的古代图标，就是对密码的提示。\n\n经过艰苦的破译，小可可发现，这些图标表示一个数以及这个数与密码的关系。假设这个数是 $n$，密码为 $x$，那么可以得到如下表述： 密码 $x$ 大于等于 $0$，且小于 $n$，而 $x$ 的平方除以 $n$，得到的余数为 $1$。 小可可知道满足上述条件的 $x$ 可能不止一个，所以一定要把所有满足条件的 $x$ 计算出来，密码肯定就在其中。计算的过程是很艰苦的，你能否编写一个程序来帮助小可可呢？", "inputFormat": "一行，一个数字 $n$（$1 \\leq n \\leq 2 \\times 10^9$）。", "outputFormat": "你的程序需要找到所有满足前面所描述条件的 $x$，如果不存在这样的 $x$，你的程序只需输出一行 `None`，否则请按照从小到大的顺序输出这些 $x$，每行一个数。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2007] Password Box", "background": "", "description": "By chance, Little Keke obtained a password box said to contain an ancient treasure map. The box can be opened by cracking the password, and the ancient symbols engraved on the back of the box serve as hints.\n\nAfter painstaking deciphering, Little Keke discovered that these symbols describe a number and its relation to the password. Suppose this number is $n$, and the password is $x$. Then we have: the password $x$ is greater than or equal to $0$ and less than $n$, and the remainder of $x^2$ divided by $n$ is $1$. Little Keke knows there may be more than one $x$ that satisfies these conditions, so she must compute all such $x$; the correct password is among them. The computation is arduous—can you write a program to help?", "inputFormat": "One line containing an integer $n$ ($1 \\leq n \\leq 2 \\times 10^9$).", "outputFormat": "Find all $x$ that satisfy the conditions described above. If no such $x$ exists, output a single line `None`. Otherwise, output these $x$ in increasing order, one per line.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2007] 密码箱", "background": "", "description": "在一次偶然的情况下，小可可得到了一个密码箱，听说里面藏着一份古代流传下来的藏宝图，只要能破解密码就能打开箱子，而箱子背面刻着的古代图标，就是对密码的提示。\n\n经过艰苦的破译，小可可发现，这些图标表示一个数以及这个数与密码的关系。假设这个数是 $n$，密码为 $x$，那么可以得到如下表述： 密码 $x$ 大于等于 $0$，且小于 $n$，而 $x$ 的平方除以 $n$，得到的余数为 $1$。 小可可知道满足上述条件的 $x$ 可能不止一个，所以一定要把所有满足条件的 $x$ 计算出来，密码肯定就在其中。计算的过程是很艰苦的，你能否编写一个程序来帮助小可可呢？", "inputFormat": "一行，一个数字 $n$（$1 \\leq n \\leq 2 \\times 10^9$）。", "outputFormat": "你的程序需要找到所有满足前面所描述条件的 $x$，如果不存在这样的 $x$，你的程序只需输出一行 `None`，否则请按照从小到大的顺序输出这些 $x$，每行一个数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4297", "type": "P", "difficulty": 7, "samples": [["2\n1 0 1 0\n2 2 10 9\n10 1 2\n2 1\n3", "8"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "NOI", "O2优化", "最近公共祖先 LCA", "状压 DP"], "title": "[NOI2006] 网络收费", "background": "noi2006 day1t1", "description": "网络已经成为当今世界不可或缺的一部分。每天都有数以亿计的人使用网络进行学习、科研、娱乐等活动。然而，不可忽视的一点就是网络本身有着庞大的运行费用。所以，向使用网络的人进行适当的收费是必须的，也是合理的。\n\nMY 市 NS 中学就有着这样一个教育网络。网络中的用户一共有 $2^N$ 个，编号依次为 $1,2,3,\\cdots,2^N$。这些用户之间是用路由点和网线组成的。用户、路由点与网线共同构成一个满二叉树结构。树中的每一个叶子结点都是一个用户，每一个非叶子结点（灰色）都是一个路由点，而每一条边都是一条网线（见下图，用户结点中的数字为其编号）。\n\n![](https://cdn.luogu.com.cn/upload/pic/12807.png)\n\nMY 网络公司的网络收费方式比较奇特，称为“配对收费”。即对于每两个用户 $i,j$ $(1\\leq i<j\\leq 2^N)$ 进行收费。由于用户可以自行选择两种付费方式 A、B 中的一种，所以网络公司向学校收取的费用与每一位用户的付费方式有关。该费用等于每两位不同用户配对产生费用之和。\n\n为了描述方便，首先定义这棵网络树上的一些概念：\n\n- 祖先：根结点没有祖先，非根结点的祖先包括它的父亲以及它的父亲的祖先；\n- 管辖叶结点：叶结点本身不管辖任何叶结点，非叶结点管辖它的左儿子所管辖的叶结点与它的右儿子所管辖的叶结点；\n- 距离：在树上连接两个点之间的用边最少的路径所含的边数。\n\n对于任两个用户 $i,j$ $(1\\leq i<j\\leq2^N)$，首先在树上找到与它们距离最近的公共祖先：路由点 $P$，然后观察 $P$ 所管辖的叶结点（即用户）中选择付费方式 A 与 B 的人数，分别记为 $n_A$ 与 $n_B$，接着按照网络管理条例第 X 章第 Y 条第 Z 款进行收费（如下表），其中 $F_{i,j}$ 为 $i$ 和 $j$ 之间的流量，且为已知量。\n\n![](https://cdn.luogu.com.cn/upload/pic/12809.png)\n\n由于最终所付费用与付费方式有关，所以 NS 中学的用户希望能够自行改变自己的付费方式以减少总付费。然而，由于网络公司已经将每个用户注册时所选择的付费方式记录在案，所以对于用户 $i$，如果他/她想改变付费方式（由 A 改为 B 或由 B 改为 A），就必须支付 $C_i$ 元给网络公司以修改档案（修改付费方式记录）。\n\n现在的问题是，给定每个用户注册时所选择的付费方式以及 $C_i$，试求这些用户应该如何选择自己的付费方式以使得 NS 中学支付给网络公司的总费用最少（更改付费方式费用 + 配对收费的费用）。", "inputFormat": "输入文件中第一行有一个正整数 $N$。\n\n第二行有 $2^N$ 个整数，依次表示 $1,2,\\cdots,2^N$ 号用户注册时的付费方式，每一个数字若为 `0`，则表示对应用户的初始付费方式为 A，否则该数字为 `1`，表示付费方式为 B。\n\n第三行有 $2^N$ 个整数，表示每一个用户修改付费方式需要支付的费用，依次为 $C_1,C_2,\\cdots,C_{2^N}$。\n\n以下 $2^N-1$ 行描述给定的两两用户之间的流量表 $F$，总共的第 $i+3$ 行第 $j$ 列的整数为 $F_{i,j+i}$。（$1\\leq i<2^N,1\\leq j\\leq2^N-i$）\n\n所有变量的含义可以参见题目描述。", "outputFormat": "你的程序只需要向输出文件输出一个整数，表示 NS 中学支付给网络公司的最小总费用。（单位：元）", "hint": "【样例说明】\n\n将 $1$ 号用户的付费方式由 B 改为 A，NS 中学支付给网络公司的费用达到最小。\n\n【数据范围】\n\n$40\\%$ 的数据中 $N\\leq4$；\n\n$80\\%$ 的数据中 $N\\leq7$；\n\n$100\\%$ 的数据中 $N\\leq10,0\\leq F_{i,j}\\leq500,0\\leq C_i\\leq500000$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2006] Network Charging", "background": "NOI2006 Day 1 T1.", "description": "The network has become an indispensable part of today’s world. Hundreds of millions of people use the network every day for learning, research, entertainment, and more. However, it is important to note that the network itself has huge operating costs. Therefore, it is necessary and reasonable to charge users appropriately.\n\nNS Middle School in MY City has such an educational network. There are $2^N$ users in the network, numbered $1, 2, 3, \\cdots, 2^N$. These users are connected by router nodes and network cables. The users, router nodes, and network cables together form a full binary tree. Every leaf node of the tree is a user, every non-leaf node (gray) is a router node, and every edge is a network cable (see the figure; the numbers in user nodes are their IDs).\n\nMY Network Company uses an unusual pricing model called “paired charging.” That is, fees are charged for every pair of users $i, j$ with $1 \\leq i < j \\leq 2^N$. Since each user can independently choose one of the two payment plans A or B, the fee the company charges the school depends on each user’s plan. The total fee equals the sum of the fees generated by all pairs of distinct users.\n\nFor convenience, we first define some concepts on this network tree:\n\n- Ancestor: The root node has no ancestors. For a non-root node, its ancestors include its parent and all ancestors of its parent.\n- Covered leaf nodes: A leaf node covers no leaf nodes. A non-leaf node covers the leaf nodes covered by its left child and the leaf nodes covered by its right child.\n- Distance: The number of edges on a shortest path connecting two nodes in the tree.\n\nFor any two users $i, j$ with $1 \\leq i < j \\leq 2^N$, first find their nearest common ancestor (LCA) in the tree: router node $P$. Then, among the leaf nodes (i.e., users) covered by $P$, count how many chose plan A and how many chose plan B, denoted $n_A$ and $n_B$, respectively. Next, the fee is charged according to Article X, Section Y, Clause Z of the Network Management Regulations (see the table below), where $F_{i,j}$ is the traffic between $i$ and $j$, and $F_{i,j}$ is known.\n\nSince the final amount paid depends on the choice of payment plans, users at NS Middle School hope to change their plans to reduce the total payment. However, since the network company has recorded the plan each user chose at registration, user $i$ must pay $C_i$ yuan to the company to modify the record (switch plan A to B or B to A).\n\nNow the problem: given each user’s initial plan and the values $C_i$, determine how these users should choose their plans to minimize the total fee NS Middle School pays to the network company (switching fees + paired charging fees).", "inputFormat": "The first line contains a positive integer $N$.\n\nThe second line contains $2^N$ integers, giving the initial plan of users $1, 2, \\cdots, 2^N$. If a number is `0`, the corresponding user’s initial plan is A; otherwise the number is `1`, meaning plan B.\n\nThe third line contains $2^N$ integers, the switching fee for each user, namely $C_1, C_2, \\cdots, C_{2^N}$.\n\nThe next $2^N - 1$ lines describe the traffic table $F$ between every pair of users. Specifically, in the overall line $i + 3$, the integer in column $j$ equals $F_{i, j + i}$, for $1 \\leq i < 2^N$ and $1 \\leq j \\leq 2^N - i$.\n\nSee the problem statement for the meaning of all variables.", "outputFormat": "Output a single integer: the minimum total fee (in yuan) that NS Middle School pays to the network company.", "hint": "Sample Explanation:\nChanging user $1$ from plan B to plan A yields the minimum total payment.\n\nConstraints:\n- In $40\\%$ of the testdata, $N \\leq 4$.\n- In $80\\%$ of the testdata, $N \\leq 7$.\n- In $100\\%$ of the testdata, $N \\leq 10$, $0 \\leq F_{i,j} \\leq 500$, $0 \\leq C_i \\leq 500000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2006] 网络收费", "background": "noi2006 day1t1", "description": "网络已经成为当今世界不可或缺的一部分。每天都有数以亿计的人使用网络进行学习、科研、娱乐等活动。然而，不可忽视的一点就是网络本身有着庞大的运行费用。所以，向使用网络的人进行适当的收费是必须的，也是合理的。\n\nMY 市 NS 中学就有着这样一个教育网络。网络中的用户一共有 $2^N$ 个，编号依次为 $1,2,3,\\cdots,2^N$。这些用户之间是用路由点和网线组成的。用户、路由点与网线共同构成一个满二叉树结构。树中的每一个叶子结点都是一个用户，每一个非叶子结点（灰色）都是一个路由点，而每一条边都是一条网线（见下图，用户结点中的数字为其编号）。\n\n![](https://cdn.luogu.com.cn/upload/pic/12807.png)\n\nMY 网络公司的网络收费方式比较奇特，称为“配对收费”。即对于每两个用户 $i,j$ $(1\\leq i<j\\leq 2^N)$ 进行收费。由于用户可以自行选择两种付费方式 A、B 中的一种，所以网络公司向学校收取的费用与每一位用户的付费方式有关。该费用等于每两位不同用户配对产生费用之和。\n\n为了描述方便，首先定义这棵网络树上的一些概念：\n\n- 祖先：根结点没有祖先，非根结点的祖先包括它的父亲以及它的父亲的祖先；\n- 管辖叶结点：叶结点本身不管辖任何叶结点，非叶结点管辖它的左儿子所管辖的叶结点与它的右儿子所管辖的叶结点；\n- 距离：在树上连接两个点之间的用边最少的路径所含的边数。\n\n对于任两个用户 $i,j$ $(1\\leq i<j\\leq2^N)$，首先在树上找到与它们距离最近的公共祖先：路由点 $P$，然后观察 $P$ 所管辖的叶结点（即用户）中选择付费方式 A 与 B 的人数，分别记为 $n_A$ 与 $n_B$，接着按照网络管理条例第 X 章第 Y 条第 Z 款进行收费（如下表），其中 $F_{i,j}$ 为 $i$ 和 $j$ 之间的流量，且为已知量。\n\n![](https://cdn.luogu.com.cn/upload/pic/12809.png)\n\n由于最终所付费用与付费方式有关，所以 NS 中学的用户希望能够自行改变自己的付费方式以减少总付费。然而，由于网络公司已经将每个用户注册时所选择的付费方式记录在案，所以对于用户 $i$，如果他/她想改变付费方式（由 A 改为 B 或由 B 改为 A），就必须支付 $C_i$ 元给网络公司以修改档案（修改付费方式记录）。\n\n现在的问题是，给定每个用户注册时所选择的付费方式以及 $C_i$，试求这些用户应该如何选择自己的付费方式以使得 NS 中学支付给网络公司的总费用最少（更改付费方式费用 + 配对收费的费用）。", "inputFormat": "输入文件中第一行有一个正整数 $N$。\n\n第二行有 $2^N$ 个整数，依次表示 $1,2,\\cdots,2^N$ 号用户注册时的付费方式，每一个数字若为 `0`，则表示对应用户的初始付费方式为 A，否则该数字为 `1`，表示付费方式为 B。\n\n第三行有 $2^N$ 个整数，表示每一个用户修改付费方式需要支付的费用，依次为 $C_1,C_2,\\cdots,C_{2^N}$。\n\n以下 $2^N-1$ 行描述给定的两两用户之间的流量表 $F$，总共的第 $i+3$ 行第 $j$ 列的整数为 $F_{i,j+i}$。（$1\\leq i<2^N,1\\leq j\\leq2^N-i$）\n\n所有变量的含义可以参见题目描述。", "outputFormat": "你的程序只需要向输出文件输出一个整数，表示 NS 中学支付给网络公司的最小总费用。（单位：元）", "hint": "【样例说明】\n\n将 $1$ 号用户的付费方式由 B 改为 A，NS 中学支付给网络公司的费用达到最小。\n\n【数据范围】\n\n$40\\%$ 的数据中 $N\\leq4$；\n\n$80\\%$ 的数据中 $N\\leq7$；\n\n$100\\%$ 的数据中 $N\\leq10,0\\leq F_{i,j}\\leq500,0\\leq C_i\\leq500000$。", "locale": "zh-CN"}}}
{"pid": "P4298", "type": "P", "difficulty": 7, "samples": [["4 4\n1 2\n3 4\n3 2\n4 2", "2\n1010\n1011"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "网络流", "Special Judge", "二分图", "构造", "CTSC/CTS"], "title": "[CTSC2008] 祭祀", "background": "", "description": "在遥远的东方，有一个神秘的民族，自称 Y 族。他们世代居住在水面上，奉龙王为神。每逢重大庆典，Y 族都会在水面上举办盛大的祭祀活动。我们可以把 Y 族居住地水系看成一个由岔口和河道组成的网络。每条河道连接着两个岔口，并且水在河道内按照一个固定的方向流动。显然，水系中不会有环流（下图描述一个环流的例子）。\n\n ![](https://cdn.luogu.com.cn/upload/pic/15479.png)\n\n由于人数众多的原因，Y 族的祭祀活动会在多个岔口上同时举行。出于对龙王的尊重，这些祭祀地点的选择必须非常慎重。准确地说，Y 族人认为，如果水流可以从一个祭祀点流到另外一个祭祀点，那么祭祀就会失去它神圣的意义。族长希望在保持祭祀神圣性的基础上，选择尽可能多的祭祀的地点。", "inputFormat": "第一行包含两个用空格隔开的整数 $N$、$M$，分别表示岔口和河道的数目，岔口从 $1$ 到 $N$ 编号。\n\n接下来 $M$ 行，每行包含两个用空格隔开的整数 $u$、$v$，描述一条连接岔口 $u$ 和岔口 $v$ 的河道，水流方向为自 $u$ 向 $v$。", "outputFormat": "第一行包含一个整数 $K$，表示最多能选取的祭祀点的个数。\n\n接下来一行输出一种可行的选取方案。对于每个岔口依次输出一个整数，如果在该岔口设置了祭祀点，那么输出一个 `1`，否则输出一个 `0`。应确保你输出的 `1` 的个数最多，且中间没有空格。\n\n接下来一行输出，在选择最多祭祀点的前提下，每个岔口是否能够设置祭祀点。对于每个岔口依次输出一个整数，如果在该岔口能够设置祭祀点，那么输出一个 `1`，否则输出一个 `0`。\n\n注意：多余的空格和换行可能会导致你的答案被判断为错误答案。", "hint": "$N \\le 100, M \\le 1000$\n\n在样例给出的水系中，不存在一种方法能够选择三个或者三个以上的祭祀点。包含两个祭祀点的测试点的方案有两种：\n\n选择岔口 $1$ 与岔口 $3$（如样例输出第二行），选择岔口 $1$ 与岔口 $4$。\n\n水流可以从任意岔口流至岔口 $2$。如果在岔口 $2$ 建立祭祀点，那么任意其他岔口都不能建立祭祀点但是在最优的一种祭祀点的选取方案中我们可以建立两个祭祀点，所以岔口 $2$ 不能建立祭祀点。对于其他岔口至少存在一个最优方案选择该岔口为祭祀点，所以输出为 `1011`。\n\n感谢@ACdreamer 提供SPJ", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2008] Ritual", "background": "", "description": "In the distant East, there is a mysterious people who call themselves the Y tribe. They have lived on the water for generations and worship the Dragon King as their deity. On major festivals, the Y tribe holds grand ritual ceremonies on the water. We can regard the water system of their habitat as a network composed of junctions and rivers. Each river connects two junctions, and water flows along each river in a fixed direction. Clearly, there is no circular flow in the water system (the figure below shows an example of a circular flow).\n\n![](https://cdn.luogu.com.cn/upload/pic/15479.png)\n\nBecause of their large population, the rituals will be held simultaneously at multiple junctions. Out of respect for the Dragon King, the selection of ritual locations must be very cautious. Specifically, the Y tribespeople believe that if water can flow from one ritual point to another ritual point, the ritual loses its sacred meaning. The chief wants to select as many ritual locations as possible while maintaining sacredness.", "inputFormat": "The first line contains two integers $N$ and $M$ separated by a space, representing the numbers of junctions and rivers, respectively. Junctions are numbered from $1$ to $N$.\n\nEach of the next $M$ lines contains two integers $u$ and $v$ separated by a space, describing a river connecting junction $u$ and junction $v$, with water flowing from $u$ to $v$.", "outputFormat": "The first line contains an integer $K$, the maximum number of junctions that can be selected as ritual points.\n\nThe next line outputs one feasible selection scheme. For each junction in order, output an integer: output `1` if a ritual point is set at this junction, otherwise output `0`. The number of `1`s must be maximum, and there should be no spaces between them.\n\nThe next line outputs, under the premise of selecting the maximum number of ritual points, whether each junction can be chosen as a ritual point in some optimal scheme. For each junction in order, output an integer: output `1` if this junction can be chosen as a ritual point in at least one optimal scheme, otherwise output `0`.\n\nNote: Extra spaces and line breaks may cause your answer to be judged as a Wrong Answer.", "hint": "$N \\le 100$, $M \\le 1000$.\n\nIn the sample water system, there is no way to select three or more ritual points. There are two solutions that contain two ritual points:\n- Choose junction $1$ and junction $3$ (as in the second line of the sample output).\n- Choose junction $1$ and junction $4$.\n\nWater can flow from any junction to junction $2$. If a ritual point is set at junction $2$, then no other junction can host a ritual point. However, in an optimal selection scheme we can set two ritual points, so junction $2$ cannot be chosen as a ritual point. For every other junction, there exists at least one optimal scheme that chooses it, so the output is `1011`.\n\nThanks to @ACdreamer for providing the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2008] 祭祀", "background": "", "description": "在遥远的东方，有一个神秘的民族，自称 Y 族。他们世代居住在水面上，奉龙王为神。每逢重大庆典，Y 族都会在水面上举办盛大的祭祀活动。我们可以把 Y 族居住地水系看成一个由岔口和河道组成的网络。每条河道连接着两个岔口，并且水在河道内按照一个固定的方向流动。显然，水系中不会有环流（下图描述一个环流的例子）。\n\n ![](https://cdn.luogu.com.cn/upload/pic/15479.png)\n\n由于人数众多的原因，Y 族的祭祀活动会在多个岔口上同时举行。出于对龙王的尊重，这些祭祀地点的选择必须非常慎重。准确地说，Y 族人认为，如果水流可以从一个祭祀点流到另外一个祭祀点，那么祭祀就会失去它神圣的意义。族长希望在保持祭祀神圣性的基础上，选择尽可能多的祭祀的地点。", "inputFormat": "第一行包含两个用空格隔开的整数 $N$、$M$，分别表示岔口和河道的数目，岔口从 $1$ 到 $N$ 编号。\n\n接下来 $M$ 行，每行包含两个用空格隔开的整数 $u$、$v$，描述一条连接岔口 $u$ 和岔口 $v$ 的河道，水流方向为自 $u$ 向 $v$。", "outputFormat": "第一行包含一个整数 $K$，表示最多能选取的祭祀点的个数。\n\n接下来一行输出一种可行的选取方案。对于每个岔口依次输出一个整数，如果在该岔口设置了祭祀点，那么输出一个 `1`，否则输出一个 `0`。应确保你输出的 `1` 的个数最多，且中间没有空格。\n\n接下来一行输出，在选择最多祭祀点的前提下，每个岔口是否能够设置祭祀点。对于每个岔口依次输出一个整数，如果在该岔口能够设置祭祀点，那么输出一个 `1`，否则输出一个 `0`。\n\n注意：多余的空格和换行可能会导致你的答案被判断为错误答案。", "hint": "$N \\le 100, M \\le 1000$\n\n在样例给出的水系中，不存在一种方法能够选择三个或者三个以上的祭祀点。包含两个祭祀点的测试点的方案有两种：\n\n选择岔口 $1$ 与岔口 $3$（如样例输出第二行），选择岔口 $1$ 与岔口 $4$。\n\n水流可以从任意岔口流至岔口 $2$。如果在岔口 $2$ 建立祭祀点，那么任意其他岔口都不能建立祭祀点但是在最优的一种祭祀点的选取方案中我们可以建立两个祭祀点，所以岔口 $2$ 不能建立祭祀点。对于其他岔口至少存在一个最优方案选择该岔口为祭祀点，所以输出为 `1011`。\n\n感谢@ACdreamer 提供SPJ", "locale": "zh-CN"}}}
{"pid": "P4299", "type": "P", "difficulty": 6, "samples": [["10 10 \nXor \nQ 1 \nA 10 1 \nA 1 4 \nQ 4 \nQ 10 \nA 7 6 \nXor \nQ 7 \nXor", "11 \n1 \n1 \n1 \n2 \n6 \n2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["二分", "并查集", "动态树 LCT", "树的重心"], "title": "首都", "background": "", "description": "在 X 星球上有 $n$ 个国家，每个国家占据着 X 星球的一座城市，城市从 $1$ 至 $n$ 编号。由于国家之间是敌对关系，所以不同国家的两个城市是不会有公路相连的。\n\nX 星球上战乱频发，如果 A 国打败了 B 国，那么 B 国将永远从这个星球消失，而 B 国的国土也将归 A 国管辖。A 国国王为了加强统治，会在 A 国和 B 国之间修建一条公路，即选择原 A 国的某个城市和 B 国某个城市，修建一条连接这两座城市的公路。\n\n同样为了便于统治自己的国家，国家的首都会选在某个使得其他城市到它距离之和最小的城市，这里的距离是指需要经过公路的条数，如果有多个这样的城市，编号最小的将成为首都。\n\n现在告诉你发生在 X 星球的战事，需要你处理一些关于国家首都的信息，具体地，有如下3种信息需要处理：\n\n- `A x y`：表示某两个国家发生战乱，战胜国选择了 $x$ 城市和 $y$ 城市，在它们之间修建公路（保证其中城市一个在战胜国另一个在战败国）。\n- `Q x`：询问当前编号为 $x$ 的城市所在国家的首都。\n- `Xor`：询问当前所有国家首都编号的异或和。\n", "inputFormat": "输入的第一行有两个整数，分别表示城市数 $n$ 和需要处理的信息数 $m$。\n\n接下来 $m$ 行，每行首先有一个字符串 $op$，表示信息类型，后有若干个整数，其格式如【题目描述】所示。", "outputFormat": "对于每个 `Q` 操作和 `Xor` 操作，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 2 \\times 10^5$，$1 \\leq x, y \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "Capital", "background": "", "description": "On Planet X there are $n$ countries, each occupying exactly one city of Planet X. Cities are numbered from $1$ to $n$. Since countries are hostile to each other, there are no roads between cities of different countries.\n\nWars often break out on Planet X. If country A defeats country B, then B disappears from the planet forever, and B’s territory comes under A’s control. To strengthen governance, the king of A will build a road between A and B: specifically, he chooses one original city of A and one city of B and builds a road connecting these two cities.\n\nTo facilitate governing the country, the capital is chosen as the city that minimizes the sum of distances from all other cities in that country; here, distance means the number of roads traversed. If there are multiple such cities, the one with the smallest index becomes the capital.\n\nYou are given the wars that happen on Planet X and need to process information about capitals. Specifically, there are three types of operations to handle:\n- `A x y`: Two countries go to war. The winner chooses cities $x$ and $y$ and builds a road between them (it is guaranteed that one of the two cities belongs to the winner and the other to the loser).\n- `Q x`: Query the current capital of the country containing city $x$.\n- `Xor`: Query the bitwise XOR of the indices of all current countries’ capitals.", "inputFormat": "The first line contains two integers, the number of cities $n$ and the number of operations $m$.\n\nThen follow $m$ lines. Each line starts with a string $op$ indicating the operation type, followed by several integers, with formats as described in the Description.", "outputFormat": "For each `Q` operation and `Xor` operation, output one line with a single integer as the answer.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq n \\leq 10^5$, $1 \\leq m \\leq 2 \\times 10^5$, and $1 \\leq x, y \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "首都", "background": "", "description": "在 X 星球上有 $n$ 个国家，每个国家占据着 X 星球的一座城市，城市从 $1$ 至 $n$ 编号。由于国家之间是敌对关系，所以不同国家的两个城市是不会有公路相连的。\n\nX 星球上战乱频发，如果 A 国打败了 B 国，那么 B 国将永远从这个星球消失，而 B 国的国土也将归 A 国管辖。A 国国王为了加强统治，会在 A 国和 B 国之间修建一条公路，即选择原 A 国的某个城市和 B 国某个城市，修建一条连接这两座城市的公路。\n\n同样为了便于统治自己的国家，国家的首都会选在某个使得其他城市到它距离之和最小的城市，这里的距离是指需要经过公路的条数，如果有多个这样的城市，编号最小的将成为首都。\n\n现在告诉你发生在 X 星球的战事，需要你处理一些关于国家首都的信息，具体地，有如下3种信息需要处理：\n\n- `A x y`：表示某两个国家发生战乱，战胜国选择了 $x$ 城市和 $y$ 城市，在它们之间修建公路（保证其中城市一个在战胜国另一个在战败国）。\n- `Q x`：询问当前编号为 $x$ 的城市所在国家的首都。\n- `Xor`：询问当前所有国家首都编号的异或和。\n", "inputFormat": "输入的第一行有两个整数，分别表示城市数 $n$ 和需要处理的信息数 $m$。\n\n接下来 $m$ 行，每行首先有一个字符串 $op$，表示信息类型，后有若干个整数，其格式如【题目描述】所示。", "outputFormat": "对于每个 `Q` 操作和 `Xor` 操作，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 2 \\times 10^5$，$1 \\leq x, y \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4300", "type": "P", "difficulty": 6, "samples": [["6 7 \n1 2 1 3 \n2 6 1 5 \n1 3 1 1 \n3 4 1 1 \n4 6 1 1 \n5 6 1 2 \n1 5 1 4", "2\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "各省省选", "安徽"], "title": "[AHOI2006] 上学路线", "background": "", "description": "可可和卡卡家住 HF 市的东郊，每天上学他们都要转车多次才能到达市区西端的学校。直到有一天他们两人参加了学校的信息学奥林匹克竞赛小组才发现每天上学的乘车路线不一定是最优的。\n\n可可：“很可能我们在上学的路途上浪费了大量的时间，让我们写一个程序来计算上学需要的最少时间吧！”\n\nHF 市一共设有 $N$ 个公交车站，不妨将它们编号为 $1\\sim N$ 的自然数，并认为可可和卡卡家住在 $1$ 号汽车站附近，而他们学校在 $N$ 号汽车站。市内有 $M$ 条直达汽车路线，执行第 $i$ 条路线的公交车往返于站点 $p_i$ 和 $q_i$ 之间，从起点到终点需要花费的时间为 $t_i$（$1\\leq i\\leq M$，$1\\leq p_i,q_i\\leq N$）。\n\n两个人坐在电脑前，根据上面的信息很快就编程算出了最优的乘车方案。然而可可忽然有了一个鬼点子，他想趁卡卡不备，在卡卡的输入数据中删去一些路线，从而让卡卡的程序得出的答案大于实际的最短时间。而对于每一条路线 $i$ 事实上都有一个代价 $c_i$：删去路线的 $c_i$ 越大卡卡就越容易发现这个玩笑，可可想知道什么样的删除方案可以达到他的目的而让被删除的公交车路线 $c_i$ 之和最小。\n\n编写一个程序：\n-  从输入文件中读取 HF 市公交路线的信息；\n-  计算出实际上可可和卡卡上学需要花费的最少时间；\n-  帮助可可设计一个方案，删除输入信息中的一些公交路线，使得删除后从家到学校需要的最少时间变大，而被删除路线的 $c_i$ 和最小；\n- 向输出文件输出答案。", "inputFormat": "输入文件中第一行有两个正整数 $N$ 和 $M$，分别表示 HF 市公交车站和公交汽车路线的个数。\n\n以下 $M$ 行，每行（第 $i$ 行，总第 $(i+1)$ 行）用四个正整数描述第 $i$ 条路线：$p_i,q_i,t_i,c_i$，具体含义见上文描述。", "outputFormat": "第一行中仅有一个整数，表示从可可和卡卡家到学校需要的最短时间。 \n\n第二行输出一个整数 $C$，表示 $c_i$ 之和。", "hint": "$2\\leq N\\leq 500$，$1\\leq M\\leq 124750$，$1\\leq t_i,c_i\\leq 10^4$。\n\nHF 市的公交网络十分发达，你可以认为任意两个车站间都可以通过直达或转车互相到达，当然如果在你提供的删除方案中，家和学校无法互相到达，那么则认为上学需要的最短为正无穷大：这显然是一个合法的方案。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2006] School Route", "background": "", "description": "Keke and Kaka live in the eastern suburbs of HF City. Every day, they have to transfer several times to reach their school at the western end of the city. One day, after joining the school's informatics olympiad group, they realized that their daily commuting route might not be optimal.\n\nKeke: \"We might be wasting a lot of time on the way to school. Let's write a program to compute the minimum time needed!\"\n\nHF City has $N$ bus stops, numbered from $1$ to $N$. Assume Keke and Kaka live near stop $1$, and their school is at stop $N$. There are $M$ direct bus routes in the city. For the $i$-th route, buses shuttle back and forth between stops $p_i$ and $q_i$, and the time from one endpoint to the other is $t_i$ ( $1 \\leq i \\leq M$, $1 \\leq p_i, q_i \\leq N$ ).\n\nThey quickly wrote a program to compute the optimal commuting plan. However, Keke suddenly had a mischievous idea: he wanted to delete some routes from Kaka’s input data so that Kaka’s program would output an answer larger than the true shortest time. Each route $i$ has a cost $c_i$: the larger $c_i$ is, the easier it is for Kaka to notice the prank. Keke wants to know how to choose routes to delete so that the minimum time from home to school increases, while the sum of $c_i$ of the deleted routes is minimized.\n\nWrite a program to:\n- Read the bus network of HF City from the input file.\n- Compute the actual minimum time needed for Keke and Kaka to get to school.\n- Help Keke design a deletion plan: remove some bus routes from the input so that the minimum time from home to school becomes larger after deletion, and the sum of $c_i$ of the deleted routes is minimized.\n- Output the answers.", "inputFormat": "The first line contains two positive integers $N$ and $M$, the number of bus stops and direct bus routes in HF City.\n\nEach of the next $M$ lines (the $i$-th of these lines is overall line $(i+1)$) describes the $i$-th route with four positive integers $p_i, q_i, t_i, c_i$, as defined above.", "outputFormat": "The first line contains a single integer, the minimum time needed to travel from Keke and Kaka’s home to their school.\n\nThe second line contains a single integer $C$, the sum of $c_i$ of the deleted routes.", "hint": "$2 \\leq N \\leq 500$, $1 \\leq M \\leq 124750$, $1 \\leq t_i, c_i \\leq 10^4$.\n\nHF City’s bus network is very well connected; you may assume any two stops are mutually reachable via direct routes or transfers. Of course, if under your deletion plan the home and school become disconnected, then the minimum time is considered to be $+\\infty$. This is a valid plan.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2006] 上学路线", "background": "", "description": "可可和卡卡家住 HF 市的东郊，每天上学他们都要转车多次才能到达市区西端的学校。直到有一天他们两人参加了学校的信息学奥林匹克竞赛小组才发现每天上学的乘车路线不一定是最优的。\n\n可可：“很可能我们在上学的路途上浪费了大量的时间，让我们写一个程序来计算上学需要的最少时间吧！”\n\nHF 市一共设有 $N$ 个公交车站，不妨将它们编号为 $1\\sim N$ 的自然数，并认为可可和卡卡家住在 $1$ 号汽车站附近，而他们学校在 $N$ 号汽车站。市内有 $M$ 条直达汽车路线，执行第 $i$ 条路线的公交车往返于站点 $p_i$ 和 $q_i$ 之间，从起点到终点需要花费的时间为 $t_i$（$1\\leq i\\leq M$，$1\\leq p_i,q_i\\leq N$）。\n\n两个人坐在电脑前，根据上面的信息很快就编程算出了最优的乘车方案。然而可可忽然有了一个鬼点子，他想趁卡卡不备，在卡卡的输入数据中删去一些路线，从而让卡卡的程序得出的答案大于实际的最短时间。而对于每一条路线 $i$ 事实上都有一个代价 $c_i$：删去路线的 $c_i$ 越大卡卡就越容易发现这个玩笑，可可想知道什么样的删除方案可以达到他的目的而让被删除的公交车路线 $c_i$ 之和最小。\n\n编写一个程序：\n-  从输入文件中读取 HF 市公交路线的信息；\n-  计算出实际上可可和卡卡上学需要花费的最少时间；\n-  帮助可可设计一个方案，删除输入信息中的一些公交路线，使得删除后从家到学校需要的最少时间变大，而被删除路线的 $c_i$ 和最小；\n- 向输出文件输出答案。", "inputFormat": "输入文件中第一行有两个正整数 $N$ 和 $M$，分别表示 HF 市公交车站和公交汽车路线的个数。\n\n以下 $M$ 行，每行（第 $i$ 行，总第 $(i+1)$ 行）用四个正整数描述第 $i$ 条路线：$p_i,q_i,t_i,c_i$，具体含义见上文描述。", "outputFormat": "第一行中仅有一个整数，表示从可可和卡卡家到学校需要的最短时间。 \n\n第二行输出一个整数 $C$，表示 $c_i$ 之和。", "hint": "$2\\leq N\\leq 500$，$1\\leq M\\leq 124750$，$1\\leq t_i,c_i\\leq 10^4$。\n\nHF 市的公交网络十分发达，你可以认为任意两个车站间都可以通过直达或转车互相到达，当然如果在你提供的删除方案中，家和学校无法互相到达，那么则认为上学需要的最短为正无穷大：这显然是一个合法的方案。", "locale": "zh-CN"}}}
{"pid": "P4301", "type": "P", "difficulty": 5, "samples": [["6\n5 5 6 6 5 5", "21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "博弈论", "2013", "重庆", "各省省选", "线性基", "构造"], "title": "[CQOI2013] 新Nim游戏", "background": "", "description": "传统的 Nim 游戏是这样的：有一些火柴堆，每堆都有若干根火柴（不同堆的火柴数量可以不同）。两个游戏者轮流操作，每次可以选一个火柴堆拿走若干根火柴。可以只拿一根，也可以拿走整堆火柴，但不能同时从超过一堆火柴中拿。拿走最后一根火柴的游戏者胜利。\n\n本题的游戏稍微有些不同：在第一个回合中，双方可以直接拿走若干个整堆的火柴。可以一堆都不拿，但不可以全部拿走。从第二个回合（又轮到第一个游戏者）开始，规则和 Nim 游戏一样。\n\n如果你先拿，怎样才能保证获胜？如果可以获胜的话，还要让第一回合拿的火柴总数尽量小。", "inputFormat": "第一行为整数 $k$，即火柴堆数。\n\n第二行包含 $k$ 个整数 $a_i$，即各堆的火柴个数。\n", "outputFormat": "输出第一回合拿的火柴数目的最小值。如果不能保证取胜，输出 $-1$。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq k \\leq 100$，$1 \\leq a_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2013] New Nim Game", "background": "", "description": "The traditional Nim game is as follows: There are several piles of matches, each pile has some matches (different piles may have different numbers). Two players take turns; on each turn, a player may choose one pile and remove some matches from it. They may remove just one match or the entire pile, but cannot remove matches from more than one pile. The player who takes the last match wins.\n\nThis problem’s game is slightly different: On the first turn, the player may directly remove any number of whole piles. You may remove none, but you may not remove all piles. Starting from the second turn (i.e., when it is the first player’s turn again), the rules are the same as in Nim.\n\nIf you move first, how can you guarantee a win? If a win is possible, you should also minimize the total number of matches taken on the first turn.", "inputFormat": "The first line contains an integer $k$, the number of piles.\n\nThe second line contains $k$ integers $a_i$, the number of matches in each pile.", "outputFormat": "Output the minimum number of matches taken on the first turn. If you cannot guarantee a win, output $-1$.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq k \\leq 100$, $1 \\leq a_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2013] 新Nim游戏", "background": "", "description": "传统的 Nim 游戏是这样的：有一些火柴堆，每堆都有若干根火柴（不同堆的火柴数量可以不同）。两个游戏者轮流操作，每次可以选一个火柴堆拿走若干根火柴。可以只拿一根，也可以拿走整堆火柴，但不能同时从超过一堆火柴中拿。拿走最后一根火柴的游戏者胜利。\n\n本题的游戏稍微有些不同：在第一个回合中，双方可以直接拿走若干个整堆的火柴。可以一堆都不拿，但不可以全部拿走。从第二个回合（又轮到第一个游戏者）开始，规则和 Nim 游戏一样。\n\n如果你先拿，怎样才能保证获胜？如果可以获胜的话，还要让第一回合拿的火柴总数尽量小。", "inputFormat": "第一行为整数 $k$，即火柴堆数。\n\n第二行包含 $k$ 个整数 $a_i$，即各堆的火柴个数。\n", "outputFormat": "输出第一回合拿的火柴数目的最小值。如果不能保证取胜，输出 $-1$。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq k \\leq 100$，$1 \\leq a_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4302", "type": "P", "difficulty": 4, "samples": [["NEERCYESYESYESNEERCYESYESYES", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "搜索", "2003", "四川", "各省省选", "枚举", "区间 DP"], "title": "[SCOI2003] 字符串折叠", "background": null, "description": "折叠的定义如下：\n\n1. 一个字符串可以看成它自身的折叠。记作 ```S = S```\n\n2. ```X(S)``` 是 $X$ 个 ```S``` 连接在一起的串的折叠。记作 ```X(S) = SSSS…S```。\n\n3. 如果 ```A = A’```, ```B = B’```，则 ```AB = A’B’ ```。例如：因为 ```3(A) = AAA```, ```2(B) = BB```，所以 ```3(A)C2(B) = AAACBB```，而 ```2(3(A)C)2(B) = AAACAAACBB```\n\n给一个字符串，求它的最短折叠。\n\n例如 ```AAAAAAAAAABABABCCD``` 的最短折叠为：```9(A)3(AB)CCD```。", "inputFormat": "仅一行，即字符串 `S`，长度保证不超过 $100$。", "outputFormat": "仅一行，即最短的折叠长度。", "hint": "一个最短的折叠为：`2(NEERC3(YES))`\n\n保证 $100 \\%$ 的数据满足字符串 $S$ 由大写字母构成。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2003] String Folding", "background": "", "description": "The definition of folding is as follows:\n\n1. A string can be considered its own folding. Denoted as `S = S`.\n\n2. `X(S)` is the folding of the string formed by concatenating $X$ copies of `S`. Denoted as `X(S) = SSSS…S`.\n\n3. If `A = A'`, `B = B'`, then `AB = A'B'`. For example: since `3(A) = AAA`, `2(B) = BB`, we have `3(A)C2(B) = AAACBB`, and `2(3(A)C)2(B) = AAACAAACBB`.\n\nGiven a string, find its shortest folding.\n\nFor example, the shortest folding of `AAAAAAAAAABABABCCD` is `9(A)3(AB)CCD`.", "inputFormat": "A single line containing the string `S`, whose length does not exceed $100$.", "outputFormat": "A single line containing the length of the shortest folding.", "hint": "One shortest folding is `2(NEERC3(YES))`.\n\nIt is guaranteed that for $100 \\%$ of the testdata, the string `S` consists only of uppercase letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2003] 字符串折叠", "background": null, "description": "折叠的定义如下：\n\n1. 一个字符串可以看成它自身的折叠。记作 ```S = S```\n\n2. ```X(S)``` 是 $X$ 个 ```S``` 连接在一起的串的折叠。记作 ```X(S) = SSSS…S```。\n\n3. 如果 ```A = A’```, ```B = B’```，则 ```AB = A’B’ ```。例如：因为 ```3(A) = AAA```, ```2(B) = BB```，所以 ```3(A)C2(B) = AAACBB```，而 ```2(3(A)C)2(B) = AAACAAACBB```\n\n给一个字符串，求它的最短折叠。\n\n例如 ```AAAAAAAAAABABABCCD``` 的最短折叠为：```9(A)3(AB)CCD```。", "inputFormat": "仅一行，即字符串 `S`，长度保证不超过 $100$。", "outputFormat": "仅一行，即最短的折叠长度。", "hint": "一个最短的折叠为：`2(NEERC3(YES))`\n\n保证 $100 \\%$ 的数据满足字符串 $S$ 由大写字母构成。", "locale": "zh-CN"}}}
{"pid": "P4303", "type": "P", "difficulty": 5, "samples": [["2\n1 1 1 1 1 2 2 2 2 2 \n1 1 1 2 2 2 2 2 1 1 \n", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "各省省选", "树状数组", "安徽", "背包 DP", "栈"], "title": "[AHOI2006] 基因匹配", "background": null, "description": "卡卡昨天晚上做梦梦见他和可可来到了另外一个星球，这个星球上生物的 DNA 序列由无数种碱基排列而成（地球上只有 $4$ 种），而更奇怪的是，组成 DNA 序列的每一种碱基在该序列中正好出现 $5$ 次！这样如果一个 DNA 序列由 $N$ 种不同的碱基构成，那么它的长度一定是 $5N$。 \n\n卡卡醒来后向可可叙述了这个奇怪的梦，而可可这些日子正在研究生物信息学中的基因匹配问题，于是他决定为这个奇怪星球上的生物写一个简单的 DNA 匹配程序。 \n\n为了描述基因匹配的原理，我们需要先定义子序列的概念：若从一个 DNA 序列（字符串）$s$ 中任意抽取一些碱基（字符），将它们仍按在s中的顺序排列成一个新串 $u$，则称 $u$ 是 $s$ 的一个子序列。对于两个 DNA 序列 $s_1$ 和 $s_2$，如果存在一个序列 $u$ 同时成为 $s_1$ 和 $s_2$ 的子序列，则称 $u$ 是 $s_1$ 和 $s_2$ 的公共子序列。 \n\n卡卡已知两个 DNA 序列 $s_1$ 和 $s_2$，求 $s_1$ 和 $s_2$ 的最大匹配就是指 $s_1$ 和 $s_2$ 最长公共子序列的长度。 \n\n[任务] \n编写一个程序： \n- 从输入文件中读入两个等长的 DNA 序列； \n- 计算它们的最大匹配； \n- 向输出文件打印你得到的结果。", "inputFormat": "输入文件中第一行有一个整数 $N$，表示这个星球上某种生物使用了 $N$ 种不同的碱基，以后将它们编号为 $1…N$ 的整数。 \n\n以下还有两行，每行描述一个 DNA 序列：包含 $5N$ 个 $1…N$ 的整数，且每一个整数在对应的序列中正好出现 $5$ 次。", "outputFormat": "输出文件中只有一个整数，即两个 DNA 序列的最大匹配数目。", "hint": "$1 \\leq N \\leq 20000$", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2006] Gene Matching", "background": "", "description": "Kaka dreamed last night that he and Keke arrived on another planet. On this planet, organisms have DNA sequences formed by countless types of bases (on Earth there are only $4$ types). Even stranger, each type of base appears exactly $5$ times in any given DNA sequence. Thus, if a DNA sequence consists of $N$ distinct types of bases, its length must be $5N$.\n\nAfter waking up, Kaka told Keke about this strange dream. Keke has been studying the gene matching problem in bioinformatics, so he decided to write a simple DNA matching program for organisms on this strange planet.\n\nTo describe the principle of gene matching, we first define the concept of a subsequence: if we arbitrarily pick some bases (characters) from a DNA sequence (string) $s$ and arrange them in the same order as in $s$ to form a new string $u$, then $u$ is called a subsequence of $s$. For two DNA sequences $s_1$ and $s_2$, if there exists a sequence $u$ that is a subsequence of both $s_1$ and $s_2$, then $u$ is called a common subsequence of $s_1$ and $s_2$.\n\nGiven two DNA sequences $s_1$ and $s_2$, the maximum match is defined as the length of the longest common subsequence of $s_1$ and $s_2$.\n\n[Task]\nWrite a program to:\n- Read two DNA sequences of equal length from the input file.\n- Compute their maximum match.\n- Print your result to the output file.", "inputFormat": "The first line contains an integer $N$, meaning that a certain organism on this planet uses $N$ distinct types of bases, numbered by the integers $1 \\ldots N$.\n\nThe next two lines each describe a DNA sequence: each contains $5N$ integers in the range $1 \\ldots N$, and every integer appears exactly $5$ times in the corresponding sequence.", "outputFormat": "Output a single integer: the maximum match of the two DNA sequences.", "hint": "$1 \\leq N \\leq 20000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2006] 基因匹配", "background": null, "description": "卡卡昨天晚上做梦梦见他和可可来到了另外一个星球，这个星球上生物的 DNA 序列由无数种碱基排列而成（地球上只有 $4$ 种），而更奇怪的是，组成 DNA 序列的每一种碱基在该序列中正好出现 $5$ 次！这样如果一个 DNA 序列由 $N$ 种不同的碱基构成，那么它的长度一定是 $5N$。 \n\n卡卡醒来后向可可叙述了这个奇怪的梦，而可可这些日子正在研究生物信息学中的基因匹配问题，于是他决定为这个奇怪星球上的生物写一个简单的 DNA 匹配程序。 \n\n为了描述基因匹配的原理，我们需要先定义子序列的概念：若从一个 DNA 序列（字符串）$s$ 中任意抽取一些碱基（字符），将它们仍按在s中的顺序排列成一个新串 $u$，则称 $u$ 是 $s$ 的一个子序列。对于两个 DNA 序列 $s_1$ 和 $s_2$，如果存在一个序列 $u$ 同时成为 $s_1$ 和 $s_2$ 的子序列，则称 $u$ 是 $s_1$ 和 $s_2$ 的公共子序列。 \n\n卡卡已知两个 DNA 序列 $s_1$ 和 $s_2$，求 $s_1$ 和 $s_2$ 的最大匹配就是指 $s_1$ 和 $s_2$ 最长公共子序列的长度。 \n\n[任务] \n编写一个程序： \n- 从输入文件中读入两个等长的 DNA 序列； \n- 计算它们的最大匹配； \n- 向输出文件打印你得到的结果。", "inputFormat": "输入文件中第一行有一个整数 $N$，表示这个星球上某种生物使用了 $N$ 种不同的碱基，以后将它们编号为 $1…N$ 的整数。 \n\n以下还有两行，每行描述一个 DNA 序列：包含 $5N$ 个 $1…N$ 的整数，且每一个整数在对应的序列中正好出现 $5$ 次。", "outputFormat": "输出文件中只有一个整数，即两个 DNA 序列的最大匹配数目。", "hint": "$1 \\leq N \\leq 20000$", "locale": "zh-CN"}}}
{"pid": "P4304", "type": "P", "difficulty": 5, "samples": [["3\n010\n000\n100", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "网络流", "二分图", "天津"], "title": "[TJOI2013] 攻击装置", "background": "", "description": "给定一个 01 矩阵，其中你可以在 0 的位置放置攻击装置。每一个攻击装置 $(x,y)$ 都可以按照“日”字攻击其周围的 $8$ 个位置 $(x-1,y-2)$，$(x-2,y-1)$，$(x+1,y-2)$，$(x+2,y-1)$，$(x-1,y+2)$，$(x-2,y+1)$，$(x+1,y+2)$，$(x+2,y+1)$。\n\n求在装置互不攻击的情况下，最多可以放置多少个装置。", "inputFormat": "第一行一个整数 $N$，表示矩阵大小为 $N \\times N$。\n\n接下来 $N$ 行每一行一个长度 $N$ 的 01 串，表示矩阵。", "outputFormat": "一个整数，表示在装置互不攻击的情况下最多可以放置多少个装置。", "hint": "对于 $30\\%$ 的数据，保证 $N \\le 50$。\n\n对于 $100\\%$ 的数据，保证 $N \\le 200$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2013] Attack Devices", "background": "", "description": "Given a 0-1 matrix, you can place an attack device on any cell with value 0. Each device at $(x,y)$ can attack in a knight’s move the following 8 positions: $(x-1,y-2)$, $(x-2,y-1)$, $(x+1,y-2)$, $(x+2,y-1)$, $(x-1,y+2)$, $(x-2,y+1)$, $(x+1,y+2)$, $(x+2,y+1)$. Find the maximum number of devices that can be placed so that no two devices attack each other.", "inputFormat": "The first line contains an integer $N$, meaning the matrix size is $N \\times N$.  \nThe next $N$ lines each contain a binary string of length $N$, representing the matrix.", "outputFormat": "Output a single integer, the maximum number of devices that can be placed so that no two devices attack each other.", "hint": "For $30\\%$ of the testdata, it is guaranteed that $N \\le 50$.  \nFor $100\\%$ of the testdata, it is guaranteed that $N \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2013] 攻击装置", "background": "", "description": "给定一个 01 矩阵，其中你可以在 0 的位置放置攻击装置。每一个攻击装置 $(x,y)$ 都可以按照“日”字攻击其周围的 $8$ 个位置 $(x-1,y-2)$，$(x-2,y-1)$，$(x+1,y-2)$，$(x+2,y-1)$，$(x-1,y+2)$，$(x-2,y+1)$，$(x+1,y+2)$，$(x+2,y+1)$。\n\n求在装置互不攻击的情况下，最多可以放置多少个装置。", "inputFormat": "第一行一个整数 $N$，表示矩阵大小为 $N \\times N$。\n\n接下来 $N$ 行每一行一个长度 $N$ 的 01 串，表示矩阵。", "outputFormat": "一个整数，表示在装置互不攻击的情况下最多可以放置多少个装置。", "hint": "对于 $30\\%$ 的数据，保证 $N \\le 50$。\n\n对于 $100\\%$ 的数据，保证 $N \\le 200$。", "locale": "zh-CN"}}}
{"pid": "P4305", "type": "P", "difficulty": 2, "samples": [["2\n11\n1 2 18 3 3 19 2 3 6 5 4\n6\n1 2 3 4 5 6\n", "1 2 18 3 19 6 5 4\n1 2 3 4 5 6\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "吉林", "O2优化", "排序", "哈希 hashing", "哈希表"], "title": "[JLOI2011] 不重复数字", "background": "", "description": "给定 $n$ 个数，要求把其中重复的去掉，只保留第一次出现的数。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行一个整数 $n$。\n\n第二行 $n$ 个数，表示给定的数。", "outputFormat": "对于每组数据，输出一行，为去重后剩下的数，两个数之间用一个空格隔开。", "hint": "对于 $30\\%$ 的数据，$n \\le 100$，给出的数 $\\in [0, 100]$。\n\n对于 $60\\%$ 的数据，$n \\le 10^4$，给出的数 $\\in [0, 10^4]$。\n\n对于 $100\\%$ 的数据，$1 \\le T\\le 50$，$1 \\le n \\le 5 \\times 10^4$，给出的数在 $32$ 位有符号整数范围内。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2011] Non-repeating Numbers", "background": "", "description": "Given $n$ numbers, remove the duplicates and keep only the first occurrence of each number.", "inputFormat": "**This problem contains multiple test cases.**\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case:\n\nThe first line contains an integer $n$.\n\nThe second line contains $n$ numbers, which are the given numbers.", "outputFormat": "For each test case, output one line containing the remaining numbers after deduplication, separated by a single space.", "hint": "For $30\\%$ of the testdata, $n \\le 100$, and each given number $\\in [0, 100]$.\n\nFor $60\\%$ of the testdata, $n \\le 10^4$, and each given number $\\in [0, 10^4]$.\n\nFor $100\\%$ of the testdata, $1 \\le T \\le 50$, $1 \\le n \\le 5 \\times 10^4$, and each given number is within the $32$-bit signed integer range.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2011] 不重复数字", "background": "", "description": "给定 $n$ 个数，要求把其中重复的去掉，只保留第一次出现的数。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行一个整数 $n$。\n\n第二行 $n$ 个数，表示给定的数。", "outputFormat": "对于每组数据，输出一行，为去重后剩下的数，两个数之间用一个空格隔开。", "hint": "对于 $30\\%$ 的数据，$n \\le 100$，给出的数 $\\in [0, 100]$。\n\n对于 $60\\%$ 的数据，$n \\le 10^4$，给出的数 $\\in [0, 10^4]$。\n\n对于 $100\\%$ 的数据，$1 \\le T\\le 50$，$1 \\le n \\le 5 \\times 10^4$，给出的数在 $32$ 位有符号整数范围内。", "locale": "zh-CN"}}}
{"pid": "P4306", "type": "P", "difficulty": 3, "samples": [["3\n010\n001\n100", "9"]], "limits": {"time": [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "各省省选", "江苏", "枚举", "图论建模", "连通块", "强连通分量", "bitset", "Floyd 算法"], "title": "[JSOI2010] 连通数", "background": null, "description": "度量一个有向图连通情况的一个指标是连通数，指图中可达顶点对个的个数。\n\n如图\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8jviim6w.png)\n\n顶点 $1$ 可达 $1, 2, 3, 4, 5$\n\n顶点 $2$ 可达 $2, 3, 4, 5$\n\n顶点 $3$ 可达 $3, 4, 5$\n\n顶点 $4, 5$ 都只能到达自身。\n\n所以这张图的连通数为 $14$。\n\n给定一张图，请你求出它的连通数", "inputFormat": "输入数据第一行是图顶点的数量，一个正整数 $N$。  \n接下来 $N$ 行，每行 $N$ 个字符。第 $i$ 行第 $j$ 列的 `1` 表示顶点 $i$ 到 $j$ 有边，`0` 则表示无边。", "outputFormat": "输出一行一个整数，表示该图的连通数。", "hint": "对于 $100 \\%$ 的数据，$1 \\le N \\le 2000$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2010] Reachability Count", "background": "", "description": "A metric for measuring the connectivity of a directed graph is the reachability count, defined as the number of ordered pairs of vertices in which the second is reachable from the first.\n\nAs shown in the figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8jviim6w.png)\n\nVertex 1 can reach 1, 2, 3, 4, 5.\nVertex 2 can reach 2, 3, 4, 5.\nVertex 3 can reach 3, 4, 5.\nVertices 4 and 5 can only reach themselves.\n\nTherefore, the reachability count of this graph is $14$.\n\nGiven a graph, please compute its reachability count.", "inputFormat": "The first line contains the number of vertices, a positive integer $N$.  \nThen follow $N$ lines, each containing $N$ characters. In the $i$-th row and $j$-th column, a `1` indicates there is a directed edge from $i$ to $j$, and `0` indicates no edge.", "outputFormat": "Output a single line with one integer, the reachability count of the graph.", "hint": "For $100\\%$ of the testdata, $1 \\le N \\le 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2010] 连通数", "background": null, "description": "度量一个有向图连通情况的一个指标是连通数，指图中可达顶点对个的个数。\n\n如图\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8jviim6w.png)\n\n顶点 $1$ 可达 $1, 2, 3, 4, 5$\n\n顶点 $2$ 可达 $2, 3, 4, 5$\n\n顶点 $3$ 可达 $3, 4, 5$\n\n顶点 $4, 5$ 都只能到达自身。\n\n所以这张图的连通数为 $14$。\n\n给定一张图，请你求出它的连通数", "inputFormat": "输入数据第一行是图顶点的数量，一个正整数 $N$。  \n接下来 $N$ 行，每行 $N$ 个字符。第 $i$ 行第 $j$ 列的 `1` 表示顶点 $i$ 到 $j$ 有边，`0` 则表示无边。", "outputFormat": "输出一行一个整数，表示该图的连通数。", "hint": "对于 $100 \\%$ 的数据，$1 \\le N \\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P4307", "type": "P", "difficulty": 6, "samples": [["3 3\n1 0 2 1\n1 1 10 1\n0 1 3 3\n1 2\n2 3\n3 1", "43"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "江苏", "图论建模", "费用流"], "title": "[JSOI2009] 球队收益 / 球队预算", "background": "", "description": "在一个篮球联赛里，有$n$支球队，球队的支出是和他们的胜负场次有关系的，具体来说，第i支球队的赛季总支出是$C_i\\times x^2+D_i \\times y^2,D_i \\le C_i$。(赢得多，给球员的奖金就多嘛)\n其中$x,y$分别表示这只球队本赛季的胜负场次。现在赛季进行到了一半，每只球队分别取得了$a_i$场胜利和$b_i$场失利。而接下来还有$m$场比赛要进行。问联盟球队的最小总支出是多少。", "inputFormat": "第一行$n$，$m$\n\n接下来$n$行每行$4$个整数$a_i,b_i,C_i,D_i$\n\n再接下来$m$行每行两个整数$s$，$t$表示第$s$支队伍和第$t$支队伍之间将有一场比赛，注意两只队间可能有多场比赛。", "outputFormat": "一个整数代表总支出的最小值。", "hint": "对于20%的数据$2 \\le n \\le 10,0 \\le m \\le 20$；  \n对于100%的数据$2 \\le n \\le 5000,0 \\le m \\le 1000,0 \\le D_i \\le C_i \\le 10,0 \\le a_i,b_i \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Team Revenue / Team Budget", "background": "", "description": "In a basketball league, there are $n$ teams. A team's expenditure is related to its numbers of wins and losses. Specifically, the season's total expenditure of the $i$-th team is $C_i\\times x^2+D_i \\times y^2,D_i \\le C_i$. (The more you win, the more bonuses you pay to the players.)\n\nNow the season is halfway through. Each team has achieved $a_i$ wins and $b_i$ losses. There are still $m$ games to be played. Find the minimum total expenditure across all teams in the league.", "inputFormat": "The first line contains $n$ and $m$.\n\nEach of the next $n$ lines contains $4$ integers $a_i,b_i,C_i,D_i$.\n\nEach of the next $m$ lines contains two integers $s$, $t$, meaning the $s$-th team and the $t$-th team will play one game. Note that there may be multiple games between the same pair of teams.", "outputFormat": "Print one integer representing the minimum total expenditure.", "hint": "For $20\\%$ of the testdata, $2 \\le n \\le 10,0 \\le m \\le 20$.\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 5000,0 \\le m \\le 1000,0 \\le D_i \\le C_i \\le 10,0 \\le a_i,b_i \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 球队收益 / 球队预算", "background": "", "description": "在一个篮球联赛里，有$n$支球队，球队的支出是和他们的胜负场次有关系的，具体来说，第i支球队的赛季总支出是$C_i\\times x^2+D_i \\times y^2,D_i \\le C_i$。(赢得多，给球员的奖金就多嘛)\n其中$x,y$分别表示这只球队本赛季的胜负场次。现在赛季进行到了一半，每只球队分别取得了$a_i$场胜利和$b_i$场失利。而接下来还有$m$场比赛要进行。问联盟球队的最小总支出是多少。", "inputFormat": "第一行$n$，$m$\n\n接下来$n$行每行$4$个整数$a_i,b_i,C_i,D_i$\n\n再接下来$m$行每行两个整数$s$，$t$表示第$s$支队伍和第$t$支队伍之间将有一场比赛，注意两只队间可能有多场比赛。", "outputFormat": "一个整数代表总支出的最小值。", "hint": "对于20%的数据$2 \\le n \\le 10,0 \\le m \\le 20$；  \n对于100%的数据$2 \\le n \\le 5000,0 \\le m \\le 1000,0 \\le D_i \\le C_i \\le 10,0 \\le a_i,b_i \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P4308", "type": "P", "difficulty": 6, "samples": [["5 5 \n10.0 8.0 8.0 8.0 15.0 \n1 \n0.5 \n1 2 \n2 3 \n3 4 \n4 2 \n4 5", "18.0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "倍增", "枚举", "CTSC/CTS"], "title": "[CTSC2011] 幸福路径", "background": "", "description": "有向图 $G$ 有 $n$ 个顶点 $1, 2, \\cdots, n$，点 $i$ 的权值为 $w(i)$。\n\n现在有一只蚂蚁，从给定的起点 $v_0$ 出发，沿着图 $G$ 的边爬行。开始时，它的体力为 $1$。每爬过一条边，它的体力都会下降为原来的 $\\rho$ 倍，其中 $\\rho$ 是一个给定的小于 $1$ 的正常数。而蚂蚁爬到某个顶点时的幸福度，是它当时的体力与该点权值的乘积。 \n\n我们把蚂蚁在爬行路径上幸福度的总和记为 $H$。很显然，对于不同的爬行路径，$H$ 的值也可能不同。小 Z 对 $H$ 值的最大可能值很感兴趣，你能帮助他计算吗？注意，蚂蚁爬行的路径长度可能是无穷的。", "inputFormat": "每一行中两个数之间用一个空格隔开。 \n\n输入文件第一行包含两个正整数 $n,m$，分别表示 $G$ 中顶点的个数和边的条数。 \n\n第二行包含 $n$ 个非负实数，依次表示 $n$ 个顶点权值  $w(1), w(2), \\cdots, w(n)$。\n\n第三行包含一个正整数 $v_0$，表示给定的起点。\n\n第四行包含一个实数 $\\rho$，表示给定的小于 $1$ 的正常数。 \n\n接下来 $m$ 行，每行两个正整数 $x, y$，表示 $(x, y)$ 是 $G$ 的一条有向边。可能有自环，但不会有重边。", "outputFormat": "仅包含一个实数，即 $H$ 值的最大可能值，四舍五入到小数点后一位。", "hint": "对于 $100\\%$ 的数据，$1\\leq n \\le 100$，$1\\leq m \\le 1000$，$0 < \\rho \\le 1 - 10^{-6}$，$0\\leq w(i) \\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2011] Happy Path", "background": "", "description": "There is a directed graph $G$ with $n$ vertices $1, 2, \\cdots, n$, and the weight of vertex $i$ is $w(i)$.\n\nAn ant starts from a given starting vertex $v_0$ and crawls along the edges of $G$. Initially, its stamina is $1$. Each time it traverses an edge, its stamina is multiplied by $\\rho$, where $\\rho$ is a given positive constant less than $1$. When the ant reaches a vertex, its happiness is the product of its current stamina and the weight of that vertex.\n\nWe denote the total happiness along the crawling path by $H$. Clearly, for different crawling paths, the value of $H$ may differ. Xiao Z is interested in the maximum possible value of $H$. Can you help compute it? Note that the length of the ant’s path may be infinite.", "inputFormat": "Numbers on each line are separated by a single space.\n\nThe first line contains two positive integers $n, m$, the number of vertices and edges in $G$.\n\nThe second line contains $n$ non-negative real numbers, representing the vertex weights $w(1), w(2), \\cdots, w(n)$.\n\nThe third line contains a positive integer $v_0$, the given starting vertex.\n\nThe fourth line contains a real number $\\rho$, the given positive constant less than $1$.\n\nEach of the next $m$ lines contains two positive integers $x, y$, indicating that $(x, y)$ is a directed edge of $G$. Self-loops may exist, but there are no multiple edges.", "outputFormat": "Output a single real number: the maximum possible value of $H$, rounded to one decimal place.", "hint": "For $100\\%$ of the testdata, $1 \\leq n \\le 100$, $1 \\leq m \\le 1000$, $0 < \\rho \\le 1 - 10^{-6}$, $0 \\leq w(i) \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2011] 幸福路径", "background": "", "description": "有向图 $G$ 有 $n$ 个顶点 $1, 2, \\cdots, n$，点 $i$ 的权值为 $w(i)$。\n\n现在有一只蚂蚁，从给定的起点 $v_0$ 出发，沿着图 $G$ 的边爬行。开始时，它的体力为 $1$。每爬过一条边，它的体力都会下降为原来的 $\\rho$ 倍，其中 $\\rho$ 是一个给定的小于 $1$ 的正常数。而蚂蚁爬到某个顶点时的幸福度，是它当时的体力与该点权值的乘积。 \n\n我们把蚂蚁在爬行路径上幸福度的总和记为 $H$。很显然，对于不同的爬行路径，$H$ 的值也可能不同。小 Z 对 $H$ 值的最大可能值很感兴趣，你能帮助他计算吗？注意，蚂蚁爬行的路径长度可能是无穷的。", "inputFormat": "每一行中两个数之间用一个空格隔开。 \n\n输入文件第一行包含两个正整数 $n,m$，分别表示 $G$ 中顶点的个数和边的条数。 \n\n第二行包含 $n$ 个非负实数，依次表示 $n$ 个顶点权值  $w(1), w(2), \\cdots, w(n)$。\n\n第三行包含一个正整数 $v_0$，表示给定的起点。\n\n第四行包含一个实数 $\\rho$，表示给定的小于 $1$ 的正常数。 \n\n接下来 $m$ 行，每行两个正整数 $x, y$，表示 $(x, y)$ 是 $G$ 的一条有向边。可能有自环，但不会有重边。", "outputFormat": "仅包含一个实数，即 $H$ 值的最大可能值，四舍五入到小数点后一位。", "hint": "对于 $100\\%$ 的数据，$1\\leq n \\le 100$，$1\\leq m \\le 1000$，$0 < \\rho \\le 1 - 10^{-6}$，$0\\leq w(i) \\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P4309", "type": "P", "difficulty": 6, "samples": [["3\n0 0 2", "1\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "线段树", "各省省选", "平衡树", "树状数组", "天津"], "title": "[TJOI2013] 最长上升子序列", "background": "", "description": "给定一个序列，初始为空。现在我们将 $1$ 到 $N$ 的数字插入到序列中，每次将一个数字插入到一个特定的位置。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？", "inputFormat": "第一行一个整数 $N$，表示我们要将 $1$ 到 $N$ 插入序列中。\n\n接下是 $N$ 个数字，第 $k$ 个数字 $X_k$，表示我们将 $k$ 插入到位置 $X_k(0\\le X_k\\le k-1,1\\le k\\le N)$\n", "outputFormat": "$N$ 行，第 $i$ 行表示 $i$ 插入 $X_i$ 位置后序列的最长上升子序列的长度是多少。", "hint": "$100\\%$ 的数据 $n\\le10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2013] Longest Increasing Subsequence", "background": "", "description": "You are given a sequence that is initially empty. We will insert the numbers $1$ through $N$ into the sequence, each time inserting one number at a specific position. After each insertion, we want to know the length of the current longest increasing subsequence.", "inputFormat": "The first line contains an integer $N$, indicating that we will insert $1$ through $N$ into the sequence.\n\nThen follow $N$ integers. The $k$-th number $X_k$ indicates that we insert $k$ at position $X_k$ ($0 \\le X_k \\le k - 1$, $1 \\le k \\le N$).", "outputFormat": "Output $N$ lines. The $i$-th line is the length of the longest increasing subsequence after inserting $i$ at position $X_i$.", "hint": "Constraints: For $100\\%$ of the testdata, $N \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2013] 最长上升子序列", "background": "", "description": "给定一个序列，初始为空。现在我们将 $1$ 到 $N$ 的数字插入到序列中，每次将一个数字插入到一个特定的位置。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？", "inputFormat": "第一行一个整数 $N$，表示我们要将 $1$ 到 $N$ 插入序列中。\n\n接下是 $N$ 个数字，第 $k$ 个数字 $X_k$，表示我们将 $k$ 插入到位置 $X_k(0\\le X_k\\le k-1,1\\le k\\le N)$\n", "outputFormat": "$N$ 行，第 $i$ 行表示 $i$ 插入 $X_i$ 位置后序列的最长上升子序列的长度是多少。", "hint": "$100\\%$ 的数据 $n\\le10^5$。", "locale": "zh-CN"}}}
{"pid": "P4310", "type": "P", "difficulty": 4, "samples": [["3\n1 2 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "枚举", "进制", "位运算"], "title": "绝世好题", "background": null, "description": "给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i \\& b_{i-1} \\ne 0 $，其中 $2\\leq i\\leq k$， $\\&$ 表示位运算取与。", "inputFormat": "输入文件共 2 行。\n第一行包括一个整数 $n$。\n第二行包括 $n$ 个整数，第 $i$ 个整数表示 $a_i$。", "outputFormat": "输出文件共一行。\n包括一个整数，表示子序列 $b_i$ 的最长长度。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 100000$，$a_i\\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "A Peerless Problem", "background": "", "description": "Given a sequence $a_i$ of length $n$, find the maximum length $k$ of a subsequence $b_i$ of $a_i$ such that $b_i \\& b_{i-1} \\ne 0$, where $2 \\le i \\le k$, and $\\&$ denotes the bitwise AND operation.", "inputFormat": "The input contains 2 lines.\nThe first line contains an integer $n$.\nThe second line contains $n$ integers, where the $i$-th integer is $a_i$.", "outputFormat": "Output one line containing a single integer, the maximum length of the subsequence $b_i$.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 100000$, $a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "绝世好题", "background": null, "description": "给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i \\& b_{i-1} \\ne 0 $，其中 $2\\leq i\\leq k$， $\\&$ 表示位运算取与。", "inputFormat": "输入文件共 2 行。\n第一行包括一个整数 $n$。\n第二行包括 $n$ 个整数，第 $i$ 个整数表示 $a_i$。", "outputFormat": "输出文件共一行。\n包括一个整数，表示子序列 $b_i$ 的最长长度。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 100000$，$a_i\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4311", "type": "P", "difficulty": 6, "samples": [["4 4 4\n1 1 1 1\n0 1 0 3\n1 4\n2 2\n3 3\n4 3\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "费用流"], "title": "士兵占领", "background": null, "description": "有一个 $M \\times N$ 的棋盘，有的格子是障碍。现在你要选择一些格子来放置一些士兵，一个格子里最多可以放置一个士兵，障碍格里不能放置士兵。我们称这些士兵占领了整个棋盘当满足第 $i$ 行至少放置了 $L_i$ 个士兵，第 $j$ 列至少放置了 $C_j$ 个士兵。现在你的任务是要求使用最少个数的士兵来占领整个棋盘。", "inputFormat": "第一行两个数 $M, N, K$ 分别表示棋盘的行数，列数以及障碍的个数。  \n第二行有 $M$ 个数表示 $L_i$。  \n第三行有 $N$ 个数表示 $C_i$。  \n接下来有 $K$ 行，每行两个数 $X, Y$ 表示 $(X, Y)$ 这个格子是障碍。", "outputFormat": "输出一个数表示最少需要使用的士兵个数。如果无论放置多少个士兵都没有办法占领整个棋盘，输出 `JIONG!`。", "hint": "对于 $100 \\%$ 的数据，$1 \\le M, N \\le 100$，$0 \\le K \\le M \\times N$。", "locale": "zh-CN", "translations": {"en": {"title": "Soldiers Occupy", "background": "", "description": "There is an $M \\times N$ board, and some cells are obstacles. You need to choose some cells to place soldiers. At most one soldier can be placed in a cell, and soldiers cannot be placed in obstacle cells. We say the soldiers occupy the entire board if, for each row $i$, at least $L_i$ soldiers are placed, and for each column $j$, at least $C_j$ soldiers are placed. Your task is to use the fewest number of soldiers to occupy the entire board.", "inputFormat": "The first line contains three integers $M, N, K$, representing the number of rows, the number of columns, and the number of obstacles.  \nThe second line contains $M$ integers representing $L_i$.  \nThe third line contains $N$ integers representing $C_j$.  \nThe next $K$ lines each contain two integers $X, Y$, indicating that cell $(X, Y)$ is an obstacle.", "outputFormat": "Output one integer representing the minimum number of soldiers required. If it is impossible to occupy the entire board no matter how many soldiers are placed, output `JIONG!`.", "hint": "For $100\\%$ of the testdata, $1 \\le M, N \\le 100$, $0 \\le K \\le M \\times N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "士兵占领", "background": null, "description": "有一个 $M \\times N$ 的棋盘，有的格子是障碍。现在你要选择一些格子来放置一些士兵，一个格子里最多可以放置一个士兵，障碍格里不能放置士兵。我们称这些士兵占领了整个棋盘当满足第 $i$ 行至少放置了 $L_i$ 个士兵，第 $j$ 列至少放置了 $C_j$ 个士兵。现在你的任务是要求使用最少个数的士兵来占领整个棋盘。", "inputFormat": "第一行两个数 $M, N, K$ 分别表示棋盘的行数，列数以及障碍的个数。  \n第二行有 $M$ 个数表示 $L_i$。  \n第三行有 $N$ 个数表示 $C_i$。  \n接下来有 $K$ 行，每行两个数 $X, Y$ 表示 $(X, Y)$ 这个格子是障碍。", "outputFormat": "输出一个数表示最少需要使用的士兵个数。如果无论放置多少个士兵都没有办法占领整个棋盘，输出 `JIONG!`。", "hint": "对于 $100 \\%$ 的数据，$1 \\le M, N \\le 100$，$0 \\le K \\le M \\times N$。", "locale": "zh-CN"}}}
{"pid": "P4312", "type": "P", "difficulty": 6, "samples": [["5\n4 2 4 5 6\n10\nexcursion 1 1\nexcursion 1 2\nbridge 1 2\nexcursion 1 2\nbridge 3 4\nbridge 3 5\nexcursion 4 5\nbridge 1 3\nexcursion 2 4\nexcursion 2 5", "4\nimpossible\nyes\n6\nyes\nyes\n15\nyes\n15\n16"], ["6\n1 2 3 4 5 6\n10\nbridge 1 2\nbridge 2 3\nbridge 4 5\nexcursion 1 3\nexcursion 1 5\nbridge 3 4\nexcursion 1 5\npenguins 3 10\nexcursion 1 3\nbridge 1 5", "yes\nyes\nyes\n6\nimpossible\nyes\n15\n13\nno"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "树状数组", "树链剖分", "动态树 LCT", "COI（克罗地亚）"], "title": "[COI 2009] OTOCI", "background": "注：本题原题通过**交互**的形式强制在线。但是在本题您不需要考虑交互的问题。", "description": "不久之前，Mirko 建立了一个旅行社，名叫“极地之梦”。这家旅行社在北极附近购买了 $n$ 座冰岛，并且提供观光服务。\n\n当地最受欢迎的当然是帝企鹅了，这些小家伙经常成群结队的游走在各个冰岛之间。Mirko 的旅行社遭受一次重大打击，以至于观光游轮已经不划算了。旅行社将在冰岛之间建造大桥，并用观光巴士来运载游客。\n\nMirko 希望开发一个电脑程序来管理这些大桥的建造过程，以免有不可预料的错误发生。这些冰岛从1到N标号。一开始时这些岛屿没有大桥连接，并且所有岛上的帝企鹅数量都是知道的。每座岛上的企鹅数量虽然会有所改变，但是始终在 $[0, 1000]$ 之间。你的程序需要处理以下三种命令：  \n\n- `bridge u v`：询问结点 $u$ 与结点 $v$ 是否连通。如果是则输出 `no`；否则输出 `yes`，并且在结点 $u$ 和结点 $v$ 之间连一条无向边。 \n- `penguins u x`：将结点 $u$ 对应的权值 $w_u$ 修改为 $x$。 \n- `excursion u v`：如果结点 $u$ 和结点 $v$ 不连通，则输出 `impossible`。否则输出结点 $u$ 到结点 $v$ 的路径上的点对应的权值的和。 \n\n共有 $q$ 个操作。\n", "inputFormat": "第一行包含一个整数 $n$，表示节点的数目。 \n\n第二行包含 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个节点初始时的权值 $w_i$。 \n\n第三行包含一个整数 $q$，表示操作的数目。 \n\n以下 $q$ 行，每行包含一个操作，操作的类别见题目描述。", "outputFormat": "输出所有 `bridge` 操作和 `excursion` 操作对应的输出，每个一行表示答案。\n\n", "hint": "【数据范围】   \n对于 $100\\%$ 的数据，$1 \\le n \\le 3 \\times 10^4$，$1 \\le q \\le 3\\times 10^5$, $0 \\le w_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[COI 2009] OTOCI", "background": "Note: The original problem is interactive and enforces online processing. In this version, you do not need to consider interaction.", "description": "Not long ago, Mirko founded a travel agency called “Polar Dream.” The agency bought $n$ islands near the Arctic and offers sightseeing services.\n\nThe most popular attraction is, of course, the emperor penguins. These little fellows often move in groups between the islands. Mirko’s agency suffered a major setback, making cruise tours no longer cost-effective. The agency will build bridges between islands and use sightseeing buses to carry tourists.\n\nMirko wants to develop a computer program to manage the bridge-building process to avoid unexpected errors. The islands are labeled from $1$ to $n$. Initially, there are no bridges between islands, and the number of emperor penguins on each island is known. Although the number on each island may change, it is always within $[0, 1000]$. Your program must process the following three commands:\n\n- `bridge u v`: Ask whether nodes $u$ and $v$ are connected. If they are, output `no`; otherwise output `yes`, and add an undirected edge between $u$ and $v$.\n- `penguins u x`: Set the weight $w_u$ of node $u$ to $x$.\n- `excursion u v`: If nodes $u$ and $v$ are not connected, output `impossible`. Otherwise, output the sum of the weights of the nodes on the path from $u$ to $v$.\n\nThere are $q$ operations in total.", "inputFormat": "- The first line contains an integer $n$, the number of nodes.\n- The second line contains $n$ integers; the $i$-th integer is the initial weight $w_i$ of node $i$.\n- The third line contains an integer $q$, the number of operations.\n- Each of the next $q$ lines contains one operation as described above.", "outputFormat": "Output the results of all `bridge` and `excursion` operations, one answer per line.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 3 \\times 10^4$, $1 \\le q \\le 3 \\times 10^5$, $0 \\le w_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COI 2009] OTOCI", "background": "注：本题原题通过**交互**的形式强制在线。但是在本题您不需要考虑交互的问题。", "description": "不久之前，Mirko 建立了一个旅行社，名叫“极地之梦”。这家旅行社在北极附近购买了 $n$ 座冰岛，并且提供观光服务。\n\n当地最受欢迎的当然是帝企鹅了，这些小家伙经常成群结队的游走在各个冰岛之间。Mirko 的旅行社遭受一次重大打击，以至于观光游轮已经不划算了。旅行社将在冰岛之间建造大桥，并用观光巴士来运载游客。\n\nMirko 希望开发一个电脑程序来管理这些大桥的建造过程，以免有不可预料的错误发生。这些冰岛从1到N标号。一开始时这些岛屿没有大桥连接，并且所有岛上的帝企鹅数量都是知道的。每座岛上的企鹅数量虽然会有所改变，但是始终在 $[0, 1000]$ 之间。你的程序需要处理以下三种命令：  \n\n- `bridge u v`：询问结点 $u$ 与结点 $v$ 是否连通。如果是则输出 `no`；否则输出 `yes`，并且在结点 $u$ 和结点 $v$ 之间连一条无向边。 \n- `penguins u x`：将结点 $u$ 对应的权值 $w_u$ 修改为 $x$。 \n- `excursion u v`：如果结点 $u$ 和结点 $v$ 不连通，则输出 `impossible`。否则输出结点 $u$ 到结点 $v$ 的路径上的点对应的权值的和。 \n\n共有 $q$ 个操作。\n", "inputFormat": "第一行包含一个整数 $n$，表示节点的数目。 \n\n第二行包含 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个节点初始时的权值 $w_i$。 \n\n第三行包含一个整数 $q$，表示操作的数目。 \n\n以下 $q$ 行，每行包含一个操作，操作的类别见题目描述。", "outputFormat": "输出所有 `bridge` 操作和 `excursion` 操作对应的输出，每个一行表示答案。\n\n", "hint": "【数据范围】   \n对于 $100\\%$ 的数据，$1 \\le n \\le 3 \\times 10^4$，$1 \\le q \\le 3\\times 10^5$, $0 \\le w_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P4313", "type": "P", "difficulty": 6, "samples": [["3 4\n13 2 4 13\n7 13 8 12\n18 17 0 5\n8 13 15 4\n11 3 8 11\n11 18 6 5\n1 2 3 4 \n4 2 3 2\n3 1 0 4\n3 2 3 2\n0 2 2 1\n0 2 4 4 ", "152"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["网络流", "图论建模", "最小割"], "title": "文理分科", "background": "", "description": "文理分科是一件很纠结的事情！（虽然看到这个题目的人肯定都没有纠结过）\n\n小 P 所在的班级要进行文理分科。他的班级可以用一个 $n\\times m$ 的矩阵进行描述，每个格子代表一个同学的座位。每位同学必须从文科和理科中选择一科。同学们在选择科目的时候会获得一个满意值。满意值按如下的方式得到：\n\n- 如果第 $i$ 行第 $j$ 列的同学选择了文科，则他将获得 $art_{i,j}$ 的满意值，如果选择理科，将得到 $science_{i,j}$ 的满意值。\n\n- 如果第 $i$ 行第 $j$ 列的同学选择了文科，并且他相邻（两个格子相邻当且仅当它们拥有一条相同的边）的同学全部选择了文科，则他会更开心，所以会增加 $same\\text{\\underline{ }}art_{i,j}$ 的满意值。\n\n- 如果第 $i$ 行第 $j$ 列的同学选择了理科，并且他相邻的同学全部选择了理科，则增加 $same\\text{\\underline{ }}science_{i,j}$ 的满意值。\n\n小 P 想知道，大家应该如何选择，才能使所有人的满意值之和最大。请告诉他这个最大值。", "inputFormat": "输入第一行为两个正整数 $n,m$。  \n接下来 $n$ 行 $m$ 个整数，第 $i$ 行第 $j$ 个整数表示 $art_{i,j}$；  \n接下来 $n$ 行 $m$ 个整数，第 $i$ 行第 $j$ 个整数表示 $science_{i,j}$；  \n接下来 $n$ 行 $m$ 个整数，第 $i$ 行第 $j$ 个整数表示 $same\\text{\\underline{ }}art_{i,j}$；  \n接下来 $n$ 行 $m$ 个整数，第 $i$ 行第 $j$ 个整数表示 $same\\text{\\underline{ }}science_{i,j}$。", "outputFormat": "输出为一个整数，表示最大的满意值之和。", "hint": "### 样例说明\n\n1 表示选择文科，0 表示选择理科，方案如下：\n\n1  0  0  1\n\n0  1  0  0\n\n1  0  0  0\n\n### 数据范围\n\n$n,m\\leq 100$，读入数据均 $\\leq 500$。                                                                                                                                                              ", "locale": "zh-CN", "translations": {"en": {"title": "Arts or Science", "background": "", "description": "Choosing between arts and science is a very frustrating thing. (Although people who see this problem surely have never been frustrated about it.)\n\nStudent P's class is going to split into arts and science. The class can be described by an $n\\times m$ matrix, where each cell represents a student's seat. Every student must choose exactly one subject: arts or science. Students will gain a satisfaction value based on their choices, computed as follows:\n\n- If the student at row $i$, column $j$ chooses arts, they gain $art_{i,j}$ satisfaction; if they choose science, they gain $science_{i,j}$.\n\n- If the student at row $i$, column $j$ chooses arts, and all of their adjacent classmates (two cells are adjacent if and only if they share a common edge) also choose arts, then they will be happier, so an additional $same\\text{\\underline{ }}art_{i,j}$ satisfaction is added.\n\n- If the student at row $i$, column $j$ chooses science, and all of their adjacent classmates also choose science, then an additional $same\\text{\\underline{ }}science_{i,j}$ satisfaction is added.\n\nStudent P wants to know how everyone should choose in order to maximize the total satisfaction of all students. Please output this maximum value.", "inputFormat": "The first line contains two positive integers $n,m$.  \nThe next $n$ lines each contain $m$ integers; the integer in row $i$, column $j$ represents $art_{i,j}$.  \nThe next $n$ lines each contain $m$ integers; the integer in row $i$, column $j$ represents $science_{i,j}$.  \nThe next $n$ lines each contain $m$ integers; the integer in row $i$, column $j$ represents $same\\text{\\underline{ }}art_{i,j}$.  \nThe next $n$ lines each contain $m$ integers; the integer in row $i$, column $j$ represents $same\\text{\\underline{ }}science_{i,j}$.", "outputFormat": "Output a single integer, representing the maximum total satisfaction.", "hint": "### Sample Explanation\n\n$1$ means choosing arts, and $0$ means choosing science. One possible plan is as follows:\n\n1  0  0  1\n\n0  1  0  0\n\n1  0  0  0\n\n### Constraints\n\n$n,m\\leq 100$, and all input values are $\\leq 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "文理分科", "background": "", "description": "文理分科是一件很纠结的事情！（虽然看到这个题目的人肯定都没有纠结过）\n\n小 P 所在的班级要进行文理分科。他的班级可以用一个 $n\\times m$ 的矩阵进行描述，每个格子代表一个同学的座位。每位同学必须从文科和理科中选择一科。同学们在选择科目的时候会获得一个满意值。满意值按如下的方式得到：\n\n- 如果第 $i$ 行第 $j$ 列的同学选择了文科，则他将获得 $art_{i,j}$ 的满意值，如果选择理科，将得到 $science_{i,j}$ 的满意值。\n\n- 如果第 $i$ 行第 $j$ 列的同学选择了文科，并且他相邻（两个格子相邻当且仅当它们拥有一条相同的边）的同学全部选择了文科，则他会更开心，所以会增加 $same\\text{\\underline{ }}art_{i,j}$ 的满意值。\n\n- 如果第 $i$ 行第 $j$ 列的同学选择了理科，并且他相邻的同学全部选择了理科，则增加 $same\\text{\\underline{ }}science_{i,j}$ 的满意值。\n\n小 P 想知道，大家应该如何选择，才能使所有人的满意值之和最大。请告诉他这个最大值。", "inputFormat": "输入第一行为两个正整数 $n,m$。  \n接下来 $n$ 行 $m$ 个整数，第 $i$ 行第 $j$ 个整数表示 $art_{i,j}$；  \n接下来 $n$ 行 $m$ 个整数，第 $i$ 行第 $j$ 个整数表示 $science_{i,j}$；  \n接下来 $n$ 行 $m$ 个整数，第 $i$ 行第 $j$ 个整数表示 $same\\text{\\underline{ }}art_{i,j}$；  \n接下来 $n$ 行 $m$ 个整数，第 $i$ 行第 $j$ 个整数表示 $same\\text{\\underline{ }}science_{i,j}$。", "outputFormat": "输出为一个整数，表示最大的满意值之和。", "hint": "### 样例说明\n\n1 表示选择文科，0 表示选择理科，方案如下：\n\n1  0  0  1\n\n0  1  0  0\n\n1  0  0  0\n\n### 数据范围\n\n$n,m\\leq 100$，读入数据均 $\\leq 500$。                                                                                                                                                              ", "locale": "zh-CN"}}}
{"pid": "P4314", "type": "P", "difficulty": 6, "samples": [["10\n-62 -83 -9 -70 79 -78 -31 40 -18 -5 \n20\nA 2 7\nA 4 4\nQ 4 4\nP 2 2 -74\nP 7 9 -71\nP 7 10 -8\nA 10 10\nA 5 9\nC 1 8 10\nQ 6 6\nQ 8 10\nA 1 7\nP 9 9 96\nA 5 5\nP 8 10 -53\nP 6 6 5\nA 10 10\nA 4 4\nQ 1 5\nP 4 9 -69", "79\n-70\n-70\n-5\n79\n10\n10\n79\n79\n-5\n10\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["线段树", "矩阵乘法"], "title": "CPU 监控", "background": "Bob 家的机子很烂……真的很烂……\n\n以至于看视频或者跑邪恶的暴力程序的时候，由于 CPU 使用率持续过高而宕机。", "description": "Bob 需要一个程序来监视 CPU 使用率。这是一个很繁琐的过程，为了让问题更加简单，Bob 会慢慢列出今天会在用计算机时做什么事。 \n\nBob 会干很多事，除了跑暴力程序看视频之外，还会做出去玩玩和用鼠标乱点之类的事，甚至会一脚踢掉电源……这些事有的会让做这件事的这段时间内 CPU 使用率增加或减少一个值；有的事还会直接让 CPU 使用率变为一个值。 \n\n当然 Bob 会询问：在之前给出的事件影响下，CPU 在某段时间内，使用率最高是多少。有时候 Bob 还会好奇地询问，在某段时间内 CPU 曾经的最高使用率是多少。 \n\n为了使计算精确，使用率不用百分比而用一个整数表示。 \n\n不保证 Bob 的事件列表没有出莫名的问题，使得使用率为负………………", "inputFormat": "第一行一个正整数 $T$，表示 Bob 需要监视 CPU 的总时间。 \n\n然后第二行给出 $T$ 个数表示在你的监视程序执行之前，Bob 干的事让 CPU 在这段时间内每个时刻的使用率达已经达到了多少。 \n\n第三行给出一个整数 $E$，表示 Bob 需要做的事和询问的总数。 \n\n接下来 $E$ 行每行表示给出一个询问或者列出一条事件： \n\n- `Q X Y`：询问从 $X$ 到 $Y$ 这段时间内 CPU 最高使用率。\n- `A X Y`：询问从 $X$ 到 $Y$ 这段时间内之前列出的事件使 CPU 达到过的最高使用率。\n- `P X Y Z`：列出一个事件这个事件使得从 $X$ 到 $Y$ 这段时间内 CPU 使用率增加 $Z$。\n- `C X Y Z`：列出一个事件这个事件使得从 $X$ 到 $Y$ 这段时间内 CPU 使用率变为 $Z$。\n\n时间的单位为秒，使用率没有单位。 \n\n$X$ 和 $Y$ 均为正整数（$X\\le Y$），$Z$ 为一个整数。 \n\n从 $X$ 到 $Y$ 这段时间包含第 $X$ 秒和第 $Y$ 秒。 \n\n保证必要运算在有符号 32 位整数以内。", "outputFormat": "对于每个询问，输出一行一个整数回答。", "hint": "数据分布如下： \n\n第 $1,2$ 个数据保证 $T$ 和 $E$ 均小于等于 $10^3$。 \n\n第 $3,4$ 个数据保证只有 `Q` 类询问。\n\n第 $5,6$ 个数据保证只有 `C` 类事件。\n\n第 $7,8$ 个数据保证只有 `P` 类事件。\n\n对于 $100\\%$ 的数据，$1\\le T,E\\le 10^5$，$1\\le X\\le Y\\le T$，$-2^{31}\\leq Z\\lt 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "CPU Monitoring", "background": "Bob's machine is terrible... really terrible... to the point that when watching videos or running evil brute-force programs, it crashes due to sustained high CPU usage.", "description": "Bob needs a program to monitor CPU usage. This is a tedious task. To make it simpler, Bob will gradually list what he will do today while using the computer.\n\nBob does many things. Besides running brute-force programs and watching videos, he also goes out to play, randomly clicks the mouse, and might even kick out the power cord. Some actions increase or decrease the CPU usage by a value during the time they are performed; some actions directly set the CPU usage to a specific value.\n\nOf course, Bob will ask: under the influence of the previously listed events, what is the maximum CPU usage in a certain time interval. Sometimes Bob will also curiously ask: in a certain time interval, what is the highest CPU usage that has ever been reached.\n\nTo be precise, usage is represented by an integer instead of a percentage.\n\nIt is not guaranteed that Bob's event list is free of weird issues that could make the usage negative...\n\n# Description", "inputFormat": "The first line contains a positive integer $T$, the total time Bob needs to monitor the CPU.\n\nThe second line contains $T$ numbers indicating, before your monitoring program starts, the CPU usage that has already been reached at each moment within this time span.\n\nThe third line contains an integer $E$, the total number of actions and queries Bob will perform.\n\nEach of the next $E$ lines is either a query or an event:\n- `Q X Y`: Query the maximum current CPU usage from $X$ to $Y$ (under the effects of all events listed so far).\n- `A X Y`: Query the highest CPU usage that has ever been reached from $X$ to $Y$ (over the entire history up to now).\n- `P X Y Z`: List an event that increases the CPU usage by $Z$ from $X$ to $Y$.\n- `C X Y Z`: List an event that sets the CPU usage to $Z$ from $X$ to $Y$.\n\nTime is measured in seconds, and usage has no unit.\n\n$X$ and $Y$ are positive integers ($X\\le Y$), and $Z$ is an integer.\n\nThe interval from $X$ to $Y$ is inclusive of second $X$ and second $Y$.\n\nIt is guaranteed that all necessary operations fit within 32-bit signed integers.", "outputFormat": "For each query, output one integer on its own line as the answer.", "hint": "The testdata is distributed as follows:\n- In testdata 1 and 2, $T$ and $E$ are both at most $10^3$.\n- In testdata 3 and 4, there are only `Q` queries.\n- In testdata 5 and 6, there are only `C` events.\n- In testdata 7 and 8, there are only `P` events.\n\nFor $100\\%$ of the testdata, $1\\le T,E\\le 10^5$, $1\\le X\\le Y\\le T$, $-2^{31}\\leq Z\\lt 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "CPU 监控", "background": "Bob 家的机子很烂……真的很烂……\n\n以至于看视频或者跑邪恶的暴力程序的时候，由于 CPU 使用率持续过高而宕机。", "description": "Bob 需要一个程序来监视 CPU 使用率。这是一个很繁琐的过程，为了让问题更加简单，Bob 会慢慢列出今天会在用计算机时做什么事。 \n\nBob 会干很多事，除了跑暴力程序看视频之外，还会做出去玩玩和用鼠标乱点之类的事，甚至会一脚踢掉电源……这些事有的会让做这件事的这段时间内 CPU 使用率增加或减少一个值；有的事还会直接让 CPU 使用率变为一个值。 \n\n当然 Bob 会询问：在之前给出的事件影响下，CPU 在某段时间内，使用率最高是多少。有时候 Bob 还会好奇地询问，在某段时间内 CPU 曾经的最高使用率是多少。 \n\n为了使计算精确，使用率不用百分比而用一个整数表示。 \n\n不保证 Bob 的事件列表没有出莫名的问题，使得使用率为负………………", "inputFormat": "第一行一个正整数 $T$，表示 Bob 需要监视 CPU 的总时间。 \n\n然后第二行给出 $T$ 个数表示在你的监视程序执行之前，Bob 干的事让 CPU 在这段时间内每个时刻的使用率达已经达到了多少。 \n\n第三行给出一个整数 $E$，表示 Bob 需要做的事和询问的总数。 \n\n接下来 $E$ 行每行表示给出一个询问或者列出一条事件： \n\n- `Q X Y`：询问从 $X$ 到 $Y$ 这段时间内 CPU 最高使用率。\n- `A X Y`：询问从 $X$ 到 $Y$ 这段时间内之前列出的事件使 CPU 达到过的最高使用率。\n- `P X Y Z`：列出一个事件这个事件使得从 $X$ 到 $Y$ 这段时间内 CPU 使用率增加 $Z$。\n- `C X Y Z`：列出一个事件这个事件使得从 $X$ 到 $Y$ 这段时间内 CPU 使用率变为 $Z$。\n\n时间的单位为秒，使用率没有单位。 \n\n$X$ 和 $Y$ 均为正整数（$X\\le Y$），$Z$ 为一个整数。 \n\n从 $X$ 到 $Y$ 这段时间包含第 $X$ 秒和第 $Y$ 秒。 \n\n保证必要运算在有符号 32 位整数以内。", "outputFormat": "对于每个询问，输出一行一个整数回答。", "hint": "数据分布如下： \n\n第 $1,2$ 个数据保证 $T$ 和 $E$ 均小于等于 $10^3$。 \n\n第 $3,4$ 个数据保证只有 `Q` 类询问。\n\n第 $5,6$ 个数据保证只有 `C` 类事件。\n\n第 $7,8$ 个数据保证只有 `P` 类事件。\n\n对于 $100\\%$ 的数据，$1\\le T,E\\le 10^5$，$1\\le X\\le Y\\le T$，$-2^{31}\\leq Z\\lt 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P4315", "type": "P", "difficulty": 5, "samples": [["4\n1 2 8\n1 3 7\n3 4 9\nMax 2 4\nCover 2 4 5\nAdd 1 4 10\nChange 1 16\nMax 2 4\nStop", "9\n16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["线段树", "最近公共祖先 LCA", "树链剖分"], "title": "月下“毛景树”", "background": "毛毛虫经过及时的变形，最终逃过的一劫，离开了菜妈的菜园。毛毛虫经过千山万水，历尽千辛万苦，最后来到了小小的绍兴一中的校园里。", "description": "爬啊爬~爬啊爬~~毛毛虫爬到了一颗小小的“毛景树”下面，发现树上长着他最爱吃的毛毛果~~~ “毛景树”上有 $N$ 个节点和 $N-1$ 条树枝，但节点上是没有毛毛果的，毛毛果都是长在树枝上的。但是这棵“毛景树”有着神奇的魔力，他能改变树枝上毛毛果的个数：\n\n- `Change k w`：将第 $k$ 条树枝上毛毛果的个数改变为 $w$ 个。\n- `Cover u v w`：将节点 $u$ 与节点 $v$ 之间的树枝上毛毛果的个数都改变为 $w$ 个。\n- `Add u v w`：将节点 $u$ 与节点 $v$ 之间的树枝上毛毛果的个数都增加 $w$ 个。\n\n由于毛毛虫很贪，于是他会有如下询问：\n\n-  `Max u v`：询问节点 $u$ 与节点 $v$ 之间树枝上毛毛果个数最多有多少个。", "inputFormat": "第一行一个正整数 $N$。\n\n接下来 $N-1$ 行，每行三个正整数 $U_i,V_i$ 和 $W_i$，第 $i+1$ 行描述第 $i$ 条树枝。表示第 $i$ 条树枝连接节点 $U_i$ 和节点 $V_i$，树枝上有 $W_i$ 个毛毛果。 接下来是操作和询问，以 `Stop` 结束。", "outputFormat": "对于毛毛虫的每个询问操作，输出一个答案。", "hint": "对于全部数据，$1\\le N\\le 10^5$，操作和询问数目不超过 $10^5$。\n\n保证在任意时刻，所有树枝上毛毛果的个数都不会超过 $10^9$ 个。", "locale": "zh-CN", "translations": {"en": {"title": "Moonlit \"Maojing Tree\"", "background": "After a timely transformation, the caterpillar narrowly escaped and left the vegetable garden. It traveled over mountains and rivers, through countless hardships, and finally arrived at the campus of Shaoxing No. 1 High School.", "description": "Crawl, crawl~ crawl, crawl~~ The caterpillar crawled under a small \"Maojing Tree\" and found that it bore its favorite maomao fruits. The \"Maojing Tree\" has $N$ nodes and $N-1$ edges. There are no maomao fruits on the nodes; all maomao fruits grow on the edges. This \"Maojing Tree\" has magical power: it can change the number of maomao fruits on its edges:\n\n- `Change k w`: Set the number of maomao fruits on the $k$-th edge to $w$.\n- `Cover u v w`: Set the number of maomao fruits on every edge along the path between nodes $u$ and $v$ to $w$.\n- `Add u v w`: Increase by $w$ the number of maomao fruits on every edge along the path between nodes $u$ and $v$.\n\nSince the caterpillar is greedy, it will ask the following query:\n\n- `Max u v`: Query the maximum number of maomao fruits among all edges along the path between nodes $u$ and $v$.", "inputFormat": "The first line contains a positive integer $N$.\n\nThe next $N-1$ lines each contain three positive integers $U_i$, $V_i$, and $W_i$. The $(i+1)$-th line describes the $i$-th edge: it connects nodes $U_i$ and $V_i$, and there are $W_i$ maomao fruits on that edge.\n\nThen follow the operations and queries, one per line, terminated by a single line `Stop`.", "outputFormat": "For each `Max` query, output its answer on a separate line.", "hint": "For all testdata, $1 \\le N \\le 10^5$, and the total number of operations and queries does not exceed $10^5$.\n\nIt is guaranteed that at any time, the number of maomao fruits on every edge does not exceed $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "月下“毛景树”", "background": "毛毛虫经过及时的变形，最终逃过的一劫，离开了菜妈的菜园。毛毛虫经过千山万水，历尽千辛万苦，最后来到了小小的绍兴一中的校园里。", "description": "爬啊爬~爬啊爬~~毛毛虫爬到了一颗小小的“毛景树”下面，发现树上长着他最爱吃的毛毛果~~~ “毛景树”上有 $N$ 个节点和 $N-1$ 条树枝，但节点上是没有毛毛果的，毛毛果都是长在树枝上的。但是这棵“毛景树”有着神奇的魔力，他能改变树枝上毛毛果的个数：\n\n- `Change k w`：将第 $k$ 条树枝上毛毛果的个数改变为 $w$ 个。\n- `Cover u v w`：将节点 $u$ 与节点 $v$ 之间的树枝上毛毛果的个数都改变为 $w$ 个。\n- `Add u v w`：将节点 $u$ 与节点 $v$ 之间的树枝上毛毛果的个数都增加 $w$ 个。\n\n由于毛毛虫很贪，于是他会有如下询问：\n\n-  `Max u v`：询问节点 $u$ 与节点 $v$ 之间树枝上毛毛果个数最多有多少个。", "inputFormat": "第一行一个正整数 $N$。\n\n接下来 $N-1$ 行，每行三个正整数 $U_i,V_i$ 和 $W_i$，第 $i+1$ 行描述第 $i$ 条树枝。表示第 $i$ 条树枝连接节点 $U_i$ 和节点 $V_i$，树枝上有 $W_i$ 个毛毛果。 接下来是操作和询问，以 `Stop` 结束。", "outputFormat": "对于毛毛虫的每个询问操作，输出一个答案。", "hint": "对于全部数据，$1\\le N\\le 10^5$，操作和询问数目不超过 $10^5$。\n\n保证在任意时刻，所有树枝上毛毛果的个数都不会超过 $10^9$ 个。", "locale": "zh-CN"}}}
{"pid": "P4316", "type": "P", "difficulty": 4, "samples": [["4 4 \n1 2 1 \n1 3 2 \n2 3 3 \n3 4 4", "7.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递归", "拓扑排序", "期望", "栈"], "title": "绿豆蛙的归宿", "background": "随着新版百度空间的上线，Blog 宠物绿豆蛙完成了它的使命，去寻找它新的归宿。", "description": "给出张 $n$ 个点 $m$ 条边的有向无环图，起点为 $1$，终点为 $n$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。\n\n绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 $k$ 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\\frac{1}{k}$。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？", "inputFormat": "输入的第一行是两个整数，分别代表图的点数 $n$ 和边数 $m$。\n\n第 $2$ 到第 $(m + 1)$ 行，每行有三个整数 $u, v, w$，代表存在一条从 $u$ 指向 $v$ 长度为 $w$ 的有向边。", "outputFormat": "输出一行一个实数代表答案，四舍五入保留两位小数。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n \\leq 10^2$。\n- 对于 $40\\%$ 的数据，保证 $n \\leq 10^3$。\n- 对于 $60\\%$ 的数据，保证 $n \\leq 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 2 \\times n$，$1 \\leq u, v \\leq n$，$0 \\leq w \\leq 10^9$，给出的图无重边和自环。", "locale": "zh-CN", "translations": {"en": {"title": "Green Bean Frog's Home", "background": "With the launch of the new Baidu Space, the blog pet Green Bean Frog has completed its mission and is looking for its new home.", "description": "You are given a directed acyclic graph with $n$ vertices and $m$ edges. The start vertex is $1$, and the terminal vertex is $n$. Each edge has a length. From the start, every vertex is reachable, and every vertex can reach the terminal.\n\nGreen Bean Frog starts from the start and moves to the terminal. Upon arriving at a vertex that has $k$ outgoing edges, the frog may choose any outgoing edge to leave the vertex, and each edge is chosen with probability $\\frac{1}{k}$. What is the expected total length of the path from the start to the terminal?", "inputFormat": "The first line contains two integers representing the number of vertices $n$ and the number of edges $m$.\n\nLines $2$ through $(m + 1)$ each contain three integers $u, v, w$, indicating there is a directed edge from $u$ to $v$ with length $w$.", "outputFormat": "Output a single real number: the answer, rounded to two decimal places.", "hint": "- Constraints\n  - For $20\\%$ of the testdata, $n \\leq 10^2$.\n  - For $40\\%$ of the testdata, $n \\leq 10^3$.\n  - For $60\\%$ of the testdata, $n \\leq 10^4$.\n  - For $100\\%$ of the testdata, $1 \\leq n \\leq 10^5$, $1 \\leq m \\leq 2 \\times n$, $1 \\leq u, v \\leq n$, $0 \\leq w \\leq 10^9$, and the graph has no parallel edges or self-loops.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "绿豆蛙的归宿", "background": "随着新版百度空间的上线，Blog 宠物绿豆蛙完成了它的使命，去寻找它新的归宿。", "description": "给出张 $n$ 个点 $m$ 条边的有向无环图，起点为 $1$，终点为 $n$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。\n\n绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 $k$ 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\\frac{1}{k}$。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？", "inputFormat": "输入的第一行是两个整数，分别代表图的点数 $n$ 和边数 $m$。\n\n第 $2$ 到第 $(m + 1)$ 行，每行有三个整数 $u, v, w$，代表存在一条从 $u$ 指向 $v$ 长度为 $w$ 的有向边。", "outputFormat": "输出一行一个实数代表答案，四舍五入保留两位小数。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n \\leq 10^2$。\n- 对于 $40\\%$ 的数据，保证 $n \\leq 10^3$。\n- 对于 $60\\%$ 的数据，保证 $n \\leq 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 2 \\times n$，$1 \\leq u, v \\leq n$，$0 \\leq w \\leq 10^9$，给出的图无重边和自环。", "locale": "zh-CN"}}}
{"pid": "P4317", "type": "P", "difficulty": 5, "samples": [["3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["枚举", "数位 DP", "进制"], "title": "花神的数论题", "background": "众所周知，花神多年来凭借无边的神力狂虐各大 OJ、OI、CF、TC …… 当然也包括 CH 啦。", "description": "话说花神这天又来讲课了。课后照例有超级难的神题啦…… 我等蒟蒻又遭殃了。 花神的题目是这样的：设  $\\text{sum}(i)$  表示  $i$  的二进制表示中  $1$  的个数。给出一个正整数  $N$  ，花神要问你  $\\prod_{i=1}^{N}\\text{sum}(i)$ ，也就是  $\\text{sum}(1)\\sim\\text{sum}(N)$  的乘积。", "inputFormat": "一个正整数 $N$。", "outputFormat": "一个数，答案模 $10000007$ 的值。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 10^{15}$。", "locale": "zh-CN", "translations": {"en": {"title": "Huashen's Number Theory Problem", "background": "As is well known, for many years Huashen has crushed various OJ, OI, CF, TC ... of course including CH.", "description": "One day, Huashen came to give another lecture. As usual, there was a super hard problem afterwards... We weaklings suffered again. The problem is as follows: Let $\\text{sum}(i)$ denote the number of $1$ s in the binary representation of $i$. Given a positive integer $N$, Huashen asks you to compute $\\prod_{i=1}^{N}\\text{sum}(i)$, that is, the product of $\\text{sum}(1)\\sim\\text{sum}(N)$.", "inputFormat": "A positive integer $N$.", "outputFormat": "One integer: the answer modulo $10000007$.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le N \\le 10^{15}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "花神的数论题", "background": "众所周知，花神多年来凭借无边的神力狂虐各大 OJ、OI、CF、TC …… 当然也包括 CH 啦。", "description": "话说花神这天又来讲课了。课后照例有超级难的神题啦…… 我等蒟蒻又遭殃了。 花神的题目是这样的：设  $\\text{sum}(i)$  表示  $i$  的二进制表示中  $1$  的个数。给出一个正整数  $N$  ，花神要问你  $\\prod_{i=1}^{N}\\text{sum}(i)$ ，也就是  $\\text{sum}(1)\\sim\\text{sum}(N)$  的乘积。", "inputFormat": "一个正整数 $N$。", "outputFormat": "一个数，答案模 $10000007$ 的值。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 10^{15}$。", "locale": "zh-CN"}}}
{"pid": "P4318", "type": "P", "difficulty": 6, "samples": [["4 \n1 \n13 \n100 \n1234567", "1 \n19 \n163 \n2030745"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["二分", "素数判断,质数,筛法", "莫比乌斯反演", "容斥原理", "分块", "杜教筛"], "title": "完全平方数", "background": null, "description": "小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌除了 $1$ 之外的完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是这些完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。\n\n这天是小 X 的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小 X 讨厌的数。他列出了所有小 X 不讨厌的数，然后选取了第 $K$ 个数送给了小 X。小 X 很开心地收下了。\n\n然而现在小 W 却记不起送给小 X 的是哪个数了。你能帮他一下吗？", "inputFormat": "包含多组测试数据。文件第一行有一个整数 $T$，表示测试数据的组数。\n第 $2$ 至第 $T+1$ 行每行有一个整数 $K_i$，描述一组数据，含义如题目中所描述。", "outputFormat": "含 $T$ 行，分别对每组数据作出回答。第 $i$ 行输出相应的第 $K_i$ 个不是完全平方数的正整数倍的数。", "hint": "对于 50% 的数据有 $1\\le K_i\\le10^5$，\n对于 100% 的数据有 $1\\le K_i\\le10^9,T\\le50$", "locale": "zh-CN", "translations": {"en": {"title": "Perfect Squares", "background": "", "description": "Xiao X has liked numbers since childhood. Strangely, he hates perfect squares other than $1$. He finds those numbers unpleasant to look at. As a result, he also hates every positive integer that is a multiple of these perfect squares. However, this does not affect his love for all the other numbers.\n\nIt is Xiao X’s birthday, and Xiao W wants to give him a number as a gift. Of course, he cannot give a number that Xiao X hates. He listed all the numbers that Xiao X does not hate and then chose the $K$-th number to give to Xiao X. Xiao X happily accepted it.\n\nNow Xiao W cannot remember which number he gave to Xiao X. Can you help him?", "inputFormat": "Multiple test cases. The first line contains an integer $T$, the number of test cases.  \nFrom the $2$-nd to the $(T+1)$-th lines, each line contains an integer $K_i$, describing one test case as stated above.", "outputFormat": "Output $T$ lines, one answer per test case. In the $i$-th line, output the $K_i$-th positive integer that is not a multiple of any perfect square greater than $1$.", "hint": "For 50% of the testdata, $1 \\le K_i \\le 10^5$.  \nFor 100% of the testdata, $1 \\le K_i \\le 10^9$, $T \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "完全平方数", "background": null, "description": "小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌除了 $1$ 之外的完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是这些完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。\n\n这天是小 X 的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小 X 讨厌的数。他列出了所有小 X 不讨厌的数，然后选取了第 $K$ 个数送给了小 X。小 X 很开心地收下了。\n\n然而现在小 W 却记不起送给小 X 的是哪个数了。你能帮他一下吗？", "inputFormat": "包含多组测试数据。文件第一行有一个整数 $T$，表示测试数据的组数。\n第 $2$ 至第 $T+1$ 行每行有一个整数 $K_i$，描述一组数据，含义如题目中所描述。", "outputFormat": "含 $T$ 行，分别对每组数据作出回答。第 $i$ 行输出相应的第 $K_i$ 个不是完全平方数的正整数倍的数。", "hint": "对于 50% 的数据有 $1\\le K_i\\le10^5$，\n对于 100% 的数据有 $1\\le K_i\\le10^9,T\\le50$", "locale": "zh-CN"}}}
{"pid": "P4319", "type": "P", "difficulty": 6, "samples": [["4\n1 3 3\n3 4 4\n2 4 5\n3\n1 2 1 1 2\n2 3 8 2 3\n3 4 2 1 1", "7\n9\n13\n由于版面原因，仅显示三行，接下来32763行都是13"]], "limits": {"time": [1000, 1000, 1000, 1000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "O2优化", "生成树", "动态树 LCT", "可持久化"], "title": "变化的道路", "background": null, "description": "小 w 和小 c 在 H 国，近年来，随着 H 国的发展，H 国的道路也在不断变化着。\n\n根据 H 国的道路法，H 国道路都有一个值 $w$，表示如果小 w 和小 c 通过这条道路，那么他们的 $L$ 值会减少 $w$，但是如果小 w 和小 c 在之前已经经过了这条路，那么他们的 $L$ 值不会减少。\n\nH 国有 $N$ 个国家，最开始 H 国有 $N-1$ 条道路，这 $N-1$ 条道路刚好构成一棵树。\n\n小 w 将和小 c 从 H 国的城市 $1$ 出发，游览 H 国的所有城市，总共游览 $32766$ 天，对于每一天，他们都希望游览结束后 $L$ 值还是一个正数，求他们出发时 $L$ 值至少为多少。\n\nH 国的所有边都是无向边，没有一条道路连接相同的一个城市。", "inputFormat": "输入第 1 行，一个整数 $N$。\n\n输入第 2 至第 $N$ 行，每行三个正整数 $u, v, w$，表示城市 $u$ 与城市 $v$ 有一条值为 $w$ 道路。\n\t\n输入第 $N+1$ 行，一个整数 $M$，表示 H 国有 $M$ 条正在变化的道路。\n\n输入第 $N+2$ 行到第 $N+M+1$ 行，每行 5 个整数 $u, v, w, l, r$，表示城市 $u$ 到城市 $v$ 有一条值为 $w$ 的道路，这条道路存在于第 $l$ 天到第 $r$ 天。", "outputFormat": "输出共 $32766$ 行，第 $i$ 行表示第 $i$ 天游览的 $L$ 值至少为多少。", "hint": "第一天，选择 $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{2} 4$，$L$ 值总共减少了 $6$，所以 $L$ 值至少为 $7$。\n\n第二天，选择 $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{4} 4$，$L$ 值总共减少了 $8$，所以 $L$ 值至少为 $9$。\n\n第三天及之后，选择 $1 \\xrightarrow{3} 3 \\xrightarrow{4} 4 \\xrightarrow{5} 2$，$L$ 值总共减少了 $12$，所以 $L$ 值至少为 $13$。\n\nsubtask1 : 15分，$N = 100, rm = 233$。\n\nsubtask2 : 15分，$N = 1000, rm = 2333$。\n\nsubtask3 : 20分，$N = 49998, rm = 32766, l = r$。\n\nsubtask4：20分，$N = 49999, rm = 32766, r = rm$。\n\nsubtask5：30分，$N = 50000, rm = 32766$。\n\n对于 subtask3，$M = rm$；对于其他 subtask，$M=3\\times rm$。\n\n对于所有数据 : $1\\leq N\\leq 50000, 1\\leq l\\leq r\\leq rm\\leq 32766, 1\\leq w\\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Changing Roads", "background": "", "description": "Xiao w and Xiao c are in Country H. In recent years, as Country H has developed, its roads have been constantly changing.\n\nAccording to Country H’s road law, every road has a value $w$, meaning that if Xiao w and Xiao c pass through this road, their $L$ value will decrease by $w$. However, if Xiao w and Xiao c have already passed this road before, their $L$ value will not decrease.\n\nCountry H has $N$ cities. Initially, Country H has $N-1$ roads, and these $N-1$ roads form a tree.\n\nXiao w and Xiao c will start from city $1$ and visit all cities of Country H. They will travel for 32766 days in total. For each day, they want the $L$ value to still be positive after finishing the tour. Find the minimum initial $L$ they need at departure for each day.\n\nAll edges in Country H are undirected. No road connects a city to itself.", "inputFormat": "Line 1: an integer $N$.\n\nLines 2 to $N$: each line contains three positive integers $u, v, w$, meaning there is a road of value $w$ between cities $u$ and $v$.\n\nLine $N+1$: an integer $M$, meaning Country H has $M$ roads that are changing.\n\nLines $N+2$ to $N+M+1$: each line contains $5$ integers $u, v, w, l, r$, meaning there is a road of value $w$ from city $u$ to city $v$, and this road exists from day $l$ to day $r$.", "outputFormat": "Output $32766$ lines. The $i$-th line is the minimum $L$ required on day $i$.", "hint": "On day 1, choose $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{2} 4$. The $L$ value decreases by $6$ in total, so the minimum $L$ is $7$.\n\nOn day 2, choose $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{4} 4$. The $L$ value decreases by $8$ in total, so the minimum $L$ is $9$.\n\nFrom day 3 onward, choose $1 \\xrightarrow{3} 3 \\xrightarrow{4} 4 \\xrightarrow{5} 2$. The $L$ value decreases by $12$ in total, so the minimum $L$ is $13$.\n\nSubtask 1: 15 points, $N = 100$, rm = 233.\n\nSubtask 2: 15 points, $N = 1000$, rm = 2333.\n\nSubtask 3: 20 points, $N = 49998$, rm = 32766, $l = r$.\n\nSubtask 4: 20 points, $N = 49999$, rm = 32766, $r = rm$.\n\nSubtask 5: 30 points, $N = 50000$, rm = 32766.\n\nFor subtask 3, $M = rm$; for other subtasks, $M = 3 \\times rm$.\n\nConstraints for all testdata: $1 \\leq N \\leq 50000$, $1 \\leq l \\leq r \\leq rm \\leq 32766$, $1 \\leq w \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "变化的道路", "background": null, "description": "小 w 和小 c 在 H 国，近年来，随着 H 国的发展，H 国的道路也在不断变化着。\n\n根据 H 国的道路法，H 国道路都有一个值 $w$，表示如果小 w 和小 c 通过这条道路，那么他们的 $L$ 值会减少 $w$，但是如果小 w 和小 c 在之前已经经过了这条路，那么他们的 $L$ 值不会减少。\n\nH 国有 $N$ 个国家，最开始 H 国有 $N-1$ 条道路，这 $N-1$ 条道路刚好构成一棵树。\n\n小 w 将和小 c 从 H 国的城市 $1$ 出发，游览 H 国的所有城市，总共游览 $32766$ 天，对于每一天，他们都希望游览结束后 $L$ 值还是一个正数，求他们出发时 $L$ 值至少为多少。\n\nH 国的所有边都是无向边，没有一条道路连接相同的一个城市。", "inputFormat": "输入第 1 行，一个整数 $N$。\n\n输入第 2 至第 $N$ 行，每行三个正整数 $u, v, w$，表示城市 $u$ 与城市 $v$ 有一条值为 $w$ 道路。\n\t\n输入第 $N+1$ 行，一个整数 $M$，表示 H 国有 $M$ 条正在变化的道路。\n\n输入第 $N+2$ 行到第 $N+M+1$ 行，每行 5 个整数 $u, v, w, l, r$，表示城市 $u$ 到城市 $v$ 有一条值为 $w$ 的道路，这条道路存在于第 $l$ 天到第 $r$ 天。", "outputFormat": "输出共 $32766$ 行，第 $i$ 行表示第 $i$ 天游览的 $L$ 值至少为多少。", "hint": "第一天，选择 $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{2} 4$，$L$ 值总共减少了 $6$，所以 $L$ 值至少为 $7$。\n\n第二天，选择 $1 \\xrightarrow{1} 2 \\xrightarrow{0} 1 \\xrightarrow{3} 3 \\xrightarrow{4} 4$，$L$ 值总共减少了 $8$，所以 $L$ 值至少为 $9$。\n\n第三天及之后，选择 $1 \\xrightarrow{3} 3 \\xrightarrow{4} 4 \\xrightarrow{5} 2$，$L$ 值总共减少了 $12$，所以 $L$ 值至少为 $13$。\n\nsubtask1 : 15分，$N = 100, rm = 233$。\n\nsubtask2 : 15分，$N = 1000, rm = 2333$。\n\nsubtask3 : 20分，$N = 49998, rm = 32766, l = r$。\n\nsubtask4：20分，$N = 49999, rm = 32766, r = rm$。\n\nsubtask5：30分，$N = 50000, rm = 32766$。\n\n对于 subtask3，$M = rm$；对于其他 subtask，$M=3\\times rm$。\n\n对于所有数据 : $1\\leq N\\leq 50000, 1\\leq l\\leq r\\leq rm\\leq 32766, 1\\leq w\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4320", "type": "P", "difficulty": 6, "samples": [["5 6\n1 2\n1 3\n2 3\n3 4\n4 5\n3 5\n1\n1 5", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "倍增", "O2优化", "树链剖分", "圆方树"], "title": "道路相遇", "background": "", "description": "在 H 国的小 w 决定到从城市 $u$ 到城市 $v$ 旅行，但是此时小 c 由于各种原因不在城市 $u$，但是小 c 决定到在中途与小 w 相遇\n\n由于 H 国道路的原因，小 w 从城市 $u$ 到城市 $v$ 的路线不是固定的，为了合理分配时间，小 c 想知道从城市 $u$ 到城市 $v$ 有多少个城市小 w 一定会经过，特别地，$u, v$ 也必须被算进去，也就是说无论如何答案不会小于 2\n\n由于各种特殊的原因，小 c 并不知道小 w 的起点和终点，但是小 c 知道小 w 的起点和终点只有 $q$ 种可能，所以对于这 $q$ 种可能，小 c 都想知道小 w 一定会经过的城市数\n\nH 国所有的边都是无向边，两个城市之间最多只有一条道路直接相连，没有一条道路连接相同的一个城市\n\n任何时候，H 国不存在城市 $u$ 和城市 $v$ 满足从 $u$ 无法到达 $v$", "inputFormat": "第一行两个正整数 $n,m$，表示 H 国的城市数，以及道路数。\n\n下面 $m$ 行，每行两个不同的正整数 $u, v$，表示城市 $u$ 到城市 $v$ 之间有一条边。\n\n然后一行一个正整数 $q$。\n接下来 $q$ 行，每行两个正整数 $u, v$ 表示小 w 旅行的一种可能的路线", "outputFormat": "输出共 $q$ 行，每行一个正整数", "hint": "从城市 $1$ 到城市 $5$ 总共有 $4$ 种可能 : \n\n$1 \\to 2 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 2 \\to 3 \\to 5$\n\n$1 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 3 \\to 5$\n\n可以发现小 w 总会经过城市 $1,3,5$，所以答案为 $3$\n\n你可以认为小 w 不会经过相同的城市两次，当然，如果你认为可以经过相同的城市两次也不会影响答案\n\nsubtask1 : 15分，$n = 5, q = 50$\n\nsubtask2 : 15分，$n = 100, q = 5000$\n\nsubtask3 : 20分，$n = 3000, q = 5\\times 10^5$\n\nsubtask4 : 20分，$n = 499999, q = 5 \\times 10^5, m = n-1$\n\nsubtask5 : 30分，$n = q = 5 \\times 10^5$\n\n对于所有数据 : $1\\leq n\\leq 5 \\times 10^5, 1\\leq q\\leq 5\\times 10^5, 1\\leq m\\leq \\min(\\frac{n(n-1)}{2}, 10^6)$", "locale": "zh-CN", "translations": {"en": {"title": "Road Encounter", "background": "# Description\n\nIn country H, Xiao w decides to travel from city $u$ to city $v$. However, for various reasons, Xiao c is not in city $u$, but Xiao c decides to meet Xiao w somewhere along the way.\n\nBecause of the road network in country H, the route Xiao w takes from city $u$ to city $v$ is not fixed. To plan time reasonably, Xiao c wants to know how many cities Xiao w will definitely pass through on all possible routes from city $u$ to city $v$. In particular, $u$ and $v$ must also be counted, which means the answer is never less than $2$.\n\nFor various reasons, Xiao c does not know Xiao w’s exact start and end cities, but Xiao c knows there are only $q$ possible pairs of start and end cities. For each of these $q$ possibilities, Xiao c wants to know the number of cities that Xiao w will definitely pass through.\n\nAll edges in country H are undirected. Between any two cities, there is at most one direct road. There is no road that connects a city to itself.\n\nAt all times, the graph is connected.", "description": "", "inputFormat": "", "outputFormat": "Output $q$ lines, each containing a single positive integer.", "hint": "From city $1$ to city $5$ there are $4$ possible routes:\n\n$1 \\to 2 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 2 \\to 3 \\to 5$\n\n$1 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 3 \\to 5$\n\nIt can be seen that Xiao w will always pass through cities $1, 3, 5$, so the answer is $3$.\n\nYou may assume Xiao w will not visit the same city twice. Of course, even if you think revisiting cities is allowed, it does not affect the answer.\n\nSubtask 1: 15 points, $n = 5, q = 50$.\n\nSubtask 2: 15 points, $n = 100, q = 5000$.\n\nSubtask 3: 20 points, $n = 3000, q = 5 \\times 10^5$.\n\nSubtask 4: 20 points, $n = 499999, q = 5 \\times 10^5, m = n - 1$.\n\nSubtask 5: 30 points, $n = q = 5 \\times 10^5$.\n\nConstraints:\nFor all testdata: $1 \\leq n \\leq 5 \\times 10^5, 1 \\leq q \\leq 5 \\times 10^5, 1 \\leq m \\leq \\min(\\frac{n(n-1)}{2}, 10^6)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "道路相遇", "background": "", "description": "在 H 国的小 w 决定到从城市 $u$ 到城市 $v$ 旅行，但是此时小 c 由于各种原因不在城市 $u$，但是小 c 决定到在中途与小 w 相遇\n\n由于 H 国道路的原因，小 w 从城市 $u$ 到城市 $v$ 的路线不是固定的，为了合理分配时间，小 c 想知道从城市 $u$ 到城市 $v$ 有多少个城市小 w 一定会经过，特别地，$u, v$ 也必须被算进去，也就是说无论如何答案不会小于 2\n\n由于各种特殊的原因，小 c 并不知道小 w 的起点和终点，但是小 c 知道小 w 的起点和终点只有 $q$ 种可能，所以对于这 $q$ 种可能，小 c 都想知道小 w 一定会经过的城市数\n\nH 国所有的边都是无向边，两个城市之间最多只有一条道路直接相连，没有一条道路连接相同的一个城市\n\n任何时候，H 国不存在城市 $u$ 和城市 $v$ 满足从 $u$ 无法到达 $v$", "inputFormat": "第一行两个正整数 $n,m$，表示 H 国的城市数，以及道路数。\n\n下面 $m$ 行，每行两个不同的正整数 $u, v$，表示城市 $u$ 到城市 $v$ 之间有一条边。\n\n然后一行一个正整数 $q$。\n接下来 $q$ 行，每行两个正整数 $u, v$ 表示小 w 旅行的一种可能的路线", "outputFormat": "输出共 $q$ 行，每行一个正整数", "hint": "从城市 $1$ 到城市 $5$ 总共有 $4$ 种可能 : \n\n$1 \\to 2 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 2 \\to 3 \\to 5$\n\n$1 \\to 3 \\to 4 \\to 5$\n\n$1 \\to 3 \\to 5$\n\n可以发现小 w 总会经过城市 $1,3,5$，所以答案为 $3$\n\n你可以认为小 w 不会经过相同的城市两次，当然，如果你认为可以经过相同的城市两次也不会影响答案\n\nsubtask1 : 15分，$n = 5, q = 50$\n\nsubtask2 : 15分，$n = 100, q = 5000$\n\nsubtask3 : 20分，$n = 3000, q = 5\\times 10^5$\n\nsubtask4 : 20分，$n = 499999, q = 5 \\times 10^5, m = n-1$\n\nsubtask5 : 30分，$n = q = 5 \\times 10^5$\n\n对于所有数据 : $1\\leq n\\leq 5 \\times 10^5, 1\\leq q\\leq 5\\times 10^5, 1\\leq m\\leq \\min(\\frac{n(n-1)}{2}, 10^6)$", "locale": "zh-CN"}}}
{"pid": "P4321", "type": "P", "difficulty": 7, "samples": [["3 2\n1 2\n2 3\n3\n2 1 2 1\t\t\n3 1 2 3 1\n1 3 1", "1\n4\n4"]], "limits": {"time": [2000, 2000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "图论", "O2优化", "期望", "高斯消元"], "title": "随机漫游", "background": "", "description": "H 国有 $N$ 个城市\n\n在接下来的 $M$ 天，小 c 都会去找小 w，但是小 c 不知道小 w 的具体位置，所以小 c 决定每次随机找一条路走，直到遇到了小 w 为止\n\n小 c 知道小 w 只有可能是在 $c_1, c_2.. c_n$ 这 $n$ 个城市中的一个，小 c 想知道在最坏情况下，小 c 遇到小 w 期望要经过多少条道路\n\nH 国所有的边都是无向边，两个城市之间最多只有一条道路直接相连，没有一条道路连接相同的一个城市\n\n任何时候，H 国不存在城市 $u$ 和城市 $v$ 满足从 $u$ 无法到达 $v$", "inputFormat": "输入第 1 行一个正整数$N, E$，分别表示 H 国的城市数与边的数量\n\n输入第 2 行至第 $E+1$ 行，每行两个正整数 $u, v$，分别表示城市 $u$ 到城市 $v$ 有一条道路\n\n输入第 $E+2$ 行一个正整数 $M$\n\n输入第 $E+3$ 行至第 $E+M+2$ 行每行 $n+2$ 个正整数，第一个正整数为 $n$，接下来 $n$ 个互不相同的正整数 $c_i$，最后一个正整数 $s$ 表示小 c 所在的城市", "outputFormat": "输出共 $M$ 行，每行一个正整数 $r$ 表示答案\n\n如果你计算出来的期望为 $\\frac{q}{p}$，其中$p, q$互质，那么你输出的 $r$ 满足 $r\\times p \\equiv q(\\mathrm{mod}\\ 998244353)$，\n且$0\\leq r < 998244353$，可以证明这样的 $r$是唯一的", "hint": "$H$ 国的道路构成一条链，所以最坏情况下就是小 w 在深度最大的点上(以小 c 所在的城市为根)\n\n对于第一天，小 c 所在的城市为 1，深度最大的点为 2，城市 1 只能到达城市 2，期望经过 1 条道路到达\n\n对于第二天，小 c 所在的城市为 1，深度最大的点为 3，计算的期望经过 4 条道路到达\n\n第三天同第二天\n\n最坏情况也就是说经过所有 $n$ 个可能的城市至少一遍\n\nsubtask1 : 10分，$N = 4, M = 12$\n\nsubtask2 : 15分，$N =10, M = 100000$\n\nsubtask3 : 15分，$N = 18, M = 1$\n\nsubtask4 : 10分，$N = 18, M = 99995$，图是一条链\n\nsubtask5 : 10分，$N = 18, M = 99996$，所有的 $s$ 都相同\n\nsubtask6 : 15分，$N = 18, M = 99997$，$E = N-1$\n\nsubtask7 : 15分，$N = 18, M = 99998$，所有的 $s$ 都相同\n\nsubtask8 : 10分，$N = 18, M = 99999$\n\n对于所有数据 : $1\\leq N\\leq 18, 1\\leq M\\leq 100000, 1\\leq E\\leq \\frac{N(N-1)}{2}$", "locale": "zh-CN", "translations": {"en": {"title": "Random Walk", "background": "", "description": "Country H has $N$ cities.\n\nIn the next $M$ days, Xiao c will go to look for Xiao w, but Xiao c does not know the exact location of Xiao w, so Xiao c decides to randomly choose one road to walk each time until meeting Xiao w.\n\nXiao c knows that Xiao w can only be in one of the $n$ cities $c_1, c_2.. c_n$. Xiao c wants to know, in the worst case, the expected number of roads Xiao c needs to traverse before meeting Xiao w.\n\nAll edges in country H are undirected. Between any two cities, there is at most one road directly connecting them, and no road connects the same city to itself.\n\nAt any time, in country H there do not exist cities $u$ and $v$ such that $v$ cannot be reached from $u$.", "inputFormat": "The first line contains two positive integers $N, E$, representing the number of cities and the number of edges in country H.\n\nLines 2 to $E+1$ each contain two positive integers $u, v$, indicating there is a road between city $u$ and city $v$.\n\nLine $E+2$ contains one positive integer $M$.\n\nLines $E+3$ to $E+M+2$ each contain $n+2$ positive integers: the first integer is $n$, followed by $n$ distinct integers $c_i$, and the last integer $s$ indicates the city where Xiao c is located.", "outputFormat": "Output $M$ lines, each containing a single integer $r$ representing the answer.\n\nIf the expected value you compute is $\\frac{q}{p}$, where $p, q$ are coprime, then you should output an $r$ such that $r\\times p \\equiv q(\\mathrm{mod}\\ 998244353)$ and $0\\leq r < 998244353$. It can be proved that such an $r$ is unique.", "hint": "The roads of country H form a chain, so in the worst case Xiao w is at the deepest node (taking Xiao c’s city as the root).\n\nFor the first day, Xiao c is in city 1, the deepest node is 2, city 1 can only reach city 2, and the expected number of roads to reach it is 1.\n\nFor the second day, Xiao c is in city 1, the deepest node is 3, and the computed expectation is 4 roads to reach it.\n\nThe third day is the same as the second day.\n\nThe worst case means going through all $n$ possible cities at least once.\n\nSubtask 1: 10 points, $N = 4, M = 12$.\n\nSubtask 2: 15 points, $N =10, M = 100000$.\n\nSubtask 3: 15 points, $N = 18, M = 1$.\n\nSubtask 4: 10 points, $N = 18, M = 99995$, the graph is a chain.\n\nSubtask 5: 10 points, $N = 18, M = 99996$, all $s$ are the same.\n\nSubtask 6: 15 points, $N = 18, M = 99997$, $E = N-1$.\n\nSubtask 7: 15 points, $N = 18, M = 99998$, all $s$ are the same.\n\nSubtask 8: 10 points, $N = 18, M = 99999$.\n\nConstraints for all testdata: $1\\leq N\\leq 18, 1\\leq M\\leq 100000, 1\\leq E\\leq \\frac{N(N-1)}{2}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "随机漫游", "background": "", "description": "H 国有 $N$ 个城市\n\n在接下来的 $M$ 天，小 c 都会去找小 w，但是小 c 不知道小 w 的具体位置，所以小 c 决定每次随机找一条路走，直到遇到了小 w 为止\n\n小 c 知道小 w 只有可能是在 $c_1, c_2.. c_n$ 这 $n$ 个城市中的一个，小 c 想知道在最坏情况下，小 c 遇到小 w 期望要经过多少条道路\n\nH 国所有的边都是无向边，两个城市之间最多只有一条道路直接相连，没有一条道路连接相同的一个城市\n\n任何时候，H 国不存在城市 $u$ 和城市 $v$ 满足从 $u$ 无法到达 $v$", "inputFormat": "输入第 1 行一个正整数$N, E$，分别表示 H 国的城市数与边的数量\n\n输入第 2 行至第 $E+1$ 行，每行两个正整数 $u, v$，分别表示城市 $u$ 到城市 $v$ 有一条道路\n\n输入第 $E+2$ 行一个正整数 $M$\n\n输入第 $E+3$ 行至第 $E+M+2$ 行每行 $n+2$ 个正整数，第一个正整数为 $n$，接下来 $n$ 个互不相同的正整数 $c_i$，最后一个正整数 $s$ 表示小 c 所在的城市", "outputFormat": "输出共 $M$ 行，每行一个正整数 $r$ 表示答案\n\n如果你计算出来的期望为 $\\frac{q}{p}$，其中$p, q$互质，那么你输出的 $r$ 满足 $r\\times p \\equiv q(\\mathrm{mod}\\ 998244353)$，\n且$0\\leq r < 998244353$，可以证明这样的 $r$是唯一的", "hint": "$H$ 国的道路构成一条链，所以最坏情况下就是小 w 在深度最大的点上(以小 c 所在的城市为根)\n\n对于第一天，小 c 所在的城市为 1，深度最大的点为 2，城市 1 只能到达城市 2，期望经过 1 条道路到达\n\n对于第二天，小 c 所在的城市为 1，深度最大的点为 3，计算的期望经过 4 条道路到达\n\n第三天同第二天\n\n最坏情况也就是说经过所有 $n$ 个可能的城市至少一遍\n\nsubtask1 : 10分，$N = 4, M = 12$\n\nsubtask2 : 15分，$N =10, M = 100000$\n\nsubtask3 : 15分，$N = 18, M = 1$\n\nsubtask4 : 10分，$N = 18, M = 99995$，图是一条链\n\nsubtask5 : 10分，$N = 18, M = 99996$，所有的 $s$ 都相同\n\nsubtask6 : 15分，$N = 18, M = 99997$，$E = N-1$\n\nsubtask7 : 15分，$N = 18, M = 99998$，所有的 $s$ 都相同\n\nsubtask8 : 10分，$N = 18, M = 99999$\n\n对于所有数据 : $1\\leq N\\leq 18, 1\\leq M\\leq 100000, 1\\leq E\\leq \\frac{N(N-1)}{2}$", "locale": "zh-CN"}}}
{"pid": "P4322", "type": "P", "difficulty": 5, "samples": [["1 2\n1000 1 0\n1 1000 1", "0.001"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "二分", "各省省选", "江苏", "背包 DP", "分数规划"], "title": "[JSOI2016] 最佳团体", "background": null, "description": "JSOI 信息学代表队一共有 $N$ 名候选人，这些候选人从 $1$ 到 $N$ 编号。方便起见，JYY 的编号是 $0$ 号。每个候选人都由一位编号比他小的候选人 $R_i$ 推荐。如果 $R_i = 0$，则说明这个候选人是 JYY 自己看上的。\n\n为了保证团队的和谐，JYY 需要保证，如果招募了候选人 $i$，那么候选人 $R_i$ 也一定需要在团队中。当然了，JYY 自己总是在团队里的。每一个候选人都有一个战斗值 $P_i$ ，也有一个招募费用 $S_i$ 。JYY 希望招募 $K$ 个候选人（JYY 自己不算），组成一个性价比最高的团队。也就是，这 $K$ 个被 JYY 选择的候选人的总战斗值与总招募费用的比值最大。", "inputFormat": "输入一行包含两个正整数 $K$ 和 $N$ 。\n\n接下来 $N$ 行，其中第 $i$ 行包含三个整数 $S_i$ , $P_i$ , $R_i$ ,\n表示候选人 $i$ 的招募费用，战斗值和推荐人编号。", "outputFormat": "输出一行一个实数，表示最佳比值。答案保留三位小数。", "hint": "对于 $100\\%$ 的数据满足 $1 \\le K \\le N \\le 2500$，$0 < S_i,P_i \\le 10^4$，$0 \\le R_i < i$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Best Team", "background": "", "description": "There are $N$ candidates in the JSOI informatics team, numbered from $1$ to $N$. For convenience, JYY is numbered $0$. Each candidate $i$ is recommended by a candidate with a smaller number $R_i$. If $R_i = 0$, it means this candidate was picked by JYY himself.\n\nTo ensure team harmony, JYY requires that if candidate $i$ is recruited, then candidate $R_i$ must also be in the team. JYY is always in the team. Each candidate has a combat power $P_i$ and a recruitment cost $S_i$. JYY wants to recruit $K$ candidates (excluding JYY) to form the team with the best ratio; that is, maximize the ratio of the total combat power to the total recruitment cost of these $K$ selected candidates.", "inputFormat": "The first line contains two positive integers $K$ and $N$.\n\nThe $i$-th of the next $N$ lines contains three integers $S_i$, $P_i$, $R_i$, indicating candidate $i$’s recruitment cost, combat power, and recommender number.", "outputFormat": "Print one real number, the best ratio. The answer should be rounded to three decimal places.", "hint": "For $100\\%$ of the testdata, $1 \\le K \\le N \\le 2500$, $0 < S_i, P_i \\le 10^4$, $0 \\le R_i < i$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 最佳团体", "background": null, "description": "JSOI 信息学代表队一共有 $N$ 名候选人，这些候选人从 $1$ 到 $N$ 编号。方便起见，JYY 的编号是 $0$ 号。每个候选人都由一位编号比他小的候选人 $R_i$ 推荐。如果 $R_i = 0$，则说明这个候选人是 JYY 自己看上的。\n\n为了保证团队的和谐，JYY 需要保证，如果招募了候选人 $i$，那么候选人 $R_i$ 也一定需要在团队中。当然了，JYY 自己总是在团队里的。每一个候选人都有一个战斗值 $P_i$ ，也有一个招募费用 $S_i$ 。JYY 希望招募 $K$ 个候选人（JYY 自己不算），组成一个性价比最高的团队。也就是，这 $K$ 个被 JYY 选择的候选人的总战斗值与总招募费用的比值最大。", "inputFormat": "输入一行包含两个正整数 $K$ 和 $N$ 。\n\n接下来 $N$ 行，其中第 $i$ 行包含三个整数 $S_i$ , $P_i$ , $R_i$ ,\n表示候选人 $i$ 的招募费用，战斗值和推荐人编号。", "outputFormat": "输出一行一个实数，表示最佳比值。答案保留三位小数。", "hint": "对于 $100\\%$ 的数据满足 $1 \\le K \\le N \\le 2500$，$0 < S_i,P_i \\le 10^4$，$0 \\le R_i < i$。", "locale": "zh-CN"}}}
{"pid": "P4323", "type": "P", "difficulty": 6, "samples": [["5\n1 2\n2 3\n1 4\n1 5\n1 2\n2 3\n3 4\n4 5\n3 6", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "各省省选", "江苏", "深度优先搜索 DFS", "哈希 hashing"], "title": "[JSOI2016] 独特的树叶", "background": null, "description": "JYY 有两棵树 $A$ 和 $B$：树 $A$ 有 $N$ 个点，编号为 $1$ 到 $N$；树 $B$ 有 $N + 1$ 个节点，编号为 $1$ 到 $N + 1$。\n\nJYY 知道树 $B$ 恰好是由树 $A$ 加上一个叶节点，然后将节点的编号打乱后得到的。他想知道，这个多余的叶子到底是树 $B$ 中的哪一个叶节点呢？", "inputFormat": "输入一行包含一个正整数 $N$。接下来 $N - 1$ 行，描述树 $A$，每行包含两个整数表示树 $A$ 中的一条边；接下来 $N$ 行，描述树 $B$，每行包含两个整数表示树 $B$ 中的一条边。", "outputFormat": "输出一行一个整数，表示树 $B$ 中相比树 $A$ 多余的那个叶子的编号。如果有多个符合要求的叶子，输出 $B$ 中编号最小的那一个的编号。", "hint": "对于所有数据，$1 \\leq n \\leq 10 ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Unique Leaf", "background": "", "description": "JYY has two trees $A$ and $B$: tree $A$ has $N$ nodes labeled from $1$ to $N$; tree $B$ has $N + 1$ nodes labeled from $1$ to $N + 1$.\n\nJYY knows that tree $B$ is obtained from tree $A$ by adding one leaf node and then shuffling the node labels. He wants to determine which leaf node in tree $B$ is the extra one.", "inputFormat": "The first line contains a positive integer $N$.  \nThe next $N - 1$ lines describe tree $A$, each containing two integers that represent an edge of tree $A$.  \nThe next $N$ lines describe tree $B$, each containing two integers that represent an edge of tree $B$.", "outputFormat": "Output a single integer: the label in tree $B$ of the extra leaf compared to tree $A$. If multiple leaves satisfy the condition, output the smallest label among them.", "hint": "For all testdata, $1 \\leq N \\leq 10^{5}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 独特的树叶", "background": null, "description": "JYY 有两棵树 $A$ 和 $B$：树 $A$ 有 $N$ 个点，编号为 $1$ 到 $N$；树 $B$ 有 $N + 1$ 个节点，编号为 $1$ 到 $N + 1$。\n\nJYY 知道树 $B$ 恰好是由树 $A$ 加上一个叶节点，然后将节点的编号打乱后得到的。他想知道，这个多余的叶子到底是树 $B$ 中的哪一个叶节点呢？", "inputFormat": "输入一行包含一个正整数 $N$。接下来 $N - 1$ 行，描述树 $A$，每行包含两个整数表示树 $A$ 中的一条边；接下来 $N$ 行，描述树 $B$，每行包含两个整数表示树 $B$ 中的一条边。", "outputFormat": "输出一行一个整数，表示树 $B$ 中相比树 $A$ 多余的那个叶子的编号。如果有多个符合要求的叶子，输出 $B$ 中编号最小的那一个的编号。", "hint": "对于所有数据，$1 \\leq n \\leq 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P4324", "type": "P", "difficulty": 5, "samples": [["5\nABCDE\nBAECB", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "动态规划 DP", "2016", "二分", "各省省选", "江苏", "枚举", "哈希 hashing"], "title": "[JSOI2016] 扭动的回文串", "background": null, "description": "JYY 有两个长度均为 $N$ 的字符串 $A$ 和 $B$。\n\n一个扭动字符串 $S(i,j,k)$ 由 $A$ 中的第 $i$ 个字符到第 $j$ 个字符组成的子串与 $B$ 中的第 $j$ 个字符到第 $k$ 个字符组成的子串拼接而成。\n\n比如，若 $A= \\mathtt{XYZ}$，$B= \\mathtt{UVW}$，则扭动字符串 $S(1,2,3)=\\mathtt{XYVW}$。\n\nJYY 定义一个扭动的回文串为如下情况中的一个：\n\n- $A$ 中的一个回文串；\n- $B$ 中的一个回文串；\n- 或者某一个回文的扭动字符串 $S(i,j,k)$。\n\n现在 JYY 希望找出最长的扭动回文串。", "inputFormat": "第一行包含一个正整数 $N$。\n第二行包含一个长度为 $N$ 的由大写字母组成的字符串 $A$。\n第三行包含一个长度为 $N$ 的由大写字母组成的字符串 $B$。", "outputFormat": "输出的第一行一个整数，表示最长的扭动回文串。", "hint": "**样例解释**\n最佳方案中的扭动回文串如下所示（不在回文串中的字符用 `.` 表示）：\n\n```pain\n.BC..\n..ECB\n```\n\n对于所有的数据，$1 \\leq n \\leq 10 ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Twisted Palindrome String", "background": "", "description": "JYY has two strings $A$ and $B$, both of length $N$.\n\nA \"twisted string\" $S(i,j,k)$ is formed by concatenating the substring of $A$ from the $i$-th character to the $j$-th character and the substring of $B$ from the $j$-th character to the $k$-th character.\n\nFor example, if $A=\\mathtt{XYZ}$ and $B=\\mathtt{UVW}$, then the twisted string $S(1,2,3)=\\mathtt{XYVW}$.\n\nJYY defines a \"twisted palindrome\" as one of the following:\n- A palindrome in $A$;\n- A palindrome in $B$;\n- Or a twisted string $S(i,j,k)$ that is a palindrome.\n\nNow JYY wants to find the longest twisted palindrome.", "inputFormat": "The first line contains a positive integer $N$.\nThe second line contains a string $A$ of length $N$ consisting of uppercase letters.\nThe third line contains a string $B$ of length $N$ consisting of uppercase letters.", "outputFormat": "Output a single integer on the first line, the length of the longest twisted palindrome.", "hint": "Sample explanation:\nThe twisted palindrome in the best solution is shown below (characters not in the palindrome are marked with `.`):\n\n```pain\n.BC..\n..ECB\n```\n\nConstraints: For all testdata, $1 \\leq N \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 扭动的回文串", "background": null, "description": "JYY 有两个长度均为 $N$ 的字符串 $A$ 和 $B$。\n\n一个扭动字符串 $S(i,j,k)$ 由 $A$ 中的第 $i$ 个字符到第 $j$ 个字符组成的子串与 $B$ 中的第 $j$ 个字符到第 $k$ 个字符组成的子串拼接而成。\n\n比如，若 $A= \\mathtt{XYZ}$，$B= \\mathtt{UVW}$，则扭动字符串 $S(1,2,3)=\\mathtt{XYVW}$。\n\nJYY 定义一个扭动的回文串为如下情况中的一个：\n\n- $A$ 中的一个回文串；\n- $B$ 中的一个回文串；\n- 或者某一个回文的扭动字符串 $S(i,j,k)$。\n\n现在 JYY 希望找出最长的扭动回文串。", "inputFormat": "第一行包含一个正整数 $N$。\n第二行包含一个长度为 $N$ 的由大写字母组成的字符串 $A$。\n第三行包含一个长度为 $N$ 的由大写字母组成的字符串 $B$。", "outputFormat": "输出的第一行一个整数，表示最长的扭动回文串。", "hint": "**样例解释**\n最佳方案中的扭动回文串如下所示（不在回文串中的字符用 `.` 表示）：\n\n```pain\n.BC..\n..ECB\n```\n\n对于所有的数据，$1 \\leq n \\leq 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P4325", "type": "P", "difficulty": 1, "samples": [["1\n2\n3\n4\n5\n6\n7\n8\n9\n10", "10"], ["42\n84\n252\n420\n840\n126\n42\n84\n420\n126", "1"], ["39\n40\n41\n42\n43\n44\n82\n83\n84\n85", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2006", "枚举", "排序", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #1] Modulo", "background": "", "description": "Given two integers A and B, A modulo B is the remainder when dividing A by B. For example, the numbers 7, 14, 27 and 38 become 1, 2, 0 and 2, modulo 3. Write a program that accepts 10 numbers as input and outputs the number of distinct numbers in the input, if the numbers are considered modulo 42.", "inputFormat": "The input will contain 10 non-negative integers, each smaller than 1000, one per line.", "outputFormat": "Output the number of distinct values when considered modulo 42 on a single line.", "hint": "In the first example, the numbers modulo 42 are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10.\nIn the second example all numbers modulo 42 are 0.\nIn the third example, the numbers modulo 42 are 39, 40, 41, 0, 1, 2, 40, 41, 0 and 1. There are 6 distinct numbers.", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Modulo", "background": "", "description": "Given two integers A and B, A modulo B is the remainder when dividing A by B. For example, the numbers 7, 14, 27 and 38 become 1, 2, 0 and 2, modulo 3. Write a program that accepts 10 numbers as input and outputs the number of distinct numbers in the input, if the numbers are considered modulo 42.", "inputFormat": "The input will contain 10 non-negative integers, each smaller than 1000, one per line.", "outputFormat": "Output the number of distinct values when considered modulo 42 on a single line.", "hint": "In the first example, the numbers modulo 42 are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10.\nIn the second example all numbers modulo 42 are 0.\nIn the third example, the numbers modulo 42 are 39, 40, 41, 0, 1, 2, 40, 41, 0 and 1. There are 6 distinct numbers.", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Modulo", "background": "", "description": "给定两个整数 A 和 B，A 模 B 是 A 除以 B 的余数。例如，数字 7、14、27 和 38 模 3 后分别为 1、2、0 和 2。编写一个程序，接受 10 个数字作为输入，并输出这些数字模 42 后的不同数字的个数。", "inputFormat": "输入将包含 10 个非负整数，每个整数小于 1000，每行一个。", "outputFormat": "输出这些数字模 42 后的不同值的个数，输出为一行。", "hint": "在第一个例子中，数字模 42 后为 1、2、3、4、5、6、7、8、9 和 10。  \n在第二个例子中，所有数字模 42 后为 0。  \n在第三个例子中，数字模 42 后为 39、40、41、0、1、2、40、41、0 和 1。有 6 个不同的数字。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4326", "type": "P", "difficulty": 1, "samples": [["1", "3.141593\n2.000000"], ["21", "1385.442360\n882.000000"], ["42", "5541.769441\n3528.000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["数学", "2006", "Special Judge", "COCI（克罗地亚）", "平面几何"], "title": "[COCI 2006/2007 #1] Herman", "background": "", "description": "The 19th century German mathematician Hermann Minkowski investigated a non-Euclidian geometry, called the taxicab geometry. In taxicab geometry the distance between two points T1(x1, y1) and T2(x2, y2) is defined as:\nD(T1,T2) = |x1 - x2| + |y1 - y2|\nAll other definitions are the same as in Euclidian geometry, including that of a circle:\nA circle is the set of all points in a plane at a fixed distance (the radius) from a fixed point (the centre of the circle).\nWe are interested in the difference of the areas of two circles with radius R, one of which is in normal (Euclidian) geometry, and the other in taxicab geometry. The burden of solving this difficult problem has fallen onto you.", "inputFormat": "The first and only line of input will contain the radius R, an integer smaller than or equal to 10000.", "outputFormat": "On the first line you should output the area of a circle with radius R in normal (Euclidian) geometry.\nOn the second line you should output the area of a circle with radius R in taxicab geometry.\nNote: Outputs within ±0.0001 of the official solution will be accepted.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Herman", "background": "", "description": "The 19th century German mathematician Hermann Minkowski investigated a non-Euclidian geometry, called the taxicab geometry. In taxicab geometry the distance between two points T1(x1, y1) and T2(x2, y2) is defined as:\nD(T1,T2) = |x1 - x2| + |y1 - y2|\nAll other definitions are the same as in Euclidian geometry, including that of a circle:\nA circle is the set of all points in a plane at a fixed distance (the radius) from a fixed point (the centre of the circle).\nWe are interested in the difference of the areas of two circles with radius R, one of which is in normal (Euclidian) geometry, and the other in taxicab geometry. The burden of solving this difficult problem has fallen onto you.", "inputFormat": "The first and only line of input will contain the radius R, an integer smaller than or equal to 10000.", "outputFormat": "On the first line you should output the area of a circle with radius R in normal (Euclidian) geometry.\nOn the second line you should output the area of a circle with radius R in taxicab geometry.\nNote: Outputs within ±0.0001 of the official solution will be accepted.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Herman", "background": "", "description": "19世纪的德国数学家赫尔曼·闵可夫斯基(Hermann Minkowski)研究了一种名为出租车几何学的非欧几何。\n在出租车几何里$T_1(x_1,y_1)$ $T_2(x_2,y_2)$两点之间的距离被定义为$dis(T_1,T_2)=|x_1-x_2|+|y_1-y_2|$(曼哈顿距离)。\n其他定义均与欧几里得几何相同。  \n例如圆的定义：在同一平面内，到定点(圆心)的距离等于定长(半径)的点的集合。\n\n我们对欧几里得几何与出租车几何两种定义下半径为$R$的圆的面积很感兴趣。解决这个问题的重担就落在你身上了。", "inputFormat": "仅有一行为圆的半径$R$。 $(R \\leq 10000)$", "outputFormat": "第一行输出欧几里得几何下半径为$R$的圆的面积，第二行输出出租车几何下半径为$R$的圆的面积。\n\n注意：你的输出与标准答案绝对误差不超过$0.0001$将会被认为正确", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4327", "type": "P", "difficulty": 1, "samples": [["A", "..#..\n.#.#.\n#.A.#\n.#.#.\n..#.."], ["DOG", "..#...#...*..\n.#.#.#.#.*.*.\n#.D.#.O.*.G.*\n.#.#.#.#.*.*.\n..#...#...*.."], ["ABCD", "..#...#...*...#..\n.#.#.#.#.*.*.#.#.\n#.A.#.B.*.C.*.D.#\n.#.#.#.#.*.*.#.#.\n..#...#...*...#.."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["模拟", "字符串", "2006", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #1] Okviri", "background": "", "description": "“Peter Pan frames” are a way of decorating text in which every character is framed by a diamond shaped frame, with frames of neigbhouring characters interleaving. A Peter Pan frame for one letter looks like this ('X' is the letter we are framing):\n```\n..#..\n.#.#.\n#.X.#\n.#.#.\n..#..\n```\nHowever, such a framing would be somewhat dull so we'll frame every third letter using a “Wendyframe”. A Wendy frame looks like this:\n\n```\n..*..\n.*.*.\n*.X.*\n.*.*.\n..*..\n```\nWhen a Wendy frame interleaves with a Peter Pan frame, the Wendy frame (being much nicer) is put on top. For an example of the interleaving check the sample cases.", "inputFormat": "The first and only line of input will contain at most 15 capital letters of the English alphabet.", "outputFormat": "Output the word written using Peter Pan and Wendy frames on 5 lines.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Okviri", "background": "", "description": "“Peter Pan frames” are a way of decorating text in which every character is framed by a diamond shaped frame, with frames of neigbhouring characters interleaving. A Peter Pan frame for one letter looks like this ('X' is the letter we are framing):\n```\n..#..\n.#.#.\n#.X.#\n.#.#.\n..#..\n```\nHowever, such a framing would be somewhat dull so we'll frame every third letter using a “Wendyframe”. A Wendy frame looks like this:\n\n```\n..*..\n.*.*.\n*.X.*\n.*.*.\n..*..\n```\nWhen a Wendy frame interleaves with a Peter Pan frame, the Wendy frame (being much nicer) is put on top. For an example of the interleaving check the sample cases.", "inputFormat": "The first and only line of input will contain at most 15 capital letters of the English alphabet.", "outputFormat": "Output the word written using Peter Pan and Wendy frames on 5 lines.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Okviri", "background": null, "description": "“彼得·潘框架”是一种装饰文字，每一个字母都是由一个菱形框架。一个彼得·潘框架看起来像这样（`x` 是字母，`#` 是框架）：\n```\n..#..\n.#.#.\n#.X.#\n.#.#.\n..#..\n```\n然而，只是一个框架会有些沉闷，所以我们每遇到三个字母会把第三个字母用温迪框架把它框起来。温迪框架看起来像这样：\n```\n..*..\n.*.*.\n*.X.*\n.*.*.\n..*..\n```\n当温迪和彼得·潘的框架重叠时，温迪框架覆盖在上面。 （见样例 3）", "inputFormat": "一行由英文大写字母组成的长度不超过 15 字符的字符串。", "outputFormat": "输出使用彼得·潘和温迪框架写成的 5 行字符串。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4328", "type": "P", "difficulty": 3, "samples": [["3 3\nD.*\n...\n.S.", "3"], ["3 3\nD.*\n...\n..S", "KAKTUS"], ["3 6\nD...*.\n.X.X..\n....S.", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2006", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #1] Slikar", "background": "", "description": "The evil emperor Cactus has in his possession the Magic Keg and has flooded the Enchanted Forest! The Painter and the three little hedgehogs now have to return to the Beaver's den where they will be safe from the water as quickly as possible!\nThe map of the Enchanted Forest consists of R rows and C columns. Empty fields are represented by '.' characters, flooded fields by '*' and rocks by 'X'. Additionally, the Beaver's den is represented by 'D' and the Painter and the three little hedgehogs are shown as 'S'.\nEvery minute the Painter and the three little hedgehogs can move to 4 neighbouring fields (up, down, left or right). Every minute the flood expands as well so that all empty fields that have at least one common side with a flooded field become flooded as well. Neither water nor the Painter and the three little hedgehogs can pass through rocks. Naturally, the Painter and the three little hedgehogs cannot pass through flooded fields, and water cannot flood the Beaver's den.\nWrite a program that will, given a map of the Enchanted Forest, output the shortest time needed for the Painter and the three little hedgehogs to safely reach the Beaver's den.\nNote: The Painter and the three little hedgehogs cannot move into a field that is about to be flooded (in the same minute).", "inputFormat": "The first line of input will contain two integers, R and C, smaller than or equal to 50.\nThe following R lines will each contain C characters ('.', '*', 'X', 'D' or 'S'). The map will contain exactly one 'D' character and exactly one 'S' character.", "outputFormat": "Output the shortest possible time needed for the Painter and the three little hedgehogs to safely reach the Beaver's den. If this is impossible output the word “KAKTUS” on a line by itself.", "hint": "Clarification of the second sample test: The best they can do is to go along the lower border and then the left border, and get flooded one minute before reaching the den.", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Slikar", "background": "", "description": "The evil emperor Cactus has in his possession the Magic Keg and has flooded the Enchanted Forest! The Painter and the three little hedgehogs now have to return to the Beaver's den where they will be safe from the water as quickly as possible!\nThe map of the Enchanted Forest consists of R rows and C columns. Empty fields are represented by '.' characters, flooded fields by '*' and rocks by 'X'. Additionally, the Beaver's den is represented by 'D' and the Painter and the three little hedgehogs are shown as 'S'.\nEvery minute the Painter and the three little hedgehogs can move to 4 neighbouring fields (up, down, left or right). Every minute the flood expands as well so that all empty fields that have at least one common side with a flooded field become flooded as well. Neither water nor the Painter and the three little hedgehogs can pass through rocks. Naturally, the Painter and the three little hedgehogs cannot pass through flooded fields, and water cannot flood the Beaver's den.\nWrite a program that will, given a map of the Enchanted Forest, output the shortest time needed for the Painter and the three little hedgehogs to safely reach the Beaver's den.\nNote: The Painter and the three little hedgehogs cannot move into a field that is about to be flooded (in the same minute).", "inputFormat": "The first line of input will contain two integers, R and C, smaller than or equal to 50.\nThe following R lines will each contain C characters ('.', '*', 'X', 'D' or 'S'). The map will contain exactly one 'D' character and exactly one 'S' character.", "outputFormat": "Output the shortest possible time needed for the Painter and the three little hedgehogs to safely reach the Beaver's den. If this is impossible output the word “KAKTUS” on a line by itself.", "hint": "Clarification of the second sample test: The best they can do is to go along the lower border and then the left border, and get flooded one minute before reaching the den.", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Slikar", "background": "", "description": "邪恶的皇帝 Cactus 拥有魔法酒桶，并且已经淹没了魔法森林！画家和三只小刺猬现在必须尽快返回到海狸的巢穴，以免被水淹没！魔法森林的地图由 R 行 C 列组成。空地用字符 '.' 表示，淹没的区域用 '*' 表示，岩石用 'X' 表示。此外，海狸的巢穴用 'D' 表示，画家和三只小刺猬用 'S' 表示。每分钟，画家和三只小刺猬可以移动到四个相邻的区域（上、下、左或右）。每分钟，洪水也会扩散，使得所有与淹没区域至少有一个公共边的空地也被淹没。水和画家及三只小刺猬都不能穿过岩石。当然，画家和三只小刺猬不能穿过淹没的区域，水也不能淹没海狸的巢穴。编写一个程序，给定魔法森林的地图，输出画家和三只小刺猬安全到达海狸巢穴所需的最短时间。注意：画家和三只小刺猬不能移动到即将在同一分钟被淹没的区域。", "inputFormat": "输入的第一行包含两个整数 R 和 C，均小于或等于 50。接下来的 R 行每行包含 C 个字符（'.'，'*'，'X'，'D' 或 'S'）。地图将包含恰好一个 'D' 字符和恰好一个 'S' 字符。", "outputFormat": "输出画家和三只小刺猬安全到达海狸巢穴所需的最短时间。如果这不可能，输出单独一行“KAKTUS”。", "hint": "对第二个样例测试的说明：他们能做的最好就是沿着下边界走，然后沿着左边界走，并在到达巢穴前一分钟被淹没。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4329", "type": "P", "difficulty": 4, "samples": [["2\n100 100\n50 50", "50.000000"], ["2\n0 50\n50 0", "25.00000"], ["3\n25 60 100\n13 0 50\n12 70 90", "9.10000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["搜索", "2006", "Special Judge", "图论建模", "二分图", "费用流", "COCI（克罗地亚）", "状压 DP"], "title": "[COCI 2006/2007 #1] Bond", "background": "", "description": "Everyone knows of the secret agent double-oh-seven, the popular Bond (James Bond). A lesser known fact is that he actually did not perform most of his missions by himself; they were instead done by his cousins, Jimmy Bonds. Bond (James Bond) has grown weary of having to distribute assign missions to Jimmy Bonds every time he gets new missions so he has asked you to help him out.\nEvery month Bond (James Bond) receives a list of missions. Using his detailed intelligence from past missions, for every mission and for every Jimmy Bond he calculates the probability of that particular mission being successfully completed by that particular Jimmy Bond. Your program should process that data and find the arrangement that will result in the greatest probability that all missions are completed successfully.\nNote: the probability of all missions being completed successfully is equal to the product of the probabilities of the single missions being completed successfully.", "inputFormat": "The first line will contain an integer N, the number of Jimmy Bonds and missions (1 ≤ N ≤ 20).\nThe following N lines will contain N integers between 0 and 100, inclusive. The j-th integer on the ith line is the probability that Jimmy Bond i would successfully complete mission j, given as a percentage.", "outputFormat": "Output the maximum probability of Jimmy Bonds successfully completing all the missions, as a percentage.", "hint": "Clarification of the third example: If Jimmy bond 1 is assigned the 3rd mission, Jimmy Bond 2 the 1st mission and Jimmy Bond 3 the 2nd mission the probability is: 1.0 * 0.13 * 0.7 = 0.091 = 9.1%. All other arrangements give a smaller probability of success.\nNote: Outputs within ±0.000001 of the official solution will be accepted.", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Bond", "background": "", "description": "Everyone knows of the secret agent double-oh-seven, the popular Bond (James Bond). A lesser known fact is that he actually did not perform most of his missions by himself; they were instead done by his cousins, Jimmy Bonds. Bond (James Bond) has grown weary of having to distribute assign missions to Jimmy Bonds every time he gets new missions so he has asked you to help him out.\nEvery month Bond (James Bond) receives a list of missions. Using his detailed intelligence from past missions, for every mission and for every Jimmy Bond he calculates the probability of that particular mission being successfully completed by that particular Jimmy Bond. Your program should process that data and find the arrangement that will result in the greatest probability that all missions are completed successfully.\nNote: the probability of all missions being completed successfully is equal to the product of the probabilities of the single missions being completed successfully.", "inputFormat": "The first line will contain an integer N, the number of Jimmy Bonds and missions (1 ≤ N ≤ 20).\nThe following N lines will contain N integers between 0 and 100, inclusive. The j-th integer on the ith line is the probability that Jimmy Bond i would successfully complete mission j, given as a percentage.", "outputFormat": "Output the maximum probability of Jimmy Bonds successfully completing all the missions, as a percentage.", "hint": "Clarification of the third example: If Jimmy bond 1 is assigned the 3rd mission, Jimmy Bond 2 the 1st mission and Jimmy Bond 3 the 2nd mission the probability is: 1.0 * 0.13 * 0.7 = 0.091 = 9.1%. All other arrangements give a smaller probability of success.\nNote: Outputs within ±0.000001 of the official solution will be accepted.", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Bond", "background": null, "description": "每个人都知道特工 007，著名的邦德（詹姆斯·邦德）。一个鲜为人知的事实是，他实际上并没有亲自完成大多数任务；这些任务是由他的表亲，吉米·邦德们完成的。邦德（詹姆斯·邦德）已经厌倦了每次接到新任务时都要分配任务给吉米·邦德们，所以他请求你帮助他。每个月，邦德（詹姆斯·邦德）都会收到一份任务清单。利用他从过去任务中获得的详细情报，对于每个任务和每个吉米·邦德，他计算出该吉米·邦德成功完成该任务的概率。你的程序应该处理这些数据，并找到一种安排，使得所有任务成功完成的概率最大化。注意：所有任务成功完成的概率等于单个任务成功完成的概率的乘积。", "inputFormat": "第一行包含一个整数 $N$，表示吉米·邦德和任务的数量（$1 \\le N \\le 20$）。接下来的 $N$ 行将包含 $N$ 个介于 $0$ 和 $100$ 之间的整数（包括 $0$ 和 $100$）。第 $i$ 行的第 $j$ 个整数表示吉米·邦德 $i$ 成功完成任务 $j$ 的概率，以百分比表示。", "outputFormat": "输出吉米·邦德成功完成所有任务的最大概率，以百分比表示。", "hint": "第三个例子的说明：如果吉米·邦德 $1$ 被分配第 $3$ 个任务，吉米·邦德 $2$ 被分配第 $1$ 个任务，吉米·邦德 $3$ 被分配第 $2$ 个任务，则概率为：$1.0 \\times 0.13 \\times 0.7 = 0.091 = 9.1\\%$。所有其他安排的成功概率都较小。注意：与官方答案相差不超过 $\\pm 10^{-6}$ 的输出将被接受。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4330", "type": "P", "difficulty": 5, "samples": [["3 6\n101010\n111001\n101001", "3"], ["4 5\n10010\n01010\n10101\n01001", "3"], ["3 3\n101\n111\n100", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2006", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #1] Debug", "background": "", "description": "While debugging a program Mirko noticed that a bug in the program may be linked with the existence of so called square killers in the program memory. The program memory is a matrix composed of R rows and C columns consisting only of zeroes and ones. A square killer is a square submatrix in memory, consisting of more than one character, that, when rotated 180 degrees looks exactly the same. For example, the following matrix contains 3 square killers:\n\n![](https://cdn.luogu.com.cn/upload/pic/15764.png)\n\nMirko is wondering if there is a connection between the size of the largest square killer and the bug in the program. Help Mirko by writing a program that, given the layout of the memory, outputs the size of the largest square killer. The size of the square killer is the number of rows (or columns) that the killer consists of. In the example above the killer sizes are 2, 2 and 3, respectively.", "inputFormat": "The first will contain two integers, R and C, smaller than or equal to 300.\nThe next R lines will each contain C characters ('0' or '1') with no spaces.", "outputFormat": "Output the size of the largest killer on a single line, or output -1 if there are no square killers.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #1] Debug", "background": "", "description": "While debugging a program Mirko noticed that a bug in the program may be linked with the existence of so called square killers in the program memory. The program memory is a matrix composed of R rows and C columns consisting only of zeroes and ones. A square killer is a square submatrix in memory, consisting of more than one character, that, when rotated 180 degrees looks exactly the same. For example, the following matrix contains 3 square killers:\n\n![](https://cdn.luogu.com.cn/upload/pic/15764.png)\n\nMirko is wondering if there is a connection between the size of the largest square killer and the bug in the program. Help Mirko by writing a program that, given the layout of the memory, outputs the size of the largest square killer. The size of the square killer is the number of rows (or columns) that the killer consists of. In the example above the killer sizes are 2, 2 and 3, respectively.", "inputFormat": "The first will contain two integers, R and C, smaller than or equal to 300.\nThe next R lines will each contain C characters ('0' or '1') with no spaces.", "outputFormat": "Output the size of the largest killer on a single line, or output -1 if there are no square killers.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #1] Debug", "background": "", "description": "在调试程序时，Mirko 注意到程序中的一个错误可能与程序内存中存在的所谓“方形杀手”有关。程序内存是一个由 R 行 C 列组成的矩阵，仅包含 0 和 1。一个“方形杀手”是内存中的一个方形子矩阵，由多个字符组成，当旋转 180 度时看起来完全相同。例如，下面的矩阵包含 3 个“方形杀手”：\n\n![](https://cdn.luogu.com.cn/upload/pic/15764.png)\n\nMirko 想知道最大“方形杀手”的大小与程序中的错误是否存在关联。请帮助 Mirko 编写一个程序，给定内存的布局，输出最大“方形杀手”的大小。“方形杀手”的大小是指其包含的行数（或列数）。在上面的例子中，“方形杀手”的大小分别为 2、2 和 3。", "inputFormat": "第一行包含两个整数 R 和 C，均小于或等于 300。接下来的 R 行每行包含 C 个字符（'0' 或 '1'），没有空格。", "outputFormat": "输出最大“方形杀手”的大小，单独一行；如果没有“方形杀手”，则输出 -1。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4331", "type": "P", "difficulty": 6, "samples": [["7\n9\n4\n8\n20\n14\n15\n18", "13\n6\n7\n8\n13\n14\n15\n18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2004", "线段树", "Special Judge", "可并堆", "BalticOI（波罗的海）", "斜率维护技巧 slope trick"], "title": "[BalticOI 2004] Sequence (Day1)", "background": "", "description": "给定一个序列 $t_1,t_2,\\dots,t_n$，求出一个递增序列 $z_1,z_2,\\dots,z_n$，使得序列 $t_i$ 和 $z_i$ 的各项之差的绝对值之和 $|t_1-z_1|+|t_2-z_2|+\\dots+|t_n-z_n|$ 最小。", "inputFormat": "输入文件的第一行包含一个整数 $n$。\n\n接下来 $n$ 行，每行包含一个整数，表示给定的序列 $t_i$。", "outputFormat": "输出文件的第一行应当包含最小的各项之差的绝对值之和。\n\n接下来 $n$ 行，每行应当包含一个整数，表示所求的序列 $z_i$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 10^6$，$0\\le t_i\\le 2\\times 10^9$。\n\n#### 说明\n\n译自 [BalticOI 2004 Day1 C Sequence](https://boi.cses.fi/files/boi2004_day1.pdf)。\n\n感谢 @TimeTraveller 提供的 SPJ！", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2004] Sequence (Day1)", "background": "", "description": "Given a sequence $t_1, t_2, \\dots, t_n$, find an increasing sequence $z_1, z_2, \\dots, z_n$ such that the sum of absolute differences $|t_1 - z_1| + |t_2 - z_2| + \\dots + |t_n - z_n|$ is minimized.", "inputFormat": "The first line contains an integer $n$.\nThe next $n$ lines each contain an integer, representing the given sequence values $t_i$.", "outputFormat": "The first line should contain the minimum sum of absolute differences.\nThe next $n$ lines should each contain an integer, representing the sequence values $z_i$.", "hint": "#### Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^6$, $0 \\le t_i \\le 2 \\times 10^9$.\n\n#### Notes\n\nTranslated from [BalticOI 2004 Day1 C Sequence](https://boi.cses.fi/files/boi2004_day1.pdf).\nThanks to @TimeTraveller for providing the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2004] Sequence (Day1)", "background": "", "description": "给定一个序列 $t_1,t_2,\\dots,t_n$，求出一个递增序列 $z_1,z_2,\\dots,z_n$，使得序列 $t_i$ 和 $z_i$ 的各项之差的绝对值之和 $|t_1-z_1|+|t_2-z_2|+\\dots+|t_n-z_n|$ 最小。", "inputFormat": "输入文件的第一行包含一个整数 $n$。\n\n接下来 $n$ 行，每行包含一个整数，表示给定的序列 $t_i$。", "outputFormat": "输出文件的第一行应当包含最小的各项之差的绝对值之和。\n\n接下来 $n$ 行，每行应当包含一个整数，表示所求的序列 $z_i$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 10^6$，$0\\le t_i\\le 2\\times 10^9$。\n\n#### 说明\n\n译自 [BalticOI 2004 Day1 C Sequence](https://boi.cses.fi/files/boi2004_day1.pdf)。\n\n感谢 @TimeTraveller 提供的 SPJ！", "locale": "zh-CN"}}}
{"pid": "P4332", "type": "P", "difficulty": 6, "samples": [["3\n2 3 4\n5 6 7\n8 9 10\n0 0 0 0 1 1 1\n5\n4\n4\n5\n6\n8\n", "1\n0\n0\n1\n1\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["模拟", "2014", "线段树", "各省省选", "上海", "O2优化", "分治", "树链剖分", "动态树 LCT"], "title": "[SHOI2014] 三叉神经树", "background": "", "description": "计算神经学作为新兴的交叉学科近些年来一直是学术界的热点。一种叫做 SHOI 的神经组织因为其和近日发现的化合物 SHTSC 的密切联系引起了人们的极大关注。\n\nSHOI 组织由若干个 SHOI 细胞构成，SHOI 细胞之间形成严密的树形结构。每个 SHOI 细胞都有且只有一个输出端,被称为轴突,除了一个特殊的、被称为根细胞的 SHOI 细胞的输出作为整个组织的输出以外,其余细胞的轴突均连向其上级 SHOI 细胞；并且有且只有三个接收端,被称为树突,从其下级细胞或者其它神经组织那里接收信息。SHOI 细胞的信号机制较为简单,仅有 $0$和 $1$ 两种。每个 SHOI 细胞根据三个输入端中 $0$和 $1$ 信号的多寡输出较多的那一种。\n\n现在给出了一段 SHOI 组织的信息，以及外部神经组织的输入变化情况。请你模拟 SHOI 组织的输出结果。", "inputFormat": "输入的第一行包含一个整数 $n$。表示 SHOI 组织的总细胞个数。SHOI 细胞由 $1\\sim n$ 编号,编号为 $1$ 的是根细胞。\n\n从第二行开始的 $n$ 行,每行三个整数 $x_1, x_2, x_3$，分别表示编号为 $1\\sim n$ 的 SHOI 细胞的树突连接。$1 < x_i \\leq n$ 表示连向编号为 $x_i$ 的细胞的轴突, $n < x_i \\leq 3n+1$ 表示连向编号为 $x_i$ 的外界输入。输入数据保证给出的 SHOI 组织是合法的，且所有的 $x_i$ 两两不同。\n\n接下来一行包含 $2n+1$ 个整数（$0$ 或者 $1$），表示初始时的外界输入。\n\n第 $n+3$ 行有一个整数 $q$，表示总操作数。\n\n之后 $q$ 行，每行一个整数 $x$，表示编号为 $x$ 的外界输入发生了变化。", "outputFormat": "输出共 $q$ 行，每行一个整数，对应第 $i$ 次外界输入变化后的根细胞的输出。", "hint": "- 对于 $10 \\%$ 的数据，满足 $1\\le n \\leq 10^3$，$ 1\\le q \\leq 10^3$。\n- 对于 $30 \\%$ 的数据，满足 $1\\le n \\leq 10^5$，$ 1\\le q \\leq 10^5$。\n- 对于 $100 \\%$ 的数据，满足 $1\\le n \\leq 5\\times 10^5$，$ 1\\le q \\leq 5\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2014] Trinary Neural Tree", "background": "", "description": "Computational neuroscience, as an emerging interdisciplinary field, has been a research hotspot in recent years. A kind of neural tissue called SHOI has attracted great attention because of its close relationship with a recently discovered compound, SHTSC.\n\nA SHOI tissue consists of several SHOI cells forming a strict tree structure. Each SHOI cell has exactly one output terminal, called an axon. Except for a special SHOI cell called the root cell whose output serves as the output of the entire tissue, the axons of all other cells connect to their parent SHOI cell. Each cell also has exactly three input terminals, called dendrites, which receive information from its child cells or from other neural tissues. The signaling mechanism of SHOI cells is simple, with only $0$ and $1$. Each SHOI cell outputs the majority value among the three input signals, i.e., whichever of $0$ or $1$ appears more times among its three inputs.\n\nYou are given the structure of a SHOI tissue and the changes of external neural inputs. Please simulate the output of the SHOI tissue.", "inputFormat": "- The first line contains an integer $n$, the total number of SHOI cells. Cells are numbered $1 \\sim n$, and cell $1$ is the root cell.\n- The next $n$ lines each contain three integers $x_1, x_2, x_3$, describing the dendrite connections of cells $1 \\sim n$, respectively. If $1 < x_i \\leq n$, it connects to the axon of cell $x_i$. If $n < x_i \\leq 3n+1$, it connects to the external input with index $x_i$. The input guarantees that the given SHOI tissue is valid, and for each cell the three $x_i$ are pairwise distinct.\n- The next line contains $2n+1$ integers (each $0$ or $1$), giving the initial values of the external inputs in the order of indices $n+1, n+2, \\dots, 3n+1$.\n- The next line contains an integer $q$, the number of operations.\n- The next $q$ lines each contain one integer $x$, indicating that the external input with index $x$ (where $n < x \\leq 3n+1$) toggles its value.", "outputFormat": "Output $q$ lines. For the $i$-th change of an external input, print one integer: the output of the root cell after this change.", "hint": "- For $10 \\%$ of the testdata, $1 \\leq n \\leq 10^3$, $1 \\leq q \\leq 10^3$.\n- For $30 \\%$ of the testdata, $1 \\leq n \\leq 10^5$, $1 \\leq q \\leq 10^5$.\n- For $100 \\%$ of the testdata, $1 \\leq n \\leq 5 \\times 10^5$, $1 \\leq q \\leq 5 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2014] 三叉神经树", "background": "", "description": "计算神经学作为新兴的交叉学科近些年来一直是学术界的热点。一种叫做 SHOI 的神经组织因为其和近日发现的化合物 SHTSC 的密切联系引起了人们的极大关注。\n\nSHOI 组织由若干个 SHOI 细胞构成，SHOI 细胞之间形成严密的树形结构。每个 SHOI 细胞都有且只有一个输出端,被称为轴突,除了一个特殊的、被称为根细胞的 SHOI 细胞的输出作为整个组织的输出以外,其余细胞的轴突均连向其上级 SHOI 细胞；并且有且只有三个接收端,被称为树突,从其下级细胞或者其它神经组织那里接收信息。SHOI 细胞的信号机制较为简单,仅有 $0$和 $1$ 两种。每个 SHOI 细胞根据三个输入端中 $0$和 $1$ 信号的多寡输出较多的那一种。\n\n现在给出了一段 SHOI 组织的信息，以及外部神经组织的输入变化情况。请你模拟 SHOI 组织的输出结果。", "inputFormat": "输入的第一行包含一个整数 $n$。表示 SHOI 组织的总细胞个数。SHOI 细胞由 $1\\sim n$ 编号,编号为 $1$ 的是根细胞。\n\n从第二行开始的 $n$ 行,每行三个整数 $x_1, x_2, x_3$，分别表示编号为 $1\\sim n$ 的 SHOI 细胞的树突连接。$1 < x_i \\leq n$ 表示连向编号为 $x_i$ 的细胞的轴突, $n < x_i \\leq 3n+1$ 表示连向编号为 $x_i$ 的外界输入。输入数据保证给出的 SHOI 组织是合法的，且所有的 $x_i$ 两两不同。\n\n接下来一行包含 $2n+1$ 个整数（$0$ 或者 $1$），表示初始时的外界输入。\n\n第 $n+3$ 行有一个整数 $q$，表示总操作数。\n\n之后 $q$ 行，每行一个整数 $x$，表示编号为 $x$ 的外界输入发生了变化。", "outputFormat": "输出共 $q$ 行，每行一个整数，对应第 $i$ 次外界输入变化后的根细胞的输出。", "hint": "- 对于 $10 \\%$ 的数据，满足 $1\\le n \\leq 10^3$，$ 1\\le q \\leq 10^3$。\n- 对于 $30 \\%$ 的数据，满足 $1\\le n \\leq 10^5$，$ 1\\le q \\leq 10^5$。\n- 对于 $100 \\%$ 的数据，满足 $1\\le n \\leq 5\\times 10^5$，$ 1\\le q \\leq 5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4333", "type": "P", "difficulty": 6, "samples": [["3\n0 3\n1 5\n1 7", "0"], ["5\n0 8626\n1 29255\n2 21486\n2 26193\n1 22439", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "各省省选", "江苏"], "title": "[JSOI2010] 游戏", "background": null, "description": "JSOI 集训队的小 L，小 H，小 X 在紧张的训练之余，总是喜欢玩一个称之为“取数”的游戏来调节自己：\n\n这是一个人玩的游戏，仅仅需要一张白纸和一支笔。玩家在纸上随机写下一行共 $n$ 个整数，形成一个数列，就可以开始游戏了。\n\n每次玩家从原数列最左端或最右端选择一个数，将它从原数列中划去，并写在下一行。当原数列的数全部被划去后，在第二行就出现了一个新的长度为 $n$ 的数列，记为 $S$。将按照如下方式计算数列 $S$ 的分数 $P$：\n\n$$P=S_1\\times 5^0+S_2\\times 5^1+\\cdots+S_n\\times 5^{n-1}$$\n\n算出分数 $P$ 后，将其转为二进制表示，如果末三位数字是  $011$ 的话，玩家就取得了游戏的胜利，否则就失败了。\n\n在玩了很多次这个游戏后，小 L，小 H，小 X 发现一个重要的事实：对于某些随机写下的数列，是无论如何也无法取得游戏胜利的，这样的数列被称为“刁列”，其它的数列则被\n称为“良列”。\n\n这个游戏虽然趣味性极强，但有一个弊端：每次游戏前需要花很多时间来写出这个随机数列，这一点一直深深困扰着小 L，小 H 和小 X。\n\n直到在今年省选前的那天晚上，小 L 想出了一个惊为天人的创意，一举攻克了这个难题：他们先在纸上画出一颗庞大的无根树（共 $m$ 个结点），每个结点上写下一个整数。当想要玩游戏时，玩家只需随便选择两个结点，通过找出连接这两个结点的那条唯一的路径，将路径上所有结点（包括两个端点）上标注的整数按路径的顺序列出来，就得到了一个数列，然后就可以在这个数列上玩游戏了。如果选择的两个端点分别是树上结点 $v_i$ 和结点 $v_j$，得到的数列就简记为 $i\\sim j$。当然，如前所述，$i\\sim j$ 这个数列也有“良列”和“刁列”两种可能。\n\n他们发现这样改进以后真的方便了很多！不仅如此，还给游戏带来了一些新的趣味。比如小 X 就声称他发现了一个重要的规律：数列的属性是具有传递性的，即：对于任意互不相同的 $i,j,k$ 有：\n\n- 如果 $i\\sim j$ 是良列，$j\\sim k$ 是良列，则 $i\\sim k$ 是良列。\n\n- 如果 $i\\sim j$ 是刁列且 $j\\sim k$ 是刁列，则 $i\\sim k$ 是刁列。\n\n这个结论出奇地优美，但很快就被小 H 找到了反例，这让小 X 心情沮丧。小 L 为了安慰小 X，说：不如我们来看看你这个结论在多少情况下是成立的吧。\n\n小 X 振作了起来，大家一起投入了繁重的工作中。他们要找出存在多少个三元组 $(i,j,k)$，其中 $i<j<k$，使得 $i,j,k$ 满足小 X 发现的传递性结论。", "inputFormat": "第一行一个整数 $m$，代表无根树的节点个数。\n\n接下来 $m$ 行，每行两个整数 $f_i,x_i$，其中 $f_i<i$。$f_i$ 表示节点 $v_i$ 的父节点编号，如果 $f_i=0$ 则该节点为根，$x_i$ 表示节点 $v_i$ 上写的数。", "outputFormat": "一行一个整数，表示答案。", "hint": "### 数据范围\n\n对于 $10\\%$ 的数据，$1\\leq m\\leq 5$。\n\n对于 $30\\%$ 的数据，$1\\leq m\\leq 100$。\n\n对于 $50\\%$ 的数据，$1\\leq m\\leq 10^3$。\n\n对于 $100\\%$ 的数据，$1\\leq m\\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2010] 游戏", "background": null, "description": "JSOI 集训队的小 L，小 H，小 X 在紧张的训练之余，总是喜欢玩一个称之为“取数”的游戏来调节自己：\n\n这是一个人玩的游戏，仅仅需要一张白纸和一支笔。玩家在纸上随机写下一行共 $n$ 个整数，形成一个数列，就可以开始游戏了。\n\n每次玩家从原数列最左端或最右端选择一个数，将它从原数列中划去，并写在下一行。当原数列的数全部被划去后，在第二行就出现了一个新的长度为 $n$ 的数列，记为 $S$。将按照如下方式计算数列 $S$ 的分数 $P$：\n\n$$P=S_1\\times 5^0+S_2\\times 5^1+\\cdots+S_n\\times 5^{n-1}$$\n\n算出分数 $P$ 后，将其转为二进制表示，如果末三位数字是  $011$ 的话，玩家就取得了游戏的胜利，否则就失败了。\n\n在玩了很多次这个游戏后，小 L，小 H，小 X 发现一个重要的事实：对于某些随机写下的数列，是无论如何也无法取得游戏胜利的，这样的数列被称为“刁列”，其它的数列则被\n称为“良列”。\n\n这个游戏虽然趣味性极强，但有一个弊端：每次游戏前需要花很多时间来写出这个随机数列，这一点一直深深困扰着小 L，小 H 和小 X。\n\n直到在今年省选前的那天晚上，小 L 想出了一个惊为天人的创意，一举攻克了这个难题：他们先在纸上画出一颗庞大的无根树（共 $m$ 个结点），每个结点上写下一个整数。当想要玩游戏时，玩家只需随便选择两个结点，通过找出连接这两个结点的那条唯一的路径，将路径上所有结点（包括两个端点）上标注的整数按路径的顺序列出来，就得到了一个数列，然后就可以在这个数列上玩游戏了。如果选择的两个端点分别是树上结点 $v_i$ 和结点 $v_j$，得到的数列就简记为 $i\\sim j$。当然，如前所述，$i\\sim j$ 这个数列也有“良列”和“刁列”两种可能。\n\n他们发现这样改进以后真的方便了很多！不仅如此，还给游戏带来了一些新的趣味。比如小 X 就声称他发现了一个重要的规律：数列的属性是具有传递性的，即：对于任意互不相同的 $i,j,k$ 有：\n\n- 如果 $i\\sim j$ 是良列，$j\\sim k$ 是良列，则 $i\\sim k$ 是良列。\n\n- 如果 $i\\sim j$ 是刁列且 $j\\sim k$ 是刁列，则 $i\\sim k$ 是刁列。\n\n这个结论出奇地优美，但很快就被小 H 找到了反例，这让小 X 心情沮丧。小 L 为了安慰小 X，说：不如我们来看看你这个结论在多少情况下是成立的吧。\n\n小 X 振作了起来，大家一起投入了繁重的工作中。他们要找出存在多少个三元组 $(i,j,k)$，其中 $i<j<k$，使得 $i,j,k$ 满足小 X 发现的传递性结论。", "inputFormat": "第一行一个整数 $m$，代表无根树的节点个数。\n\n接下来 $m$ 行，每行两个整数 $f_i,x_i$，其中 $f_i<i$。$f_i$ 表示节点 $v_i$ 的父节点编号，如果 $f_i=0$ 则该节点为根，$x_i$ 表示节点 $v_i$ 上写的数。", "outputFormat": "一行一个整数，表示答案。", "hint": "### 数据范围\n\n对于 $10\\%$ 的数据，$1\\leq m\\leq 5$。\n\n对于 $30\\%$ 的数据，$1\\leq m\\leq 100$。\n\n对于 $50\\%$ 的数据，$1\\leq m\\leq 10^3$。\n\n对于 $100\\%$ 的数据，$1\\leq m\\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4334", "type": "P", "difficulty": 6, "samples": [["13 15\n1 2\n2 3\n3 5\n2 4\n4 6\n2 6\n1 4\n1 7\n7 8\n7 9\n7 10\n8 11\n8 12\n9 12\n12 13\n5\n1 5 13 1 2\n1 6 2 1 4\n1 13 6 7 8\n2 13 6 7\n2 13 6 8", "yes\nyes\nyes\nno\nyes"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2007", "COI（克罗地亚）"], "title": "[COI 2007] Policija", "background": null, "description": "为了帮助抓捕逃犯，警方引进了一套新的电脑系统。警察的辖区包含 $N$ 座城市和 $E$ 条双向道路，城市的编号是 $1\\sim N$。\n\n警察常常要抓住那些逃往另一个城市的罪犯。侦查员看着地图，试着确定在哪里设置路障。新的计算机系统要回答以下两种问题：\n\n1. 考虑城市 $A$ 和 $B$，以及连接城市 $G_1$ 和 $G_2$ 的道路。罪犯能否在那条路不通的情况下从 $A$ 逃到 $B$？\n\n2. 考虑三个城市 $A, B, C$。罪犯能否在无法通过 $C$ 的情况下从 $A$ 逃到 $B$？\n\n写一个程序实现上述系统。", "inputFormat": "第一行两个整数 $N, E$（$2\\leq N\\leq 10 ^ 5$，$1\\leq E\\leq 5\\times 10 ^ 5$），表示城市数量和道路数量。\n\n接下来 $E$ 行，每行两个不同的数字 $u, v$，表示编号为 $u, v$ 的城市之间有一条道路。一对城市之间最多只有一条道路。\n\n接下来一行，一个整数 $Q$（$1\\leq Q\\leq 3\\times 10 ^ 5$），表示询问数量。\n\n接下来 $Q$ 行，每行四或五个整数描述一组询问。第一个数表示询问的类型 —— $1$ 或 $2$。\n\n如果询问类型为 $1$，那么在同一行还有四个整数 $A, B, G_1, G_2$。$A, B$ 不同，且 $G_1, G_2$ 之间存在道路。\n\n如果询问类型为 $2$，那么在同一行还有三个整数 $A, B, C$。$A, B, C$ 两两不同。\n\n保证图中每两个点相互连通。", "outputFormat": "对于每组询问，输出 `yes` 或 `no` 表示回答。", "hint": "翻译自 [Croatian Olympiad in Informatics 2007 B Policija](https://hsin.hr/coci/archive/2006_2007/olympiad_tasks.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[COI 2007] Policija", "background": null, "description": "To help capture criminals on the run, the police are introducing a new computer system. The area covered by the police contains $N$ cities and $E$ bidirectional roads connecting them. The cities are labelled $1$ to $N$.\n\nThe police often want to catch criminals trying to get from one city to another. Inspectors, looking at a map, try to determine where to set up barricades and roadblocks. The new computer system should answer the following two types of queries:\n\n1. Consider two cities $A$ and $B$, and a road connecting cities $G_1$ and $G_2$. Can the criminals get from city $A$ to city $B$ if that one road is blocked and the criminals can't use it?\n\n2. Consider three cities $A, B$ and $C$. Can the criminals get from city $A$ to city $B$ if the entire city $C$ is cut off and the criminals can't enter that city?\n\nWrite a program that implements the described system.", "inputFormat": "The first line contains two integers $N$ and $E\\ (2 \\le N \\le 100\\,000, 1 \\le E \\le 500\\,000)$, the number of cities and roads.\n\nEach of the following $E$ lines contains two distinct integers between $1$ and $N$ – the labels of two cities connected by a road. There will be at most one road between any pair of cities.\n\nThe following line contains the integer $Q\\ (1 \\le Q \\le 300\\,000)$, the number of queries the system is being tested on.\n\nEach of the following $Q$ lines contains either four or five integers. The first of these integers is the type of the query – $1$ or $2$.\n\nIf the query is of type $1$, then the same line contains four more integers $A, B, G_1$ and $G_2$ as described earlier. $A$ and $B$ will be different. $G_1$ and $G_2$ will represent an existing road.\n\nIf the query is of type $2$, then the same line contains three more integers $A, B$ and $C$. $A, B$ and $C$ will be distinct integers.\n\nThe test data will be such that it is initially possible to get from each city to every other city.", "outputFormat": "Output the answers to all $Q$ queries, one per line. The answer to a query can be `yes` or `no`.", "hint": "Resource: Croatian Olympiad in Informatics 2007.", "locale": "en"}, "zh-CN": {"title": "[COI 2007] Policija", "background": null, "description": "为了帮助抓捕逃犯，警方引进了一套新的电脑系统。警察的辖区包含 $N$ 座城市和 $E$ 条双向道路，城市的编号是 $1\\sim N$。\n\n警察常常要抓住那些逃往另一个城市的罪犯。侦查员看着地图，试着确定在哪里设置路障。新的计算机系统要回答以下两种问题：\n\n1. 考虑城市 $A$ 和 $B$，以及连接城市 $G_1$ 和 $G_2$ 的道路。罪犯能否在那条路不通的情况下从 $A$ 逃到 $B$？\n\n2. 考虑三个城市 $A, B, C$。罪犯能否在无法通过 $C$ 的情况下从 $A$ 逃到 $B$？\n\n写一个程序实现上述系统。", "inputFormat": "第一行两个整数 $N, E$（$2\\leq N\\leq 10 ^ 5$，$1\\leq E\\leq 5\\times 10 ^ 5$），表示城市数量和道路数量。\n\n接下来 $E$ 行，每行两个不同的数字 $u, v$，表示编号为 $u, v$ 的城市之间有一条道路。一对城市之间最多只有一条道路。\n\n接下来一行，一个整数 $Q$（$1\\leq Q\\leq 3\\times 10 ^ 5$），表示询问数量。\n\n接下来 $Q$ 行，每行四或五个整数描述一组询问。第一个数表示询问的类型 —— $1$ 或 $2$。\n\n如果询问类型为 $1$，那么在同一行还有四个整数 $A, B, G_1, G_2$。$A, B$ 不同，且 $G_1, G_2$ 之间存在道路。\n\n如果询问类型为 $2$，那么在同一行还有三个整数 $A, B, C$。$A, B, C$ 两两不同。\n\n保证图中每两个点相互连通。", "outputFormat": "对于每组询问，输出 `yes` 或 `no` 表示回答。", "hint": "翻译自 [Croatian Olympiad in Informatics 2007 B Policija](https://hsin.hr/coci/archive/2006_2007/olympiad_tasks.pdf)。", "locale": "zh-CN"}}}
{"pid": "P4335", "type": "P", "difficulty": 6, "samples": [["0 2\n", "9 4\n"], ["4 5\n-1 1\n0 -1\n0 1\n1 0\n", "10 16\n"], ["4 50000\n1 1\n-1 -1\n1 -1\n-1 1\n", "2500099997 2500000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2007", "COI（克罗地亚）"], "title": "[COI 2007] Sabor", "background": "", "description": "The president of the political party in power is holding a conference in the party headquarters. Politicians, members of the party, live in a two-dimensional grid, one member in each cell (except in cells containing obstacles). The headquarters are located in cell $(0, 0)$. This is also where the president of the party lives.\n\nPoliticians make steps in one of the four directions (up, down, left, right), moving to one of the four adjacent cells in one step. They can't enter cells with obstacles. The conference will be attended by all party members that can reach headquarters in $S$ steps or less. Each member coming to the conference will take the shortest route to headquarters (or any such route, if there is more than one).\n\nThe president has observed that politicians change their party affiliation with each step they take, becoming a member of the other party (there are only two parties on the political scene).\n\nWrite a program that determines how many politicians come to the conference as members of the party in power, and how many come as members of the opposing party.", "inputFormat": "The first line contains two integers $B$ and $S\\ (0 \\le B \\le 10\\,000, 1 \\le S \\le 10\\,000\\,000)$, the number of obstacles and the largest number of steps from the task description.\n\nEach of the following $B$ lines contains two integers, the coordinates of one obstacle. The absolute value of both coordinates will be less than $1000$.\n\nNo two obstacles will be in the same cell and there will be no obstacle in cell $(0, 0)$.", "outputFormat": "Output two integers on a single line separated by a space, the number of politicians that come to the conference as members of the party in power and the opposing party, respectively.", "hint": "Resource: Croatian Olympiad in Informatics 2007.", "locale": "en", "translations": {"en": {"title": "[COI 2007] Sabor", "background": "", "description": "The president of the political party in power is holding a conference in the party headquarters. Politicians, members of the party, live in a two-dimensional grid, one member in each cell (except in cells containing obstacles). The headquarters are located in cell $(0, 0)$. This is also where the president of the party lives.\n\nPoliticians make steps in one of the four directions (up, down, left, right), moving to one of the four adjacent cells in one step. They can't enter cells with obstacles. The conference will be attended by all party members that can reach headquarters in $S$ steps or less. Each member coming to the conference will take the shortest route to headquarters (or any such route, if there is more than one).\n\nThe president has observed that politicians change their party affiliation with each step they take, becoming a member of the other party (there are only two parties on the political scene).\n\nWrite a program that determines how many politicians come to the conference as members of the party in power, and how many come as members of the opposing party.", "inputFormat": "The first line contains two integers $B$ and $S\\ (0 \\le B \\le 10\\,000, 1 \\le S \\le 10\\,000\\,000)$, the number of obstacles and the largest number of steps from the task description.\n\nEach of the following $B$ lines contains two integers, the coordinates of one obstacle. The absolute value of both coordinates will be less than $1000$.\n\nNo two obstacles will be in the same cell and there will be no obstacle in cell $(0, 0)$.", "outputFormat": "Output two integers on a single line separated by a space, the number of politicians that come to the conference as members of the party in power and the opposing party, respectively.", "hint": "Resource: Croatian Olympiad in Informatics 2007.", "locale": "en"}, "zh-CN": {"title": "[COI 2007] Sabor", "background": "", "description": "执政党的首相正在国会大厦召开会议。议员们分布在一个二维平面的网格上（初始状态下所有议员都属于执政党，包括首相），每个格子里有一位议员（除了有障碍的格子）。国会大厦位于 $(0,0)$，即首相所在的位置。\n\n议员们可以选择上、下、左、右四个方向之一，移动到相邻的格子中。他们不能进入有障碍的格子。只有那些能在 $S$ 步以内到达国会大厦的议员，才能参加会议。每位议员都会选择最短路径前往国会大厦（如果存在多条最短路径，可以任选其一）。\n\n首相注意到，每位议员在移动的过程中，每走一步，其政治立场都会在执政党与反对党之间切换一次（该国实行两党制）。\n请编写一个程序，计算最终能参加会议的议员中，有多少人是执政党成员，有多少人是反对党成员。", "inputFormat": "第一行包含两个整数 $B$ 和 $S$（$0\\leq B\\leq 10 ^ 4$，$1\\leq S\\leq 10^7$），分别表示障碍的数量和议员能移动的最大步数。\n\n接下来 $B$ 行，每行包含两个整数，表示障碍所在格子的横纵坐标。横纵坐标的绝对值均小于 $10^3$。\n\n没有两个障碍位于同一个格子，也没有障碍位于格子 $(0,0)$。\n", "outputFormat": "输出仅一行，包含两个整数，用空格隔开，分别表示执政党议员和反对党议员的人数。", "hint": "翻译自 [Croatian Olympiad in Informatics 2007 C Sabor](https://hsin.hr/coci/archive/2006_2007/olympiad_tasks.pdf)。", "locale": "zh-CN"}}}
{"pid": "P4336", "type": "P", "difficulty": 6, "samples": [["4\n2 3 2 4 2\n5 2 1 3 1 3 2 4 1 4 3\n4 2 1 3 2 4 1 4 2", "17"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "各省省选", "矩阵树定理", "上海", "生成树", "容斥原理"], "title": "[SHOI2016] 黑暗前的幻想乡", "background": "四年一度的幻想乡大选开始了，最近幻想乡最大的问题是很多来历不明的妖怪涌入了幻想乡，扰乱了幻想乡昔日的秩序。但是幻想乡的建制派妖怪（人类）博丽灵梦和八云紫等人整日高谈所有妖怪平等，幻想乡多元化等等，对于幻想乡目前面临的种种大问题却给不出合理的解决方案。\n\n风见幽香是幻想乡里少有的意识到了问题严重性的大妖怪。她这次勇敢地站了出来参加幻想乡大选，提出包括在幻想乡边境建墙（并让人类出钱），大力开展基础设施建设挽回失业率等一系列方案，成为了大选年出人意料的黑马并顺利地当上了幻想乡的大统领。", "description": "幽香上台以后，第一项措施就是要修建幻想乡的公路。幻想乡一共有 $n$ 个城市，之前原来没有任何路。幽香向选民承诺要减税，所以她打算只修 $n-1$ 条公路将这些城市连接起来。但是幻想乡有正好 $n-1$ 个建筑公司，每个建筑公司都想在修路的过程中获得一些好处。虽然这些建筑公司在选举前没有给幽香钱，幽香还是打算和他们搞好关系，因为她还指望他们帮她建墙。所以她打算让每个建筑公司都负责一条路来修。\n\n每个建筑公司都告诉了幽香自己有能力负责修建的路是哪些城市之间的。所以幽香打算 $n - 1$ 条能够连接幻想乡所有城市的边，然后每条边都交给一个能够负责该边的建筑公司修建，并且每个建筑公司都恰好修建一条边。\n\n幽香现在想要知道一共有多少种可能的方案呢？两个方案不同当且仅当它们要么修的边的集合不同，要么边的分配方式不同。", "inputFormat": "第一行包含一个整数 $n$，表示城市个数。\n\n第 $2$ 到第 $n$ 行，第 $(i + 1)$ 行表示 第 $i$ 个建筑公司可以修建的路的列表：以一个非负整数 $m_i$ 开头，表示其可以修建条路的条数；接下来有 $m_i$ 对整数 $u, v$，每对数表示一条边的两个端点。其中不会出现重复的边，也不会出现自环。", "outputFormat": "输出一行一个整数，表示所有可能的方案数对 $10^9+7$ 取模的结果。", "hint": "#### 数据规模与约定\n\n+ 对于 $20\\%$ 的测试点，$n \\le 5$。\n+ 对于 $50\\%$ 的测试点，$n \\le 8$。\n+ 对于 $60\\%$ 的测试点，$n \\le 10$。\n+ 对于 $100\\%$ 的测试点，$2 \\leq n \\le 17$，$0 \\leq m_i \\leq \\frac{n(n - 1)}{2}$，$1 \\leq u, v \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2016] Gensokyo Before the Dark", "background": "The quadrennial Gensokyo election has begun. Recently, the biggest problem in Gensokyo is that many mysterious youkai have flooded in, disrupting its former order. However, the establishment youkai (and humans) such as Reimu Hakurei and Yukari Yakumo keep talking about equality for all youkai and diversity in Gensokyo, while offering no reasonable solutions to the pressing issues Gensokyo now faces.\n\nYuuka Kazami is one of the few great youkai in Gensokyo who realized the severity of the problem. She bravely stepped up to run in the election, proposing a series of plans such as building a wall on Gensokyo’s border (and making humans pay for it) and vigorously promoting infrastructure to reduce unemployment. She became the unexpected dark horse of the election year and successfully became the leader of Gensokyo.", "description": "After taking office, Yuuka’s first measure is to build Gensokyo’s highways. There are $n$ cities in Gensokyo, and initially there are no roads. Yuuka promised voters to cut taxes, so she plans to build only $n - 1$ roads to connect all these cities. There are exactly $n - 1$ construction companies, and each company wants to gain some benefits during road construction. Although these companies did not give Yuuka money before the election, she still intends to maintain good relations with them, since she is counting on them to help her build the wall. So she plans to have each construction company be responsible for exactly one road.\n\nEach construction company has told Yuuka between which pairs of cities it is capable of building a road. Yuuka will choose $n - 1$ edges that can connect all cities in Gensokyo, then assign each edge to a construction company that can build it, with each company building exactly one edge.\n\nYuuka now wants to know how many possible schemes there are in total. Two schemes are different if and only if either the set of edges to be built is different, or the assignment of companies to edges is different.", "inputFormat": "The first line contains an integer $n$, the number of cities.\n\nLines $2$ through $n$: line $i + 1$ describes the list of roads that the $i$-th construction company can build. It starts with a non-negative integer $m_i$, the number of roads it can build; then follow $m_i$ pairs of integers $u, v$, each pair denoting the endpoints of an edge. Within a company’s list, there are no duplicate edges and no self-loops.", "outputFormat": "Output a single integer on one line: the number of all possible schemes modulo $10^9+7$.", "hint": "Constraints\n\n- For $20\\%$ of the test points, $n \\le 5$.\n- For $50\\%$ of the test points, $n \\le 8$.\n- For $60\\%$ of the test points, $n \\le 10$.\n- For $100\\%$ of the test points, $2 \\leq n \\le 17$, $0 \\leq m_i \\leq \\frac{n(n - 1)}{2}$, $1 \\leq u, v \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2016] 黑暗前的幻想乡", "background": "四年一度的幻想乡大选开始了，最近幻想乡最大的问题是很多来历不明的妖怪涌入了幻想乡，扰乱了幻想乡昔日的秩序。但是幻想乡的建制派妖怪（人类）博丽灵梦和八云紫等人整日高谈所有妖怪平等，幻想乡多元化等等，对于幻想乡目前面临的种种大问题却给不出合理的解决方案。\n\n风见幽香是幻想乡里少有的意识到了问题严重性的大妖怪。她这次勇敢地站了出来参加幻想乡大选，提出包括在幻想乡边境建墙（并让人类出钱），大力开展基础设施建设挽回失业率等一系列方案，成为了大选年出人意料的黑马并顺利地当上了幻想乡的大统领。", "description": "幽香上台以后，第一项措施就是要修建幻想乡的公路。幻想乡一共有 $n$ 个城市，之前原来没有任何路。幽香向选民承诺要减税，所以她打算只修 $n-1$ 条公路将这些城市连接起来。但是幻想乡有正好 $n-1$ 个建筑公司，每个建筑公司都想在修路的过程中获得一些好处。虽然这些建筑公司在选举前没有给幽香钱，幽香还是打算和他们搞好关系，因为她还指望他们帮她建墙。所以她打算让每个建筑公司都负责一条路来修。\n\n每个建筑公司都告诉了幽香自己有能力负责修建的路是哪些城市之间的。所以幽香打算 $n - 1$ 条能够连接幻想乡所有城市的边，然后每条边都交给一个能够负责该边的建筑公司修建，并且每个建筑公司都恰好修建一条边。\n\n幽香现在想要知道一共有多少种可能的方案呢？两个方案不同当且仅当它们要么修的边的集合不同，要么边的分配方式不同。", "inputFormat": "第一行包含一个整数 $n$，表示城市个数。\n\n第 $2$ 到第 $n$ 行，第 $(i + 1)$ 行表示 第 $i$ 个建筑公司可以修建的路的列表：以一个非负整数 $m_i$ 开头，表示其可以修建条路的条数；接下来有 $m_i$ 对整数 $u, v$，每对数表示一条边的两个端点。其中不会出现重复的边，也不会出现自环。", "outputFormat": "输出一行一个整数，表示所有可能的方案数对 $10^9+7$ 取模的结果。", "hint": "#### 数据规模与约定\n\n+ 对于 $20\\%$ 的测试点，$n \\le 5$。\n+ 对于 $50\\%$ 的测试点，$n \\le 8$。\n+ 对于 $60\\%$ 的测试点，$n \\le 10$。\n+ 对于 $100\\%$ 的测试点，$2 \\leq n \\le 17$，$0 \\leq m_i \\leq \\frac{n(n - 1)}{2}$，$1 \\leq u, v \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4337", "type": "P", "difficulty": 7, "samples": [["5 3 \n1 2 \n2 3 \n2 5\n3 4", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "各省省选", "浙江", "枚举", "剪枝", "状压 DP"], "title": "[ZJOI2018] 线图", "background": "九条可怜是一个热爱出题的女孩子。", "description": "今天可怜想要出一道和图论相关的题。在一张无向图 $G$ 上，我们可以对它进行一些非常有趣的变换，比如说对偶，又或者说取补。这样的操作往往可以赋予一些传统的问题新的活力。例如求补图的连通性、补图的最短路等等，都是非常有趣的问题。\n\n最近可怜知道了一种新的变换：求原图的线图 (line graph)。对于无向图 $G = ⟨V, E⟩$，它的 线图 $L(G)$ 也是一个无向图：\n- 它的点集大小为 $|E|$，每个点唯一对应着原图的一条边。 \n- 两个点之间有边当且仅当这两个点对应的边在原图上有公共点（注意不会有自环）。 下图是一个简单的例子，左图是原图，右图是它对应的线图。其中点 $1$ 对应原图的边 $(1, 2)$，点 $2$ 对应 $(1, 4)$，点 $3$ 对应 $(1, 3)$，点 $4$ 对应 $(3, 4)$。\n\n![](https://cdn.luogu.com.cn/upload/pic/16013.png )\n\n经过一些初步的摸索，可怜发现线图的性质要比补图复杂很多，其中突出的一点就是补图 的补图会变回原图，而 $L(L(G))$ 在绝大部分情况下不等于 $G$，甚至在大多数情况下它的点数和边数会以很快的速度增长。\n\n因此，可怜想要从最简单的入手，即计算 $L^k(G)$ 的点数（$L^k(G)$ 表示对 $G$ 求 $k$ 次线图）。 然而遗憾的是，即使是这个问题，对可怜来说还是太困难了，因此她进行了一定的弱化。她给出了一棵 $n$ 个节点的树 $T$，现在她想让你计算一下 $L^k(T)$ 的点数。\n", "inputFormat": "第一行输入两个整数 $n, k$，表示树的点数以及连续求线图的次数。\n\n接下来 $n − 1$ 行每行两个整数 $u, v$ 表示树上的一条边。", "outputFormat": "输出一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "如下图所示，左图为原树，中图为 $L(G)$，右图为 $L^2(G)$。这儿并未画出 $L^3(G)$，但是由于 $L^2(G)$ 有 5 条边，因此 $L^3(G)$ 中有 5 个点。\n\n![](https://cdn.luogu.com.cn/upload/pic/16014.png )\n\n![](https://cdn.luogu.com.cn/upload/pic/16015.png )", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2018] Line Graph", "background": "Jiutiao Kelian is a girl who loves creating problems.", "description": "Today, Kelian wants to make a problem related to graph theory. On an undirected graph $G$, we can perform some interesting transformations, such as taking the dual or the complement. These operations often bring new life to classical problems. For example, connectivity of the complement graph and shortest paths on the complement graph are both very interesting problems.\n\nRecently, Kelian learned a new transformation: taking the line graph of the original graph. For an undirected graph $G = ⟨V, E⟩$, its line graph $L(G)$ is also an undirected graph:\n- Its vertex set has size $|E|$, and each vertex corresponds uniquely to an edge of the original graph.\n- There is an edge between two vertices if and only if the two corresponding edges in the original graph share an endpoint (note that there are no self-loops). The figure below shows a simple example: the left figure is the original graph, and the right figure is its line graph. Vertex $1$ corresponds to edge $(1, 2)$ in the original graph, vertex $2$ corresponds to $(1, 4)$, vertex $3$ corresponds to $(1, 3)$, and vertex $4$ corresponds to $(3, 4)$.\n\n![](https://cdn.luogu.com.cn/upload/pic/16013.png )\n\nAfter some initial exploration, Kelian found that the properties of line graphs are much more complicated than those of complement graphs. A notable point is that the complement of the complement returns to the original graph, while $L(L(G))$ is not equal to $G$ in most cases, and in many cases the number of vertices and edges grows rapidly.\n\nTherefore, Kelian wants to start from the simplest case, namely computing the number of vertices of $L^k(G)$ (where $L^k(G)$ means taking the line graph of $G$ $k$ times). Unfortunately, even this problem is too hard for her, so she weakens it. She gives a tree $T$ with $n$ nodes and asks you to compute the number of vertices in $L^k(T)$.", "inputFormat": "The first line contains two integers $n, k$, denoting the number of vertices in the tree and the number of times to take the line graph.\n\nThe next $n - 1$ lines each contain two integers $u, v$, representing an edge of the tree.", "outputFormat": "Output a single integer: the answer modulo $998244353$.", "hint": "As shown below, the left figure is the original tree, the middle figure is $L(G)$, and the right figure is $L^2(G)$. $L^3(G)$ is not shown here, but since $L^2(G)$ has 5 edges, $L^3(G)$ has 5 vertices.\n\n![](https://cdn.luogu.com.cn/upload/pic/16014.png )\n\n![](https://cdn.luogu.com.cn/upload/pic/16015.png )\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2018] 线图", "background": "九条可怜是一个热爱出题的女孩子。", "description": "今天可怜想要出一道和图论相关的题。在一张无向图 $G$ 上，我们可以对它进行一些非常有趣的变换，比如说对偶，又或者说取补。这样的操作往往可以赋予一些传统的问题新的活力。例如求补图的连通性、补图的最短路等等，都是非常有趣的问题。\n\n最近可怜知道了一种新的变换：求原图的线图 (line graph)。对于无向图 $G = ⟨V, E⟩$，它的 线图 $L(G)$ 也是一个无向图：\n- 它的点集大小为 $|E|$，每个点唯一对应着原图的一条边。 \n- 两个点之间有边当且仅当这两个点对应的边在原图上有公共点（注意不会有自环）。 下图是一个简单的例子，左图是原图，右图是它对应的线图。其中点 $1$ 对应原图的边 $(1, 2)$，点 $2$ 对应 $(1, 4)$，点 $3$ 对应 $(1, 3)$，点 $4$ 对应 $(3, 4)$。\n\n![](https://cdn.luogu.com.cn/upload/pic/16013.png )\n\n经过一些初步的摸索，可怜发现线图的性质要比补图复杂很多，其中突出的一点就是补图 的补图会变回原图，而 $L(L(G))$ 在绝大部分情况下不等于 $G$，甚至在大多数情况下它的点数和边数会以很快的速度增长。\n\n因此，可怜想要从最简单的入手，即计算 $L^k(G)$ 的点数（$L^k(G)$ 表示对 $G$ 求 $k$ 次线图）。 然而遗憾的是，即使是这个问题，对可怜来说还是太困难了，因此她进行了一定的弱化。她给出了一棵 $n$ 个节点的树 $T$，现在她想让你计算一下 $L^k(T)$ 的点数。\n", "inputFormat": "第一行输入两个整数 $n, k$，表示树的点数以及连续求线图的次数。\n\n接下来 $n − 1$ 行每行两个整数 $u, v$ 表示树上的一条边。", "outputFormat": "输出一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "如下图所示，左图为原树，中图为 $L(G)$，右图为 $L^2(G)$。这儿并未画出 $L^3(G)$，但是由于 $L^2(G)$ 有 5 条边，因此 $L^3(G)$ 中有 5 个点。\n\n![](https://cdn.luogu.com.cn/upload/pic/16014.png )\n\n![](https://cdn.luogu.com.cn/upload/pic/16015.png )", "locale": "zh-CN"}}}
{"pid": "P4338", "type": "P", "difficulty": 7, "samples": [["5 3 \n1 1 1 1 1 \n1 2 \n1 3 \n2 4 \n2 5 \n2 1 \n3 1\n4 1", "6 \n7 \n9\n10"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "各省省选", "浙江", "树链剖分", "动态树 LCT", "构造"], "title": "[ZJOI2018] 历史", "background": "九条可怜是一个热爱阅读的女孩子。", "description": "这个世界有 n 个城市，这 n 个城市被恰好 $n-1$ 条双向道路联通，即任意两个城市都可以 互相到达。同时城市 1 坐落在世界的中心，占领了这个城市就称霸了这个世界。\n\n在最开始，这 n 个城市都不在任何国家的控制之下，但是随着社会的发展，一些城市会崛 起形成国家并夺取世界的霸权。为了方便，我们标记第 i 个城市崛起产生的国家为第 i 个国家。 在第 i 个城市崛起的过程中，第 i 个国家会取得城市 i 到城市 1 路径上所有城市的控制权。\n\n新的城市的崛起往往意味着战争与死亡，若第 i 个国家在崛起中，需要取得一个原本被国 家 $j(j ≠ i)$ 控制的城市的控制权，那么国家 i 就必须向国家 j 宣战并进行战争。\n\n现在，可怜知道了，在历史上，第 i 个城市一共崛起了 $a_i$ 次。但是这些事件发生的相对顺 序已经无从考究了，唯一的信息是，在一个城市崛起称霸世界之前，新的城市是不会崛起的。 \n\n战争对人民来说是灾难性的。可怜定义一次崛起的灾难度为崛起的过程中会和多少不同的国家进行战争（和同一个国家进行多次战争只会被计入一次）。可怜想要知道，在所有可能的崛 起顺序中，灾难度之和最大是多少。\n\n同时，在考古学家的努力下，越来越多的历史资料被发掘了出来，根据这些新的资料，可怜会对 $a_i$ 进行一些修正。具体来说，可怜会对 $a_i$ 进行一些操作，每次会将 $a_x$ 加上 w。她希望 在每次修改之后，都能计算得到最大的灾难度。\n\n然而可怜对复杂的计算并不感兴趣，因此她想让你来帮她计算一下这些数值。\n对题面的一些补充：\n\n- 同一个城市多次崛起形成的国家是同一个国家，这意味着同一个城市连续崛起两次是不会 和任何国家开战的：因为这些城市原来就在它的控制之下。\n- 在历史的演变过程中，第 i 个国家可能会有一段时间没有任何城市的控制权。但是这并不 意味着第 i 个国家灭亡了，在城市 i 崛起的时候，第 i 个国家仍然会取得 1 到 i 路径上的城市的控制权。", "inputFormat": "第一行输入两个整数 n,m 表示城市个数和操作个数。 \n\n第二行输入 n 个整数表示 ai 的初始值。 接下来 n − 1 行，每行输入两个整数 $u_i, v_i(1\\leq ui, vi \\leq n)$ 描述了一条道路。 \n\n接下来 m 行每行输入两个整数 $x_i$, $w_i$ 表示将 $a_{x_i}$\n加上 $w_i$。", "outputFormat": "输出共 $m+1$ 行，第一行表示初始的 ai 的答案，接下来 m 行每行表示这次修正后的答案。", "hint": "在修正开始之前，如果按照所在城市 4, 1, 5, 3, 2 的顺序崛起，那么依次会和 0, 1, 2, 1, 2 个 国家进行战争。\n\n这时一共会产生 6 对敌对关系。可以证明这是所有崛起顺序中的最大值。\n\n![](https://cdn.luogu.com.cn/upload/pic/16016.png)", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2018] History", "background": "Jiutiao Kelian (pinyin) is a girl who loves reading.", "description": "There are $n$ cities in this world, connected by exactly $n - 1$ bidirectional roads, so any two cities are mutually reachable. City $1$ lies at the center of the world; whoever takes this city dominates the world.\n\nInitially, none of the $n$ cities is controlled by any country. As society develops, some cities will rise to form countries and seize world hegemony. For convenience, we label the country that rises at city $i$ as country $i$. During the rise at city $i$, country $i$ will take control of all cities on the path from city $i$ to city $1$.\n\nThe rise of a new city often means war and death. If, during the rise of country $i$, it needs to take a city that is currently controlled by another country $j$ ($j \\ne i$), then country $i$ must declare war on country $j$ and fight.\n\nNow, Kelian knows that in history, city $i$ rose exactly $a_i$ times. However, the relative order of these events is unknown. The only information is that while one city is rising to dominate the world, no new city will start rising.\n\nWar is catastrophic for the people. Kelian defines the disaster degree of a single rise as the number of distinct countries it goes to war with during that rise (multiple wars against the same country within one rise count only once). She wants to know, among all possible rise orders, what is the maximum possible sum of the disaster degrees.\n\nMeanwhile, thanks to archaeologists’ efforts, more and more historical records are being unearthed. Based on these new materials, Kelian will adjust the values of $a_i$. Specifically, she will perform operations on $a_i$, each time adding $w$ to $a_x$. She hopes that after each modification, the maximum total disaster degree can be computed.\n\nHowever, Kelian is not interested in complicated calculations, so she wants you to help her compute these values.\n\nAdditional notes:\n- Multiple rises at the same city form the same country. This means that if the same city rises twice in a row, it will not go to war with any country, because those cities are already under its control.\n- Over the course of history, country $i$ may temporarily control no city. This does not mean country $i$ is destroyed. When city $i$ rises, country $i$ will still take control of all cities on the path from $1$ to $i$.", "inputFormat": "The first line contains two integers $n$, $m$, the number of cities and the number of operations.\n\nThe second line contains $n$ integers, the initial values of $a_i$.\n\nThe next $n - 1$ lines each contain two integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$) describing a road.\n\nThe next $m$ lines each contain two integers $x_i$, $w_i$, meaning add $w_i$ to $a_{x_i}$.", "outputFormat": "Output $m + 1$ lines. The first line is the answer for the initial $a_i$. Each of the next $m$ lines is the answer after that modification.", "hint": "Before the modifications, if the cities rise in the order $4, 1, 5, 3, 2$, then they will go to war with $0, 1, 2, 1, 2$ countries, respectively.\n\nA total of $6$ pairs of hostile relationships will be produced. It can be proven that this is the maximum among all rise orders.\n\n![](https://cdn.luogu.com.cn/upload/pic/16016.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2018] 历史", "background": "九条可怜是一个热爱阅读的女孩子。", "description": "这个世界有 n 个城市，这 n 个城市被恰好 $n-1$ 条双向道路联通，即任意两个城市都可以 互相到达。同时城市 1 坐落在世界的中心，占领了这个城市就称霸了这个世界。\n\n在最开始，这 n 个城市都不在任何国家的控制之下，但是随着社会的发展，一些城市会崛 起形成国家并夺取世界的霸权。为了方便，我们标记第 i 个城市崛起产生的国家为第 i 个国家。 在第 i 个城市崛起的过程中，第 i 个国家会取得城市 i 到城市 1 路径上所有城市的控制权。\n\n新的城市的崛起往往意味着战争与死亡，若第 i 个国家在崛起中，需要取得一个原本被国 家 $j(j ≠ i)$ 控制的城市的控制权，那么国家 i 就必须向国家 j 宣战并进行战争。\n\n现在，可怜知道了，在历史上，第 i 个城市一共崛起了 $a_i$ 次。但是这些事件发生的相对顺 序已经无从考究了，唯一的信息是，在一个城市崛起称霸世界之前，新的城市是不会崛起的。 \n\n战争对人民来说是灾难性的。可怜定义一次崛起的灾难度为崛起的过程中会和多少不同的国家进行战争（和同一个国家进行多次战争只会被计入一次）。可怜想要知道，在所有可能的崛 起顺序中，灾难度之和最大是多少。\n\n同时，在考古学家的努力下，越来越多的历史资料被发掘了出来，根据这些新的资料，可怜会对 $a_i$ 进行一些修正。具体来说，可怜会对 $a_i$ 进行一些操作，每次会将 $a_x$ 加上 w。她希望 在每次修改之后，都能计算得到最大的灾难度。\n\n然而可怜对复杂的计算并不感兴趣，因此她想让你来帮她计算一下这些数值。\n对题面的一些补充：\n\n- 同一个城市多次崛起形成的国家是同一个国家，这意味着同一个城市连续崛起两次是不会 和任何国家开战的：因为这些城市原来就在它的控制之下。\n- 在历史的演变过程中，第 i 个国家可能会有一段时间没有任何城市的控制权。但是这并不 意味着第 i 个国家灭亡了，在城市 i 崛起的时候，第 i 个国家仍然会取得 1 到 i 路径上的城市的控制权。", "inputFormat": "第一行输入两个整数 n,m 表示城市个数和操作个数。 \n\n第二行输入 n 个整数表示 ai 的初始值。 接下来 n − 1 行，每行输入两个整数 $u_i, v_i(1\\leq ui, vi \\leq n)$ 描述了一条道路。 \n\n接下来 m 行每行输入两个整数 $x_i$, $w_i$ 表示将 $a_{x_i}$\n加上 $w_i$。", "outputFormat": "输出共 $m+1$ 行，第一行表示初始的 ai 的答案，接下来 m 行每行表示这次修正后的答案。", "hint": "在修正开始之前，如果按照所在城市 4, 1, 5, 3, 2 的顺序崛起，那么依次会和 0, 1, 2, 1, 2 个 国家进行战争。\n\n这时一共会产生 6 对敌对关系。可以证明这是所有崛起顺序中的最大值。\n\n![](https://cdn.luogu.com.cn/upload/pic/16016.png)", "locale": "zh-CN"}}}
{"pid": "P4339", "type": "P", "difficulty": 7, "samples": [["3 \n2 3\n2 4 \n6 8", "3 \n3\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2018", "各省省选", "浙江", "强连通分量"], "title": "[ZJOI2018] 迷宫", "background": "九条可怜是一个贪玩的女孩子。", "description": "暑假快要到了，可怜打算在她家的私人海滩旁边建一座城堡，这样就可以在放暑假的时候 邀请她的朋友们来玩了。同时，可怜打算在城堡的地下修建一座迷宫，因为探险总是一件充满 乐趣的事情。\n\n经过简单的设计，可怜打算修建一座这样的迷宫：\n- 迷宫可以被抽象成 $n$ 个点，$nm$ 条边的有向图。$1$ 号点是唯一的入口也是唯一的出口。 \n- 每一个点恰好有 $m$ 条出边，且这些出边被依次标号为 $[0,m)$ 的正整数。 \n- 迷宫允许自环和重边。\n\n同时，一座优秀的迷宫应该有一定的解谜因素。因此可怜希望每一条从 $1$ 号点出发并回到 $1$ 号点的回路都有着一定的规律。可怜发现，如果把一条从 $1$ 出发的路径经过的所有边的编号都记录下来，那么能得到一个（可能有前导 $0$）的 $m$ 进制数；同时对于每一个（可能有前导 $0$）的 $m$ 进制数，都能对应回一 条从 $1$ 出发的路径。\n\n于是可怜选定了一个整数 $K$，她希望这个迷宫满足一条从 $1$ 出发的路径能回到 $1$ **当且仅当**这条路径对应的数是 $K$ 的倍数。\n\n现在可怜已经选定了 $m$ 和 $K$，但是她发现并不是对所有的 $n$，都存在满足上述所有条件的迷宫设计方案。建造迷宫是一件费时费力的事情，于是可怜想要找到一个最小的满足条件的 $n$。\n\n然而可怜对复杂的计算并不感兴趣，因此她想让你来帮她计算一下这个数值。", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。 \n\n接下来 $T$ 行每行两个十进制正整数 $m,K$ 表示可怜选定的整数。", "outputFormat": "对于每组数据，输出一行一个整数表示能够满足所有条件的最小的 $n$。如果不存在这样的 $n$，输出 `-1`。", "hint": "第一组数据（左）和第二组数据（右）的一种设计方案如下图所示。其中紫色边表示 $0$ 号边，蓝色边表示 $1$ 号边。\n\n![](https://cdn.luogu.com.cn/upload/pic/16017.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/16018.png)", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2018] Maze", "background": "Kelian is a playful girl.", "description": "Summer vacation is coming, and Kelian plans to build a castle next to her private beach so she can invite her friends over during the holidays. She also plans to build a maze under the castle, because exploration is always fun.\n\nAfter a simple design, Kelian plans to build a maze as follows:\n- The maze can be abstracted as a directed graph with $n$ vertices and $nm$ edges. Vertex $1$ is the only entrance and also the only exit.\n- Each vertex has exactly $m$ outgoing edges, and these outgoing edges are labeled in order by integers in $[0, m)$.\n- Self-loops and parallel edges are allowed.\n\nA good maze should also have some puzzle elements. Kelian hopes that every cycle starting from vertex $1$ and returning to vertex $1$ follows a certain pattern. She finds that if you record the labels of all edges along a path starting from vertex $1$, you obtain a base-$m$ number (possibly with leading $0$s). Conversely, for every base-$m$ number (possibly with leading $0$s), there exists a corresponding path starting from vertex $1$.\n\nKelian then chooses an integer $K$. She wants the maze to satisfy: a path starting from vertex $1$ returns to vertex $1$ if and only if the number corresponding to this path is a multiple of $K$.\n\nNow that $m$ and $K$ have been chosen, she realizes that not every $n$ admits a maze design that meets all the conditions above. Since building a maze is time-consuming and laborious, Kelian wants to find the minimum $n$ that satisfies the conditions.\n\nHowever, Kelian is not interested in complicated calculations, so she asks you to compute this value for her.", "inputFormat": "The first line contains an integer $T$ — the number of test cases.\n\nEach of the next $T$ lines contains two positive decimal integers $m, K$ — the chosen integers.", "outputFormat": "For each test case, output a single integer: the minimum $n$ that satisfies all the conditions. If no such $n$ exists, output `-1`.", "hint": "One possible design for the first test case (left) and the second test case (right) is shown below. Purple edges denote the edge labeled $0$, and blue edges denote the edge labeled $1$.\n\n![](https://cdn.luogu.com.cn/upload/pic/16017.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/16018.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2018] 迷宫", "background": "九条可怜是一个贪玩的女孩子。", "description": "暑假快要到了，可怜打算在她家的私人海滩旁边建一座城堡，这样就可以在放暑假的时候 邀请她的朋友们来玩了。同时，可怜打算在城堡的地下修建一座迷宫，因为探险总是一件充满 乐趣的事情。\n\n经过简单的设计，可怜打算修建一座这样的迷宫：\n- 迷宫可以被抽象成 $n$ 个点，$nm$ 条边的有向图。$1$ 号点是唯一的入口也是唯一的出口。 \n- 每一个点恰好有 $m$ 条出边，且这些出边被依次标号为 $[0,m)$ 的正整数。 \n- 迷宫允许自环和重边。\n\n同时，一座优秀的迷宫应该有一定的解谜因素。因此可怜希望每一条从 $1$ 号点出发并回到 $1$ 号点的回路都有着一定的规律。可怜发现，如果把一条从 $1$ 出发的路径经过的所有边的编号都记录下来，那么能得到一个（可能有前导 $0$）的 $m$ 进制数；同时对于每一个（可能有前导 $0$）的 $m$ 进制数，都能对应回一 条从 $1$ 出发的路径。\n\n于是可怜选定了一个整数 $K$，她希望这个迷宫满足一条从 $1$ 出发的路径能回到 $1$ **当且仅当**这条路径对应的数是 $K$ 的倍数。\n\n现在可怜已经选定了 $m$ 和 $K$，但是她发现并不是对所有的 $n$，都存在满足上述所有条件的迷宫设计方案。建造迷宫是一件费时费力的事情，于是可怜想要找到一个最小的满足条件的 $n$。\n\n然而可怜对复杂的计算并不感兴趣，因此她想让你来帮她计算一下这个数值。", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。 \n\n接下来 $T$ 行每行两个十进制正整数 $m,K$ 表示可怜选定的整数。", "outputFormat": "对于每组数据，输出一行一个整数表示能够满足所有条件的最小的 $n$。如果不存在这样的 $n$，输出 `-1`。", "hint": "第一组数据（左）和第二组数据（右）的一种设计方案如下图所示。其中紫色边表示 $0$ 号边，蓝色边表示 $1$ 号边。\n\n![](https://cdn.luogu.com.cn/upload/pic/16017.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/16018.png)", "locale": "zh-CN"}}}
{"pid": "P4340", "type": "P", "difficulty": 6, "samples": [["5 5\n9384 887 2778 6916 7794\n2 8336\n5 493\n3 1422\n1 28\n4 60", "890543652\n252923708\n942282590\n228728040\n608998099"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "线段树", "各省省选", "上海", "矩阵乘法", "逆元"], "title": "[SHOI2016] 随机序列", "background": "", "description": "你的面前有 $n$ 个数排成一行，分别为 $a_1,a_2,...,a_n$ 。你打算在每相邻的两个 $a_i$​​  和 $a_{i+1}$ 间都插入一个加号、减号或者乘号。那么一共有$3^{n-1}$ 种可能的表达式。\n\n你对所有可能的表达式的值的和非常感兴趣。但这毕竟太简单了，所以你还打算支持一个修改操作，可以修改某个 $a_i$ 的值。\n\n你能够编写一个程序对每个修改都输出修改完之后所有可能表达式的和吗？注意，修改是永久的，也就是说每次修改都是在上一次修改的基础上进行，而不是在最初的表达式上进行。", "inputFormat": "第一行包含两个正整数 $n$ 和 $Q$，为数的个数和询问的个数。\n第二行包含 $n$ 个非负整数，依次表示 $a_1,a_2,...,a_n$。\n接下来 $Q$ 行，每行包含两个非负整数 $t$ 和 $v$，表示要将 $a_t$ 修改为 $v$，其中 $1≤t≤n$。\n\n保证对于 $1≤j≤n$,$1≤i≤Q$，都有 $aj,vi≤10^4$\n", "outputFormat": "输出 $Q$ 行。对于每个修改输出一行，包含一个整数，表示修改之后所有可能表达式的和，对 $10^9+7$ 取模。", "hint": "对于20%的数据，n,q<=20\n\n对于50%的数据，n,q<=1000\n\n对于100%的数据，n,q<=100000\n\n- 2023.11.17 添加一组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2016] Random Sequence", "background": "", "description": "There are $n$ numbers in a row, namely $a_1, a_2, ..., a_n$. You plan to insert a plus, minus, or multiplication sign between each adjacent pair $a_i$ and $a_{i+1}$. Then there are $3^{n-1}$ possible expressions.\n\nYou are very interested in the sum of the values of all possible expressions. But that would be too easy, so you also plan to support an update operation that modifies the value of some $a_i$.\n\nCan you write a program that, after each update, outputs the sum of all possible expressions after the modification? Note that updates are permanent, which means each update is applied on top of the previous one, not on the initial sequence.", "inputFormat": "The first line contains two positive integers $n$ and $Q$, the number of values and the number of queries.\nThe second line contains $n$ non-negative integers, namely $a_1, a_2, ..., a_n$ in order.\nThe next $Q$ lines each contain two non-negative integers $t$ and $v$, meaning you set $a_t$ to $v$, where $1 \\le t \\le n$.\n\nIt is guaranteed that for all $1 \\le j \\le n$ and all $1 \\le i \\le Q$, we have $a_j, v_i \\le 10^4$.", "outputFormat": "Output $Q$ lines. For each update, output one line containing a single integer, the sum of all possible expressions after the update, modulo $10^9+7$.", "hint": "- For 20% of the testdata, $n, Q \\le 20$.\n- For 50% of the testdata, $n, Q \\le 1000$.\n- For 100% of the testdata, $n, Q \\le 100000$.\n- 2023-11-17: Added a set of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2016] 随机序列", "background": "", "description": "你的面前有 $n$ 个数排成一行，分别为 $a_1,a_2,...,a_n$ 。你打算在每相邻的两个 $a_i$​​  和 $a_{i+1}$ 间都插入一个加号、减号或者乘号。那么一共有$3^{n-1}$ 种可能的表达式。\n\n你对所有可能的表达式的值的和非常感兴趣。但这毕竟太简单了，所以你还打算支持一个修改操作，可以修改某个 $a_i$ 的值。\n\n你能够编写一个程序对每个修改都输出修改完之后所有可能表达式的和吗？注意，修改是永久的，也就是说每次修改都是在上一次修改的基础上进行，而不是在最初的表达式上进行。", "inputFormat": "第一行包含两个正整数 $n$ 和 $Q$，为数的个数和询问的个数。\n第二行包含 $n$ 个非负整数，依次表示 $a_1,a_2,...,a_n$。\n接下来 $Q$ 行，每行包含两个非负整数 $t$ 和 $v$，表示要将 $a_t$ 修改为 $v$，其中 $1≤t≤n$。\n\n保证对于 $1≤j≤n$,$1≤i≤Q$，都有 $aj,vi≤10^4$\n", "outputFormat": "输出 $Q$ 行。对于每个修改输出一行，包含一个整数，表示修改之后所有可能表达式的和，对 $10^9+7$ 取模。", "hint": "对于20%的数据，n,q<=20\n\n对于50%的数据，n,q<=1000\n\n对于100%的数据，n,q<=100000\n\n- 2023.11.17 添加一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P4341", "type": "P", "difficulty": 4, "samples": [["7\n1010101", "3\n3\n2\n2\n4\n3\n3\n2\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "北京", "枚举", "后缀数组 SA"], "title": "[BJWC2010] 外星联络", "background": "", "description": "小 P 在看过电影《超时空接触》(Contact)之后被深深的打动，决心致力于寻找外星人的事业。于是，他每天晚上都爬在屋顶上试图用自己的收音机收听外星人发来的信息。\n\n虽然他收听到的仅仅是一些噪声，但是他还是按照这些噪声的高低电平将接收到的信号改写为由 `0` 和 `1` 构成的串， 并坚信外星人的信息就隐藏在其中。他认为，外星人发来的信息一定会在他接受到的 01 串中重复出现，所以他希望找到他接受到的 01 串中所有重复出现次数大于 $1$ 的子串。\n\n但是他收到的信号串实在是太长了，于是，他希望你能编一个程序来帮助他。", "inputFormat": "输入文件的第一行是一个整数$N$ ，代表小 P 接收到的信号串的长度。  \n输入文件第二行包含一个长度为$N$ 的 01 串，代表小 P 接收到的信号串。", "outputFormat": "输出文件的每一行包含一个出现次数大于$1$ 的子串所出现的次数。输出的顺序按对应的子串的字典序排列。", "hint": "对于 100%的数据，满足 $0 \\le N \\le 3000$", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2010] Alien Contact", "background": "", "description": "After watching the movie \"Contact\" (超时空接触), Little P was deeply moved and decided to devote himself to the search for extraterrestrial life. Every night, he climbs onto the roof and tries to use his radio to listen for messages from aliens.\n\nAlthough he hears only noise, he still rewrites the received signal into a string of 0s and 1s according to the high and low levels of the noise, and firmly believes that the aliens' message is hidden within. He believes that the message sent by the aliens must repeat within the binary string he received, so he wants to find all substrings of the binary string that appear more than $1$ time.\n\nHowever, the signal string he received is too long, so he hopes you can write a program to help him.", "inputFormat": "The first line contains an integer $N$, the length of the received signal string.  \nThe second line contains a binary string of length $N$, representing the received signal string.", "outputFormat": "Output one line for each substring that appears more than $1$ time, containing its number of occurrences. Output the lines in lexicographical order of the corresponding substrings.", "hint": "For 100% of the testdata, $0 \\le N \\le 3000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2010] 外星联络", "background": "", "description": "小 P 在看过电影《超时空接触》(Contact)之后被深深的打动，决心致力于寻找外星人的事业。于是，他每天晚上都爬在屋顶上试图用自己的收音机收听外星人发来的信息。\n\n虽然他收听到的仅仅是一些噪声，但是他还是按照这些噪声的高低电平将接收到的信号改写为由 `0` 和 `1` 构成的串， 并坚信外星人的信息就隐藏在其中。他认为，外星人发来的信息一定会在他接受到的 01 串中重复出现，所以他希望找到他接受到的 01 串中所有重复出现次数大于 $1$ 的子串。\n\n但是他收到的信号串实在是太长了，于是，他希望你能编一个程序来帮助他。", "inputFormat": "输入文件的第一行是一个整数$N$ ，代表小 P 接收到的信号串的长度。  \n输入文件第二行包含一个长度为$N$ 的 01 串，代表小 P 接收到的信号串。", "outputFormat": "输出文件的每一行包含一个出现次数大于$1$ 的子串所出现的次数。输出的顺序按对应的子串的字典序排列。", "hint": "对于 100%的数据，满足 $0 \\le N \\le 3000$", "locale": "zh-CN"}}}
{"pid": "P4342", "type": "P", "difficulty": 4, "samples": [["4\nt -7 t 4 x 2 x 5\n", "33\n1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "1998", "IOI", "区间 DP"], "title": "[IOI 1998] Polygon", "background": "", "description": "Polygon is a game for one player that starts on a polygon with $N$ vertices, like the one in Figure 1, where $N=4$. Each vertex is labelled with an integer and each edge is labelled with either the symbol `+` (addition) or the symbol `*` (product). The edges are numbered from $1$ to $N$.\n\n![](https://cdn.luogu.com.cn/upload/pic/16086.png)\n\nOn the first move, one of the edges is removed. Subsequent moves involve the following steps: \n- pick an edge $E$ and the two vertices $V_1$ and $V_2$ that are linked by $E$; and \n- replace them by a new vertex, labelled with the result of performing the operation indicated in $E$ on the labels of $V_1$ and $V_2$.\n\nThe game ends when there are no more edges, and its score is the label of the single vertex remaining. \n\nConsider the polygon of Figure 1. The player started by removing edge 3. After that, the player picked edge 1, then edge 4, and, finally, edge 2. The score is 0. \n\n![](https://cdn.luogu.com.cn/upload/pic/16088.png)\n\nWrite a program that, given a polygon, computes the highest possible score and lists all the edges that, if removed on the first move, can lead to a game with that score. \n", "inputFormat": "Your program is to read from standard input. The input describes a polygon with N vertices. It contains two lines. On the first line is the number N. The second line contains the labels of edges 1, ..., N, interleaved with the vertices' labels (first that of the vertex between edges 1 and 2, then that of the vertex between edges 2 and 3, and so on, until that of the vertex between edges N and 1), all separated by one space. An edge label is either the letter t (representing +) or the letter x (representing *). \n\n3 <= N <= 50 \n\n\nFor any sequence of moves, vertex labels are in the range [-32768,32767]. \n", "outputFormat": "Your program is to write to standard output. On the first line your program must write the highest score one can get for the input polygon. On the second line it must write the list of all edges that, if removed on the first move, can lead to a game with that score. Edges must be written in increasing order, separated by one space.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[IOI 1998] Polygon", "background": "", "description": "Polygon is a game for one player that starts on a polygon with $N$ vertices, like the one in Figure 1, where $N=4$. Each vertex is labelled with an integer and each edge is labelled with either the symbol `+` (addition) or the symbol `*` (product). The edges are numbered from $1$ to $N$.\n\n![](https://cdn.luogu.com.cn/upload/pic/16086.png)\n\nOn the first move, one of the edges is removed. Subsequent moves involve the following steps: \n- pick an edge $E$ and the two vertices $V_1$ and $V_2$ that are linked by $E$; and \n- replace them by a new vertex, labelled with the result of performing the operation indicated in $E$ on the labels of $V_1$ and $V_2$.\n\nThe game ends when there are no more edges, and its score is the label of the single vertex remaining. \n\nConsider the polygon of Figure 1. The player started by removing edge 3. After that, the player picked edge 1, then edge 4, and, finally, edge 2. The score is 0. \n\n![](https://cdn.luogu.com.cn/upload/pic/16088.png)\n\nWrite a program that, given a polygon, computes the highest possible score and lists all the edges that, if removed on the first move, can lead to a game with that score. \n", "inputFormat": "Your program is to read from standard input. The input describes a polygon with N vertices. It contains two lines. On the first line is the number N. The second line contains the labels of edges 1, ..., N, interleaved with the vertices' labels (first that of the vertex between edges 1 and 2, then that of the vertex between edges 2 and 3, and so on, until that of the vertex between edges N and 1), all separated by one space. An edge label is either the letter t (representing +) or the letter x (representing *). \n\n3 <= N <= 50 \n\n\nFor any sequence of moves, vertex labels are in the range [-32768,32767]. \n", "outputFormat": "Your program is to write to standard output. On the first line your program must write the highest score one can get for the input polygon. On the second line it must write the list of all edges that, if removed on the first move, can lead to a game with that score. Edges must be written in increasing order, separated by one space.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[IOI 1998] Polygon", "background": null, "description": "**题目可能有些许修改，但大意一致。**\n\nPolygon 是一个玩家在一个有 $n$ 个顶点的多边形上玩的游戏，如图所示，其中 $n = 4$。每个顶点用整数标记，每个边用符号 `+`（加）或符号 `*`（乘积）标记。\n\n![](https://cdn.luogu.org/upload/pic/16086.png)\n\n第一步，删除其中一条边。随后每一步： \n\n选择一条边连接的两个顶点 $V_1$ 和 $V_2$，用边上的运算符计算 $V_1$ 和 $V_2$ 得到的结果来替换这两个顶点。 \n\n游戏结束时，只有一个顶点，没有多余的边。\n\n如图所示，玩家先移除编号为 $3$ 的边。之后，玩家选择计算编号为 $1$ 的边，然后计算编号为 $4$ 的边，最后，计算编号为 $2$ 的边。结果是 $0$。\n\n![](https://cdn.luogu.org/upload/pic/16088.png)\n\n（译者注：这里每条边的运算符旁边的数字为边的编号，不拿来计算）\n\n编写一个程序，给定一个多边形，计算最高可能的分数。", "inputFormat": "输入描述一个有 $n$ 个顶点的多边形，它包含两行。第一行是数字 $n$，为总边数。\n\n第二行描述这个多边形，一共有 $n$ 组，每组中第一个字符为边 $i$ 的计算符号（`t` 代表相加，`x` 代表相乘），第二个代表顶点 $i$ 上的数字。多边形首尾相连。", "outputFormat": "第一行，输出最高的分数。在第二行，输出所有可能的在第一步即被清除后仍能得到最高分的边的下标，以严格升序输出。", "hint": "保证 $3 \\le n \\le 50$。\n\n对于任何一系列的操作，顶点数字都在 $[-32768,32767]$ 的范围内。", "locale": "zh-CN"}}}
{"pid": "P4343", "type": "P", "difficulty": 4, "samples": [["4 2\n2\n5\n-3\n9", "3 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "二分", "各省省选", "上海"], "title": "[SHOI2015] 自动刷题机", "background": "曾经发明了信号增幅仪的发明家 SHTSC 又公开了他的新发明：自动刷题机——一种可以自动 AC 题目的神秘装置。", "description": "自动刷题机刷题的方式非常简单：首先会瞬间得出题目的正确做法，然后开始写程序。每秒，自动刷题机的代码生成模块会有两种可能的结果：\n\n1. 写了 $x$ 行代码。\n2. 心情不好，删掉了之前写的 $y$ 行代码。（如果 $y$ 大于当前代码长度则相当于全部删除。）\n\n对于一个 OJ，存在某个固定的正整数长度 $n$，一旦自动刷题机在某秒结束时积累了大于等于 $n$ 行的代码，它就会自动提交并 AC 此题，然后新建一个文件（即弃置之前的所有代码）并开始写下一题。SHTSC 在某个 OJ 上跑了一天的自动刷题机，得到了很多条关于写代码的日志信息。他突然发现自己没有记录这个 OJ 的 $n$ 究竟是多少。所幸他通过自己在 OJ 上的 Rank 知道了自动刷题机一共切了 $k$ 道题，希望你计算 $n$ 可能的最小值和最大值。", "inputFormat": "第一行两个整数 $l,k$，表示刷题机的日志一共有 $l$ 行，一共切了 $k$ 题。\n\n接下来 $l$ 行，每行一个整数 $x_i$，依次表示每条日志。若 $x_i \\geq 0$，则表示写了 $x_i$ 行代码，若 $x_i \\lt 0$，则表示删除了 $-x_i$ 行代码。", "outputFormat": "输出一行两个整数，分别表示 $n$ 可能的最小值和最大值。  \n如果这样的 $n$ 不存在，请输出一行一个整数 $-1$。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $1 \\le l \\le 10$；\n- 对于 $40\\%$ 的数据，保证 $1 \\le l \\le 100$ ；\n- 对于 $60\\%$ 的数据，保证 $1 \\le l \\le 2 \\times 10^3$；\n- 对于 $100\\%$ 的数据，保证 $1 \\leq l \\le 10^5$，$-10^9 \\le x_i \\le 10^9$，$k$ 在 ```int``` 存储范围内。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2015] Automatic Problem-Solving Machine", "background": "The inventor SHTSC, who once invented a signal amplifier, has unveiled his new invention: an automatic problem-solving machine — a mysterious device that can automatically AC problems.", "description": "The way the automatic problem-solving machine works is very simple: it instantly figures out the correct solution to a problem, then starts writing code. Every second, the code generation module has two possible outcomes:\n\n1. It writes $x$ lines of code.\n2. In a bad mood, it deletes $y$ lines of previously written code. (If $y$ is greater than the current code length, this is equivalent to deleting everything.)\n\nFor an OJ, there is a fixed positive integer length $n$. Once the machine has accumulated at least $n$ lines of code at the end of a second, it will automatically submit and AC the problem, then create a new file (i.e., discard all previous code) and start the next problem. SHTSC ran the machine on an OJ for one day and obtained many log entries about code writing. He suddenly realized he did not record what $n$ on this OJ actually is. Fortunately, from his Rank on the OJ, he knows the machine solved $k$ problems in total. Please compute the minimum and maximum possible values of $n$.", "inputFormat": "The first line contains two integers $l, k$, indicating that the machine produced $l$ log entries and solved $k$ problems in total.\n\nThe next $l$ lines each contain an integer $x_i$, describing each log entry in order. If $x_i \\geq 0$, it means $x_i$ lines of code were written. If $x_i \\lt 0$, it means $-x_i$ lines of code were deleted.", "outputFormat": "Output one line with two integers, representing the minimum and maximum possible values of $n$.  \nIf no such $n$ exists, output one line with a single integer $-1$.", "hint": "Constraints\n- For $20\\%$ of the testdata, it is guaranteed that $1 \\le l \\le 10$.\n- For $40\\%$ of the testdata, it is guaranteed that $1 \\le l \\le 100$.\n- For $60\\%$ of the testdata, it is guaranteed that $1 \\le l \\le 2 \\times 10^3$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq l \\le 10^5$, $-10^9 \\le x_i \\le 10^9$, and $k$ fits in the range of ```int```.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2015] 自动刷题机", "background": "曾经发明了信号增幅仪的发明家 SHTSC 又公开了他的新发明：自动刷题机——一种可以自动 AC 题目的神秘装置。", "description": "自动刷题机刷题的方式非常简单：首先会瞬间得出题目的正确做法，然后开始写程序。每秒，自动刷题机的代码生成模块会有两种可能的结果：\n\n1. 写了 $x$ 行代码。\n2. 心情不好，删掉了之前写的 $y$ 行代码。（如果 $y$ 大于当前代码长度则相当于全部删除。）\n\n对于一个 OJ，存在某个固定的正整数长度 $n$，一旦自动刷题机在某秒结束时积累了大于等于 $n$ 行的代码，它就会自动提交并 AC 此题，然后新建一个文件（即弃置之前的所有代码）并开始写下一题。SHTSC 在某个 OJ 上跑了一天的自动刷题机，得到了很多条关于写代码的日志信息。他突然发现自己没有记录这个 OJ 的 $n$ 究竟是多少。所幸他通过自己在 OJ 上的 Rank 知道了自动刷题机一共切了 $k$ 道题，希望你计算 $n$ 可能的最小值和最大值。", "inputFormat": "第一行两个整数 $l,k$，表示刷题机的日志一共有 $l$ 行，一共切了 $k$ 题。\n\n接下来 $l$ 行，每行一个整数 $x_i$，依次表示每条日志。若 $x_i \\geq 0$，则表示写了 $x_i$ 行代码，若 $x_i \\lt 0$，则表示删除了 $-x_i$ 行代码。", "outputFormat": "输出一行两个整数，分别表示 $n$ 可能的最小值和最大值。  \n如果这样的 $n$ 不存在，请输出一行一个整数 $-1$。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $1 \\le l \\le 10$；\n- 对于 $40\\%$ 的数据，保证 $1 \\le l \\le 100$ ；\n- 对于 $60\\%$ 的数据，保证 $1 \\le l \\le 2 \\times 10^3$；\n- 对于 $100\\%$ 的数据，保证 $1 \\leq l \\le 10^5$，$-10^9 \\le x_i \\le 10^9$，$k$ 在 ```int``` 存储范围内。", "locale": "zh-CN"}}}
{"pid": "P4344", "type": "P", "difficulty": 5, "samples": [["10 10\n0 2 2\n0 4 6\n0 10 10\n2 1 10\n1 8 10 1 4\n2 1 10\n1 1 4 8 10\n2 1 10\n1 7 10 1 6\n2 1 10", "3\n3\n6\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "线段树", "各省省选", "上海"], "title": "[SHOI2015] 脑洞治疗仪", "background": "", "description": "曾经发明了自动刷题机的发明家 SHTSC 又公开了他的新发明：脑洞治疗仪——一种可以治疗他因为发明而日益增大的脑洞的神秘装置。\n\n为了简单起见，我们将大脑视作一个 01 序列。$1$ 代表这个位置的脑组织正常工作，$0$ 代表这是一块脑洞。\n\n```cpp\n1      0      1      0      0      0      1      1      1      0\n```\n\n脑洞治疗仪修补某一块脑洞的基本工作原理就是将另一块连续区域挖出，将其中正常工作的脑组织填补在这块脑洞中。（所以脑洞治疗仪是脑洞的治疗仪？）\n\n例如，用上面第 $8$ 号位置到第 $10$ 号位置去修补第 $1$ 号位置到第 $4$ 号位置的脑洞，我们就会得到：\n\n```cpp\n1      1      1      1      0      0      1      0      0      0\n```\n\n如果再用第 $1$ 号位置到第 $4$ 号位置去修补第 $8$ 号位置到第 $10$ 号位置：\n\n```cpp\n0      0      0      0      0      0      1      1      1      1\n```\n\n这是因为脑洞治疗仪会把多余出来的脑组织直接扔掉。\n\n如果再用第 $7$ 号位置到第 $10$ 号位置去填补第 $1$ 号位置到第 $6$ 号位置：\n\n```cpp\n1      1      1      1      0      0      0      0      0      0\n```\n\n这是因为如果新脑洞挖出来的脑组织不够多，脑洞治疗仪仅会尽量填补位置比较靠前的脑洞。\n\n假定初始时 SHTSC 并没有脑洞，给出一些挖脑洞和脑洞治疗的操作序列，你需要即时回答 SHTSC 的问题：在大脑某个区间中最大的连续脑洞区域有多大。", "inputFormat": "第一行两个整数 $n,m$，表示 SHTSC 的大脑可分为从 $1$ 到 $n$ 编号的 $n$ 个连续区域，有 $m$ 个操作。\n\n以下 $m$ 行每行是下列三种格式之一：\n* $0\\quad l\\quad r$：SHTSC 挖了一个范围为 $[l, r]$ 的脑洞。\n* $1\\quad l_0\\quad r_0\\quad l_1\\quad r_1$：SHTSC 进行了一次脑洞治疗，用从 $l_0$ 到 $r_0$ 的脑组织修补 $l_1$ 到 $r_1$ 的脑洞。\n* $2\\quad l\\quad r$：SHTSC 询问 $[l, r]$ 区间内最大的脑洞有多大。\n\n上述区间均在 $[1, n]$ 范围内。", "outputFormat": "对于每个询问，输出一行一个整数，表示询问区间内最大连续脑洞区域有多大。", "hint": "对于 $20\\%$ 的数据，$n, m \\leq 100$；  \n对于 $50\\%$ 的数据，$n, m \\leq 20000$；  \n对于 $100\\%$ 的数据，$n, m \\leq 200000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2015] Brainhole Treatment Device", "background": "", "description": "The inventor SHTSC, who once created the automatic problem-solving machine, has unveiled his new invention: the Brainhole Treatment Device — a mysterious apparatus that can treat the ever-enlarging “brainholes” caused by his inventions.\n\nFor simplicity, we regard the brain as a 01 sequence. $1$ means the tissue at that position is working normally, and $0$ means it is a brainhole.\n\n```cpp\n1      0      1      0      0      0      1      1      1      0\n```\n\nThe basic principle for repairing a certain brainhole is to excavate another contiguous region and use the normal tissue from it to fill the hole. (So is the brainhole treatment device actually a treatment device for brainholes?)\n\nFor example, if we use positions $8$ to $10$ to repair the hole from positions $1$ to $4$, we get:\n\n```cpp\n1      1      1      1      0      0      1      0      0      0\n```\n\nIf we then use positions $1$ to $4$ to repair positions $8$ to $10$:\n\n```cpp\n0      0      0      0      0      0      1      1      1      1\n```\n\nThis is because the Brainhole Treatment Device discards any excess tissue.\n\nIf we then use positions $7$ to $10$ to fill positions $1$ to $6$:\n\n```cpp\n1      1      1      1      0      0      0      0      0      0\n```\n\nThis is because if the excavated normal tissue is not enough, the device only fills the brainhole as much as possible starting from the earlier positions (smaller indices).\n\nAssume that initially SHTSC has no brainholes. Given a sequence of digging and treatment operations, you need to answer online: within a given interval of the brain, what is the size of the largest contiguous brainhole.", "inputFormat": "The first line contains two integers $n, m$, meaning SHTSC’s brain is divided into $n$ contiguous regions numbered from $1$ to $n$, and there are $m$ operations.\n\nEach of the following $m$ lines is in one of the following three formats:\n* $0\\quad l\\quad r$: SHTSC digs a brainhole covering the range $[l, r]$.\n* $1\\quad l_0\\quad r_0\\quad l_1\\quad r_1$: SHTSC performs one treatment, using the normal tissue from $l_0$ to $r_0$ to repair the brainholes from $l_1$ to $r_1$.\n* $2\\quad l\\quad r$: SHTSC asks for the size of the largest brainhole within the interval $[l, r]$.\n\nAll the above intervals lie within $[1, n]$.", "outputFormat": "For each query, output one line with one integer, the size of the largest contiguous brainhole within the query interval.", "hint": "For $20\\%$ of the testdata, $n, m \\leq 100$.\nFor $50\\%$ of the testdata, $n, m \\leq 20000$.\nFor $100\\%$ of the testdata, $n, m \\leq 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2015] 脑洞治疗仪", "background": "", "description": "曾经发明了自动刷题机的发明家 SHTSC 又公开了他的新发明：脑洞治疗仪——一种可以治疗他因为发明而日益增大的脑洞的神秘装置。\n\n为了简单起见，我们将大脑视作一个 01 序列。$1$ 代表这个位置的脑组织正常工作，$0$ 代表这是一块脑洞。\n\n```cpp\n1      0      1      0      0      0      1      1      1      0\n```\n\n脑洞治疗仪修补某一块脑洞的基本工作原理就是将另一块连续区域挖出，将其中正常工作的脑组织填补在这块脑洞中。（所以脑洞治疗仪是脑洞的治疗仪？）\n\n例如，用上面第 $8$ 号位置到第 $10$ 号位置去修补第 $1$ 号位置到第 $4$ 号位置的脑洞，我们就会得到：\n\n```cpp\n1      1      1      1      0      0      1      0      0      0\n```\n\n如果再用第 $1$ 号位置到第 $4$ 号位置去修补第 $8$ 号位置到第 $10$ 号位置：\n\n```cpp\n0      0      0      0      0      0      1      1      1      1\n```\n\n这是因为脑洞治疗仪会把多余出来的脑组织直接扔掉。\n\n如果再用第 $7$ 号位置到第 $10$ 号位置去填补第 $1$ 号位置到第 $6$ 号位置：\n\n```cpp\n1      1      1      1      0      0      0      0      0      0\n```\n\n这是因为如果新脑洞挖出来的脑组织不够多，脑洞治疗仪仅会尽量填补位置比较靠前的脑洞。\n\n假定初始时 SHTSC 并没有脑洞，给出一些挖脑洞和脑洞治疗的操作序列，你需要即时回答 SHTSC 的问题：在大脑某个区间中最大的连续脑洞区域有多大。", "inputFormat": "第一行两个整数 $n,m$，表示 SHTSC 的大脑可分为从 $1$ 到 $n$ 编号的 $n$ 个连续区域，有 $m$ 个操作。\n\n以下 $m$ 行每行是下列三种格式之一：\n* $0\\quad l\\quad r$：SHTSC 挖了一个范围为 $[l, r]$ 的脑洞。\n* $1\\quad l_0\\quad r_0\\quad l_1\\quad r_1$：SHTSC 进行了一次脑洞治疗，用从 $l_0$ 到 $r_0$ 的脑组织修补 $l_1$ 到 $r_1$ 的脑洞。\n* $2\\quad l\\quad r$：SHTSC 询问 $[l, r]$ 区间内最大的脑洞有多大。\n\n上述区间均在 $[1, n]$ 范围内。", "outputFormat": "对于每个询问，输出一行一个整数，表示询问区间内最大连续脑洞区域有多大。", "hint": "对于 $20\\%$ 的数据，$n, m \\leq 100$；  \n对于 $50\\%$ 的数据，$n, m \\leq 20000$；  \n对于 $100\\%$ 的数据，$n, m \\leq 200000$。", "locale": "zh-CN"}}}
{"pid": "P4345", "type": "P", "difficulty": 6, "samples": [["3\n5 5\n10 7\n1145 14", "32\n968\n763"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2015", "各省省选", "上海", "Lucas 定理"], "title": "[SHOI2015] 超能粒子炮·改", "background": "", "description": "曾经发明了脑洞治疗仪与超能粒子炮的发明家 SHTSC 又公开了他的新发明：超能粒子炮・改——一种可以发射威力更加强大的粒子流的神秘装置。\n\n超能粒子炮・改相比超能粒子炮，在威力上有了本质的提升。它有两个参数 $n,k$ ，它会向每个编号为 $0$ 到 $k$ （包含两端）的位置 $i$ 发射威力为 $C_{n}^{i} \\bmod 2333$ 的粒子流。\n\n现在 SHTSC 给出了他的超能粒子炮・改的参数，让你求出其发射的粒子流的威力之和除以 $2333$ 所得的余数。", "inputFormat": "第一行一个整数 $t$ 表示数据组数。\n\n之后 $t$ 行，每行两个整数 $n,k$，含义如题面描述。", "outputFormat": "$t$ 行，每行一个整数，表示其粒子流的威力之和模 $2333$ 的值。", "hint": "对于 $10\\%$ 的数据，$t = 1,n,k \\le 1000$ ；  \n对于 $30\\%$ 的数据，$t = 1,n,k \\le 1000000$ ；  \n对于 $50\\%$ 的数据，$t = 1,n \\le 10^{18},k \\le 1000$ ；  \n对于 $70\\%$ 的数据，$t = 100,n,k \\le 10^{18}$ ；  \n对于 $100\\%$ 的数据，$t = 100000,n,k \\le 10^{18}$ .", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2015] Super Particle Cannon · Modified", "background": "", "description": "The inventor SHTSC, who once created the Brain-hole Therapy Device and the Super Particle Cannon, has now unveiled his new invention: Super Particle Cannon · Modified — a mysterious device that can fire particle streams with much greater power.\n\nCompared with the Super Particle Cannon, Super Particle Cannon · Modified has a fundamental increase in power. It has two parameters $n, k$. It fires, at each position $i$ numbered from $0$ to $k$ inclusive, a particle stream with power $C_{n}^{i} \\bmod 2333$.\n\nNow SHTSC gives you the parameters of his Super Particle Cannon · Modified. Please compute the remainder modulo $2333$ of the sum of the powers of the particle streams it fires.", "inputFormat": "The first line contains an integer $t$ denoting the number of test cases.\n\nThen follow $t$ lines. Each line contains two integers $n, k$, as described above.", "outputFormat": "Output $t$ lines. Each line contains one integer: the value of the sum of the powers modulo $2333$.", "hint": "For $10\\%$ of the testdata, $t = 1$, $n, k \\le 1000$.  \nFor $30\\%$ of the testdata, $t = 1$, $n, k \\le 1000000$.  \nFor $50\\%$ of the testdata, $t = 1$, $n \\le 10^{18}$, $k \\le 1000$.  \nFor $70\\%$ of the testdata, $t = 100$, $n, k \\le 10^{18}$.  \nFor $100\\%$ of the testdata, $t = 100000$, $n, k \\le 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2015] 超能粒子炮·改", "background": "", "description": "曾经发明了脑洞治疗仪与超能粒子炮的发明家 SHTSC 又公开了他的新发明：超能粒子炮・改——一种可以发射威力更加强大的粒子流的神秘装置。\n\n超能粒子炮・改相比超能粒子炮，在威力上有了本质的提升。它有两个参数 $n,k$ ，它会向每个编号为 $0$ 到 $k$ （包含两端）的位置 $i$ 发射威力为 $C_{n}^{i} \\bmod 2333$ 的粒子流。\n\n现在 SHTSC 给出了他的超能粒子炮・改的参数，让你求出其发射的粒子流的威力之和除以 $2333$ 所得的余数。", "inputFormat": "第一行一个整数 $t$ 表示数据组数。\n\n之后 $t$ 行，每行两个整数 $n,k$，含义如题面描述。", "outputFormat": "$t$ 行，每行一个整数，表示其粒子流的威力之和模 $2333$ 的值。", "hint": "对于 $10\\%$ 的数据，$t = 1,n,k \\le 1000$ ；  \n对于 $30\\%$ 的数据，$t = 1,n,k \\le 1000000$ ；  \n对于 $50\\%$ 的数据，$t = 1,n \\le 10^{18},k \\le 1000$ ；  \n对于 $70\\%$ 的数据，$t = 100,n,k \\le 10^{18}$ ；  \n对于 $100\\%$ 的数据，$t = 100000,n,k \\le 10^{18}$ .", "locale": "zh-CN"}}}
{"pid": "P4346", "type": "P", "difficulty": 3, "samples": [["....x.xxxxx.xxxxx.x...x.xxxxx.xxxxx.xxxxx.......xxxxx.xxxxx.xxxxx\n....x.....x.....x.x...x.x.....x.........x...x...x...x.x...x.x...x\n....x.....x.....x.x...x.x.....x.........x...x...x...x.x...x.x...x\n....x.xxxxx.xxxxx.xxxxx.xxxxx.xxxxx.....x.xxxxx.xxxxx.xxxxx.x...x\n....x.x.........x.....x.....x.x...x.....x...x...x...x.....x.x...x\n....x.x.........x.....x.....x.x...x.....x...x...x...x.....x.x...x\n....x.xxxxx.xxxxx.....x.xxxxx.xxxxx.....x.......xxxxx.xxxxx.xxxxx", "....x.xxxxx.xxxxx.xxxxx.x...x.xxxxx.xxxxx\n....x.....x.....x.x.....x...x.x.........x\n....x.....x.....x.x.....x...x.x.........x\n....x.xxxxx.xxxxx.xxxxx.xxxxx.xxxxx.....x\n....x.x.........x.....x.....x.....x.....x\n....x.x.........x.....x.....x.....x.....x\n....x.xxxxx.xxxxx.xxxxx.....x.xxxxx.....x"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["模拟", "字符串", "2015", "枚举", "ICPC", "CERC"], "title": "[CERC2015] ASCII Addition", "background": "Nowadays, there are smartphone applications that instantly translate text and even solve math problems if you just point your phone’s camera at them. Your job is to implement a much simpler functionality reminiscent of the past – add two integers written down as ASCII art.", "description": "An ASCII art is a matrix of characters, exactly 7 rows high, with each individual character either a dot or the lowercase letter x.\n\nAn expression of the form a + b is given, where both a and b are positive integers. The expression is converted into ASCII art by writing all the expression characters (the digits of a and b as well as the + sign) as 7  5 matrices, and concatenating the matrices together with a single column of dot characters between consecutive individual matrices. The exact matrices corresponding to the digits and the + sign are as follows:\n\n![](https://cdn.luogu.com.cn/upload/pic/16222.png )\n\nGiven an ASCII art for an expression of the form a + b, find the result of the addition and write it out in the ASCII art form.", "inputFormat": "Input consists of exactly 7 lines and contains the ASCII art for an expression of the form a + b, where\nboth a and b are positive integers consisting of at most 9 decimal digits and written without leading\nzeros.", "outputFormat": "Output 7 lines containing ASCII art corresponding to the result of the addition, without leading zeros.", "hint": "样例：1234567+890=1235457\n\nCentral Europe Regional Contest 2015 Problem A", "locale": "en", "translations": {"en": {"title": "[CERC2015] ASCII Addition", "background": "Nowadays, there are smartphone applications that instantly translate text and even solve math problems if you just point your phone’s camera at them. Your job is to implement a much simpler functionality reminiscent of the past – add two integers written down as ASCII art.", "description": "An ASCII art is a matrix of characters, exactly 7 rows high, with each individual character either a dot or the lowercase letter x.\n\nAn expression of the form a + b is given, where both a and b are positive integers. The expression is converted into ASCII art by writing all the expression characters (the digits of a and b as well as the + sign) as 7  5 matrices, and concatenating the matrices together with a single column of dot characters between consecutive individual matrices. The exact matrices corresponding to the digits and the + sign are as follows:\n\n![](https://cdn.luogu.com.cn/upload/pic/16222.png )\n\nGiven an ASCII art for an expression of the form a + b, find the result of the addition and write it out in the ASCII art form.", "inputFormat": "Input consists of exactly 7 lines and contains the ASCII art for an expression of the form a + b, where\nboth a and b are positive integers consisting of at most 9 decimal digits and written without leading\nzeros.", "outputFormat": "Output 7 lines containing ASCII art corresponding to the result of the addition, without leading zeros.", "hint": "样例：1234567+890=1235457\n\nCentral Europe Regional Contest 2015 Problem A", "locale": "en"}, "zh-CN": {"title": "[CERC2015] ASCII Addition", "background": "", "description": "# 题目背景\n\n现在，如果你只是用手机的相机对着它们，智能手机应用可以即时翻译文本，甚至解决数学问题。您的工作是实现一个更简单的功能，回忆过去——添加两个作为ASCII艺术的整数。\n\n\nASCII艺术是一个字符矩阵，正好是7行高，每个字符都是点或小写字母X。\n\n给出了A +B形式的表达式，其中A和B都是正整数。通过将所有的表达式字符（A和B的数字以及符号）作为7 5个矩阵，将这些矩阵转换成ASCII艺术，并将矩阵与单个字符的单个列串联在连续的各个矩阵之间。对应于数字和+符号的精确矩阵如下：\n\n![](https://cdn.luogu.org/upload/pic/16222.png)\n\n给定一个ASCII艺术来表达A+B的形式，找到加法的结果并用ASCII艺术形式写出。", "inputFormat": "输入由7行组成，包含用于A+B形式的表达式的ASCII技术，其中A和B都是由至多9个十进制数字组成的正整数，并且没有前导零。", "outputFormat": "输出包含ASCII艺术的7行，对应于加法的结果，没有前导零。\n\n感谢@剑圣夜雨声烦 提供的翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4347", "type": "P", "difficulty": 6, "samples": [["its a long way to the top if you wanna rock n roll\n13 16", "22\n12\n12\n15"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "CERC"], "title": "[CERC2015] Book Borders", "background": "A book is being typeset using a fixed width font and a simple greedy algorithm to fill each line. The\nbook contents is just a sequence of words, where each word contains one or more characters.", "description": "Before typesetting, we choose a maximum line length and denote this value with m. Each line can be at most m characters long including the space characters between the words. The typesetting algorithm simply processes words one by one and prints each word with exactly one space character between two consecutive words on the same line. If printing the word on the current line would exceed the maximum line length m, a new line is started instead.\n\n![](https://cdn.luogu.com.cn/upload/pic/16228.png)\n\nYou are given a text to be typeset and are experimenting with different values of the maximum line length m. For a fixed m, the leading sentence is a sentence (a sequence of words separated with a single space character) formed by the first words of lines top to bottom. In the example above, when the sample text is typeset with the maximum line length 14, the leading sentence is “its to you n”.\n\nGiven a text and two integers a and b, find the length of the leading sentence for every candidate maximum line length between a and b inclusive. The length of a sentence is the total number of characters it contains including the space characters.", "inputFormat": "The first line contains the text to be typeset – a sequence of words separated by exactly one space character. Each word is a string consisting of one or more lowercase letters from the English alphabet.\n\nThe second line contains two integers a and b – the edges of the interval we are interested in, as described above.\n\nIt is guaranteed that $1<=w<=a<=b<=z<=500 000$, where w is the length of the longest word in the text and z is the total number of characters in the text including the space characters.", "outputFormat": "Output $b - a + 1$ lines – the $k$-th of those lines should contain a single integer – the total length of the leading sentence when the maximum line length is equal to $a - 1 + k$.", "hint": "Central Europe Regional Contest 2015\nProblem B", "locale": "en", "translations": {"en": {"title": "[CERC2015] Book Borders", "background": "A book is being typeset using a fixed width font and a simple greedy algorithm to fill each line. The\nbook contents is just a sequence of words, where each word contains one or more characters.", "description": "Before typesetting, we choose a maximum line length and denote this value with m. Each line can be at most m characters long including the space characters between the words. The typesetting algorithm simply processes words one by one and prints each word with exactly one space character between two consecutive words on the same line. If printing the word on the current line would exceed the maximum line length m, a new line is started instead.\n\n![](https://cdn.luogu.com.cn/upload/pic/16228.png)\n\nYou are given a text to be typeset and are experimenting with different values of the maximum line length m. For a fixed m, the leading sentence is a sentence (a sequence of words separated with a single space character) formed by the first words of lines top to bottom. In the example above, when the sample text is typeset with the maximum line length 14, the leading sentence is “its to you n”.\n\nGiven a text and two integers a and b, find the length of the leading sentence for every candidate maximum line length between a and b inclusive. The length of a sentence is the total number of characters it contains including the space characters.", "inputFormat": "The first line contains the text to be typeset – a sequence of words separated by exactly one space character. Each word is a string consisting of one or more lowercase letters from the English alphabet.\n\nThe second line contains two integers a and b – the edges of the interval we are interested in, as described above.\n\nIt is guaranteed that $1<=w<=a<=b<=z<=500 000$, where w is the length of the longest word in the text and z is the total number of characters in the text including the space characters.", "outputFormat": "Output $b - a + 1$ lines – the $k$-th of those lines should contain a single integer – the total length of the leading sentence when the maximum line length is equal to $a - 1 + k$.", "hint": "Central Europe Regional Contest 2015\nProblem B", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Book Borders", "background": "", "description": "现有一本书,用固定宽度的字体和简单的贪婪算法来填充每行文字。书的内容是一个单词序列，每个单词包含一个或多个字符。\r\n\r\n排版前，我们选择一个最大的行长度，并用m表示这个值。每行最多可以有m个字符，包括单词之间的空格字符。请使用排版算法简单地逐个处理单词，并在同一行上的两个连续单词之间打印每个单词，每个单词只有一个空格字符。而且如果在当前行上打印该字超过最大行长度m，则开始新行。\r\n![](https://cdn.luogu.org/upload/pic/16228.png)\r\n现在你得到了一个要排版的文本，并且正在试验最大行长度m的不同值。对于固定m，前导句是一个句子(由一个空格字符分隔的一系列单词)，由行的第一个单词从上到下组成。在上例中，当样本文本以最大行长度14进行排版时，前导句是“对你来说是n”（its to you n）\r\n给定一个文本和两个整数a和b，找出a和b之间每个候选最大行长度的前导句长度。句子的长度是它包含的字符总数，包括空格字符", "inputFormat": "第一行包含要排版的文本——由一个空格字符分隔的一系列单词。每个单词都是一个字符串，由英语字母表中的一个或多个小写字母组成。 第二行包含两个整数a和b——如上所述的区间边缘。保证1<=w <=a<=b<=z<=50000,\r\n其中w是文本中最长单词的长度，z是文本中包括空格字符的字符总数。", "outputFormat": "输出b-a+1行——这些行的第k行应该包含一个整数——最大行长度等于a-1+k时前导句的总长度。\r\n\r\n**输入输出样例**\r\n\r\n输入样例#1\r\n```\r\nits a long way to the top if you wanna rock n roll\r\n13 16\r\n```\r\n输出样例#1\r\n```\r\n22\r\n12\r\n12\r\n15\r\n```", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4348", "type": "P", "difficulty": 7, "samples": [["4 \n2 2 8 4 \n1 9 4 10 \n6 7 9 9 \n3 3 7 3 \n9 \n3 4 \n8 4 \n11 5 \n10 7 \n10 8 \n9 8 \n2 8 \n4 11 \n9 11 \n8 \n1 1 \n5 10 \n6 9 \n3 7 \n7 1 \n4 2 \n7 5 \n3 3", "5 \n1 \n0 \n1 \n3 \n1 \n3 \n0 "]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "ICPC", "CERC"], "title": "[CERC2015] Cow Confinement", "background": "", "description": "A near by pasture can be represented as a rectangular grid consisting of 106 rows and 106 columns. The rows are numbered with integers 1 through 106 top to bottom, the columns with integers 1 through 106 left to right. \n\nA herd of n cows is scattered through the grid, each cow occupying a unit square. The pasture also contains m dandelion ﬂowers (which cows like), again each occupying a unit square. Finally, the pasture contains p fences, each a rectangle running along the edges of unit squares. Fences do not intersect or touch. However, a fence may contain other fences inside the enclosed area. \n\nDue to unfavorable wind conditions, cows can only move in two directions – down or right. Cows can go through squares occupied by other cows or ﬂowers, but cannot cross fences. \nFor each cow, ﬁnd the total number of ﬂowers reachable from its present location.", "inputFormat": "Input contains three blocks – the ﬁrst block describes fences, the second one ﬂowers and the third one cows. \n\nThe ﬁrst line of the ﬁrst block contains an integer f (0≤ f ≤200000) – the number of fences. Each of the following f lines contains four integers r1, c1, r2, c2 (1≤r1, c1, r2, c2 ≤$10^6$) describing a single fence – r1 and c1 are the coordinates (row and column) of the upper-left corner square inside the fence, while r2 and c2 are the coordinates of the lower-right corner square inside the fence. No two fences will intersect or touch. \n\nThe ﬁrst line of the second block contains an integer m (0≤m≤200000) – the number of ﬂowers. The k-th of the following m lines contains two integers r and c (1 ≤ r, c ≤ $10^6$) – the location of the k-th ﬂower. No two ﬂowers will occupy the same location. \n\nThe ﬁrst line of the third block contains an integer n (1≤n≤200000) – the number of cows. The k-th of the following n lines contains two integers r and c (1≤r, c≤$10^6$) – the location of the k-th cow. No two cows will occupy the same location, and no ﬂower and cow will occupy the same location.", "outputFormat": "Output should consist of n lines. The k-th line should contain a single integer – the total number of ﬂowers reachable from the location of the k-th cow.", "hint": "样例：\n\n![](https://cdn.luogu.com.cn/upload/pic/16231.png)\n\nCentral Europe Regional Contest 2015\nProblem C", "locale": "en", "translations": {"en": {"title": "[CERC2015] Cow Confinement", "background": "", "description": "A near by pasture can be represented as a rectangular grid consisting of 106 rows and 106 columns. The rows are numbered with integers 1 through 106 top to bottom, the columns with integers 1 through 106 left to right. \n\nA herd of n cows is scattered through the grid, each cow occupying a unit square. The pasture also contains m dandelion ﬂowers (which cows like), again each occupying a unit square. Finally, the pasture contains p fences, each a rectangle running along the edges of unit squares. Fences do not intersect or touch. However, a fence may contain other fences inside the enclosed area. \n\nDue to unfavorable wind conditions, cows can only move in two directions – down or right. Cows can go through squares occupied by other cows or ﬂowers, but cannot cross fences. \nFor each cow, ﬁnd the total number of ﬂowers reachable from its present location.", "inputFormat": "Input contains three blocks – the ﬁrst block describes fences, the second one ﬂowers and the third one cows. \n\nThe ﬁrst line of the ﬁrst block contains an integer f (0≤ f ≤200000) – the number of fences. Each of the following f lines contains four integers r1, c1, r2, c2 (1≤r1, c1, r2, c2 ≤$10^6$) describing a single fence – r1 and c1 are the coordinates (row and column) of the upper-left corner square inside the fence, while r2 and c2 are the coordinates of the lower-right corner square inside the fence. No two fences will intersect or touch. \n\nThe ﬁrst line of the second block contains an integer m (0≤m≤200000) – the number of ﬂowers. The k-th of the following m lines contains two integers r and c (1 ≤ r, c ≤ $10^6$) – the location of the k-th ﬂower. No two ﬂowers will occupy the same location. \n\nThe ﬁrst line of the third block contains an integer n (1≤n≤200000) – the number of cows. The k-th of the following n lines contains two integers r and c (1≤r, c≤$10^6$) – the location of the k-th cow. No two cows will occupy the same location, and no ﬂower and cow will occupy the same location.", "outputFormat": "Output should consist of n lines. The k-th line should contain a single integer – the total number of ﬂowers reachable from the location of the k-th cow.", "hint": "样例：\n\n![](https://cdn.luogu.com.cn/upload/pic/16231.png)\n\nCentral Europe Regional Contest 2015\nProblem C", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Cow Confinement", "background": "", "description": "附近的一个牧场可以表示为一个由 $10^6$ 行和 $10^6$ 列组成的矩形网格。行从上到下用整数 $1$ 到 $10^6$ 编号，列从左到右用整数 $1$ 到 $10^6$ 编号。\n\n一群共 $n$ 头牛分散在网格中，每头牛占据一个单位方格。牧场中还包含 $m$ 朵蒲公英花（牛喜欢的花），同样每朵花占据一个单位方格。此外，牧场包含 $p$ 个栅栏，每个栅栏是一个沿单位方格边缘延伸的矩形。栅栏之间不会相交或接触。然而，一个栅栏内部可能包含其他栅栏。\n\n由于不利的风向条件，牛只能朝两个方向移动——向下或向右。牛可以经过被其他牛或花占据的方格，但不能穿过栅栏。  \n对于每头牛，求从它当前位置可以到达的花朵总数。", "inputFormat": "输入包含三个部分——第一部分描述栅栏，第二部分描述花朵，第三部分描述牛。\n\n第一部分的第一行包含一个整数 $f$（$0 \\leq f \\leq 200000$）——栅栏的数量。接下来的 $f$ 行每行包含四个整数 $r_1, c_1, r_2, c_2$（$1 \\leq r_1, c_1, r_2, c_2 \\leq 10^6$），描述一个栅栏——$r_1$ 和 $c_1$ 是栅栏内部左上角方格的坐标（行和列），而 $r_2$ 和 $c_2$ 是栅栏内部右下角方格的坐标。任意两个栅栏不会相交或接触。\n\n第二部分的第一行包含一个整数 $m$（$0 \\leq m \\leq 200000$）——花朵的数量。接下来的第 $k$ 行包含两个整数 $r$ 和 $c$（$1 \\leq r, c \\leq 10^6$）——第 $k$ 朵花的位置。任意两朵花不会占据同一位置。\n\n第三部分的第一行包含一个整数 $n$（$1 \\leq n \\leq 200000$）——牛的数量。接下来的第 $k$ 行包含两个整数 $r$ 和 $c$（$1 \\leq r, c \\leq 10^6$）——第 $k$ 头牛的位置。任意两头牛不会占据同一位置，且没有花和牛会占据同一位置。\n", "outputFormat": "输出应包含 $n$ 行。第 $k$ 行应包含一个整数——从第 $k$ 头牛的位置可以到达的花朵总数。\n", "hint": "样例图示：\n\n![](https://cdn.luogu.com.cn/upload/pic/16231.png)\n\nCentral Europe Regional Contest 2015  \nProblem C\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P4349", "type": "P", "difficulty": 5, "samples": [["4 2\n1246", "4"], ["4 7\n2015", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "CERC"], "title": "[CERC2015] Digit Division", "background": "", "description": "We are given a sequence of n decimal digits. The sequence needs to be partitioned into one or more contiguous subsequences such that each subsequence, when interpreted as a decimal number, is divisible by a given integer m. \n\nFind the number of different such partitions modulo $10^9 +7$. When determining if two partitions are different, we only consider the locations of subsequence boundaries rather than the digits themselves, e.g. partitions $2|22$ and $22|2$ are considered different.", "inputFormat": "The ﬁrst line contains two integers n and m (1≤n≤300000, 1≤m≤1000000) – the length of the sequence and the divisor respectively. The second line contains a string consisting of exactly n digits.", "outputFormat": "Output a single integer – the number of different partitions modulo 109 +7.", "hint": "Central Europe Regional Contest 2015 Problem D", "locale": "en", "translations": {"en": {"title": "[CERC2015] Digit Division", "background": "", "description": "We are given a sequence of n decimal digits. The sequence needs to be partitioned into one or more contiguous subsequences such that each subsequence, when interpreted as a decimal number, is divisible by a given integer m. \n\nFind the number of different such partitions modulo $10^9 +7$. When determining if two partitions are different, we only consider the locations of subsequence boundaries rather than the digits themselves, e.g. partitions $2|22$ and $22|2$ are considered different.", "inputFormat": "The ﬁrst line contains two integers n and m (1≤n≤300000, 1≤m≤1000000) – the length of the sequence and the divisor respectively. The second line contains a string consisting of exactly n digits.", "outputFormat": "Output a single integer – the number of different partitions modulo 109 +7.", "hint": "Central Europe Regional Contest 2015 Problem D", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Digit Division", "background": "", "description": "给定一个长度为 $n$ 的十进制数字序列。需要将该序列划分为一个或多个连续的子序列，使得每个子序列在被解释为十进制数时都能被给定的整数 $m$ 整除。\n\n求不同的划分方式的数量，结果对 $10^9 + 7$ 取模。当判断两个划分是否不同的时候，我们只考虑子序列边界的位置，而不是数字本身。例如，划分 $2|22$ 和 $22|2$ 被认为是不同的。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$ ($1 \\leq n \\leq 300000$, $1 \\leq m \\leq 1000000$) —— 序列的长度和除数。第二行包含一个恰好由 $n$ 个数字组成的字符串。", "outputFormat": "输出一个整数，即不同划分的数量，对 $10^9 + 7$ 取模。", "hint": "Central Europe Regional Contest 2015 Problem D。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4350", "type": "P", "difficulty": 6, "samples": [["6 7 \n1 2 20 \n2 3 80 \n2 5 100 \n3 5 50 \n3 4 100 \n5 6 90 \n4 6 100 \n4 \n25 75 85 95", "2 3 \n1 1 \n2 1 \n4 2\n"], ["10 14 \n2 7 150 \n1 2 100 \n2 3 150 \n3 1 200 \n1 4 60 \n4 5 20 \n2 5 100 \n5 6 90 \n6 7 120 \n7 5 130 \n6 8 50 \n8 9 200 \n9 10 200 \n10 7 200 \n5 \n300 50 95 100 110", "0 0 \n6 9 \n4 5 \n4 5 \n5 4"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "CERC"], "title": "[CERC2015] Export Estimate", "background": "Luka owns a geographic data company that maintains a detailed city map and exports the data to interested parties. Often, clients do not want the complete map. Instead, they want a simpliﬁed map containing only major streets. ", "description": "City map is an undirected graph consisting of n intersections denoted with integers from 1 to n and m two-way streets. Each street is assigned a priority – a non-negative integer. When requesting a map, the client selects a threshold priority p. The original map is then copied and converted to the exported map using the following procedure:\n\n1. All streets whose priority is lower than p are deleted. \n\n2. For each intersection i from 1,2,...,n (processed in that order): \n\n(a) If the intersection i is not connected to any streets it is deleted. \n\n(b) If the intersection i is connected to exactly two different streets x and y leading to intersections a and b both different from i then the intersection i is contracted using the following procedure: \n\ni. Streets x and y are deleted. \n\nii. Intersection i is deleted. \n\niii. New street z connecting intersections a and b is added.\n\n![](https://cdn.luogu.com.cn/upload/pic/16236.png )\n\nInitially, the map does not contain loops (loop is a street that connects an intersection to itself) or parallel edges (more than one street between the same pair of intersections), but the loops and parallel edges may form during the contraction procedure. Notice that, in the step 2. (b) above, neither x nor y can be a loop (both a and b have to be different from i), but the newly added street z could be a loop (it is possible that a and b are same). \n\nGiven a map and a sequence of incoming export requests, for each request ﬁnd the number of intersections and the number of streets in the exported map.", "inputFormat": "The ﬁrst line contains two integers n (1 ≤ n ≤ 300000) and m (1 ≤ m ≤ 300000) – the number of intersections and the number of streets, respectively. Each of the following m lines contains three integers a, b and p (1≤ a,b≤n,0≤ p≤300000) which describe a street with priority p connecting intersections a and b. No street connects an intersection to itself. There is at most one street between every two intersections. \n\nThe following line contains an integer q (1 ≤ q ≤ 300000) – the number of export requests. The following line contains q integers. The k-th integer tk (0≤tk ≤300000) is the threshold priority of the k-th request.", "outputFormat": "Output should consist of q lines. The k-th line should contain two integers–the number of intersections and the number of streets, respectively, in the exported map for the k-th request.", "hint": "Central Europe Regional Contest 2015 Problem E", "locale": "en", "translations": {"en": {"title": "[CERC2015] Export Estimate", "background": "Luka owns a geographic data company that maintains a detailed city map and exports the data to interested parties. Often, clients do not want the complete map. Instead, they want a simpliﬁed map containing only major streets. ", "description": "City map is an undirected graph consisting of n intersections denoted with integers from 1 to n and m two-way streets. Each street is assigned a priority – a non-negative integer. When requesting a map, the client selects a threshold priority p. The original map is then copied and converted to the exported map using the following procedure:\n\n1. All streets whose priority is lower than p are deleted. \n\n2. For each intersection i from 1,2,...,n (processed in that order): \n\n(a) If the intersection i is not connected to any streets it is deleted. \n\n(b) If the intersection i is connected to exactly two different streets x and y leading to intersections a and b both different from i then the intersection i is contracted using the following procedure: \n\ni. Streets x and y are deleted. \n\nii. Intersection i is deleted. \n\niii. New street z connecting intersections a and b is added.\n\n![](https://cdn.luogu.com.cn/upload/pic/16236.png )\n\nInitially, the map does not contain loops (loop is a street that connects an intersection to itself) or parallel edges (more than one street between the same pair of intersections), but the loops and parallel edges may form during the contraction procedure. Notice that, in the step 2. (b) above, neither x nor y can be a loop (both a and b have to be different from i), but the newly added street z could be a loop (it is possible that a and b are same). \n\nGiven a map and a sequence of incoming export requests, for each request ﬁnd the number of intersections and the number of streets in the exported map.", "inputFormat": "The ﬁrst line contains two integers n (1 ≤ n ≤ 300000) and m (1 ≤ m ≤ 300000) – the number of intersections and the number of streets, respectively. Each of the following m lines contains three integers a, b and p (1≤ a,b≤n,0≤ p≤300000) which describe a street with priority p connecting intersections a and b. No street connects an intersection to itself. There is at most one street between every two intersections. \n\nThe following line contains an integer q (1 ≤ q ≤ 300000) – the number of export requests. The following line contains q integers. The k-th integer tk (0≤tk ≤300000) is the threshold priority of the k-th request.", "outputFormat": "Output should consist of q lines. The k-th line should contain two integers–the number of intersections and the number of streets, respectively, in the exported map for the k-th request.", "hint": "Central Europe Regional Contest 2015 Problem E", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Export Estimate", "background": "Luka 经营一家地理数据公司，负责维护详细的城市地图，并将数据导出给有需求的客户。通常客户不需要完整地图，而是希望获得仅包含主要街道的简化地图。", "description": "城市地图是一个无向图，包含编号 $1$ 到 $n$ 的 $n$ 个交叉路口和 $m$ 条双向街道。每条街道都有一个非负整数的优先级。当客户请求地图时，会指定一个优先级阈值 $p$。原始地图会经过以下处理流程生成导出地图：\n\n1. 所有优先级小于 $p$ 的街道被删除；  \n2. 按顺序处理每个交叉路口 $i$（从 $1$ 到 $n$ 依次处理）：\n\n   (a) 如果这个路口没有连接到任何街道，它就会被删除。\n\n   (b) 如果路口 $i$ 恰好连接两条不同街道 $x$ 和 $y$（分别通向不同于 $i$ 的路口 $a$ 和 $b$），则按以下步骤进行收缩：\n\n   i.删除道路 $x$ 和道路 $y$；\n\n   ii.删除路口 $i$；\n\n   iii.加入一条连接路口 $a$ 和 $b$ 的新道路 $z$；\n\n![](https://cdn.luogu.com.cn/upload/pic/16236.png)\n\n最初，图中没有环（即一条连接到自身的边）或者平行的边（即在同一对交点之间有一条以上的边），但在收缩的过程中可能会形成环和平行边。\n\n请注意，在步骤 2.(b) 之前，$x$ 和 $y$ 都不能是环（即 $a$ 和 $b$ 必须和 $i$ 不同），但是新增的 $z$ 可以是一个环（即 $a$ 和 $b$ 可能是相同的）。\n\n给定地图和一系列导出请求，对每个请求计算导出地图中的路口数量和街道数量。", "inputFormat": "第一行包含两个整数 $n(1 \\le n\\le3\\times10^5)$ 和 $m(1\\le m\\le 3\\times10^5)$ 分别是点和边的数量。\n\n后面 $m$ 行包含三个整数分别是 $a,b$ 和 $p(1\\le a,b \\le n,0\\le p\\le 3\\times10^5)$ 用来描述 $a,b$ 之间边的优先级 $p$，没有一条边只连接一个点，两个点之间最多有一条边。\n\n第 $m+2$ 行包含一个整数 $q(1\\le q\\le 3\\times10^5)$ 表示询问的个数，下一行有 $q$ 个整数，第 $k$ 个整数 $t_k(0\\le t_k\\le 3\\times10^5)$ 是第 $k$ 次询问的优先级。", "outputFormat": "输出包括 $q$ 行。第 $k$ 行包含两个整数，分别是第 $k$ 次询问的点和边的个数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4351", "type": "P", "difficulty": 6, "samples": [["3 0 0 0 \n0 0 2 \n0 3 0", "0"], ["4 3 5 2 \n7 1 4 3 \n7 4 4 8", "41817"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000], "memory": [512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2015", "组合数学", "ICPC", "CERC"], "title": "[CERC2015] Frightful Formula", "background": "", "description": "A frightful matrix is a square matrix of order n where the ﬁrst row and the ﬁrst column are explicitly speciﬁed, while the other elements are calculated using a frightful formula which is, actually, a simple recursive rule. \n\nGiven two integer sequences l and t,both of size n,as well as integer parameters a,b and c,the frightful matrix F is deﬁned as follows:\n\n* The ﬁrst column of the matrix is the sequence l: \n\n$$F[k, 1] = lk$$ \n\n* The ﬁrst row of the matrix is the sequence t: \n\n$$F[1, k] = tk$$ \n\n* Other elements are calculated using a recursive formula: \n\n$$F[i,j]=a*F[i,j-1]+b*F[i-1,j]+c$$\n\nGiven a frightful matrix, ﬁnd the value of the element $F[n,n]$ modulo $10^6 +3$.", "inputFormat": "The ﬁrst line contains four integers n, a, b and c (2≤n≤200000, 0≤ a, b, c≤$10^6$) – the size of the matrix and the recursion parameters, as described in the problem statement. \n\nThe two following lines contain integers l1,...,ln and t1,...,tn, respectively (l1 = t1, 0≤lk, tk ≤106). ", "outputFormat": "Output a single integer – the value of $F[n,n]$ modulo $10^6 +3$.", "hint": "Central Europe Regional Contest 2015 Problem F", "locale": "en", "translations": {"en": {"title": "[CERC2015] Frightful Formula", "background": "", "description": "A frightful matrix is a square matrix of order n where the ﬁrst row and the ﬁrst column are explicitly speciﬁed, while the other elements are calculated using a frightful formula which is, actually, a simple recursive rule. \n\nGiven two integer sequences l and t,both of size n,as well as integer parameters a,b and c,the frightful matrix F is deﬁned as follows:\n\n* The ﬁrst column of the matrix is the sequence l: \n\n$$F[k, 1] = lk$$ \n\n* The ﬁrst row of the matrix is the sequence t: \n\n$$F[1, k] = tk$$ \n\n* Other elements are calculated using a recursive formula: \n\n$$F[i,j]=a*F[i,j-1]+b*F[i-1,j]+c$$\n\nGiven a frightful matrix, ﬁnd the value of the element $F[n,n]$ modulo $10^6 +3$.", "inputFormat": "The ﬁrst line contains four integers n, a, b and c (2≤n≤200000, 0≤ a, b, c≤$10^6$) – the size of the matrix and the recursion parameters, as described in the problem statement. \n\nThe two following lines contain integers l1,...,ln and t1,...,tn, respectively (l1 = t1, 0≤lk, tk ≤106). ", "outputFormat": "Output a single integer – the value of $F[n,n]$ modulo $10^6 +3$.", "hint": "Central Europe Regional Contest 2015 Problem F", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Frightful Formula", "background": null, "description": "定义一个矩阵 $F$，其中第一行和第一列是给定的，计算矩阵方法如下：\n\n- 矩阵的第一列是序列  $l$：\n\n$$F_{k,1}=l _ k$$\n\n- 矩阵的第一行是序列  $t$：\n\n$$F_{1,k}=t _ k$$\n\n- 其他元素使用给定的递归公式进行计算：\n\n$$\nF_{i,j}=a \\times F_{i,j-1}+b \\times F_{i-1,j}+c\n$$\n\n现在要求找求出 $F_{n,n}$ 模 $10^6+3$ 的值。", "inputFormat": "第一行包含四个整数 $n$，$a$，$b$ 和 $c(2 \\le n \\le 2 \\times 10^5,0 \\le a,b$，$c \\le 10^6)$ 矩阵的大小和递归参数，如问题描述中所述。\n\n下面两行分别包含整数 $l_1, \\cdots ,l_n$ 和 $t_1, \\cdots ,t_n(l_1=t_1,0 \\le l_k,t_k \\le 10^6)$。", "outputFormat": "输出一个整数的值即 $F_{n,n}$ 模 $10^6+3$。\n\n感谢 @ 守望提供的翻译。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4352", "type": "P", "difficulty": 7, "samples": [["6 5 \n4 3 5 3 6 6 \nBABAA\n", "5 5 6 6 6 6"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "CERC"], "title": "[CERC2015] Greenhouse Growth", "background": "", "description": "You are switching from computer science to agriculture and your new job involves growing sunflowers in an underground greenhouse. The greenhouse contains n sunflower plants arranged in a straight line and numbered with integers 1 through n, from left to right. Two lamps provide the light and heat the sunflowers need to grow: the lamp A is positioned at the left end, while the lamp B is positioned at the right end of the line. \n\nEvery day exactly one of the lamps is on, causing all of the sunflowers to turn towards the light and some of them to grow. The sunflower will grow if and only if the sunflower directly in front of it (towards the light) is higher. The growth is continuous with a uniform rate of exactly 1 centimeter per day. Notice that, when a sunflower starts to grow, it may cause the sunflower directly behind it to start to grow instantaneously.\n\n![](https://cdn.luogu.com.cn/upload/pic/16238.png )\n\nYou are given initial heights of the sunflowers and the lamp schedule for the following m day period, ﬁnd the ﬁnal heights of all the sunflowers.", "inputFormat": "The first line contains two integers n and m (1≤n, m≤300000) – the number of sunflowers and the number of days in the period. The following line contains n integers h1,h2,...,hn (1≤ hk ≤$10^9$) – the initial heights (in centimeters) of the sunflowers, from left to right. \n\nThe following line contains a string consisting of exactly m characters A or B – the lamp schedule starting from thefirst day of the period.", "outputFormat": "Output a single line containing n integers – the final heights of the suflowers, from left to right.\n", "hint": "Central Europe Regional Contest 2015 Problem G", "locale": "en", "translations": {"en": {"title": "[CERC2015] Greenhouse Growth", "background": "", "description": "You are switching from computer science to agriculture and your new job involves growing sunflowers in an underground greenhouse. The greenhouse contains n sunflower plants arranged in a straight line and numbered with integers 1 through n, from left to right. Two lamps provide the light and heat the sunflowers need to grow: the lamp A is positioned at the left end, while the lamp B is positioned at the right end of the line. \n\nEvery day exactly one of the lamps is on, causing all of the sunflowers to turn towards the light and some of them to grow. The sunflower will grow if and only if the sunflower directly in front of it (towards the light) is higher. The growth is continuous with a uniform rate of exactly 1 centimeter per day. Notice that, when a sunflower starts to grow, it may cause the sunflower directly behind it to start to grow instantaneously.\n\n![](https://cdn.luogu.com.cn/upload/pic/16238.png )\n\nYou are given initial heights of the sunflowers and the lamp schedule for the following m day period, ﬁnd the ﬁnal heights of all the sunflowers.", "inputFormat": "The first line contains two integers n and m (1≤n, m≤300000) – the number of sunflowers and the number of days in the period. The following line contains n integers h1,h2,...,hn (1≤ hk ≤$10^9$) – the initial heights (in centimeters) of the sunflowers, from left to right. \n\nThe following line contains a string consisting of exactly m characters A or B – the lamp schedule starting from thefirst day of the period.", "outputFormat": "Output a single line containing n integers – the final heights of the suflowers, from left to right.\n", "hint": "Central Europe Regional Contest 2015 Problem G", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Greenhouse Growth", "background": "", "description": "你正在从计算机科学转向农业，你的新工作涉及在地下温室中种植向日葵。温室中有 n 株向日葵，按从左到右的顺序排列并编号为 1 到 n。两盏灯为向日葵提供生长所需的光和热：灯 A 位于左端，而灯 B 位于右端。\n\n每天，只有一盏灯亮着，导致所有向日葵都朝向光源，并且其中一些会生长。向日葵只有在其正前方（朝向光源）的向日葵比它高时才会生长。生长是连续的，速率为每天正好 1 厘米。注意，当一株向日葵开始生长时，它可能会立即导致其正后方的向日葵开始生长。\n\n你被给定了向日葵的初始高度和接下来 m 天的灯光计划，找出所有向日葵的最终高度。", "inputFormat": "第一行包含两个整数 n 和 m (1≤n, m≤300000)——向日葵的数量和周期内的天数。接下来的一行包含 n 个整数 h1, h2, ..., hn (1≤ hk ≤$10^9$)——从左到右的向日葵的初始高度（以厘米为单位）。\n\n接下来的一行包含一个由恰好 m 个字符 A 或 B 组成的字符串——从周期的第一天开始的灯光计划。", "outputFormat": "输出一行包含 n 个整数——从左到右的向日葵的最终高度。", "hint": "Central Europe Regional Contest 2015 Problem G。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4353", "type": "P", "difficulty": 6, "samples": [["-2.5 -1.5 \n2.5 -1.5 \n2.5 3.5 \n-2.5 3.5", "10.6854838710"], ["3 0 \n0 4 \n-4 1 \n-1 -3", "10.1226478495"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "Special Judge", "ICPC", "CERC"], "title": "[CERC2015] Hovering Hornet", "background": "", "description": "You have managed to trap a hornet inside a box lying on the top of your dining table. Unfortunately, your playing dice is also trapped inside – you cannot retrieve it and continue your game of Monopoly without risking the hornet’s wrath. Instead, you pass your time calculating the expected number of spots on the dice visible to the hornet. \n\nThe hornet, the dice and the box are located in the standard three-dimensional coordinate system with the x coordinate growing eastwards, the y coordinate growing northwards and the z coordinate growing upwards. The surface of the table corresponds to the x-y plane.\n\n![](https://cdn.luogu.com.cn/upload/pic/16240.png )\n\nThe dice is a 1×1×1 cube, resting on the table with the center of the bottom side exactly in the origin. Hence,the coordinates of its two opposite cornersare (−0.5, −0.5, 0) and (0.5, 0.5, 1). The top side of  the dice has 5 spots, the south side 1 spot, the east side 3 spots, the north side 6 spots, the west side 4 spots and the (invisible and irrelevant) bottom side 2 spots. \n\nThe box is a 5×5×5 cube also resting on the table with the dice in its interior. The box is speciﬁed by giving the coordinates of its bottom side – a 5×5 square. \n\nAssume the hornet is hovering at a uniformly random point in the (continuous) space inside the box not occupied by the dice. Calculate the expected number of spots visible by the hornet. The dice is opaque and, hence, the hornet sees a spot only if the segment connecting the center of the spot and the location of the hornet does not intersect the interior of the dice.", "inputFormat": "Input consists of 4 lines. The k-th line contains two ﬂoating-point numbers xk and yk (−5≤ xk, yk ≤5) –coordinates of the k-th corner of the bottom side of the box in the x-y plane. The coordinates are given in the counterclockwise direction and they describe a square with the side length of exactly 5. \n\nThe box fully contains the dice. The surfaces of the box and the dice do not intersect or touch except along the bottom sides.", "outputFormat": "Output a single ﬂoating point number – the expected number of spots visible. The solution will be accepted if the absolute or the relative difference from the judges solution is less than $10^{−6}$.", "hint": "Central Europe Regional Contest 2015 Problem H", "locale": "en", "translations": {"en": {"title": "[CERC2015] Hovering Hornet", "background": "", "description": "You have managed to trap a hornet inside a box lying on the top of your dining table. Unfortunately, your playing dice is also trapped inside – you cannot retrieve it and continue your game of Monopoly without risking the hornet’s wrath. Instead, you pass your time calculating the expected number of spots on the dice visible to the hornet. \n\nThe hornet, the dice and the box are located in the standard three-dimensional coordinate system with the x coordinate growing eastwards, the y coordinate growing northwards and the z coordinate growing upwards. The surface of the table corresponds to the x-y plane.\n\n![](https://cdn.luogu.com.cn/upload/pic/16240.png )\n\nThe dice is a 1×1×1 cube, resting on the table with the center of the bottom side exactly in the origin. Hence,the coordinates of its two opposite cornersare (−0.5, −0.5, 0) and (0.5, 0.5, 1). The top side of  the dice has 5 spots, the south side 1 spot, the east side 3 spots, the north side 6 spots, the west side 4 spots and the (invisible and irrelevant) bottom side 2 spots. \n\nThe box is a 5×5×5 cube also resting on the table with the dice in its interior. The box is speciﬁed by giving the coordinates of its bottom side – a 5×5 square. \n\nAssume the hornet is hovering at a uniformly random point in the (continuous) space inside the box not occupied by the dice. Calculate the expected number of spots visible by the hornet. The dice is opaque and, hence, the hornet sees a spot only if the segment connecting the center of the spot and the location of the hornet does not intersect the interior of the dice.", "inputFormat": "Input consists of 4 lines. The k-th line contains two ﬂoating-point numbers xk and yk (−5≤ xk, yk ≤5) –coordinates of the k-th corner of the bottom side of the box in the x-y plane. The coordinates are given in the counterclockwise direction and they describe a square with the side length of exactly 5. \n\nThe box fully contains the dice. The surfaces of the box and the dice do not intersect or touch except along the bottom sides.", "outputFormat": "Output a single ﬂoating point number – the expected number of spots visible. The solution will be accepted if the absolute or the relative difference from the judges solution is less than $10^{−6}$.", "hint": "Central Europe Regional Contest 2015 Problem H", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Hovering Hornet", "background": "", "description": "你把一只蜜蜂困在你餐桌上的一个盒子里。但是，你玩的骰子也被困在里面（你无法取回它）不过，你通过计算蜜蜂可以看到的骰子上的预期点数来消磨时间。\n\n蜜蜂、骰子和盒子位于一个三维坐标系中，x-y轴如图\n\n骰子是一个1×1×1的立方体，放在桌子上，底部的中心为原点。因此，其两个相对角的坐标为(−0.5, −0.5,0）和（0.5,0.5,1）。骰子顶部有5个点，南侧1个点，东侧3个点，北侧6个点，西侧4个点，底部2个点（不可见和不相关）。\n\n盒子是一个5×5×5的立方体，也放在桌子上，里面有骰子。该框通过给出其底部的坐标（一个5×5的正方形）来指定。\n\n假设蜜蜂在盒子内没有骰子的（连续）空间中的一个均匀随机点上盘旋。计算蜜蜂可以看到的点数的数量。骰子是不透明的，因此，只有当连接点数中心和蜜蜂位置的部分不与骰子内部相交时，蜜蜂才能看到斑点。", "inputFormat": "输入由4行组成。第k行包含两个浮点数xk和yk(−5<=xk，yk<=5）x-y平面中长方体底部第k个角的坐标。坐标以逆时针方向给出，它们描述了边长正好为5的正方形。\n盒子和骰子的表面不相交或接触，除非放在底部。", "outputFormat": "输出一个数——预期可见点数\n（样例如下）", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4354", "type": "P", "difficulty": 6, "samples": [["5 \n4 2 0.6 \n7 3 0.7 \n8 5 0.8 \n1 3 0.7 \n3 4 0.4 \n2 \n3 1 9 6 \n3 4 7 2", "2\n1"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "CERC"], "title": "[CERC2015] Ice Igloos", "background": "", "description": "A ﬁshing village built on the surface of a frozen lake far north in the arctic is endangered by global warming-fractures are starting to form on the lake surface. The village consists of n igloos of spherical shape, each occupying a circular area of the surface. \n\nAn igloo can be represented as a circle in the coordinate plane: the center of the circle is a point with integer coordinates, while the radius is a positive ﬂoating-point number less than 1 with exactly one fractional digit. \n\nGiven the locations of possible ice fractures, the villagers would like to know how many igloos are affected by each. Formally, given q queries where each query is a straight line segment deﬁned by the two endpoints, ﬁnd the number of igloos each segment intersects. A segment intersects an igloo if it has at least one point in common with the interior of the circle.", "inputFormat": "The ﬁrst line contains an integer n (1≤n≤100000) - the number of igloos. Each of the following n lines contains three numbers x, y and r – the coordinates of the center and the radius of one igloo. The coordinates x and y are integers such that 1≤ x, y≤500, while r is a ﬂoating-point number with exactly one fractional digit such that 0 < r < 1. No two igloos will intersect or touch. \n\nThe following line contains an integer q (1 ≤ q ≤ 100000) - the number of queries. Each of the following q linescontainsfourintegers x1, y1, x2, y2 (1≤ x1, y1, x2, y2 ≤500)-thecoordinatesofthe two endpoints of the segment. The two endpoints will be different. Endpoints may be inside igloos. \n\nYou may assume that, for every igloo i and the segment s, the square of the distance between s and the center of i is either less than r2−10−5 or greater than r2 +10−5 where r is the radius of the igloo i. ", "outputFormat": "Output should consist of q lines. The k-th line should contain a single integer – the number of igloos that are intersected by the k-th segment.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/16243.png )\n\nCentral Europe Regional Contest 2015 Problem I", "locale": "en", "translations": {"en": {"title": "[CERC2015] Ice Igloos", "background": "", "description": "A ﬁshing village built on the surface of a frozen lake far north in the arctic is endangered by global warming-fractures are starting to form on the lake surface. The village consists of n igloos of spherical shape, each occupying a circular area of the surface. \n\nAn igloo can be represented as a circle in the coordinate plane: the center of the circle is a point with integer coordinates, while the radius is a positive ﬂoating-point number less than 1 with exactly one fractional digit. \n\nGiven the locations of possible ice fractures, the villagers would like to know how many igloos are affected by each. Formally, given q queries where each query is a straight line segment deﬁned by the two endpoints, ﬁnd the number of igloos each segment intersects. A segment intersects an igloo if it has at least one point in common with the interior of the circle.", "inputFormat": "The ﬁrst line contains an integer n (1≤n≤100000) - the number of igloos. Each of the following n lines contains three numbers x, y and r – the coordinates of the center and the radius of one igloo. The coordinates x and y are integers such that 1≤ x, y≤500, while r is a ﬂoating-point number with exactly one fractional digit such that 0 < r < 1. No two igloos will intersect or touch. \n\nThe following line contains an integer q (1 ≤ q ≤ 100000) - the number of queries. Each of the following q linescontainsfourintegers x1, y1, x2, y2 (1≤ x1, y1, x2, y2 ≤500)-thecoordinatesofthe two endpoints of the segment. The two endpoints will be different. Endpoints may be inside igloos. \n\nYou may assume that, for every igloo i and the segment s, the square of the distance between s and the center of i is either less than r2−10−5 or greater than r2 +10−5 where r is the radius of the igloo i. ", "outputFormat": "Output should consist of q lines. The k-th line should contain a single integer – the number of igloos that are intersected by the k-th segment.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/16243.png )\n\nCentral Europe Regional Contest 2015 Problem I", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Ice Igloos", "background": "", "description": "给你$n$个圆$,m$条线段$,$求每条线段与多少圆相交\n\n$n,m\\le10^5,1\\le x_i,y_i\\le500,0\\lt r_i\\lt 1$", "inputFormat": "第一行一个整数$n$表示圆的个数\n\n接下来$n$行每行两个整数$x,y$和一个实数$r$表示圆心坐标和半径\n\n第$n+2$行一个整数$m$表示线段个数\n\n接下来$m$行每行四个整数$x1,y1,x2,y2$表示线段的两个端点$(x1,y1),(x2,y2)$", "outputFormat": "$m$行每行一个整数表示该条线段和多少圆相交\n\n\n感谢@Kelin 提供的翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4355", "type": "P", "difficulty": 3, "samples": [["4 \n5 6 7 7 \n1 3 2 3", "1 2 4 8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "Special Judge", "ICPC", "CERC"], "title": "[CERC2015] Kernel Knights", "background": "", "description": "Jousting is a medieval contest that involves people on horseback trying to strike each other with wooden lances while riding at high speed. A total of 2n knights have entered a jousting tournament – n knights from each of the two great rival houses. Upon arrival, each knight has challenged a single knight from the other house to a duel. \n\nA kernel is deﬁned as some subset S of knights with the following two properties:\n\n• No knight in S was challenged by another knight in S. \n\n• Every knight not in S was challenged by some knight in S.\n\nGiven the set of the challenges issued, ﬁnd one kernel. It is guaranteed that a kernel always exists.", "inputFormat": "The ﬁrst line contains an integer n (1 ≤ n ≤ 100000) – the number of knights of each house. The knights from the ﬁrst house are denoted with integers 1 through n, knights from the second house with integers n+1 through 2n. \n\nThe following line contains integers $f_1$, $f_2$,..., $f_n$ – the k-th integer fk is the index of the knight challenged by knight k $(n+1≤ f_k ≤2n)$. \n\nThe following line contains integers $s_1$,$s_2$,...,$s_n$ – the k-th integer sk is the index of the knight challenged by knight n+k $(1≤s_k ≤n)$. ", "outputFormat": "Output the indices of the knights in the kernel on a single line. If there is more than one solution, you may output any one.\n\nSPJ的格式校验较为严格，请在每个数字后面都输出一个空格，且在最后一个空格输出后请不要输出任何符号。", "hint": "Central Europe Regional Contest 2015 Problem K\n\n", "locale": "en", "translations": {"en": {"title": "[CERC2015] Kernel Knights", "background": "", "description": "Jousting is a medieval contest that involves people on horseback trying to strike each other with wooden lances while riding at high speed. A total of 2n knights have entered a jousting tournament – n knights from each of the two great rival houses. Upon arrival, each knight has challenged a single knight from the other house to a duel. \n\nA kernel is deﬁned as some subset S of knights with the following two properties:\n\n• No knight in S was challenged by another knight in S. \n\n• Every knight not in S was challenged by some knight in S.\n\nGiven the set of the challenges issued, ﬁnd one kernel. It is guaranteed that a kernel always exists.", "inputFormat": "The ﬁrst line contains an integer n (1 ≤ n ≤ 100000) – the number of knights of each house. The knights from the ﬁrst house are denoted with integers 1 through n, knights from the second house with integers n+1 through 2n. \n\nThe following line contains integers $f_1$, $f_2$,..., $f_n$ – the k-th integer fk is the index of the knight challenged by knight k $(n+1≤ f_k ≤2n)$. \n\nThe following line contains integers $s_1$,$s_2$,...,$s_n$ – the k-th integer sk is the index of the knight challenged by knight n+k $(1≤s_k ≤n)$. ", "outputFormat": "Output the indices of the knights in the kernel on a single line. If there is more than one solution, you may output any one.\n\nSPJ的格式校验较为严格，请在每个数字后面都输出一个空格，且在最后一个空格输出后请不要输出任何符号。", "hint": "Central Europe Regional Contest 2015 Problem K\n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Kernel Knights", "background": "", "description": "马上长矛比武是一种中世纪的比赛，参赛者骑在马上，用木制长矛高速冲刺，试图击中对方。共有 2n 名骑士参加了马上长矛比武比赛——来自两个伟大敌对家族的 n 名骑士。到达后，每位骑士向另一家族的一名骑士发起了挑战。\n\n一个“核”被定义为骑士的某个子集 S，具有以下两个特性：\n\n- S 中没有骑士被 S 中的其他骑士挑战。\n- 不在 S 中的每个骑士都被 S 中的某个骑士挑战。\n\n给定发出的挑战集，找到一个“核”。保证“核”总是存在。", "inputFormat": "第一行包含一个整数 n (1 ≤ n ≤ 100000)——每个家族的骑士数量。第一个家族的骑士用整数 1 到 n 表示，第二个家族的骑士用整数 n+1 到 2n 表示。\n\n接下来的行包含整数 $f_1$, $f_2$,..., $f_n$——第 k 个整数 $f_k$ 是骑士 k 挑战的骑士的编号 $(n+1 ≤ f_k ≤ 2n)$。\n\n接下来的行包含整数 $s_1$,$s_2$,...,$s_n$——第 k 个整数 $s_k$ 是骑士 n+k 挑战的骑士的编号 $(1 ≤ s_k ≤ n)$。", "outputFormat": "在一行中输出“核”中的骑士编号。如果有多个解，你可以输出其中任何一个。\n\nSPJ 的格式校验较为严格，请在每个数字后面都输出一个空格，且在最后一个空格输出后请不要输出任何符号。", "hint": "Central Europe Regional Contest 2015 Problem K。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4356", "type": "P", "difficulty": 7, "samples": [["6 9 \n..#####.. \n..#...#.. \n......#.. \n..#####.. \n..#...... \n..#...#.. \n5 \n1 4 \n5 4 \n1 -5 \n5 -5 \n-1000000000 0", "yes \nno \nno \nyes \nyes"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "CERC"], "title": "[CERC2015] Looping Labyrinth", "background": "", "description": "A labyrinth is obtained by tiling the entire plane with a pattern – a rectangular grid consisting of n rows and m columns where every cell is either empty or blocked. The result is an inﬁnite grid of cells with the pattern repeating in all four directions. \n\nFormally, suppose we denote both rows and columns of the inﬁnite grid with integers (including the negative integers). The row number increases as we move downwards in the grid, while the column number increases as we go to the right. The cell at coordinates (0,0) is called the origin. The labyrinth is obtained by copying the pattern (without mirroring or rotation) to every n-by-m rectangular area that, in the upper-left corner, has a cell with the row number divisible by n and the column number divisible by m. In particular, the upper-left corner of the pattern gets copied to the origin, while the lower-right corner gets copied to the cell with coordinates (n−1,m−1). \n\nTo escape the labyrinth starting from a particular cell, we need to reach the origin via a sequence of empty cells, going up, down, left or right in each step. \n\nYou are given a pattern and a sequence of possible starting cells. For each starting cell determine if it is possible to escape the labyrinth.", "inputFormat": "The ﬁrst line contains two integers n and m (1≤n, m≤100)–the number of rows and columns in the pattern, respectively. Each of the following n lines contains a string of exactly m characters describing one row of the pattern. The character # denotes a blocked cell while the dot character denotes an empty cell. The following line contains an integer q (1≤q≤200,000) – the number of starting cells. The k-th of the following q lines contains two integers r and c ($−10^9$ ≤ r, c ≤ $10^9$) – the row and column of the k-th starting cell. \n\nThe origin and all starting cells will be empty.\n", "outputFormat": "Output should consist of q lines. The k-th line should contain the word yes if it is possible to exit the labyrinth from the k-th starting cell and the word no otherwise.\n", "hint": "![](https://cdn.luogu.com.cn/upload/pic/16244.png )\n\nCentral Europe Regional Contest 2015 Problem L", "locale": "en", "translations": {"en": {"title": "[CERC2015] Looping Labyrinth", "background": "", "description": "A labyrinth is obtained by tiling the entire plane with a pattern – a rectangular grid consisting of n rows and m columns where every cell is either empty or blocked. The result is an inﬁnite grid of cells with the pattern repeating in all four directions. \n\nFormally, suppose we denote both rows and columns of the inﬁnite grid with integers (including the negative integers). The row number increases as we move downwards in the grid, while the column number increases as we go to the right. The cell at coordinates (0,0) is called the origin. The labyrinth is obtained by copying the pattern (without mirroring or rotation) to every n-by-m rectangular area that, in the upper-left corner, has a cell with the row number divisible by n and the column number divisible by m. In particular, the upper-left corner of the pattern gets copied to the origin, while the lower-right corner gets copied to the cell with coordinates (n−1,m−1). \n\nTo escape the labyrinth starting from a particular cell, we need to reach the origin via a sequence of empty cells, going up, down, left or right in each step. \n\nYou are given a pattern and a sequence of possible starting cells. For each starting cell determine if it is possible to escape the labyrinth.", "inputFormat": "The ﬁrst line contains two integers n and m (1≤n, m≤100)–the number of rows and columns in the pattern, respectively. Each of the following n lines contains a string of exactly m characters describing one row of the pattern. The character # denotes a blocked cell while the dot character denotes an empty cell. The following line contains an integer q (1≤q≤200,000) – the number of starting cells. The k-th of the following q lines contains two integers r and c ($−10^9$ ≤ r, c ≤ $10^9$) – the row and column of the k-th starting cell. \n\nThe origin and all starting cells will be empty.\n", "outputFormat": "Output should consist of q lines. The k-th line should contain the word yes if it is possible to exit the labyrinth from the k-th starting cell and the word no otherwise.\n", "hint": "![](https://cdn.luogu.com.cn/upload/pic/16244.png )\n\nCentral Europe Regional Contest 2015 Problem L", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Looping Labyrinth", "background": "", "description": "一个$n×m$的矩形，其中每格为路或墙，通过将图案平移来获得迷宫。迷宫是一个大小有限的坐标系，其图案在四个方向上重复。\n\n用整数（包括负整数）表示横纵坐标。向下行数增加，向右列数增加，坐标$(0,0)$处称为原点。特别地，图案的左上角在原点，而右下角在坐标$(n-1,m-1)$。\n\n原点是出口，为了从开始逃离迷宫，我们要从不同的起点到达原点，每一步可向上，下，左或右。对于每个起点，确定是否可以逃离迷宫。", "inputFormat": "第一行包含两个整数$n$和$m$（$1≤n$，$m≤100$）。\n\n以下每一行包含$m$个字符。“#”表示墙，“.”表示路。\n以下的一行包含整数$q$（$1≤q≤200000$）表示起点的数量。\n\n以下$q$行每行包含两个整数$r$和$c$（$-10^9≤r$，$c≤10^9$），表示每个起点的坐标。\n\n保证原点和所有起点为路。", "outputFormat": "输出$q$行。如果可以从当前起点逃出迷宫，则每行输出$yes$，否则输出$no$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4357", "type": "P", "difficulty": 6, "samples": [["10 5\n0 0\n0 1\n1 0\n1 1\n2 0\n2 1\n1 2\n0 2\n3 0\n3 1", "9"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "重庆", "各省省选", "旋转卡壳"], "title": "[CQOI2016] K 远点对", "background": "", "description": "已知平面内 $N$ 个点的坐标，求欧氏距离下的第 $K$ 远点对。\n\n两个点 $P(x_1,y_1)$ 和 $Q(x_2,y_2)$ 的欧氏距离定义为 $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$", "inputFormat": "输入文件第一行为用空格隔开的两个整数 $N,K$ 。\n\n接下来 $N$ 行，每行两个整数 $X,Y$ ，表示一个点的坐标。", "outputFormat": "输出文件第一行为一个整数，表示第 $K$ 远点对的距离的平方（一定是个整数）。", "hint": "对于 $100\\%$ 的测试点，$N \\le 100000,1 \\le K \\le 100,K \\le \\dfrac {N(N-1)}{2},0 \\le X,Y < 2^{31}$", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2016] K-th Farthest Pair", "background": "", "description": "Given the coordinates of $N$ points in the plane, find the $K$-th farthest pair under the Euclidean distance.\n\nThe Euclidean distance between two points $P(x_1,y_1)$ and $Q(x_2,y_2)$ is defined as $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$.", "inputFormat": "The first line contains two integers $N,K$ separated by a space.\n\nThe next $N$ lines each contain two integers $X,Y$, representing the coordinates of a point.", "outputFormat": "Output a single integer on the first line, which is the square of the distance of the $K$-th farthest pair (it is guaranteed to be an integer).", "hint": "For $100\\%$ of the testdata, $N \\le 100000,1 \\le K \\le 100,K \\le \\dfrac {N(N-1)}{2},0 \\le X,Y < 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2016] K 远点对", "background": "", "description": "已知平面内 $N$ 个点的坐标，求欧氏距离下的第 $K$ 远点对。\n\n两个点 $P(x_1,y_1)$ 和 $Q(x_2,y_2)$ 的欧氏距离定义为 $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$", "inputFormat": "输入文件第一行为用空格隔开的两个整数 $N,K$ 。\n\n接下来 $N$ 行，每行两个整数 $X,Y$ ，表示一个点的坐标。", "outputFormat": "输出文件第一行为一个整数，表示第 $K$ 远点对的距离的平方（一定是个整数）。", "hint": "对于 $100\\%$ 的测试点，$N \\le 100000,1 \\le K \\le 100,K \\le \\dfrac {N(N-1)}{2},0 \\le X,Y < 2^{31}$", "locale": "zh-CN"}}}
{"pid": "P4358", "type": "P", "difficulty": 6, "samples": [["3 187 45", "107 12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "重庆", "各省省选", "递归", "素数判断,质数,筛法", "逆元"], "title": "[CQOI2016] 密钥破解", "background": "", "description": "一种非对称加密算法的密钥生成过程如下：\n\n1.任选两个不同的质数$p,q$\n\n2.计算$N=p \\times q$，$r=(p-1)(q-1)$\n\n3.选取小于$r$，且与$r$互质的整数$e$\n\n4.计算整数$d$，使得$ed≡1(mod r)$\n\n5.二元组$(N,e)$称为公钥，二元组$(N,d)$称为私钥。\n\n当需要加密消息$n$时，（假设$n$是一个小于$N$的整数，因为任何格式的消息都可转为整数表示），使用公钥$(N,e)$，按照\n\n$$n^e≡c(mod N)$$\n\n运算，可得到密文$c$\n\n对密文$c$解密时，用私钥$(N,d)$，按照\n\n$$c^d≡n(mod N)$$\n\n运算，可得到原文 $n$。算法正确性证明省略。\n\n由于用公钥加密的密文仅能用对应的私钥解密，而不能用公钥解密，因此称为非对称加密算法。通常情况下，公钥由消息的接收方公开，而私钥由消息的接收方自己持有。这样任何发送消息的人都可以用公钥对消息加密，而只有消息的接收方自己能够解密消息。\n\n现在，你的任务是寻找一种可行的方法来破解这种加密算法，即根据公钥破解出私钥，并据此解密密文。", "inputFormat": "输入文件内容只有一行，为空格分隔的三个正整数$e,N,c$。", "outputFormat": "输出文件内容只有一行，为空格分隔的两个整数$d,n$。", "hint": "对于$30\\%$的数据，$e,N,c \\le 2^{20}$；\n\n对于$100\\%$的数据，$e,N,c \\le 2^{62},c<N$", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2016] Key Recovery", "background": "", "description": "The key generation process of an asymmetric encryption algorithm is as follows:\n\n1. Choose two distinct prime numbers $p, q$.\n2. Compute $N=p \\times q$, $r=(p-1)(q-1)$.\n3. Select an integer $e$ that is less than $r$ and coprime with $r$.\n4. Compute an integer $d$ such that $ed≡1(mod r)$.\n5. The ordered pair $(N,e)$ is called the public key, and the ordered pair $(N,d)$ is called the private key.\n\nWhen encrypting a message $n$ (assume $n$ is an integer less than $N$, because any format of message can be converted to an integer), use the public key $(N,e)$ and compute\n$$n^e≡c(mod N)$$\nto obtain the ciphertext $c$.\n\nTo decrypt the ciphertext $c$, use the private key $(N,d)$ and compute\n$$c^d≡n(mod N)$$\nto obtain the original plaintext $n$. The proof of correctness is omitted.\n\nBecause ciphertext encrypted with the public key can only be decrypted with the corresponding private key, and not with the public key itself, this is called an asymmetric encryption algorithm. Typically, the public key is published by the message receiver, while the private key is kept by the receiver. In this way, anyone can encrypt messages using the public key, but only the receiver can decrypt them.\n\nNow your task is to find a feasible method to crack this encryption algorithm: derive the private key from the public key and then use it to decrypt the ciphertext.", "inputFormat": "The input contains a single line with three positive integers $e, N, c$ separated by spaces.", "outputFormat": "Output a single line with two integers $d, n$ separated by a space.", "hint": "- For $30\\%$ of the testdata, $e, N, c \\le 2^{20}$.\n- For $100\\%$ of the testdata, $e, N, c \\le 2^{62}, c < N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2016] 密钥破解", "background": "", "description": "一种非对称加密算法的密钥生成过程如下：\n\n1.任选两个不同的质数$p,q$\n\n2.计算$N=p \\times q$，$r=(p-1)(q-1)$\n\n3.选取小于$r$，且与$r$互质的整数$e$\n\n4.计算整数$d$，使得$ed≡1(mod r)$\n\n5.二元组$(N,e)$称为公钥，二元组$(N,d)$称为私钥。\n\n当需要加密消息$n$时，（假设$n$是一个小于$N$的整数，因为任何格式的消息都可转为整数表示），使用公钥$(N,e)$，按照\n\n$$n^e≡c(mod N)$$\n\n运算，可得到密文$c$\n\n对密文$c$解密时，用私钥$(N,d)$，按照\n\n$$c^d≡n(mod N)$$\n\n运算，可得到原文 $n$。算法正确性证明省略。\n\n由于用公钥加密的密文仅能用对应的私钥解密，而不能用公钥解密，因此称为非对称加密算法。通常情况下，公钥由消息的接收方公开，而私钥由消息的接收方自己持有。这样任何发送消息的人都可以用公钥对消息加密，而只有消息的接收方自己能够解密消息。\n\n现在，你的任务是寻找一种可行的方法来破解这种加密算法，即根据公钥破解出私钥，并据此解密密文。", "inputFormat": "输入文件内容只有一行，为空格分隔的三个正整数$e,N,c$。", "outputFormat": "输出文件内容只有一行，为空格分隔的两个整数$d,n$。", "hint": "对于$30\\%$的数据，$e,N,c \\le 2^{20}$；\n\n对于$100\\%$的数据，$e,N,c \\le 2^{62},c<N$", "locale": "zh-CN"}}}
{"pid": "P4359", "type": "P", "difficulty": 6, "samples": [["12345 20", "9167"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "2016", "重庆", "各省省选", "可并堆", "素数判断,质数,筛法"], "title": "[CQOI2016] 伪光滑数", "background": "", "description": "若一个大于 $1$ 的整数 $M$ 的质因数分解有 $k$ 项，其最大的质因子为 $a_k$ ，并且满足 $a_{k}^{k} \\le N$，$a_k < 128$，我们就称整数 $M$ 为 $N$ - 伪光滑数。\n\n现在给出 $N$，求所有整数中，第 $K$ 大的 $N$ - 伪光滑数。\n\n### 题意澄清\n\n设 $M = 36 = 2^2 \\times 3^2$，则其对应的 $k = 4$，也就是说，对 $M$ 运用唯一分解定理，$M = \\prod_{i=1}^n{p_i^{c_i}}$，$k = \\sum_{i=1}^n{c_i}$。\n\n第 $K$ 大为字面意思，是真的从大到小第 $K$ 个。\n\nmodified by expect2004 2020-11-25，这或许是他退役前对洛谷公共题库的最后一次贡献", "inputFormat": "只有一行，为用空格隔开的整数 $N$ 和 $K$ 。", "outputFormat": "只有一行，为一个整数，表示答案。", "hint": "对于 $30\\%$ 的数据，$N \\le 10^6$；  \n对于 $100\\%$ 的数据，$2 \\le N \\le 10^{18},1 \\le K \\le 800000$。保证至少有 $K$ 个满足要求的数。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2016] Pseudo-smooth Numbers", "background": "", "description": "If a positive integer $M > 1$ has $k$ terms in its prime factorization, its largest prime factor is $a_k$, and it satisfies $a_k^k \\le N$, $a_k < 128$, then $M$ is called an $N$-pseudo-smooth number.\n\nGiven $N$, among all integers, find the $K$-th largest $N$-pseudo-smooth number.\n\nClarification: Let $M = 36 = 2^2 \\times 3^2$. Then the corresponding $k = 4$. That is, by the Fundamental Theorem of Arithmetic, write $M = \\prod_{i=1}^n p_i^{c_i}$ and $k = \\sum_{i=1}^n c_i$. “$K$-th largest” is literal: the $K$-th from largest to smallest.\n\nModified by expect2004 on 2020-11-25; this may be his last contribution to the Luogu public problem set before retirement.", "inputFormat": "One line with two space-separated integers $N$ and $K$.", "outputFormat": "One line containing a single integer, the answer.", "hint": "For $30\\%$ of the testdata, $N \\le 10^6$.  \nFor $100\\%$ of the testdata, $2 \\le N \\le 10^{18}, 1 \\le K \\le 800000$. It is guaranteed that there are at least $K$ numbers that satisfy the requirements.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2016] 伪光滑数", "background": "", "description": "若一个大于 $1$ 的整数 $M$ 的质因数分解有 $k$ 项，其最大的质因子为 $a_k$ ，并且满足 $a_{k}^{k} \\le N$，$a_k < 128$，我们就称整数 $M$ 为 $N$ - 伪光滑数。\n\n现在给出 $N$，求所有整数中，第 $K$ 大的 $N$ - 伪光滑数。\n\n### 题意澄清\n\n设 $M = 36 = 2^2 \\times 3^2$，则其对应的 $k = 4$，也就是说，对 $M$ 运用唯一分解定理，$M = \\prod_{i=1}^n{p_i^{c_i}}$，$k = \\sum_{i=1}^n{c_i}$。\n\n第 $K$ 大为字面意思，是真的从大到小第 $K$ 个。\n\nmodified by expect2004 2020-11-25，这或许是他退役前对洛谷公共题库的最后一次贡献", "inputFormat": "只有一行，为用空格隔开的整数 $N$ 和 $K$ 。", "outputFormat": "只有一行，为一个整数，表示答案。", "hint": "对于 $30\\%$ 的数据，$N \\le 10^6$；  \n对于 $100\\%$ 的数据，$2 \\le N \\le 10^{18},1 \\le K \\le 800000$。保证至少有 $K$ 个满足要求的数。", "locale": "zh-CN"}}}
{"pid": "P4360", "type": "P", "difficulty": 6, "samples": [["9 \n1 2 \n2 1 \n3 3 \n1 1 \n3 2 \n1 6 \n2 1 \n1 2 \n1 1\n", "26"]], "limits": {"time": [200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["模拟", "动态规划 DP", "2004", "单调队列", "CEOI（中欧）", "模拟退火", "斜率优化"], "title": "[CEOI 2004] 锯木厂选址", "background": null, "description": "从山顶上到山底下沿着一条直线种植了 $n$ 棵老树。当地的人们决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。\n\n木材只能朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建这两个锯木厂，使得运输的费用总和最小。假定运输每公斤木材每米需要一分钱。\n\n你的任务是编写一个程序，从输入文件中读入树的个数和他们的重量与位置，计算最小运输费用。", "inputFormat": "输入的第一行为一个正整数 $n$ ——树的个数 $(2\\leq n\\leq 20000)$。树从山顶到山脚按照 $1,2,\\dots,n$ 标号。 \n\n接下来 $n$ 行，每行有两个正整数（用空格分开）。 \n\n第 $i+1$ 行含有：$w_i$ ——第 $i$ 棵树的重量（公斤为单位）和 $d_i$——第 $i$ 棵树和第 $i+1$ 棵树之间的距离， $1\\leq w_i\\leq 10000,0\\leq d_i\\leq 10000$。 \n\n最后一颗树的 $d_n$，表示第 $n$ 棵树到山脚的锯木厂的距离。保证所有树运到山脚的锯木厂所需要的费用小于 $2\\times 10^9$ 分。", "outputFormat": "输出最小的运输费用。", "hint": "样例图示，黑点为锯木厂。\n\n![](https://cdn.luogu.com.cn/upload/pic/16339.png)\n\n本题共有 $13$ 个测试点，每个测试点的数据范围如下：\n\n测试点 $1\\sim 5$：$n\\leq 200$；\n\n测试点 $6\\sim7$：$n\\leq 1000$；\n\n测试点 $7\\sim13$：$2\\leq n\\leq 20000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2004] Sawmill Location", "background": "", "description": "Along a straight line from the mountain top to the foot, there are $n$ old trees. The locals have decided to cut them down. To avoid wasting any wood, once a tree is felled, the wood must be transported to a sawmill.\n\nLumber can only be transported downhill. There is one sawmill at the foot of the mountain. Two additional sawmills will be newly built along the mountain road. You must decide where to build these two sawmills so that the total transportation cost is minimized. Assume it costs one cent to transport $1$ kilogram by $1$ meter.\n\nYour task is to write a program that reads the number of trees and their weights and positions from the input, and computes the minimal transportation cost.", "inputFormat": "The first line contains a positive integer $n$ — the number of trees ($2 \\le n \\le 20000$). Trees are numbered $1, 2, \\dots, n$ from the mountain top down to the foot.\n\nEach of the next $n$ lines contains two integers separated by a space.\n\nThe $(i+1)$-th line contains $w_i$ — the weight of the $i$-th tree (in kilograms), and $d_i$ — the distance between the $i$-th and the $(i+1)$-th tree, with $1 \\le w_i \\le 10000$, $0 \\le d_i \\le 10000$.\n\nFor the last tree, $d_n$ denotes the distance from tree $n$ to the sawmill at the foot of the mountain. It is guaranteed that the total cost of transporting all trees to the sawmill at the foot of the mountain is less than $2 \\times 10^9$ cents.", "outputFormat": "Output the minimal transportation cost.", "hint": "The sample illustration; black dots represent sawmills.\n\n![](https://cdn.luogu.com.cn/upload/pic/16339.png)\n\nConstraints:\n- Test points $1$–$5$: $n \\le 200$.\n- Test points $6$–$7$: $n \\le 1000$.\n- Test points $7$–$13$: $2 \\le n \\le 20000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2004] 锯木厂选址", "background": null, "description": "从山顶上到山底下沿着一条直线种植了 $n$ 棵老树。当地的人们决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。\n\n木材只能朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建这两个锯木厂，使得运输的费用总和最小。假定运输每公斤木材每米需要一分钱。\n\n你的任务是编写一个程序，从输入文件中读入树的个数和他们的重量与位置，计算最小运输费用。", "inputFormat": "输入的第一行为一个正整数 $n$ ——树的个数 $(2\\leq n\\leq 20000)$。树从山顶到山脚按照 $1,2,\\dots,n$ 标号。 \n\n接下来 $n$ 行，每行有两个正整数（用空格分开）。 \n\n第 $i+1$ 行含有：$w_i$ ——第 $i$ 棵树的重量（公斤为单位）和 $d_i$——第 $i$ 棵树和第 $i+1$ 棵树之间的距离， $1\\leq w_i\\leq 10000,0\\leq d_i\\leq 10000$。 \n\n最后一颗树的 $d_n$，表示第 $n$ 棵树到山脚的锯木厂的距离。保证所有树运到山脚的锯木厂所需要的费用小于 $2\\times 10^9$ 分。", "outputFormat": "输出最小的运输费用。", "hint": "样例图示，黑点为锯木厂。\n\n![](https://cdn.luogu.com.cn/upload/pic/16339.png)\n\n本题共有 $13$ 个测试点，每个测试点的数据范围如下：\n\n测试点 $1\\sim 5$：$n\\leq 200$；\n\n测试点 $6\\sim7$：$n\\leq 1000$；\n\n测试点 $7\\sim13$：$2\\leq n\\leq 20000$。", "locale": "zh-CN"}}}
{"pid": "P4361", "type": "P", "difficulty": 6, "samples": [["0 2 1 0\n2\n0 4 3 1 1 1\n4 0 0 -4 1 1", "1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2015", "各省省选", "上海"], "title": "[SHOI2015] 激光发生器", "background": "", "description": "曾经发明了超能粒子炮・改的发明家 SHTSC 又公开了他的新发明：激光发生器——一种可以产生高能激光的神秘装置。\n\n激光发生器从正上方看是一个无穷大的平面，里面由一个定向激光发射装置和若干个激光偏转装置组成。一个激光发生器的示例如图所示，细箭头表示定向激光发射装置，粗线段表示激光偏转装置。\n\n![](https://cdn.luogu.com.cn/upload/pic/16401.png)\n\n由定向激光发射装置发射出的激光可以看成是一条射线，如果遇到激光偏转装置就会发生偏转。奇特的是，SHTSC 所使用的激光偏转装置并非像传统的镜子那样遵循反射定律，而是对于每个激光偏转装置，有一个固定的偏转系数 $λ$，其出射角 $β$ 与入射角 $α$ 的关系为 $β=λα$，并且能在这一过程中增强激光的能量。\n\n![](https://cdn.luogu.com.cn/upload/pic/16402.png)\n\n注意：\n\n1. 入射角是入射光线和反射平面法向量的夹角。\n2. 偏转装置的两面均可偏转。\n3. 如果激光平行射入偏转装置，则认为没有发生偏转。\n4. 如果不平行且照射到了端点，则认为发生偏转。\n5. 当 $β>\\frac{1}{2}π$ 时，可能会偏转到另一面。\n\n现在 SHTSC 希望你模拟他所设计的激光发生器的工作过程，来帮助他计算激光究竟被哪些激光偏转装置所偏转。", "inputFormat": "第一行四个整数 $x,y,dx,dy$。表示定向激光发射装置的位置是 $(x,y)$，方向是 $(dx,dy)$。\n\n第二行一个整数 $n$，表示一共有 $n$ 个激光偏转装置。\n以下n行，每行六个整数 $x1,y1,x2,y2,a,b$，表示一个激光偏转装置是 $(x1,y1)$ 到 $(x2,y2)$ 的一条线段，其偏转系数 $\\lambda=a/b$。\n\n$n\\leq 100$，所有坐标与 $a$ 和 $b$ 的绝对值不超过 $1000$，$a$、$b$ 均非 $0$。保证所有的偏转装置没有交点。激光发射起始点不在任何偏转装置上。方向向量不为零向量。", "outputFormat": "一行由空格隔开的若干个整数，表示激光依次照射到的激光偏转装置的编号（按照输入顺序从 $1$ 到 $n$ 编号）。如果激光被偏转超过 $10$ 次，则只需输出前 $10$ 次所照射到的偏转装置的编号。特别地，如果激光没有被任何一个偏转装置所偏转，输出 `NONE`。", "hint": "### 样例解释\n\n如图所示，激光依次被 $1$ 号和 $2$ 号偏转装置偏转。\n\n![](https://cdn.luogu.com.cn/upload/pic/16403.png)\n\n## 数据规模和约定\n\n对于 $10\\%$ 的数据，$n=1$；  \n对于 $40\\%$ 的数据，$a=b=1$；  \n对于 $100\\%$ 的数据，$n \\le 100$，所有坐标与 $a$ 和 $b$ 的绝对值不超过 $1000$，$a,b$ 均非零，$dx$ 、$dy$ 不同时为零。保证所有的偏转装置没有交点，且激光发射起始点不在任何偏转装置上。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2015] Laser Generator", "background": "", "description": "Having once invented the Super Particle Cannon · Modified, the inventor SHTSC has now unveiled his new invention: the Laser Generator — a mysterious device that can produce high-energy lasers.\n\nFrom a top-down view, the Laser Generator is an infinite plane containing one directional laser emitter and several laser deflection devices. An example is shown in the figure: the thin arrow denotes the directional laser emitter, and the thick segments denote the laser deflection devices.\n\n![](https://cdn.luogu.com.cn/upload/pic/16401.png)\n\nThe laser emitted by the directional emitter can be regarded as a ray. When it encounters a deflection device, it will be deflected. Interestingly, the deflection devices used by SHTSC do not obey the law of reflection like traditional mirrors. For each deflection device, there is a fixed deflection coefficient $λ$, and the relation between the exit angle $β$ and the incident angle $α$ is $β=λα$. The device can also amplify the laser’s energy in the process.\n\n![](https://cdn.luogu.com.cn/upload/pic/16402.png)\n\nNotes:\n1. The incident angle is the angle between the incident ray and the normal vector of the deflection plane.\n2. Both sides of a deflection device can deflect.\n3. If the laser is incident parallel to a deflection device, we consider that no deflection occurs.\n4. If it is not parallel and hits an endpoint, we consider that a deflection occurs.\n5. When $β>\\frac{1}{2}π$, it may be deflected to the other side.\n\nNow SHTSC hopes you will simulate the operation of his Laser Generator to help compute which deflection devices the laser is deflected by.", "inputFormat": "The first line contains four integers $x, y, dx, dy$, indicating that the directional laser emitter is at $(x, y)$ and points in direction $(dx, dy)$.\n\nThe second line contains an integer $n$, the number of laser deflection devices.\nThe next $n$ lines each contain six integers $x1, y1, x2, y2, a, b$, describing one deflection device as the segment from $(x1, y1)$ to $(x2, y2)$ with deflection coefficient $\\lambda=a/b$.", "outputFormat": "Output one line with a sequence of integers separated by spaces, indicating the indices of the deflection devices the laser hits in order (devices are numbered from $1$ to $n$ in input order). If the laser is deflected more than $10$ times, output only the indices of the first $10$ devices hit. In particular, if the laser is not deflected by any device, output `NONE`.", "hint": "### Sample Explanation\n\nAs shown in the figure, the laser is deflected by device $1$ and then device $2$ in order.\n\n![](https://cdn.luogu.com.cn/upload/pic/16403.png)\n\n# Constraints\n\n- For $10\\%$ of the testdata, $n=1$.\n- For $40\\%$ of the testdata, $a=b=1$.\n- For $100\\%$ of the testdata, $n \\le 100$; the absolute values of all coordinates and of $a$ and $b$ do not exceed $1000$; $a$ and $b$ are nonzero; $dx$ and $dy$ are not both zero. It is guaranteed that no two deflection devices intersect, and the starting point of the laser emitter is not on any deflection device.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2015] 激光发生器", "background": "", "description": "曾经发明了超能粒子炮・改的发明家 SHTSC 又公开了他的新发明：激光发生器——一种可以产生高能激光的神秘装置。\n\n激光发生器从正上方看是一个无穷大的平面，里面由一个定向激光发射装置和若干个激光偏转装置组成。一个激光发生器的示例如图所示，细箭头表示定向激光发射装置，粗线段表示激光偏转装置。\n\n![](https://cdn.luogu.com.cn/upload/pic/16401.png)\n\n由定向激光发射装置发射出的激光可以看成是一条射线，如果遇到激光偏转装置就会发生偏转。奇特的是，SHTSC 所使用的激光偏转装置并非像传统的镜子那样遵循反射定律，而是对于每个激光偏转装置，有一个固定的偏转系数 $λ$，其出射角 $β$ 与入射角 $α$ 的关系为 $β=λα$，并且能在这一过程中增强激光的能量。\n\n![](https://cdn.luogu.com.cn/upload/pic/16402.png)\n\n注意：\n\n1. 入射角是入射光线和反射平面法向量的夹角。\n2. 偏转装置的两面均可偏转。\n3. 如果激光平行射入偏转装置，则认为没有发生偏转。\n4. 如果不平行且照射到了端点，则认为发生偏转。\n5. 当 $β>\\frac{1}{2}π$ 时，可能会偏转到另一面。\n\n现在 SHTSC 希望你模拟他所设计的激光发生器的工作过程，来帮助他计算激光究竟被哪些激光偏转装置所偏转。", "inputFormat": "第一行四个整数 $x,y,dx,dy$。表示定向激光发射装置的位置是 $(x,y)$，方向是 $(dx,dy)$。\n\n第二行一个整数 $n$，表示一共有 $n$ 个激光偏转装置。\n以下n行，每行六个整数 $x1,y1,x2,y2,a,b$，表示一个激光偏转装置是 $(x1,y1)$ 到 $(x2,y2)$ 的一条线段，其偏转系数 $\\lambda=a/b$。\n\n$n\\leq 100$，所有坐标与 $a$ 和 $b$ 的绝对值不超过 $1000$，$a$、$b$ 均非 $0$。保证所有的偏转装置没有交点。激光发射起始点不在任何偏转装置上。方向向量不为零向量。", "outputFormat": "一行由空格隔开的若干个整数，表示激光依次照射到的激光偏转装置的编号（按照输入顺序从 $1$ 到 $n$ 编号）。如果激光被偏转超过 $10$ 次，则只需输出前 $10$ 次所照射到的偏转装置的编号。特别地，如果激光没有被任何一个偏转装置所偏转，输出 `NONE`。", "hint": "### 样例解释\n\n如图所示，激光依次被 $1$ 号和 $2$ 号偏转装置偏转。\n\n![](https://cdn.luogu.com.cn/upload/pic/16403.png)\n\n## 数据规模和约定\n\n对于 $10\\%$ 的数据，$n=1$；  \n对于 $40\\%$ 的数据，$a=b=1$；  \n对于 $100\\%$ 的数据，$n \\le 100$，所有坐标与 $a$ 和 $b$ 的绝对值不超过 $1000$，$a,b$ 均非零，$dx$ 、$dy$ 不同时为零。保证所有的偏转装置没有交点，且激光发射起始点不在任何偏转装置上。", "locale": "zh-CN"}}}
{"pid": "P4362", "type": "P", "difficulty": 5, "samples": [["8 2 4 \n1 2 20 \n1 3 4 \n1 4 13 \n2 5 10 \n2 6 12 \n3 7 15 \n3 8 5 ", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2002", "NOI", "树形 DP"], "title": "[NOI2002] 贪吃的九头龙", "background": "传说中的九头龙是一种特别贪吃的动物。虽然名字叫“九头龙”，但这只是说它出生的时候有九个头，而在成长的过程中，它有时会长出很多的新头，头的总数会远大于九，当然也会有旧头因衰老而自己脱落。", "description": "有一天，有 $M$ 个脑袋的九头龙看到一棵长有 $N$ 个果子的果树，喜出望外，恨不得一口把它全部吃掉。可是必须照顾到每个头，因此它需要把 $N$ 个果子分成 $M$ 组，每组至少有一个果子，让每个头吃一组。\n\n这 $M$ 个脑袋中有一个最大，称为“大头”，是众头之首，它要吃掉恰好 $K$ 个果子，而且 $K$ 个果子中理所当然地应该包括唯一的一个最大的果子。果子由 $N-1$ 根树枝连接起来，由于果树是一个整体，因此可以从任意一个果子出发沿着树枝“走到”任何一个其他的果子。\n\n对于每段树枝，如果它所连接的两个果子需要由不同的头来吃掉，那么两个头会共同把树枝弄断而把果子分开；如果这两个果子是由同一个头来吃掉，那么这个头会懒得把它弄断而直接把果子连同树枝一起吃掉。当然，吃树枝并不是很舒服的，因此每段树枝都有一个吃下去的“难受值”，而九头龙的难受值就是所有头吃掉的树枝的“难受值”之和。\n\n九头龙希望它的“难受值”尽量小，你能帮它算算吗？\n\n例如图 $1$ 所示的例子中，果树包含 $8$ 个果子，$7$ 段树枝，各段树枝的“难受值”标记在了树枝的旁边。九头龙有两个脑袋，大头需要吃掉 $4$ 个果子，其中必须包含最大的果子。即 $N=8$，$M=2$，$K=4$：\n\n![](https://cdn.luogu.com.cn/upload/pic/16595.png )\n\n图一描述了果树的形态，图二描述了最优策略。", "inputFormat": "输入的第 $1$ 行包含三个整数 $N$，$M$，$K$。$N$ 个果子依次编号 $1,2, \\cdots N$，且最大的果子的编号总是 $1$。\n\n第 $2$ 行到第 $N$ 行描述了果树的形态，每行包含三个整数 $a,b,c$，表示存在一段难受值为 $c$ 的树枝连接果子 $a$ 和果子 $b$。", "outputFormat": "输出仅有一行，包含一个整数，表示在满足“大头”的要求 的前提下，九头龙的难受值的最小值。如果无法满足要求，输出 $-1$。", "hint": "该样例对应于题目描述中的例子。 \n\n【数据范围】\n  \n对于 $100\\%$ 的数据，有  $\\ 1 \\le N \\le 300\\ ,2 \\le M \\le N,1 \\le K \\le N,\\ 1 \\le {a,b} \\le N,\\ 0 \\le c \\le 10^5$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2002] The Gluttonous Nine-Headed Dragon", "background": "The legendary nine-headed dragon is especially gluttonous. Although it is called a “nine-headed dragon,” that only refers to the fact that it is born with nine heads. During its growth, it may grow many new heads, so the total number of heads can be much larger than nine, and of course some old heads may fall off due to aging.", "description": "One day, a nine-headed dragon with $M$ heads sees a fruit tree bearing $N$ fruits. Delighted, it wishes it could eat them all in one bite. However, it must treat each head fairly, so it needs to divide the $N$ fruits into $M$ groups, with at least one fruit in each group, and let each head eat one group.\n\nAmong these $M$ heads, there is a largest head, called the “Big Head,” which is the leader of the heads. It must eat exactly $K$ fruits, and those $K$ fruits must, of course, include the unique largest fruit. The $N$ fruits are connected by $N-1$ branches. Since the fruit tree is a single connected whole, one can “walk” from any fruit to any other fruit along the branches.\n\nFor each branch, if the two fruits it connects are to be eaten by different heads, then the two heads will break the branch to separate the fruits. If the two fruits are to be eaten by the same head, then that head will be too lazy to break it and will eat the fruits together with the branch. Eating branches is uncomfortable, so each branch has a “discomfort value,” and the dragon’s total discomfort is the sum of the “discomfort values” of all branches that are eaten by the heads.\n\nThe dragon wants to minimize its total discomfort. Can you help it compute the minimum?\n\nFor example, in the instance shown in Figure 1, the fruit tree has $8$ fruits and $7$ branches, with each branch’s “discomfort value” labeled next to it. The dragon has two heads, and the Big Head must eat $4$ fruits, which must include the largest fruit. That is, $N = 8$, $M = 2$, $K = 4$:\n\n![](https://cdn.luogu.com.cn/upload/pic/16595.png )\n\nFigure 1 illustrates the shape of the fruit tree, and Figure 2 illustrates the optimal strategy.", "inputFormat": "The first line contains three integers $N$, $M$, $K$. The $N$ fruits are numbered $1, 2, \\cdots, N$, and the largest fruit is always numbered $1$.\n\nLines $2$ through $N$ describe the structure of the fruit tree. Each line contains three integers $a, b, c$, indicating that there is a branch with discomfort value $c$ connecting fruits $a$ and $b$.", "outputFormat": "Output a single line containing one integer, the minimum possible total discomfort while satisfying the Big Head’s requirement. If it is impossible to meet the requirement, output $-1$.", "hint": "This sample corresponds to the example in the problem statement.\n\nConstraints\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 300$, $2 \\le M \\le N$, $1 \\le K \\le N$, $1 \\le a, b \\le N$, $0 \\le c \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2002] 贪吃的九头龙", "background": "传说中的九头龙是一种特别贪吃的动物。虽然名字叫“九头龙”，但这只是说它出生的时候有九个头，而在成长的过程中，它有时会长出很多的新头，头的总数会远大于九，当然也会有旧头因衰老而自己脱落。", "description": "有一天，有 $M$ 个脑袋的九头龙看到一棵长有 $N$ 个果子的果树，喜出望外，恨不得一口把它全部吃掉。可是必须照顾到每个头，因此它需要把 $N$ 个果子分成 $M$ 组，每组至少有一个果子，让每个头吃一组。\n\n这 $M$ 个脑袋中有一个最大，称为“大头”，是众头之首，它要吃掉恰好 $K$ 个果子，而且 $K$ 个果子中理所当然地应该包括唯一的一个最大的果子。果子由 $N-1$ 根树枝连接起来，由于果树是一个整体，因此可以从任意一个果子出发沿着树枝“走到”任何一个其他的果子。\n\n对于每段树枝，如果它所连接的两个果子需要由不同的头来吃掉，那么两个头会共同把树枝弄断而把果子分开；如果这两个果子是由同一个头来吃掉，那么这个头会懒得把它弄断而直接把果子连同树枝一起吃掉。当然，吃树枝并不是很舒服的，因此每段树枝都有一个吃下去的“难受值”，而九头龙的难受值就是所有头吃掉的树枝的“难受值”之和。\n\n九头龙希望它的“难受值”尽量小，你能帮它算算吗？\n\n例如图 $1$ 所示的例子中，果树包含 $8$ 个果子，$7$ 段树枝，各段树枝的“难受值”标记在了树枝的旁边。九头龙有两个脑袋，大头需要吃掉 $4$ 个果子，其中必须包含最大的果子。即 $N=8$，$M=2$，$K=4$：\n\n![](https://cdn.luogu.com.cn/upload/pic/16595.png )\n\n图一描述了果树的形态，图二描述了最优策略。", "inputFormat": "输入的第 $1$ 行包含三个整数 $N$，$M$，$K$。$N$ 个果子依次编号 $1,2, \\cdots N$，且最大的果子的编号总是 $1$。\n\n第 $2$ 行到第 $N$ 行描述了果树的形态，每行包含三个整数 $a,b,c$，表示存在一段难受值为 $c$ 的树枝连接果子 $a$ 和果子 $b$。", "outputFormat": "输出仅有一行，包含一个整数，表示在满足“大头”的要求 的前提下，九头龙的难受值的最小值。如果无法满足要求，输出 $-1$。", "hint": "该样例对应于题目描述中的例子。 \n\n【数据范围】\n  \n对于 $100\\%$ 的数据，有  $\\ 1 \\le N \\le 300\\ ,2 \\le M \\le N,1 \\le K \\le N,\\ 1 \\le {a,b} \\le N,\\ 0 \\le c \\le 10^5$ 。", "locale": "zh-CN"}}}
{"pid": "P4363", "type": "P", "difficulty": 6, "samples": [["2 3\n2 7 3\n9 1 2\n3 7 2\n2 3 1\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "2018", "各省省选", "轮廓线 DP", "状压 DP"], "title": "[九省联考 2018] 一双木棋 chess", "background": "", "description": "菲菲和牛牛在一块 $n$ 行 $m$ 列的棋盘上下棋，菲菲执黑棋先手，牛牛执白棋后手。\n\n棋局开始时，棋盘上没有任何棋子，两人轮流在格子上落子，直到填满棋盘时结束。  \n\n落子的规则是：一个格子可以落子当且仅当这个格子内没有棋子且这个格子的左侧及上方的所有格子内都有棋子。\n\n棋盘的每个格子上，都写有两个非负整数，从上到下第 $i$ 行中从左到右第 $j$ 列的格子上的两个整数记作 $a_{i,j}$ 和 $b_{i,j}$。\n\n在游戏结束后，菲菲和牛牛会分别计算自己的得分：菲菲的得分是所有有黑棋的格子上的 $a_{i,j}$ 之和，牛牛的得分是所有有白棋的格子上的 $b_{i,j}$ 的和。\n\n菲菲和牛牛都希望，自己的得分减去对方的得分得到的结果最大。现在他们想知道，在给定的棋盘上，如果双方都采用最优策略且知道对方会采用最优策略，那么，最终的结果如何？\n", "inputFormat": "第一行有两个整数，分别表示棋盘的行数 $n$ 和列数 $m$。  \n第 $2$ 到第 $(n + 1)$ 行，每行 $m$ 个整数，第 $(i + 1)$ 行的第 $j$ 个整数表示 $a_{i, j}$。  \n第 $(n + 2)$ 到第 $(2n + 1)$ 行，每行 $m$ 个整数，第 $(n + i + 1)$ 行的第 $j$ 个整数表示 $b_{i, j}$。", "outputFormat": "输出一行一个整数，表示菲菲的得分减去牛牛的得分的结果。", "hint": "### 样例 1 说明\n\n![](https://cdn.luogu.com.cn/upload/pic/16877.png)\n\n棋盘如图所示，双方都采用最优策略时，棋局如下：\n\n- 菲菲下在第 $1$ 行第 $1$ 列（这是第一步时唯一可以落子的格子）。\n- 牛牛下在第 $1$ 行第 $2$ 列。\n- 菲菲下在第 $2$ 行第 $1$ 列。\n- 牛牛下在第 $1$ 行第 $3$ 列。\n- 菲菲下在第 $2$ 行第 $2$ 列。\n- 牛牛下在第 $2$ 行第 $3$ 列（这是这一步时唯一可以落子的格子）。\n- 填满棋盘，游戏结束。\n\n盘面如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/16878.png)\n\n菲菲的得分为 $2 + 9 + 1 = 12$，牛牛的得分为 $7 + 2 + 1 = 10$。\n\n### 数据规模与约定\n\n各测试点信息如下表。\n\n![](https://cdn.luogu.com.cn/upload/pic/16879.png)\n\n- 对于编号为奇数的测试点，保证 $b_{i, j} = 0$。\n- 对于全部的测试点，保证 $1 \\leq n, m \\leq 10$，$0 \\leq a_{i, j}, b_{i, j} \\leq 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Nine-Province Joint Exam 2018] Double Wooden Chess (chess)", "background": "", "description": "Feifei and Niuniu play on an $n$ by $m$ board. Feifei plays black and goes first, Niuniu plays white and goes second.\n\nAt the start, the board is empty. They alternately place pieces on cells until the board is completely filled.\n\nThe placement rule is: a cell can be chosen if and only if the cell is empty and all cells to its left in the same row and all cells above it in the same column already contain pieces.\n\nEach cell of the board has two nonnegative integers written on it. For the cell in row $i$ (from top to bottom) and column $j$ (from left to right), the two integers are denoted by $a_{i, j}$ and $b_{i, j}$.\n\nAfter the game ends, Feifei’s score is the sum of $a_{i, j}$ over all cells with a black piece, and Niuniu’s score is the sum of $b_{i, j}$ over all cells with a white piece.\n\nBoth players want to maximize the result of their own score minus the opponent’s score. They would like to know, on the given board, if both sides play optimally and know the other will also play optimally, what is the final result.", "inputFormat": "The first line contains two integers, the numbers of rows $n$ and columns $m$ of the board.  \nLines $2$ through $(n + 1)$ each contain $m$ integers; on line $(i + 1)$, the $j$-th integer is $a_{i, j}$.  \nLines $(n + 2)$ through $(2n + 1)$ each contain $m$ integers; on line $(n + i + 1)$, the $j$-th integer is $b_{i, j}$.", "outputFormat": "Output a single integer, the value of Feifei’s score minus Niuniu’s score.", "hint": "### Sample 1 Explanation\n\n![](https://cdn.luogu.com.cn/upload/pic/16877.png)\n\nThe board is as shown. Under optimal play, the game proceeds as follows:\n\n- Feifei plays at row $1$, column $1$ (this is the only legal move on the first turn).\n- Niuniu plays at row $1$, column $2$.\n- Feifei plays at row $2$, column $1$.\n- Niuniu plays at row $1$, column $3$.\n- Feifei plays at row $2$, column $2$.\n- Niuniu plays at row $2$, column $3$ (this is the only legal move on this turn).\n- The board is filled, and the game ends.\n\nThe final position is:\n\n![](https://cdn.luogu.com.cn/upload/pic/16878.png)\n\nFeifei’s score is $2 + 9 + 1 = 12$, and Niuniu’s score is $7 + 2 + 1 = 10$.\n\n### Constraints\n\nThe information for each test point is shown in the table below.\n\n![](https://cdn.luogu.com.cn/upload/pic/16879.png)\n\n- For test points with odd indices, it is guaranteed that $b_{i, j} = 0$.\n- For all test points, it is guaranteed that $1 \\leq n, m \\leq 10$ and $0 \\leq a_{i, j}, b_{i, j} \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[九省联考 2018] 一双木棋 chess", "background": "", "description": "菲菲和牛牛在一块 $n$ 行 $m$ 列的棋盘上下棋，菲菲执黑棋先手，牛牛执白棋后手。\n\n棋局开始时，棋盘上没有任何棋子，两人轮流在格子上落子，直到填满棋盘时结束。  \n\n落子的规则是：一个格子可以落子当且仅当这个格子内没有棋子且这个格子的左侧及上方的所有格子内都有棋子。\n\n棋盘的每个格子上，都写有两个非负整数，从上到下第 $i$ 行中从左到右第 $j$ 列的格子上的两个整数记作 $a_{i,j}$ 和 $b_{i,j}$。\n\n在游戏结束后，菲菲和牛牛会分别计算自己的得分：菲菲的得分是所有有黑棋的格子上的 $a_{i,j}$ 之和，牛牛的得分是所有有白棋的格子上的 $b_{i,j}$ 的和。\n\n菲菲和牛牛都希望，自己的得分减去对方的得分得到的结果最大。现在他们想知道，在给定的棋盘上，如果双方都采用最优策略且知道对方会采用最优策略，那么，最终的结果如何？\n", "inputFormat": "第一行有两个整数，分别表示棋盘的行数 $n$ 和列数 $m$。  \n第 $2$ 到第 $(n + 1)$ 行，每行 $m$ 个整数，第 $(i + 1)$ 行的第 $j$ 个整数表示 $a_{i, j}$。  \n第 $(n + 2)$ 到第 $(2n + 1)$ 行，每行 $m$ 个整数，第 $(n + i + 1)$ 行的第 $j$ 个整数表示 $b_{i, j}$。", "outputFormat": "输出一行一个整数，表示菲菲的得分减去牛牛的得分的结果。", "hint": "### 样例 1 说明\n\n![](https://cdn.luogu.com.cn/upload/pic/16877.png)\n\n棋盘如图所示，双方都采用最优策略时，棋局如下：\n\n- 菲菲下在第 $1$ 行第 $1$ 列（这是第一步时唯一可以落子的格子）。\n- 牛牛下在第 $1$ 行第 $2$ 列。\n- 菲菲下在第 $2$ 行第 $1$ 列。\n- 牛牛下在第 $1$ 行第 $3$ 列。\n- 菲菲下在第 $2$ 行第 $2$ 列。\n- 牛牛下在第 $2$ 行第 $3$ 列（这是这一步时唯一可以落子的格子）。\n- 填满棋盘，游戏结束。\n\n盘面如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/16878.png)\n\n菲菲的得分为 $2 + 9 + 1 = 12$，牛牛的得分为 $7 + 2 + 1 = 10$。\n\n### 数据规模与约定\n\n各测试点信息如下表。\n\n![](https://cdn.luogu.com.cn/upload/pic/16879.png)\n\n- 对于编号为奇数的测试点，保证 $b_{i, j} = 0$。\n- 对于全部的测试点，保证 $1 \\leq n, m \\leq 10$，$0 \\leq a_{i, j}, b_{i, j} \\leq 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P4364", "type": "P", "difficulty": 6, "samples": [["4 2.0\n114 514 1919 810", "114 810 514 1919"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2018", "线段树", "各省省选", "排序"], "title": "[九省联考 2018] IIIDX", "background": "Osu 听过没？那是 Konano 最喜欢的一款音乐游戏，而他的梦想就是有一天自己也能做个独特酷炫的音乐游戏。现在，他在世界知名游戏公司 KONMAI 内工作，离他的梦想也越来越近了。\n\n这款音乐游戏内一般都包含了许多歌曲，歌曲越多，玩家越不易玩腻。同时，为了使玩家在游戏上~~氪更多的金钱~~花更多的时间，游戏一开始一般都不会将所有曲目公开，有些曲目你需要通关某首特定歌曲才会解锁，而且越晚解锁的曲目难度越高。", "description": "这一天，Konano 接到了一个任务，他需要给正在制作中的游戏《IIIDX》安排曲目的解锁顺序。游戏内共有 $n$ 首曲目，每首曲目都会有一个难度 $d$，游戏内第 $i$ 首曲目会在玩家 Pass 第 $\\left\\lfloor \\frac i k \\right\\rfloor$ 首曲目后解锁（$\\left\\lfloor x \\right\\rfloor$ 为下取整符号）若 $\\left\\lfloor \\frac i k \\right\\rfloor = 0$，则说明这首曲目**无需解锁**。\n\n举个例子：当 $k = 2$ 时，第 $1$ 首曲目是无需解锁的（$\\left\\lfloor \\frac 12 \\right\\rfloor = 0$），第 $7$ 首曲目需要玩家 Pass 第 $\\left\\lfloor \\frac 72 \\right\\rfloor = 3$ 首曲目才会被解锁。\n\nKonano 的工作，便是安排这些曲目的顺序，使得每次解锁出的曲子的难度**不低于**作为条件需要玩家通关的曲子的难度，即使得确定顺序后的曲目的难度对于每个 $i$ 满足 $d_i \\geq d_{\\left\\lfloor \\frac ik \\right\\rfloor}$。\n\n当然这难不倒曾经在信息学竞赛摸鱼许久的 Konano。那假如是你，你会怎么解决这份任务呢？", "inputFormat": "第 $1$ 行 $1$ 个正整数 $n$ 和 $1$ 个小数 $k,n$ 表示曲目数量，$k$ 其含义如题所示。\n\n第 $2$ 行 $n$ 个用空格隔开的正整数 $d$，表示这 $n$ 首曲目的难度。", "outputFormat": "输出 $1$ 行 $n$ 个整数，按顺序输出安排完曲目顺序后第 $i$ 首曲目的难度。\n\n若有多解，则输出 $d_1$ **最大**的；若仍有多解，则输出 $d_2$ **最大**的，以此类推。", "hint": "| 测试点编号 | $n$ | $k$ | $d$ | 特殊限制 |\n|-|-|-|-|-|\n| $1$ | $1 \\leq n \\leq 10$ | $k=2$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $2$ | $1 \\leq n \\leq 10$ | $k=3$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $3$ | $1 \\leq n \\leq 10$ | $k=1.1$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $4$ | $1 \\leq n \\leq 10$ | $k=n$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $5$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $6$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $7$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $8$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 无 |\n| $9$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $10$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 无 |\n| $11$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $12$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $13$ | $1\\leq n\\leq 500000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 无 |\n| $14$ | $1\\leq n\\leq 500000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 无 |\n| $15$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $16$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $17$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $18$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $19$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $20$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |", "locale": "zh-CN", "translations": {"en": {"title": "[Nine-Province Joint Exam 2018] IIIDX", "background": "Have you heard of Osu? That is Konano’s favorite rhythm game, and his dream is to make a unique and cool music game of his own someday. Now he works at the world-renowned game company KONMAI, getting closer to his dream.\n\nA music game usually contains many songs; the more songs, the less likely players get bored. Meanwhile, to make players spend ~~more money~~ more time on the game, not all tracks are available from the beginning. Some tracks are unlocked only after you clear a specific track, and the later a track is unlocked, the higher its difficulty tends to be.", "description": "Konano received a task to arrange the unlock order of tracks for the in-development game “IIIDX.” There are $n$ tracks in total. Each track has a difficulty $d$. The $i$-th track is unlocked after the player clears the $\\left\\lfloor \\frac i k \\right\\rfloor$-th track ($\\left\\lfloor x \\right\\rfloor$ is the floor function). If $\\left\\lfloor \\frac i k \\right\\rfloor = 0$, then this track requires no unlock.\n\nFor example, when $k = 2$, the $1$-st track requires no unlock ($\\left\\lfloor \\frac 1 2 \\right\\rfloor = 0$), and the $7$-th track is unlocked after the player clears the $3$-rd track since $\\left\\lfloor \\frac 7 2 \\right\\rfloor = 3$.\n\nKonano’s job is to arrange the order of these tracks so that each newly unlocked track has a difficulty not lower than the prerequisite track’s difficulty. That is, after determining the order, the difficulties satisfy $d_i \\geq d_{\\left\\lfloor \\frac i k \\right\\rfloor}$ for every $i$.\n\nOf course, this is easy for Konano, who has spent a lot of time “chilling” in informatics competitions. If it were you, how would you solve this task?", "inputFormat": "The first line contains one positive integer $n$ and one real number $k$. $n$ is the number of tracks, and $k$ is as described above.\n\nThe second line contains $n$ space-separated positive integers $d$, representing the difficulties of the $n$ tracks.", "outputFormat": "Output one line with $n$ integers: the difficulty of the $i$-th track after arranging the order.\n\nIf there are multiple valid solutions, output the one with $d_1$ maximized; if still tied, maximize $d_2$; and so on.", "hint": "| Test point ID | $n$ | $k$ | $d$ | Special constraints |\n|-|-|-|-|-|\n| $1$ | $1 \\leq n \\leq 10$ | $k=2$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $2$ | $1 \\leq n \\leq 10$ | $k=3$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $3$ | $1 \\leq n \\leq 10$ | $k=1.1$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $4$ | $1 \\leq n \\leq 10$ | $k=n$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $5$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $6$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $7$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | All $d_i$ are distinct |\n| $8$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | None |\n| $9$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | All $d_i$ are distinct |\n| $10$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | None |\n| $11$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | All $d_i$ are distinct |\n| $12$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | None |\n| $13$ | $1\\leq n\\leq 500000$ | $k=2$ | $1\\leq d\\leq 10^9$ | None |\n| $14$ | $1\\leq n\\leq 500000$ | $k=3$ | $1\\leq d\\leq 10^9$ | None |\n| $15$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | All $d_i$ are distinct |\n| $16$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | All $d_i$ are distinct |\n| $17$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | None |\n| $18$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | None |\n| $19$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | None |\n| $20$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | None |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[九省联考 2018] IIIDX", "background": "Osu 听过没？那是 Konano 最喜欢的一款音乐游戏，而他的梦想就是有一天自己也能做个独特酷炫的音乐游戏。现在，他在世界知名游戏公司 KONMAI 内工作，离他的梦想也越来越近了。\n\n这款音乐游戏内一般都包含了许多歌曲，歌曲越多，玩家越不易玩腻。同时，为了使玩家在游戏上~~氪更多的金钱~~花更多的时间，游戏一开始一般都不会将所有曲目公开，有些曲目你需要通关某首特定歌曲才会解锁，而且越晚解锁的曲目难度越高。", "description": "这一天，Konano 接到了一个任务，他需要给正在制作中的游戏《IIIDX》安排曲目的解锁顺序。游戏内共有 $n$ 首曲目，每首曲目都会有一个难度 $d$，游戏内第 $i$ 首曲目会在玩家 Pass 第 $\\left\\lfloor \\frac i k \\right\\rfloor$ 首曲目后解锁（$\\left\\lfloor x \\right\\rfloor$ 为下取整符号）若 $\\left\\lfloor \\frac i k \\right\\rfloor = 0$，则说明这首曲目**无需解锁**。\n\n举个例子：当 $k = 2$ 时，第 $1$ 首曲目是无需解锁的（$\\left\\lfloor \\frac 12 \\right\\rfloor = 0$），第 $7$ 首曲目需要玩家 Pass 第 $\\left\\lfloor \\frac 72 \\right\\rfloor = 3$ 首曲目才会被解锁。\n\nKonano 的工作，便是安排这些曲目的顺序，使得每次解锁出的曲子的难度**不低于**作为条件需要玩家通关的曲子的难度，即使得确定顺序后的曲目的难度对于每个 $i$ 满足 $d_i \\geq d_{\\left\\lfloor \\frac ik \\right\\rfloor}$。\n\n当然这难不倒曾经在信息学竞赛摸鱼许久的 Konano。那假如是你，你会怎么解决这份任务呢？", "inputFormat": "第 $1$ 行 $1$ 个正整数 $n$ 和 $1$ 个小数 $k,n$ 表示曲目数量，$k$ 其含义如题所示。\n\n第 $2$ 行 $n$ 个用空格隔开的正整数 $d$，表示这 $n$ 首曲目的难度。", "outputFormat": "输出 $1$ 行 $n$ 个整数，按顺序输出安排完曲目顺序后第 $i$ 首曲目的难度。\n\n若有多解，则输出 $d_1$ **最大**的；若仍有多解，则输出 $d_2$ **最大**的，以此类推。", "hint": "| 测试点编号 | $n$ | $k$ | $d$ | 特殊限制 |\n|-|-|-|-|-|\n| $1$ | $1 \\leq n \\leq 10$ | $k=2$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $2$ | $1 \\leq n \\leq 10$ | $k=3$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $3$ | $1 \\leq n \\leq 10$ | $k=1.1$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $4$ | $1 \\leq n \\leq 10$ | $k=n$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $5$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $6$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $7$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $8$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 无 |\n| $9$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $10$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 无 |\n| $11$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $12$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $13$ | $1\\leq n\\leq 500000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 无 |\n| $14$ | $1\\leq n\\leq 500000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 无 |\n| $15$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $16$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $17$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $18$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $19$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $20$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |", "locale": "zh-CN"}}}
{"pid": "P4365", "type": "P", "difficulty": 7, "samples": [["5 3 3\n2 1 1 2 3\n1 2\n2 3\n1 4\n1 5", "11"], ["10 2 3\n2 1 1 3 1 2 3 3 1 3\n1 2\n2 3\n2 4\n2 5\n2 6\n5 7\n1 8\n8 9\n1 10", "435"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["动态规划 DP", "2018", "线段树", "各省省选", "枚举", "背包 DP"], "title": "[九省联考 2018] 秘密袭击 coat", "background": "> We could have had it all. . . . . .\n>\n> 我们本该，拥有一切\n>\n> Counting on a tree. . . . . .\n>\n> 何至于此，数数树上\n\nCounting on a Tree（CoaT）即是本题的英文名称。", "description": "Access Globe 最近正在玩一款战略游戏。在游戏中，他操控的角色是一名 C 国士兵。他的任务就是服从指挥官的指令参加战斗，并在战斗中取胜。\n\nC 国即将向 D 国发动一场秘密袭击。作战计划是这样的：选择 D 国的 $s$ 个城市，派出 C 国战绩最高的 $s$ 个士兵分别秘密潜入这些城市。每个城市都有一个危险程度 $d_i$。\n\nC 国指挥官会派遣战绩最高的士兵潜入所选择的城市中危险程度最高的城市，派遣战绩第二高的士兵潜入所选择的城市中危险程度次高的城市，以此类推（即派遣战绩第 $i$ 高的士兵潜入所选择城市中危险程度第 $i$ 高的城市）。D 国有 $n$ 个城市，$n - 1$ 条双向道路连接着这些城市，使得这些城市两两之间都可以互相到达。为了任务执行顺利，C 国选出的 $s$ 个城市中，任意两个所选的城市，都可以不经过未被选择的城市互相到达。\n\nAccess Globe 操控的士兵的战绩是第 $k$ 高，他希望能估计出最终自己潜入的城市的危险程度。Access Globe 假设 C 国是以等概率选出任意满足条件的城市集合 $S$，他希望你帮他求出所有可能的城市集合中，Access Globe 操控的士兵潜入城市的危险程度之和。如果选择的城市不足 $k$ 个，那么Access Globe 不会被派出，这种情况下危险程度为 $0$。\n\n当然，你并不想帮他解决这个问题，你也不打算告诉他这个值除以 $998\\,244\\,353$ 的余数，你只打算告诉他这个值除以 $64\\,123$ 的余数。", "inputFormat": "第 $1$ 行包含 $3$ 个整数 $n,k,W$，表示 D 国城市的个数，Access Globe 所操控士兵潜入的城市战绩排名以及 D 国的所有城市中最大的危险程度；\n\n第 $2$ 行包含 $n$ 个 $1$ 到 $W$ 之间的整数 $d_1, d_2, \\ldots, d_n$，表示每个城市的危险程度；\n\n第 $3$ 行到第 $n + 1$ 行，每行两个整数 $x_i, y_i$，表示 D 国存在一条连接城市 $x_i$ 和城市 $y_i$ 的双向道路。", "outputFormat": "输出一个整数，表示所有可行的城市集合中，Access Globe 操控的士兵潜入城市的危险程度之和除以 $64\\,123$ 的余数。", "hint": "D 国地图如下，其中危险程度为 $d$ 的城市的形状是 $d + 3$ 边形。\n\n![](https://cdn.luogu.com.cn/upload/pic/16888.png)\n\n以下是所有符合条件且选择的城市不少于 $3$ 个的方案：\n\n- 选择城市 $1,2,3$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,4$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,5$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 选择城市 $1,2,4$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,5$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 选择城市 $1,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 而在选择的城市少于 $3$ 时，Access Globe 的士兵潜入的城市危险程度均为 $0$。\n\n所以你应该输出 $(1 + 1 + 1 + 2 + 1 + 1 + 2 + 2) \\bmod 64\\,123 = 11$。\n\n![](https://cdn.luogu.com.cn/upload/pic/16889.png)", "locale": "zh-CN", "translations": {"en": {"title": "[Nine-Province Joint Exam 2018] Secret Raid coat", "background": "> We could have had it all. . . . . .\n>\n> 我们本该，拥有一切\n>\n> Counting on a tree. . . . . .\n>\n> 何至于此，数数树上\n\nCounting on a Tree (CoaT) is the English name of this problem.", "description": "Access Globe is playing a strategy game. In the game, he controls a soldier from country C. His mission is to follow the commander’s orders to join battles and win.\n\nCountry C is about to launch a secret raid on country D. The battle plan is: choose $s$ cities in country D, and send the $s$ top-performing soldiers of country C to secretly infiltrate these cities, one soldier per city. Each city has a danger level $d_i$.\n\nThe commander of country C will send the best-performing soldier to the most dangerous city among the chosen cities, the second-best to the second most dangerous city, and so on (that is, the soldier with the $i$-th highest record goes to the city with the $i$-th highest danger level among the chosen cities). Country D has $n$ cities, with $n - 1$ bidirectional roads connecting them, so that every pair of cities is mutually reachable. To ensure smooth execution, among the $s$ chosen cities, any two chosen cities can reach each other without passing through any unchosen city.\n\nAccess Globe controls the soldier with the $k$-th highest record, and he wants to estimate the danger level of the city he will eventually infiltrate. He assumes country C chooses any set $S$ of cities that satisfies the conditions uniformly at random. He wants you to compute, over all possible city sets, the sum of the danger levels of the city that Access Globe’s soldier will infiltrate. If fewer than $k$ cities are chosen, Access Globe will not be dispatched; in this case the danger level is $0$.\n\nOf course, you do not want to solve this problem for him, and you are not going to tell him the remainder modulo $998\\,244\\,353$. You will only tell him the remainder modulo $64\\,123$.", "inputFormat": "The first line contains $3$ integers $n, k, W$, denoting the number of cities in country D, the rank of the city that Access Globe’s soldier will infiltrate, and the maximum danger level among all cities in country D.\n\nThe second line contains $n$ integers between $1$ and $W$, $d_1, d_2, \\ldots, d_n$, denoting the danger level of each city.\n\nLines $3$ through $n + 1$ each contain two integers $x_i, y_i$, indicating that there is a bidirectional road between cities $x_i$ and $y_i$ in country D.", "outputFormat": "Output a single integer: the remainder modulo $64\\,123$ of the sum, over all feasible city sets, of the danger level of the city that Access Globe’s soldier will infiltrate.", "hint": "Country D’s map is shown below. A city with danger level $d$ is drawn as a $(d + 3)$-gon.\n\n![](https://cdn.luogu.com.cn/upload/pic/16888.png)\n\nAll valid choices with at least $3$ selected cities are:\n\n- Choose cities $1, 2, 3$; the danger level for Access Globe’s soldier is $1$.\n- Choose cities $1, 2, 3, 4$; the danger level is $1$.\n- Choose cities $1, 2, 3, 5$; the danger level is $1$.\n- Choose cities $1, 2, 3, 4, 5$; the danger level is $2$.\n- Choose cities $1, 2, 4$; the danger level is $1$.\n- Choose cities $1, 2, 5$; the danger level is $1$.\n- Choose cities $1, 2, 4, 5$; the danger level is $2$.\n- Choose cities $1, 4, 5$; the danger level is $2$.\n- When fewer than $3$ cities are chosen, the danger level is $0$.\n\nTherefore you should output $(1 + 1 + 1 + 2 + 1 + 1 + 2 + 2) \\bmod 64\\,123 = 11$.\n\n![](https://cdn.luogu.com.cn/upload/pic/16889.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[九省联考 2018] 秘密袭击 coat", "background": "> We could have had it all. . . . . .\n>\n> 我们本该，拥有一切\n>\n> Counting on a tree. . . . . .\n>\n> 何至于此，数数树上\n\nCounting on a Tree（CoaT）即是本题的英文名称。", "description": "Access Globe 最近正在玩一款战略游戏。在游戏中，他操控的角色是一名 C 国士兵。他的任务就是服从指挥官的指令参加战斗，并在战斗中取胜。\n\nC 国即将向 D 国发动一场秘密袭击。作战计划是这样的：选择 D 国的 $s$ 个城市，派出 C 国战绩最高的 $s$ 个士兵分别秘密潜入这些城市。每个城市都有一个危险程度 $d_i$。\n\nC 国指挥官会派遣战绩最高的士兵潜入所选择的城市中危险程度最高的城市，派遣战绩第二高的士兵潜入所选择的城市中危险程度次高的城市，以此类推（即派遣战绩第 $i$ 高的士兵潜入所选择城市中危险程度第 $i$ 高的城市）。D 国有 $n$ 个城市，$n - 1$ 条双向道路连接着这些城市，使得这些城市两两之间都可以互相到达。为了任务执行顺利，C 国选出的 $s$ 个城市中，任意两个所选的城市，都可以不经过未被选择的城市互相到达。\n\nAccess Globe 操控的士兵的战绩是第 $k$ 高，他希望能估计出最终自己潜入的城市的危险程度。Access Globe 假设 C 国是以等概率选出任意满足条件的城市集合 $S$，他希望你帮他求出所有可能的城市集合中，Access Globe 操控的士兵潜入城市的危险程度之和。如果选择的城市不足 $k$ 个，那么Access Globe 不会被派出，这种情况下危险程度为 $0$。\n\n当然，你并不想帮他解决这个问题，你也不打算告诉他这个值除以 $998\\,244\\,353$ 的余数，你只打算告诉他这个值除以 $64\\,123$ 的余数。", "inputFormat": "第 $1$ 行包含 $3$ 个整数 $n,k,W$，表示 D 国城市的个数，Access Globe 所操控士兵潜入的城市战绩排名以及 D 国的所有城市中最大的危险程度；\n\n第 $2$ 行包含 $n$ 个 $1$ 到 $W$ 之间的整数 $d_1, d_2, \\ldots, d_n$，表示每个城市的危险程度；\n\n第 $3$ 行到第 $n + 1$ 行，每行两个整数 $x_i, y_i$，表示 D 国存在一条连接城市 $x_i$ 和城市 $y_i$ 的双向道路。", "outputFormat": "输出一个整数，表示所有可行的城市集合中，Access Globe 操控的士兵潜入城市的危险程度之和除以 $64\\,123$ 的余数。", "hint": "D 国地图如下，其中危险程度为 $d$ 的城市的形状是 $d + 3$ 边形。\n\n![](https://cdn.luogu.com.cn/upload/pic/16888.png)\n\n以下是所有符合条件且选择的城市不少于 $3$ 个的方案：\n\n- 选择城市 $1,2,3$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,4$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,5$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 选择城市 $1,2,4$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,5$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 选择城市 $1,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 而在选择的城市少于 $3$ 时，Access Globe 的士兵潜入的城市危险程度均为 $0$。\n\n所以你应该输出 $(1 + 1 + 1 + 2 + 1 + 1 + 2 + 2) \\bmod 64\\,123 = 11$。\n\n![](https://cdn.luogu.com.cn/upload/pic/16889.png)", "locale": "zh-CN"}}}
{"pid": "P4366", "type": "P", "difficulty": 5, "samples": [["4 2 1\n1 3 1\n2 4 4\n1 4", "5"], ["7 2 10\n1 3 1\n2 4 4\n3 6", "34"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论建模", "最短路", "进制", "Code+"], "title": "[Code+#4] 最短路", "background": "在北纬 91°，有一个神奇的国度，叫做企鹅国。这里的企鹅也有自己发达的文明，称为企鹅文明。因为企鹅只有黑白两种颜色，所以他们的数学也是以二进制为基础发展的。\n\n比如早在 $11101001$ 年前，他们就有了异或这样一个数学概念。如果你不知道异或是什么，请出门过墙左转到[这里](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96)。\n\n再比如早在 $1000010$ 年前，他们的大科学家 Penguin. Tu 就提出了[图](https://zh.wikipedia.org/wiki/%E5%9B%BE_%28%E6%95%B0%E5%AD%A6%29#%E6%9C%89/%E7%84%A1_%E5%90%91%E5%9B%BE)和[最短路径](https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98)这样一些概念。", "description": "企鹅国中有 $N$ 座城市，编号从 $1$ 到 $N$。\n\n对于任意的两座城市 $i$ 和 $j$，企鹅们可以花费 $(i~\\mathrm{xor}~j) \\times C$ 的时间从城市 $i$ 走到城市 $j$，这里 $C$ 为一个给定的常数。\n\n当然除此之外还有 $M$ 条单向的快捷通道，第 $i$ 条快捷通道从第 $F_i$​​ 个城市通向第 $T_i$​​ 个城市，走这条通道需要消耗 $V_i$​​ 的时间。\n\n现在来自 **P**enguin **K**ingdom **U**niversity 的企鹅豆豆正在考虑从城市 $A$ 前往城市 $B$ 最少需要多少时间？", "inputFormat": "从标准输入读入数据。\n\n输入第一行包含三个整数 $N,M,C$ $(1 \\leq C \\leq 100)$，表示企鹅国城市的个数、快捷通道的个数以及题面中提到的给定的常数 $C$。\n\n接下来的 $M$ 行，每行三个正整数 $F_i,T_i,V_i$​ ($1 \\leq F_i \\leq N$,$1 \\leq T_i \\leq N ,1\\leq V_i \\leq 100$)，分别表示对应通道的起点城市标号、终点城市标号和通过这条通道需要消耗的时间。\n\n最后一行两个正整数 $A,B$，表示企鹅豆豆选择的起点城市标号和终点城市标号。", "outputFormat": "输出到标准输出。\n\n输出一行一个整数，表示从城市 $A$ 前往城市 $B$ 需要的最少时间。", "hint": "**样例 1 解释**\n\n直接从 $1$ 走到 $4$ 就好了。\n\n**样例 2 解释**\n\n先从 $3$ 走到 $2$ ，再从 $2$ 通过通道到达 $4$ ，再从 $4$ 走到 $6$。\n\n![0](https://cdn.luogu.com.cn/upload/pic/16868.png)\n\n活泼可爱的出题人给大家留下了下面这张图。\n\n![1](https://i.loli.net/2018/04/02/5ac1bb2333c22.jpg)\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Shortest Path", "background": "At latitude 91° N, there is a magical country called the Penguin Kingdom. The penguins here have their own advanced civilization, known as the Penguin Civilization. Since penguins are only black and white, their mathematics is also based on binary.\n\nFor example, as early as $11101001$ years ago, they had the mathematical concept of XOR. If you do not know what XOR is, please go out, turn left, and head over to [here](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96).\n\nAlso, as early as $1000010$ years ago, their great scientist Penguin. Tu proposed concepts such as [graph](https://zh.wikipedia.org/wiki/%E5%9B%BE_%28%E6%95%B0%E5%AD%A6%29#%E6%9C%89/%E7%84%A1_%E5%90%91%E5%9B%BE) and [shortest path](https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98).", "description": "There are $N$ cities in the Penguin Kingdom, numbered from $1$ to $N$.\n\nFor any two cities $i$ and $j$, penguins can spend $(i~\\mathrm{xor}~j) \\times C$ time to travel from city $i$ to city $j$, where $C$ is a given constant.\n\nIn addition, there are $M$ one-way express channels. The $i$-th express channel goes from city $F_i$ to city $T_i$, and taking this channel costs $V_i$ time.\n\nNow a penguin named Doudou from **P**enguin **K**ingdom **U**niversity is considering the minimum time needed to travel from city $A$ to city $B$.", "inputFormat": "Read from standard input.\n\nThe first line of input contains three integers $N,M,C$ $(1 \\leq C \\leq 100)$, representing the number of cities, the number of express channels, and the given constant $C$ mentioned in the statement.\n\nThe next $M$ lines each contain three positive integers $F_i,T_i,V_i$ ($1 \\leq F_i \\leq N$, $1 \\leq T_i \\leq N, 1 \\leq V_i \\leq 100$), representing the start city, the end city, and the time cost of taking this channel, respectively.\n\nThe last line contains two positive integers $A,B$, representing the start city and the end city chosen by Doudou.", "outputFormat": "Output to standard output.\n\nOutput one line with a single integer, the minimum time required to travel from city $A$ to city $B$.", "hint": "Sample 1 explanation.\n\nIt is optimal to go directly from $1$ to $4$.\n\nSample 2 explanation.\n\nFirst go from $3$ to $2$, then take the channel from $2$ to $4$, and finally go from $4$ to $6$.\n\n![0](https://cdn.luogu.com.cn/upload/pic/16868.png)\n\nThe lively and lovely problem setter left everyone the picture below.\n\n![1](https://i.loli.net/2018/04/02/5ac1bb2333c22.jpg)\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] 最短路", "background": "在北纬 91°，有一个神奇的国度，叫做企鹅国。这里的企鹅也有自己发达的文明，称为企鹅文明。因为企鹅只有黑白两种颜色，所以他们的数学也是以二进制为基础发展的。\n\n比如早在 $11101001$ 年前，他们就有了异或这样一个数学概念。如果你不知道异或是什么，请出门过墙左转到[这里](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96)。\n\n再比如早在 $1000010$ 年前，他们的大科学家 Penguin. Tu 就提出了[图](https://zh.wikipedia.org/wiki/%E5%9B%BE_%28%E6%95%B0%E5%AD%A6%29#%E6%9C%89/%E7%84%A1_%E5%90%91%E5%9B%BE)和[最短路径](https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98)这样一些概念。", "description": "企鹅国中有 $N$ 座城市，编号从 $1$ 到 $N$。\n\n对于任意的两座城市 $i$ 和 $j$，企鹅们可以花费 $(i~\\mathrm{xor}~j) \\times C$ 的时间从城市 $i$ 走到城市 $j$，这里 $C$ 为一个给定的常数。\n\n当然除此之外还有 $M$ 条单向的快捷通道，第 $i$ 条快捷通道从第 $F_i$​​ 个城市通向第 $T_i$​​ 个城市，走这条通道需要消耗 $V_i$​​ 的时间。\n\n现在来自 **P**enguin **K**ingdom **U**niversity 的企鹅豆豆正在考虑从城市 $A$ 前往城市 $B$ 最少需要多少时间？", "inputFormat": "从标准输入读入数据。\n\n输入第一行包含三个整数 $N,M,C$ $(1 \\leq C \\leq 100)$，表示企鹅国城市的个数、快捷通道的个数以及题面中提到的给定的常数 $C$。\n\n接下来的 $M$ 行，每行三个正整数 $F_i,T_i,V_i$​ ($1 \\leq F_i \\leq N$,$1 \\leq T_i \\leq N ,1\\leq V_i \\leq 100$)，分别表示对应通道的起点城市标号、终点城市标号和通过这条通道需要消耗的时间。\n\n最后一行两个正整数 $A,B$，表示企鹅豆豆选择的起点城市标号和终点城市标号。", "outputFormat": "输出到标准输出。\n\n输出一行一个整数，表示从城市 $A$ 前往城市 $B$ 需要的最少时间。", "hint": "**样例 1 解释**\n\n直接从 $1$ 走到 $4$ 就好了。\n\n**样例 2 解释**\n\n先从 $3$ 走到 $2$ ，再从 $2$ 通过通道到达 $4$ ，再从 $4$ 走到 $6$。\n\n![0](https://cdn.luogu.com.cn/upload/pic/16868.png)\n\n活泼可爱的出题人给大家留下了下面这张图。\n\n![1](https://i.loli.net/2018/04/02/5ac1bb2333c22.jpg)\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN"}}}
{"pid": "P4367", "type": "P", "difficulty": 7, "samples": [["5 4\n2 1 2 1\n1 1 1\n1 2 3 4\n1 2 2\n-8 -1 6\n4 -3 7\n-7 5 5\n-7 5 -5", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "斜率优化", "凸包", "Code+"], "title": "[Code+#4] Tommy 的结合", "background": "深邃的天空仿佛要吞噬一切，一场 Codeforces 比赛刚刚结束。“怎么还不理我……”，睡眼惺忪的 Tommy 拿起盖在一旁的手机。空空荡荡的 QQ 提示框，没有一丝的温度。Tommy 叹了口气。昏黄的灯发出微弱的光芒，抚摸着呼呼作响的电脑。\n\n桌面上堆满了写满 $\\partial$ 和 $\\int$ 的草稿纸，手机闪光灯自制的简易台灯发出刺眼的白光；灯火缱绻，映照一双如画倦容。十几个 DDL 就在附近，QQ 那边的人已经三天三夜没有合眼了。这是 Tommy 所不知道的事。", "description": "人生大概就是这样。在这物欲横流的红尘紫陌中，芸芸众生为了生计四处奔走，交谈越来越少，感情越来越淡。但是，著名科学家 Access Globe 的最新研究成果可以解决这样的问题：通过增加同时做的事情来增加共同语言。\n\nA 和 B 都得到了一些任务，设他们要执行的任务集合分别为 $V_A$​​ 和 $V_B$​​。对每个人来说，任务 $1$ 是必须一开始做的，而其他的每个任务 $e$ 都存在一个前置任务 $p_e$​，表示任务 $e$ 必须在任务 $p_e$​​ 完成后才能执行。也就是说，每个人的任务的依赖关系构成了一棵**有根外向树**，一个任务 $e$ 能被执行当且仅当 $p_e,p_{p_{e}},\\cdots,1$ 这些任务全部都被执行，称 $p$ **依赖**任务 $p_e,p_{p_{e}},\\cdots,1$。\n\n现在，A 和 B 希望他们能有一些任务是共同完成的，因此他们决定这样选出一些任务：A 选出 $m$ 个任务 $a_1,\\cdots,a_m$​​，要求 $a_1=1$，并且对于任意的 $1\\le i<m$，都要求 $a_{i+1}$ 依赖任务$a_i$​​,同时 B 也选出 $m$ 个满足同样要求的任务 $b_1,\\cdots,b_m$​​，这样，A 就可以沿着从 $1$ 到 $A_m$​​ 的路径依次执行这些任务，同时 B 也可以沿着 $1$ 到 $B_m$​​ 的路径依次执行这些任务；并且经过安排，当 A 在执行任务 $a_i$​​ 的时候，B 恰好在执行任务 $b_i$​​，在这时 A 和 B 就能取得联系，增进感情。\n\n模型的目标为最大化亲密度。对于一组同时执行任务的关系 $a_i$​ 和 $b_i$，可以获得 $C_{a_i,b_i}$​​​​ 的得分；同时，A 和 B 一旦失去联系，就会使得亲密度降低，在每一分钟，如果一方距离上次和对方联系后已经执行任务 $i$ 分钟，就会使得亲密度降低 $2i-1$。\n\n例如，两个人要做的任务所花费的时间分别为 $2,1,4,7$ 和 $4,8,3,6,4$，并且共同完成了第一个任务和最后一个任务，那么 A 在执行中间两个任务的 $1+4=5$ 分钟没有和 B 联系，使得亲密度降低 $1+3+...+11=25$；同时 B 在执行中间三个任务的 $8+3+6=17$ 分钟没有和 A 联系，使得亲密度降低 $1+3+...+35=289$。注意，亲密度的计算只和任务执行的时间有关；并且任意两个任务都可以作为 $a_i$​​ 和 $b_i$​​ 同时执行，不需要保证它们花费的时间相同。\n\n现在，给出 A 和 B 的任务、依赖关系和每个任务的执行时间，请你帮我们求出能够获得的最大的亲密度。", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $|V_A|,|V_B|$；\n\n第二行 $|V_A|-1$ 个整数 $t^{(a)}_{2},t^{(a)}_{3},...,t^{(a)}_{|V_A|}$​​，表示 A 的每个任务的时间长度；\n\n第三行 $|V_B|-1$ 个整数 $t^{(b)}_{2},t^{(b)}_{3},...,t^{(b)}_{|V_B|}$，表示 B 的每个任务的时间长度；\n\n第四行 $|V_A|-1∣$ 个整数 $p^{(a)}_{2},p^{(a)}_{3},...,p^{(a)}_{|V_A|}$，表示 A 的每个任务的前置任务，保证 $p^{(a)}_{i}< i$；\n\n第五行 $|V_B|-1$ 个整数 $p^{(b)}_{2},p^{(b)}_{3},...,p^{(b)}_{|V_B|}$，表示 B 的每个任务的前置任务，保证 $p^{(b)}_{i}< i$；\n\n接下来 $|V_A|-1$ 行，每行 $|V_B|-1$ 个整数，第 $i-1$ 行第 $j-1$ 列为 $C_{i,j}$，表示 A 和 B 同时分别执行对应的任务 $i,j$ 能获得的亲密度，注意这些亲密度不一定是非负的；\n\n注意以上输入均不包括第 1 个任务的信息，因为它和亲密度的计算没有关系。\n", "outputFormat": "输出到标准输出。\n\n输出能获得的最大的亲密度。\n", "hint": "**样例解释**\n\nA 和 B 分别选出任务 $1,3,4$ 和 $1,2,3$，同时执行的任务对 $(1,1)$、$(3,2)$ 和 $(4,3)$ 使得他们获得了 $4+5=9$ 的亲密度；A 孤独地执行任务 $2$ 的 $2$ 分钟丢失了 $1+3=4$ 的亲密度，因此最终的总亲密度为 $9-4=5$。这就是亲密度最大的方案。\n\n![0](https://cdn.luogu.com.cn/upload/pic/16896.png)\n\n对于所有数据，$2\\le |V_A|,|V_B|\\le 2,666$，$1\\le t^{(a)}_i,t^{(b)}_i\\le 1,206$，$0\\le |C_{i,j}|\\le 2,017,011,328$。\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nCredit：idea 与命题/陈俊锟　验题/Tommy > <\n\nGit Repo：https://git.thusaac.org/publish/CodePlus4\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Tommy's Bonding", "background": "The deep sky seems to devour everything; a Codeforces contest has just ended. “Why are you still ignoring me...”, sleepy-eyed Tommy picks up the phone lying beside him. The empty QQ notification box carries no warmth. Tommy sighs. The dim lamp glows faintly, brushing over the humming computer.\n\nThe desk is piled with scratch paper full of $\\partial$ and $\\int$. The phone’s flashlight, a makeshift desk lamp, emits dazzling white light; the flickering lights reflect a painted, weary face. A dozen DDLs are around the corner, and the person on the other end of QQ hasn’t slept for three days and nights. This is what Tommy doesn’t know.", "description": "Life is probably like this. In this materialistic world, people hustle for a living, talk less and less, and grow more distant emotionally. However, the latest research by the renowned scientist Access Globe can solve this: increase the shared topics by increasing the things done simultaneously.\n\nA and B each receive some tasks. Let the sets of tasks they need to execute be $V_A$ and $V_B$, respectively. For each person, task $1$ must be done first, and each other task $e$ has a prerequisite task $p_e$, meaning task $e$ can be executed only after $p_e$ is completed. That is, the dependency of each person’s tasks forms a rooted directed tree whose edges point away from the root. A task $e$ can be executed if and only if all tasks $p_e, p_{p_e}, \\cdots, 1$ have been executed. We say task $e$ depends on tasks $p_e, p_{p_e}, \\cdots, 1$.\n\nNow, A and B hope to complete some tasks together, so they decide to select tasks as follows: A selects $m$ tasks $a_1, \\cdots, a_m$ with the requirements $a_1 = 1$ and, for any $1 \\le i < m$, task $a_{i+1}$ depends on $a_i$. Similarly, B selects $m$ tasks $b_1, \\cdots, b_m$ satisfying the same requirements. Then A can execute tasks along the path from $1$ to $a_m$ in order, and B can execute tasks along the path from $1$ to $b_m$ in order. Moreover, after scheduling, when A is executing task $a_i$, B is executing task $b_i$ at the same time. At such moments, A and B can get in touch and increase their intimacy.\n\nThe objective is to maximize the intimacy. For each pair of simultaneously executed tasks $a_i$ and $b_i$, they gain a score of $C_{a_i, b_i}$. Meanwhile, once A and B lose contact, their intimacy decreases: in each minute, if it is the $i$-th minute since one side last contacted the other, the intimacy decreases by $2i - 1$.\n\nFor example, suppose the times for the two people’s tasks are 2, 1, 4, 7 and 4, 8, 3, 6, 4, and they jointly complete only the first and the last tasks. Then A has 1 + 4 = 5 minutes without contact while executing the two middle tasks, which causes an intimacy decrease of $1 + 3 + \\cdots + 11 = 25$; B has 8 + 3 + 6 = 17 minutes without contact while executing the three middle tasks, which causes an intimacy decrease of $1 + 3 + \\cdots + 35 = 289$. Note that the intimacy calculation depends only on task execution times, and any two tasks can be executed simultaneously as $a_i$ and $b_i$; they need not take the same amount of time.\n\nGiven A’s and B’s tasks, dependencies, and the execution time of each task, please compute the maximum intimacy that can be achieved.", "inputFormat": "Read from standard input.\n\n- The first line contains two integers $|V_A|, |V_B|$.\n- The second line contains $|V_A| - 1$ integers $t^{(a)}_{2}, t^{(a)}_{3}, \\ldots, t^{(a)}_{|V_A|}$, the duration of each of A’s tasks.\n- The third line contains $|V_B| - 1$ integers $t^{(b)}_{2}, t^{(b)}_{3}, \\ldots, t^{(b)}_{|V_B|}$, the duration of each of B’s tasks.\n- The fourth line contains $|V_A| - 1$ integers $p^{(a)}_{2}, p^{(a)}_{3}, \\ldots, p^{(a)}_{|V_A|}$, the prerequisite of each of A’s tasks, with $p^{(a)}_{i} < i$ guaranteed.\n- The fifth line contains $|V_B| - 1$ integers $p^{(b)}_{2}, p^{(b)}_{3}, \\ldots, p^{(b)}_{|V_B|}$, the prerequisite of each of B’s tasks, with $p^{(b)}_{i} < i$ guaranteed.\n- Then follow $|V_A| - 1$ lines, each with $|V_B| - 1$ integers. In the $(i - 1)$-th row and $(j - 1)$-th column is $C_{i, j}$, the intimacy gained if A and B simultaneously execute tasks $i$ and $j$, respectively. Note that these intimacy scores are not necessarily nonnegative.\n\nNote: the above input does not include information for task $1$, because it is irrelevant to the intimacy calculation.", "outputFormat": "Output to standard output.\n\nPrint the maximum achievable intimacy.", "hint": "Sample explanation:\n\nA and B select tasks $1, 3, 4$ and $1, 2, 3$, respectively. The simultaneous pairs $(1, 1)$, $(3, 2)$, and $(4, 3)$ yield intimacy $4 + 5 = 9$. A executes task $2$ alone for 2 minutes and loses $1 + 3 = 4$ intimacy. Therefore, the final total intimacy is $9 - 4 = 5$. This is the optimal plan.\n\n![0](https://cdn.luogu.com.cn/upload/pic/16896.png)\n\nConstraints:\nFor all testdata, $2 \\le |V_A|, |V_B| \\le 2{,}666$, $1 \\le t^{(a)}_i, t^{(b)}_i \\le 1{,}206$, and $0 \\le |C_{i, j}| \\le 2{,}017{,}011{,}328$.\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nCredit: idea and problemsetting/Chen Junkun; problem verification/Tommy > <\n\nGit Repo: https://git.thusaac.org/publish/CodePlus4\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] Tommy 的结合", "background": "深邃的天空仿佛要吞噬一切，一场 Codeforces 比赛刚刚结束。“怎么还不理我……”，睡眼惺忪的 Tommy 拿起盖在一旁的手机。空空荡荡的 QQ 提示框，没有一丝的温度。Tommy 叹了口气。昏黄的灯发出微弱的光芒，抚摸着呼呼作响的电脑。\n\n桌面上堆满了写满 $\\partial$ 和 $\\int$ 的草稿纸，手机闪光灯自制的简易台灯发出刺眼的白光；灯火缱绻，映照一双如画倦容。十几个 DDL 就在附近，QQ 那边的人已经三天三夜没有合眼了。这是 Tommy 所不知道的事。", "description": "人生大概就是这样。在这物欲横流的红尘紫陌中，芸芸众生为了生计四处奔走，交谈越来越少，感情越来越淡。但是，著名科学家 Access Globe 的最新研究成果可以解决这样的问题：通过增加同时做的事情来增加共同语言。\n\nA 和 B 都得到了一些任务，设他们要执行的任务集合分别为 $V_A$​​ 和 $V_B$​​。对每个人来说，任务 $1$ 是必须一开始做的，而其他的每个任务 $e$ 都存在一个前置任务 $p_e$​，表示任务 $e$ 必须在任务 $p_e$​​ 完成后才能执行。也就是说，每个人的任务的依赖关系构成了一棵**有根外向树**，一个任务 $e$ 能被执行当且仅当 $p_e,p_{p_{e}},\\cdots,1$ 这些任务全部都被执行，称 $p$ **依赖**任务 $p_e,p_{p_{e}},\\cdots,1$。\n\n现在，A 和 B 希望他们能有一些任务是共同完成的，因此他们决定这样选出一些任务：A 选出 $m$ 个任务 $a_1,\\cdots,a_m$​​，要求 $a_1=1$，并且对于任意的 $1\\le i<m$，都要求 $a_{i+1}$ 依赖任务$a_i$​​,同时 B 也选出 $m$ 个满足同样要求的任务 $b_1,\\cdots,b_m$​​，这样，A 就可以沿着从 $1$ 到 $A_m$​​ 的路径依次执行这些任务，同时 B 也可以沿着 $1$ 到 $B_m$​​ 的路径依次执行这些任务；并且经过安排，当 A 在执行任务 $a_i$​​ 的时候，B 恰好在执行任务 $b_i$​​，在这时 A 和 B 就能取得联系，增进感情。\n\n模型的目标为最大化亲密度。对于一组同时执行任务的关系 $a_i$​ 和 $b_i$，可以获得 $C_{a_i,b_i}$​​​​ 的得分；同时，A 和 B 一旦失去联系，就会使得亲密度降低，在每一分钟，如果一方距离上次和对方联系后已经执行任务 $i$ 分钟，就会使得亲密度降低 $2i-1$。\n\n例如，两个人要做的任务所花费的时间分别为 $2,1,4,7$ 和 $4,8,3,6,4$，并且共同完成了第一个任务和最后一个任务，那么 A 在执行中间两个任务的 $1+4=5$ 分钟没有和 B 联系，使得亲密度降低 $1+3+...+11=25$；同时 B 在执行中间三个任务的 $8+3+6=17$ 分钟没有和 A 联系，使得亲密度降低 $1+3+...+35=289$。注意，亲密度的计算只和任务执行的时间有关；并且任意两个任务都可以作为 $a_i$​​ 和 $b_i$​​ 同时执行，不需要保证它们花费的时间相同。\n\n现在，给出 A 和 B 的任务、依赖关系和每个任务的执行时间，请你帮我们求出能够获得的最大的亲密度。", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $|V_A|,|V_B|$；\n\n第二行 $|V_A|-1$ 个整数 $t^{(a)}_{2},t^{(a)}_{3},...,t^{(a)}_{|V_A|}$​​，表示 A 的每个任务的时间长度；\n\n第三行 $|V_B|-1$ 个整数 $t^{(b)}_{2},t^{(b)}_{3},...,t^{(b)}_{|V_B|}$，表示 B 的每个任务的时间长度；\n\n第四行 $|V_A|-1∣$ 个整数 $p^{(a)}_{2},p^{(a)}_{3},...,p^{(a)}_{|V_A|}$，表示 A 的每个任务的前置任务，保证 $p^{(a)}_{i}< i$；\n\n第五行 $|V_B|-1$ 个整数 $p^{(b)}_{2},p^{(b)}_{3},...,p^{(b)}_{|V_B|}$，表示 B 的每个任务的前置任务，保证 $p^{(b)}_{i}< i$；\n\n接下来 $|V_A|-1$ 行，每行 $|V_B|-1$ 个整数，第 $i-1$ 行第 $j-1$ 列为 $C_{i,j}$，表示 A 和 B 同时分别执行对应的任务 $i,j$ 能获得的亲密度，注意这些亲密度不一定是非负的；\n\n注意以上输入均不包括第 1 个任务的信息，因为它和亲密度的计算没有关系。\n", "outputFormat": "输出到标准输出。\n\n输出能获得的最大的亲密度。\n", "hint": "**样例解释**\n\nA 和 B 分别选出任务 $1,3,4$ 和 $1,2,3$，同时执行的任务对 $(1,1)$、$(3,2)$ 和 $(4,3)$ 使得他们获得了 $4+5=9$ 的亲密度；A 孤独地执行任务 $2$ 的 $2$ 分钟丢失了 $1+3=4$ 的亲密度，因此最终的总亲密度为 $9-4=5$。这就是亲密度最大的方案。\n\n![0](https://cdn.luogu.com.cn/upload/pic/16896.png)\n\n对于所有数据，$2\\le |V_A|,|V_B|\\le 2,666$，$1\\le t^{(a)}_i,t^{(b)}_i\\le 1,206$，$0\\le |C_{i,j}|\\le 2,017,011,328$。\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nCredit：idea 与命题/陈俊锟　验题/Tommy > <\n\nGit Repo：https://git.thusaac.org/publish/CodePlus4\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN"}}}
{"pid": "P4368", "type": "P", "difficulty": 3, "samples": [["3\n5 5 3 3 2 2\n5 7 3 5 2 2\n5 7 4 6 1 1", "1\n1\n1"], ["3\n5 5 3 3 3 2\n5 7 1 4 2 2\n5 7 1 2 1 2", "-1\n-1\n-1"], ["4\n999999999999 999999999999 454545454545 454545454545 1 1\n777777777777 777777777777 343434343434 343434343434 1 1\n777777777777 999999999999 343434343434 454545454545 1 1\n999999999999 777777777777 454545454545 343434343434 1 1", "454545454544\n343434343433\n-1\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["模拟", "数学", "枚举", "Code+"], "title": "[Code+#4] 喵呜", "background": "", "description": "在马路边有一排整齐的 $n$ 棵樱花树，每棵树的高度都恰好为 $h$。某天，一只可爱的小猫偶然跑到树上来玩，但是这只小猫有些对樱花过敏，所以她现在想赶快离开这些樱花树。\n\n具体来说，现在小猫位于第 $x$ 棵樱花树上高度为 $y$ 的位置，她可以通过两种跳跃来离开樱花树：\n\n轻轻跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度下降 $b$，即一次轻轻跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y-b$ 的位置，注意当小猫所在高度不大于 $b$ 时不可以使用轻轻跳。\n\n使劲跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度上升 $b$，即一次使劲跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y+b$ 的位置，注意当小猫所在高度大于 $h-b$ 时不可以使用使劲跳。\n\n为了离开这片樱花树，小猫需要移动到第 $1$ 或第 $n$ 棵树上，高度为 $h$ 或 $1$ 的位置（这样她可以呼吸新鲜空气或者直接走开樱花树）。现在小猫想知道，自己最少需要多少次跳跃才能达成目标。由于她是一只可爱的小猫，所以希望由你来告诉她。\n", "inputFormat": "从标准输入读入数据。\n\n输入数据第一行包含一个正整数 $T$，表示测试数据的组数，各组数据之间没有空行。\n\n接下来 $T$ 行，依次描述每组数据：\n\n每组数据包含一行，包含六个正整数 $n,h,x,y,a,b$，其含义见题目描述。\n", "outputFormat": "输出到标准输出。\n\n输出由 $T$ 组数据组成，各组数据之间没有空行。对于每一组数据：\n\n若小猫可以成功离开樱花树，请输出她需要的最少跳跃次数。\n\n若小猫无法通过给定的跳跃方法离开樱花树，**请输出-1**。\n", "hint": "| 测试点编号 | $n,h$ 的范围 | 特殊约定 |\n| :----------: | :----------: | :----------: |\n|$1,2$  | $\\le10$ | $b=1$ |\n|$3,4$  |  $\\le10$| $a=b=1$ |\n|$5,6,7,8$  |$\\le10$  | 无 |\n|$9,10$  | $\\le500$ | $b=1$ |\n|  $11,12$| $\\le500$ | $a=b=1$ |\n|$13,14,15$  | $\\le500$ | 无 |\n|$16,17$  | $\\le10^5$ | $h\\le10$ |\n|$18,19,20$  | $\\le10^5$ | 无 |\n| $21,22$ | $\\le10^{15}$ | $h\\le10$ |\n| $23,24,25$ | $\\le10^{15}$ | 无 |\n\n对于所有数据，保证 $n \\geq 2$，$a < n$，$b \\leq h$。\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Meow", "background": "", "description": "There is a neat row of $n$ cherry trees along the roadside, each exactly of height $h$. One day, a cute kitten happened to climb onto the trees to play, but she is a bit allergic to cherry blossoms, so she now wants to leave these cherry trees as soon as possible.\n\nSpecifically, the kitten is currently at height $y$ on the $x$-th cherry tree. She can leave the cherry trees by using two types of jumps:\n\nLight jump: Move $a$ trees to the left or right while decreasing the height by $b$. That is, in one light jump, she can move from the starting point to height $y-b$ on the $(x+a)$-th or $(x-a)$-th tree. Note that when the kitten’s current height is not greater than $b$, a light jump cannot be used.\n\nStrong jump: Move $a$ trees to the left or right while increasing the height by $b$. That is, in one strong jump, she can move from the starting point to height $y+b$ on the $(x+a)$-th or $(x-a)$-th tree. Note that when the kitten’s current height is greater than $h-b$, a strong jump cannot be used.\n\nTo leave this stretch of cherry trees, the kitten needs to move to either the $1$-st or the $n$-th tree, at height $h$ or $1$ (so that she can breathe fresh air or just walk away from the trees). Now she wants to know the minimum number of jumps required to achieve the goal. Since she is a cute kitten, she hopes you will tell her.", "inputFormat": "Read from standard input.\n\nThe first line contains a positive integer $T$, the number of groups of testdata. There are no blank lines between groups.\n\nThen follow $T$ lines, each describing one group of data:\n\nEach group consists of one line containing six positive integers $n,h,x,y,a,b$, whose meanings are as described in the problem statement.", "outputFormat": "Output to standard output.\n\nThe output consists of $T$ groups of results, with no blank lines between groups. For each group of data:\n\nIf the kitten can successfully leave the cherry trees, output the minimum number of jumps she needs.\n\nIf the kitten cannot leave the cherry trees using the given jump methods, please output -1.", "hint": "| Test point ID | Range of $n,h$ | Special note |\n| :----------: | :----------: | :----------: |\n| $1,2$  | $\\le 10$ | $b=1$ |\n| $3,4$  | $\\le 10$ | $a=b=1$ |\n| $5,6,7,8$  | $\\le 10$ | None |\n| $9,10$  | $\\le 500$ | $b=1$ |\n| $11,12$ | $\\le 500$ | $a=b=1$ |\n| $13,14,15$ | $\\le 500$ | None |\n| $16,17$ | $\\le 10^5$ | $h \\le 10$ |\n| $18,19,20$ | $\\le 10^5$ | None |\n| $21,22$ | $\\le 10^{15}$ | $h \\le 10$ |\n| $23,24,25$ | $\\le 10^{15}$ | None |\n\nFor all testdata, it is guaranteed that $n \\ge 2$, $a < n$, $b \\le h$.\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] 喵呜", "background": "", "description": "在马路边有一排整齐的 $n$ 棵樱花树，每棵树的高度都恰好为 $h$。某天，一只可爱的小猫偶然跑到树上来玩，但是这只小猫有些对樱花过敏，所以她现在想赶快离开这些樱花树。\n\n具体来说，现在小猫位于第 $x$ 棵樱花树上高度为 $y$ 的位置，她可以通过两种跳跃来离开樱花树：\n\n轻轻跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度下降 $b$，即一次轻轻跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y-b$ 的位置，注意当小猫所在高度不大于 $b$ 时不可以使用轻轻跳。\n\n使劲跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度上升 $b$，即一次使劲跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y+b$ 的位置，注意当小猫所在高度大于 $h-b$ 时不可以使用使劲跳。\n\n为了离开这片樱花树，小猫需要移动到第 $1$ 或第 $n$ 棵树上，高度为 $h$ 或 $1$ 的位置（这样她可以呼吸新鲜空气或者直接走开樱花树）。现在小猫想知道，自己最少需要多少次跳跃才能达成目标。由于她是一只可爱的小猫，所以希望由你来告诉她。\n", "inputFormat": "从标准输入读入数据。\n\n输入数据第一行包含一个正整数 $T$，表示测试数据的组数，各组数据之间没有空行。\n\n接下来 $T$ 行，依次描述每组数据：\n\n每组数据包含一行，包含六个正整数 $n,h,x,y,a,b$，其含义见题目描述。\n", "outputFormat": "输出到标准输出。\n\n输出由 $T$ 组数据组成，各组数据之间没有空行。对于每一组数据：\n\n若小猫可以成功离开樱花树，请输出她需要的最少跳跃次数。\n\n若小猫无法通过给定的跳跃方法离开樱花树，**请输出-1**。\n", "hint": "| 测试点编号 | $n,h$ 的范围 | 特殊约定 |\n| :----------: | :----------: | :----------: |\n|$1,2$  | $\\le10$ | $b=1$ |\n|$3,4$  |  $\\le10$| $a=b=1$ |\n|$5,6,7,8$  |$\\le10$  | 无 |\n|$9,10$  | $\\le500$ | $b=1$ |\n|  $11,12$| $\\le500$ | $a=b=1$ |\n|$13,14,15$  | $\\le500$ | 无 |\n|$16,17$  | $\\le10^5$ | $h\\le10$ |\n|$18,19,20$  | $\\le10^5$ | 无 |\n| $21,22$ | $\\le10^{15}$ | $h\\le10$ |\n| $23,24,25$ | $\\le10^{15}$ | 无 |\n\n对于所有数据，保证 $n \\geq 2$，$a < n$，$b \\leq h$。\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN"}}}
{"pid": "P4369", "type": "P", "difficulty": 3, "samples": [["6 2", "3 1\n3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["Special Judge", "Code+"], "title": "[Code+#4] 组合数问题", "background": "", "description": "众所周知，小葱同学擅长计算，尤其擅长计算组合数，所以小葱给了你两个数 $x$ 和 $k$，希望你把 $x$ 分成恰好 $k$ 个不同的组合数的和。所谓不同，即对于两个组合数 $C(n_1,m_1)$ 和 $C(n_2,m_2)$，如果 $n_1\\neq n_2$​​ 或者 $m_1\\neq m_2$​，我们就称这两个组合数是不同的。为了使得计算不过于复杂，你需要保证你给出的任何一个组合数 $C(n,m)$ 满足 $0\\leq m\\leq n\\leq x$。数据保证一定有解。", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $x,k$。\n", "outputFormat": "输出到标准输出。\n\n$k$ 行，每行两个整数 $n,m$ 代表一个组合数 $C(n,m)$。如果有多种可能的答案，任意输出一组即可。\n", "hint": "对于 $20\\%$ 的数据，$k=1$。\n\n对于另外 $20\\%$ 的数据，$x\\leq 100$。\n\n对于另外 $20\\%$ 的数据，$k=2$。\n\n对于 $100\\%$ 的数据，$1\\leq x\\leq 10^9,1\\leq k\\leq 10^3.$\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Binomial Coefficient Problem", "background": "", "description": "As we all know, Xiao Cong is good at calculations, especially at computing binomial coefficients. So Xiao Cong gives you two numbers $x$ and $k$, and wants you to express $x$ as the sum of exactly $k$ distinct binomial coefficients. By distinct, we mean that for two binomial coefficients $C(n_1, m_1)$ and $C(n_2, m_2)$, if $n_1 \\neq n_2$ or $m_1 \\neq m_2$, then these two binomial coefficients are considered different. To keep the computation from being too complex, you must ensure that every binomial coefficient $C(n, m)$ you provide satisfies $0 \\leq m \\leq n \\leq x$. It is guaranteed that there is a solution.", "inputFormat": "Read from standard input.\n\nThe first line contains two integers $x, k$.", "outputFormat": "Output to standard output.\n\nOutput $k$ lines. Each line contains two integers $n, m$ representing a binomial coefficient $C(n, m)$. If multiple answers are possible, output any one of them.", "hint": "For $20\\%$ of the testdata, $k = 1$.\n\nFor another $20\\%$ of the testdata, $x \\leq 100$.\n\nFor another $20\\%$ of the testdata, $k = 2$.\n\nFor $100\\%$ of the testdata, $1 \\leq x \\leq 10^9, 1 \\leq k \\leq 10^3$.\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] 组合数问题", "background": "", "description": "众所周知，小葱同学擅长计算，尤其擅长计算组合数，所以小葱给了你两个数 $x$ 和 $k$，希望你把 $x$ 分成恰好 $k$ 个不同的组合数的和。所谓不同，即对于两个组合数 $C(n_1,m_1)$ 和 $C(n_2,m_2)$，如果 $n_1\\neq n_2$​​ 或者 $m_1\\neq m_2$​，我们就称这两个组合数是不同的。为了使得计算不过于复杂，你需要保证你给出的任何一个组合数 $C(n,m)$ 满足 $0\\leq m\\leq n\\leq x$。数据保证一定有解。", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $x,k$。\n", "outputFormat": "输出到标准输出。\n\n$k$ 行，每行两个整数 $n,m$ 代表一个组合数 $C(n,m)$。如果有多种可能的答案，任意输出一组即可。\n", "hint": "对于 $20\\%$ 的数据，$k=1$。\n\n对于另外 $20\\%$ 的数据，$x\\leq 100$。\n\n对于另外 $20\\%$ 的数据，$k=2$。\n\n对于 $100\\%$ 的数据，$1\\leq x\\leq 10^9,1\\leq k\\leq 10^3.$\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN"}}}
{"pid": "P4370", "type": "P", "difficulty": 6, "samples": [["2 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["优先队列", "逆元", "队列", "Code+"], "title": "[Code+#4] 组合数问题2", "background": "", "description": "众所周知，小葱同学擅长计算，尤其擅长计算组合数，所以小葱给了你两个数 $n$ 和 $k$，希望你找到 $k$ 个不同的组合数使得这 $k$ 个组合数的和最大。所谓不同的组合数，即对于组合数 $C_{a_1}^{b_1}$​​​ 和 $C_{a_2}^{b_2}$，若 $a_1\\neq a_2$ 或者 $b_1\\neq b_2$​​，则我们认为这两个组合数是不同的。现在小葱希望你找到这样 $k$ 个不同的组合数，使得它们互不相同且对于其中任何一个组合数 $C_a^b$ 有 $0\\leq b\\leq a\\leq n$。问这 $k$ 个组合数的和最大是多少？", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $n,k$。\n", "outputFormat": "输出到标准输出。\n\n一行一个整数，代表 $k$ 个组合数的和对 $10^9+7$ 取模之后的结果；数据保证一定有至少 $k$ 个数可以选。\n", "hint": "对于 $20\\%$ 的数据，$n\\leq 10$。\n\n对于 $40\\%$ 的数据，$n\\leq 500$。\n\n对于另外 $20\\%$ 的数据，$k=1$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^6,1\\leq k\\leq 10^5.$\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Binomial Coefficient Problem 2", "background": "", "description": "It is well known that Xiaocong is skilled at calculation, especially at computing binomial coefficients. Given two numbers $n$ and $k$, he wants you to find $k$ distinct binomial coefficients such that their sum is maximized. By distinct binomial coefficients, for $C_{a_1}^{b_1}$ and $C_{a_2}^{b_2}$, if $a_1\\neq a_2$ or $b_1\\neq b_2$, we consider them different. Now, please find such $k$ distinct binomial coefficients so that for any one of them $C_a^b$ we have $0\\leq b\\leq a\\leq n$. What is the maximum possible sum of these $k$ binomial coefficients?", "inputFormat": "Read from standard input.\n\nThe first line contains two integers $n,k$.", "outputFormat": "Write to standard output.\n\nOne line with a single integer, representing the sum of the $k$ binomial coefficients modulo $10^9+7$; it is guaranteed that there are at least $k$ numbers to choose from.", "hint": "For 20% of the testdata, $n\\leq 10$.\n\nFor 40% of the testdata, $n\\leq 500$.\n\nFor another 20% of the testdata, $k=1$.\n\nFor 100% of the testdata, $1\\leq n\\leq 10^6,1\\leq k\\leq 10^5.$\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] 组合数问题2", "background": "", "description": "众所周知，小葱同学擅长计算，尤其擅长计算组合数，所以小葱给了你两个数 $n$ 和 $k$，希望你找到 $k$ 个不同的组合数使得这 $k$ 个组合数的和最大。所谓不同的组合数，即对于组合数 $C_{a_1}^{b_1}$​​​ 和 $C_{a_2}^{b_2}$，若 $a_1\\neq a_2$ 或者 $b_1\\neq b_2$​​，则我们认为这两个组合数是不同的。现在小葱希望你找到这样 $k$ 个不同的组合数，使得它们互不相同且对于其中任何一个组合数 $C_a^b$ 有 $0\\leq b\\leq a\\leq n$。问这 $k$ 个组合数的和最大是多少？", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $n,k$。\n", "outputFormat": "输出到标准输出。\n\n一行一个整数，代表 $k$ 个组合数的和对 $10^9+7$ 取模之后的结果；数据保证一定有至少 $k$ 个数可以选。\n", "hint": "对于 $20\\%$ 的数据，$n\\leq 10$。\n\n对于 $40\\%$ 的数据，$n\\leq 500$。\n\n对于另外 $20\\%$ 的数据，$k=1$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^6,1\\leq k\\leq 10^5.$\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN"}}}
{"pid": "P4371", "type": "P", "difficulty": 6, "samples": [["6\n30 30 30 30\n120 60 120 60\n270 100 270 100\n30 30 120 60\n120 60 270 100\n270 100 30 30", "0.8785\n0.7540\n0.2600\n0.9704\n0.9408\n0.8785"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["Code+"], "title": "[Code+#4] 白金元首与七彩魔法", "background": "小朋友 你们好吗　还能记得 我是谁吗　我就是魔法元首まどか！", "description": "「和我签订契约，成为魔法元首吧！」\n\n于是这天元首不明所以地被地外生物 Kyubey 忽悠去成为了魔法元首。不过在开始练习魔法之前，元首需要为自己的魔法选择一个代表色。\n\n下图是一个明度最大（即，HSV 色彩空间中 $V = 100\\%$）的单位圆色盘。色盘上任意一点的坐标为一个非负实数对 (α°,$r\\%$) $(0 \\leq \\alpha < 360,0 \\leq r \\leq 100)$，表示色相为 α°、饱和度为 $r\\%$ 的颜色。另一种理解是，α° 表示从联结圆心和纯红色点的射线顺时针到达该点所经过的角度，$\\frac {r}{100}$​​ 是该点到单位圆圆心的距离。\n\n![0](https://i.loli.net/2018/04/02/5ac1bb23a4d50.png)\n\n具体而言，从这个坐标 (α°,$r\\%$) 到红绿蓝颜色值 $(R,G,B)$ 的转换如下：\n\n![1](https://cdn.luogu.com.cn/upload/pic/16828.png)\n\n请参照样例确认你对公式的理解和实现。\n\n按照 Kyubey 的判断，元首可以选择色盘所在的平面上一条给定直线段 (α1°,$r1\\%$)-(α2°,$r2\\%$) 上的任意颜色。元首可不需要犹豫，作为一名 bling bling 的帝国领导者，当然要选择最亮的颜色啦！\n\n一个颜色 $(R,G,B)$ 的亮度定义为 $L = 0.30R + 0.59G + 0.11B$。下图给出了彩色色盘和表示亮度的灰度色盘的左右对比。\n\n![2](https://i.loli.net/2018/04/02/5ac1bb2371a0b.png)\n\n你需要编写程序帮助元首计算给定直线段上所有颜色的最大亮度。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $T$—— 数据的组数。接下来包含 $T$ 组数据，格式如下，数据间没有空行。\n\n第 $1$ 行：四个空格分隔的整数 $\\alpha_1$​​、$r_1$​​、$\\alpha_2$​​、$r_2$​​。\n\n", "outputFormat": "输出到标准输出。\n\n对于每组数据输出一行，包含一个 $[0,1]$ 范围内的十进制小数 —— 直线段 (α1°,$r1\\%$)-(α2°,$r2\\%$) 上所有颜色的最大亮度，四舍五入保留恰好四位小数。数据保证若参考答案为 $A$，则 [$A-10^{-5},A+10^{-5}$]​ 范围内任意实数四舍五入到第四位小数后均相等。\n", "hint": "**样例解释**\n\n点 (30°, $30\\%$) 的红绿蓝颜色值为 $(1.00, 0.85, 0.70)$，亮度为 $0.30 \\times 1.00 + 0.59 \\times 0.85 + 0.11 \\times 0.70 = 0.8785$；\n\n点 (120°,$60\\%$) 的红绿蓝颜色值为 $(0.40, 1.00, 0.40)$，亮度为 $0.30 \\times 0.40 + 0.59 \\times 1.00 + 0.11 \\times 0.40 = 0.7540$； \n\n点 (270°,$100\\%$) 的红绿蓝颜色值为 $(0.50, 0.00, 1.00)$，亮度为 $0.30 \\times 0.50 + 0.59 \\times 0.00 + 0.11 \\times 1.00 = 0.2600$。\n\n![6](https://cdn.luogu.com.cn/upload/pic/16899.png)\n\n “Ich glaube, ich habe mich klar genug ausgedrückt!”\n\n题面与史实无关。\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Platinum Head of State and Seven-Color Magic", "background": "Children, how are you? Do you still remember who I am? I am the magical head of state Madoka!", "description": "\"Make a contract with me and become a magical head of state!\"\n\nOn this day, the head of state was coaxed by the extraterrestrial creature Kyubey into becoming a magical head of state. However, before practicing magic, the head of state needs to choose a representative color for their magic.\n\nThe figure below is a unit-circle color wheel with maximum value (that is, in the HSV color space, $V = 100\\%$). The coordinates of any point on the wheel are a pair of nonnegative real numbers $(\\alpha^\\circ, r\\%)$ ($0 \\leq \\alpha < 360, 0 \\leq r \\leq 100$), meaning a color with hue $\\alpha^\\circ$ and saturation $r\\%$. Another interpretation is that $\\alpha^\\circ$ is the angle swept clockwise from the ray connecting the center of the circle to the pure red point to the given point, and $\\frac{r}{100}$ is the distance from that point to the center of the unit circle.\n\n![0](https://i.loli.net/2018/04/02/5ac1bb23a4d50.png)\n\nSpecifically, the conversion from these coordinates $(\\alpha^\\circ, r\\%)$ to RGB values $(R, G, B)$ is as follows:\n\n![1](https://cdn.luogu.com.cn/upload/pic/16828.png)\n\nPlease refer to the sample to confirm your understanding and implementation of the formula.\n\nAccording to Kyubey, the head of state may choose any color on a given line segment $(\\alpha_1^\\circ, r_1\\%)-(\\alpha_2^\\circ, r_2\\%)$ lying on the plane of the color wheel. No need to hesitate—being a bling bling imperial leader, of course they will choose the brightest color!\n\nThe brightness of a color $(R, G, B)$ is defined as $L = 0.30R + 0.59G + 0.11B$. The figure below shows a side-by-side comparison between the colorful color wheel and a grayscale wheel representing brightness.\n\n![2](https://i.loli.net/2018/04/02/5ac1bb2371a0b.png)\n\nYou need to write a program to compute the maximum brightness among all colors on the given line segment.", "inputFormat": "Read from standard input.\n\nThe first line contains a positive integer $T$ — the number of test cases. Then follow $T$ test cases with no blank lines between them.\n\nLine 1: Four space-separated integers $\\alpha_1$, $r_1$, $\\alpha_2$, $r_2$.", "outputFormat": "Output to standard output.\n\nFor each test case, output one line containing a decimal in the range $[0, 1]$ — the maximum brightness among all colors on the line segment $(\\alpha_1^\\circ, r_1\\%)-(\\alpha_2^\\circ, r_2\\%)$, rounded to exactly four decimal places. It is guaranteed that if the reference answer is $A$, then any real number in the range $[A - 10^{-5}, A + 10^{-5}]$ will round to the same value at four decimal places.", "hint": "Sample explanation:\n\nThe point $(30^\\circ, 30\\%)$ has RGB values $(1.00, 0.85, 0.70)$, with brightness $0.30 \\times 1.00 + 0.59 \\times 0.85 + 0.11 \\times 0.70 = 0.8785$.\n\nThe point $(120^\\circ, 60\\%)$ has RGB values $(0.40, 1.00, 0.40)$, with brightness $0.30 \\times 0.40 + 0.59 \\times 1.00 + 0.11 \\times 0.40 = 0.7540$.\n\nThe point $(270^\\circ, 100\\%)$ has RGB values $(0.50, 0.00, 1.00)$, with brightness $0.30 \\times 0.50 + 0.59 \\times 0.00 + 0.11 \\times 1.00 = 0.2600$.\n\n![6](https://cdn.luogu.com.cn/upload/pic/16899.png)\n\n\"Ich glaube, ich habe mich klar genug ausgedrückt!\"\n\nThis statement has nothing to do with historical facts.\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] 白金元首与七彩魔法", "background": "小朋友 你们好吗　还能记得 我是谁吗　我就是魔法元首まどか！", "description": "「和我签订契约，成为魔法元首吧！」\n\n于是这天元首不明所以地被地外生物 Kyubey 忽悠去成为了魔法元首。不过在开始练习魔法之前，元首需要为自己的魔法选择一个代表色。\n\n下图是一个明度最大（即，HSV 色彩空间中 $V = 100\\%$）的单位圆色盘。色盘上任意一点的坐标为一个非负实数对 (α°,$r\\%$) $(0 \\leq \\alpha < 360,0 \\leq r \\leq 100)$，表示色相为 α°、饱和度为 $r\\%$ 的颜色。另一种理解是，α° 表示从联结圆心和纯红色点的射线顺时针到达该点所经过的角度，$\\frac {r}{100}$​​ 是该点到单位圆圆心的距离。\n\n![0](https://i.loli.net/2018/04/02/5ac1bb23a4d50.png)\n\n具体而言，从这个坐标 (α°,$r\\%$) 到红绿蓝颜色值 $(R,G,B)$ 的转换如下：\n\n![1](https://cdn.luogu.com.cn/upload/pic/16828.png)\n\n请参照样例确认你对公式的理解和实现。\n\n按照 Kyubey 的判断，元首可以选择色盘所在的平面上一条给定直线段 (α1°,$r1\\%$)-(α2°,$r2\\%$) 上的任意颜色。元首可不需要犹豫，作为一名 bling bling 的帝国领导者，当然要选择最亮的颜色啦！\n\n一个颜色 $(R,G,B)$ 的亮度定义为 $L = 0.30R + 0.59G + 0.11B$。下图给出了彩色色盘和表示亮度的灰度色盘的左右对比。\n\n![2](https://i.loli.net/2018/04/02/5ac1bb2371a0b.png)\n\n你需要编写程序帮助元首计算给定直线段上所有颜色的最大亮度。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $T$—— 数据的组数。接下来包含 $T$ 组数据，格式如下，数据间没有空行。\n\n第 $1$ 行：四个空格分隔的整数 $\\alpha_1$​​、$r_1$​​、$\\alpha_2$​​、$r_2$​​。\n\n", "outputFormat": "输出到标准输出。\n\n对于每组数据输出一行，包含一个 $[0,1]$ 范围内的十进制小数 —— 直线段 (α1°,$r1\\%$)-(α2°,$r2\\%$) 上所有颜色的最大亮度，四舍五入保留恰好四位小数。数据保证若参考答案为 $A$，则 [$A-10^{-5},A+10^{-5}$]​ 范围内任意实数四舍五入到第四位小数后均相等。\n", "hint": "**样例解释**\n\n点 (30°, $30\\%$) 的红绿蓝颜色值为 $(1.00, 0.85, 0.70)$，亮度为 $0.30 \\times 1.00 + 0.59 \\times 0.85 + 0.11 \\times 0.70 = 0.8785$；\n\n点 (120°,$60\\%$) 的红绿蓝颜色值为 $(0.40, 1.00, 0.40)$，亮度为 $0.30 \\times 0.40 + 0.59 \\times 1.00 + 0.11 \\times 0.40 = 0.7540$； \n\n点 (270°,$100\\%$) 的红绿蓝颜色值为 $(0.50, 0.00, 1.00)$，亮度为 $0.30 \\times 0.50 + 0.59 \\times 0.00 + 0.11 \\times 1.00 = 0.2600$。\n\n![6](https://cdn.luogu.com.cn/upload/pic/16899.png)\n\n “Ich glaube, ich habe mich klar genug ausgedrückt!”\n\n题面与史实无关。\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN"}}}
{"pid": "P4372", "type": "P", "difficulty": 6, "samples": [["7\n20\n2\n3\n4\n9\n8\n7", "12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "排序", "Ad-hoc"], "title": "[USACO18OPEN] Out of Sorts P", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。她最喜欢的两个算法是“冒泡排序”和“快速排序”，但不幸的是，Bessie 轻易地把它们搞混了，最后实现了一个奇怪的混合算法！\n\n如果数组 $A$ 中 $A[0 \\ldots i]$ 的最大值不大于 $A[i+1 \\ldots N-1]$ 的最小值，我们就称元素 $i$ 和 $i+1$ 之间的位置为一个“分隔点”。Bessie 还记得快速排序包含对数组的重排，产生一个分隔点，然后递归对两侧的 $A[0 \\ldots i]$ 和 $A[i+1 \\ldots N-1]$ 排序。然而，尽管她正确地记下了数组中所有的分隔点都可以在线性时间内求出，她却忘记了快速排序应该如何重排来快速构造一个分隔点！在这个可能是排序算法历史上最糟糕的失误之下，她做出了一个不幸的决定：使用冒泡排序来完成这个任务。\n\n以下是 Bessie 最初对数组 $A$ 进行排序的实现的概要。她首先写了一个简单的函数，执行冒泡排序的一轮：\n\n```\nbubble_sort_pass(A) {\n   for i = 0 to length(A)-2\n      if A[i] > A[i+1], swap A[i] and A[i+1]\n}\n```\n\n她的快速排序（相当快）函数的递归代码如下：\n\n```\nquickish_sort(A) {\n   if length(A) == 1, return\n   do { // Main loop\n      work_counter = work_counter + length(A)\n      bubble_sort_pass(A)\n   } while (no partition points exist in A)\n   divide A at all partition points; recursively quickish_sort each piece\n}\n```\n\nBessie 好奇于她的代码能够运行得多快。简单起见，她计算出主循环的每一轮都消耗线性时间，因此她通过增加一个全局变量 `work_counter` 的值来跟踪整个算法完成的总工作量。\n\n给定一个输入数组，请预测 `quickish_sort` 函数接收这个数组后，变量 `work_counter` 的最终值。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来的 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围在 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出 `work_counter` 的最终值。", "hint": "在这个例子中，数组初始为 `20 2 3 4 9 8 7`。在一轮冒泡排序之后（增加 $7$ 的工作量），我们得到 `2 | 3 | 4 | 9 8 7 | 20`，其中 `|` 表示一个分隔点。于是问题被分成了递归的子问题，包括对 `2`、`3`、`4`、`20` 排序（每个消耗 $0$ 单元的工作量）和对 `9 8 7` 排序。对于 `9 8 7` 这个子问题，主循环的一轮（$3$ 单元工作量）得到 `8 7 | 9`，在此之后最后一轮处理 `8 7`（$2$ 单元工作量）就有效地完成了排序。\n\n题目来源：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Out of Sorts P", "background": "", "description": "Eyeing the possibility of a long-term career beyond the farm, the cow Bessie starts learning algorithms on various online programming sites. Her two favorite algorithms are \"bubble sort\" and \"quicksort,\" but unfortunately, Bessie easily mixes them up and ends up implementing a strange hybrid algorithm!\n\nIf in array $A$ the maximum of $A[0 \\ldots i]$ is no greater than the minimum of $A[i+1 \\ldots N-1]$, then the position between elements $i$ and $i+1$ is called a \"partition point.\" Bessie also remembers that quicksort involves rearranging the array to produce a partition point, and then recursively sorting $A[0 \\ldots i]$ and $A[i+1 \\ldots N-1]$ on the two sides. However, although she correctly notes that all the partition points in the array can be found in linear time, she forgets how quicksort should rearrange the array to quickly construct a partition point. In what is perhaps the worst blunder in the history of sorting algorithms, she makes the unfortunate decision to use bubble sort to perform this task.\n\nBelow is a summary of Bessie's initial implementation for sorting array $A$. She first writes a simple function that performs one pass of bubble sort:\n\n```\nbubble_sort_pass(A) {\n   for i = 0 to length(A)-2\n      if A[i] > A[i+1], swap A[i] and A[i+1]\n}\n```\n\nThe recursive code of her quickish sort function is as follows:\n\n```\nquickish_sort(A) {\n   if length(A) == 1, return\n   do { // Main loop\n      work_counter = work_counter + length(A)\n      bubble_sort_pass(A)\n   } while (no partition points exist in A)\n   divide A at all partition points; recursively quickish_sort each piece\n}\n```\n\nBessie is curious how fast her code can run. For simplicity, she decides that each iteration of the main loop takes linear time, so she tracks the total amount of work done by the entire algorithm by increasing a global variable, work_counter.\n\nGiven an input array, please predict the final value of work_counter after the quickish_sort function processes this array.", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 100{,}000$). The next $N$ lines describe $A[0] \\ldots A[N-1]$, each being an integer in the range $0 \\ldots 10^9$. The input numbers are not guaranteed to be distinct.", "outputFormat": "Output the final value of work_counter.", "hint": "In this example, the array initially is `20 2 3 4 9 8 7`. After one pass of bubble sort (adding $7$ units of work), we obtain `2 | 3 | 4 | 9 8 7 | 20`, where `|` denotes a partition point. The problem then splits into recursive subproblems, including sorting `2`, `3`, `4`, and `20` (each costing $0$ units of work) and sorting `9 8 7`. For the subproblem `9 8 7`, one iteration of the main loop ($3$ units of work) yields `8 7 | 9`, after which the final pass on `8 7` ($2$ units of work) effectively completes the sort.\n\nSource: Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Out of Sorts P", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。她最喜欢的两个算法是“冒泡排序”和“快速排序”，但不幸的是，Bessie 轻易地把它们搞混了，最后实现了一个奇怪的混合算法！\n\n如果数组 $A$ 中 $A[0 \\ldots i]$ 的最大值不大于 $A[i+1 \\ldots N-1]$ 的最小值，我们就称元素 $i$ 和 $i+1$ 之间的位置为一个“分隔点”。Bessie 还记得快速排序包含对数组的重排，产生一个分隔点，然后递归对两侧的 $A[0 \\ldots i]$ 和 $A[i+1 \\ldots N-1]$ 排序。然而，尽管她正确地记下了数组中所有的分隔点都可以在线性时间内求出，她却忘记了快速排序应该如何重排来快速构造一个分隔点！在这个可能是排序算法历史上最糟糕的失误之下，她做出了一个不幸的决定：使用冒泡排序来完成这个任务。\n\n以下是 Bessie 最初对数组 $A$ 进行排序的实现的概要。她首先写了一个简单的函数，执行冒泡排序的一轮：\n\n```\nbubble_sort_pass(A) {\n   for i = 0 to length(A)-2\n      if A[i] > A[i+1], swap A[i] and A[i+1]\n}\n```\n\n她的快速排序（相当快）函数的递归代码如下：\n\n```\nquickish_sort(A) {\n   if length(A) == 1, return\n   do { // Main loop\n      work_counter = work_counter + length(A)\n      bubble_sort_pass(A)\n   } while (no partition points exist in A)\n   divide A at all partition points; recursively quickish_sort each piece\n}\n```\n\nBessie 好奇于她的代码能够运行得多快。简单起见，她计算出主循环的每一轮都消耗线性时间，因此她通过增加一个全局变量 `work_counter` 的值来跟踪整个算法完成的总工作量。\n\n给定一个输入数组，请预测 `quickish_sort` 函数接收这个数组后，变量 `work_counter` 的最终值。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来的 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围在 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出 `work_counter` 的最终值。", "hint": "在这个例子中，数组初始为 `20 2 3 4 9 8 7`。在一轮冒泡排序之后（增加 $7$ 的工作量），我们得到 `2 | 3 | 4 | 9 8 7 | 20`，其中 `|` 表示一个分隔点。于是问题被分成了递归的子问题，包括对 `2`、`3`、`4`、`20` 排序（每个消耗 $0$ 单元的工作量）和对 `9 8 7` 排序。对于 `9 8 7` 这个子问题，主循环的一轮（$3$ 单元工作量）得到 `8 7 | 9`，在此之后最后一轮处理 `8 7`（$2$ 单元工作量）就有效地完成了排序。\n\n题目来源：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4373", "type": "P", "difficulty": 7, "samples": [["10 3\n5 7 9 2 0 1 7 4 3 6", "5\n2\n0\n0\n0\n1\n3\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "USACO", "单调队列", "交互题", "Special Judge", "分块"], "title": "[USACO18OPEN] Train Tracking P", "background": "鉴于本题存在特殊要求且大部分人**不遵守**，题解通道关闭。如确有正解，请联系管理员单独添加。\n\n1. 你的程序不需要，也不应该包含 `grader.h` 头文件。\n2. 请在程序中加入如下函数声明语句：\n\n```cpp\nint get(int);\nvoid set(int,int);\nvoid shoutMinimum(int);\nint getTrainLength();\nint getWindowLength();\nint getCurrentCarIndex();\nint getCurrentPassIndex();\n```", "description": "每天早晨特快列车会经过农场，开往大城市，每天下午它又会折回来，回到郊区。今天，Bessie 会花时间观察它，早晨和下午都会。\n\nBessie 提前知道，列车有 $N$ 节车厢，方便起见，将其编号为 $0\\sim N-1$。车厢 $i$ 有一个 ID $c_i$。在早晨和下午，所有的数字都是可见的，所以对于每节车厢 Bessie 有两次机会观察它的 ID。也就是说，当列车早晨经过的时候，Bessie 能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。当列车下午驶回的时候，她又一次能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。 \n\nBessie 挑选了一个整数 $K$，她想要求出每个连续的 $K$ 节车厢中最小的 ID。她有一本能够帮助执行计算的笔记本，但是这个笔记本相当小，并且 Bessie 的手写（蹄写？）字相当大。比方说，可能没有足够的空间记下所有 $N+1-K$ 个最小值。由于某些神秘的原因，Bessie 满足于当她算出最小数的时候向天哞出这些数，所以这个问题至少还不成问题。\n\n列车马上就要来了！帮助 Bessie 在列车经过两次之后求出这 $N+1−K$ 个最小数，确保她有效地利用她有限的笔记本空间。她的笔记本被分为 $5500$ 个部分，方便起见编号为 $0\\sim 5499$，每个部分的空间恰好能够记录一个在 $[-2^{31} , 2^{31}-1]$ 之间的整数。最初的时候，每个部分都记录着整数 $0$。\n\n请帮助 Bessie 有效管理她有限的笔记本空间。\n\n### 交互方式\n\n这是一道交互式题目，你不需要使用标准（或文件）输入输出。具体地说，你需要实现下面的函数，这个函数用来帮助 Bessie 有效管理她有限的笔记本空间：\n\n```cpp\nvoid helpBessie(int ID);\n```\n\n每当一节列车车厢经过的时候，无论是在早晨和下午，你的函数都会被调用，函数的输入是这节车厢的 ID。 \n\n你的 `helpBessie` 函数的实现可以调用下面这些函数：\n\n- `int get(int index)`：获取记录在 Bessie 的笔记本上的给定的索引处的整数值（_index_）。\n- `void set (int index, int value)`：设置给定的索引（_index_）处的值为给定的整数值（_value_）。\n- `void shoutMinimum (int output)`：通知 Bessie 向天哞一个指定的数。\n- `int getTrainLength()`：返回列车的车厢数 $N$。\n- `int getWindowLength()`：返回窗口的长度 $K$。\n- `int getCurrentCarIndex()`：返回当前正在通过的车厢编号。\n- `int getCurrentPassIndex()`：如果 Bessie 正在观察早晨的列车返回 $0$，下午的列车返回 $1$。\n\n为了帮助你开始编码，我们为你提供了初始的 C/C++ 模板。遗憾地，这道题目不支持 Python 和 Pascal 语言的程序。\n\n```cpp\n#include \"grader.h\"\n\n// If you find it necessary, you may import standard libraries here.\n\nvoid helpBessie(int ID)\n{\n\t// Put your code here.\n}\n```\n\n调用 `void shoutMinimum (int output)` 函数进行输出。\n\n各个窗口的最小数必须按顺序输出（所以车厢 $0,1,\\cdots ,K−1$ 之中的最小值必须在车厢 $1,2,\\cdots ,K$ 之中的最小值之前输出，等等），但是除了这个顺序的限制之外，你的函数可以在任何一次函数调用中任意多次地输出一些最小值。比如，你的函数可能在某几次调用中不产生任何输出，而在某几次调用中产生多个输出。\n\nBessie 拥有惊人的短时记忆能力，因此在 `helpBessie` 函数中没有任何的内存使用限制，除了要满足常规的 256MB 限制。然而，在车厢与车厢之间，Bessie 不能够「记住」任何不在笔记本中出现过的内容。所以在两次函数调用之间，你的程序除了通过 `get` 和 `set` 函数调用之外不能保存任何的状态。\n\n这意味着：\n\n**不允许定义任何非常量的全局或静态变量。任何如此做的提交会被取消成绩。教练会人工检查所有的提交以验证是否符合题目要求。由于这个问题无需文件输入输出，所以也不允许在代码中使用任何的文件输入输出**。", "inputFormat": "", "outputFormat": "", "hint": "对于全部数据，$1\\le N\\le 10^6,0\\le c_i\\le 10^9,1\\le K\\le N$，你的程序进行的 `set` 调用和 `get` 调用的总次数被限制为 $25\\times 10^6$ 次。\n\n供题：Dhruv Rohatgi", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Train Tracking P", "background": "Given the special requirements of this problem and the fact that most people do not follow them, the solution channel is closed. If you do have a correct solution, please contact an administrator to add it separately.\n\n1. Your program does not need, and should not include, the header file `grader.h`.\n2. Please add the following function declarations in your program:\n\n```cpp\nint get(int);\nvoid set(int,int);\nvoid shoutMinimum(int);\nint getTrainLength();\nint getWindowLength();\nint getCurrentCarIndex();\nint getCurrentPassIndex();\n```", "description": "Every morning, an express train passes by the farm on its way to the big city, and every afternoon it comes back to the suburbs. Today, Bessie will watch it both in the morning and in the afternoon.\n\nBessie knows in advance that the train has $N$ cars, numbered $0\\sim N-1$ for convenience. Car $i$ has an ID $c_i$. In both the morning and the afternoon, all the numbers are visible, so Bessie has two chances to observe the ID of each car. That is, when the train goes by in the morning, Bessie can observe $c_0$, then $c_1$, up to $c_{N-1}$. When the train returns in the afternoon, she can again observe $c_0$, then $c_1$, up to $c_{N-1}$.\n\nBessie chooses an integer $K$, and she wants to compute the minimum ID in every consecutive block of $K$ cars. She has a notebook to help her do computations, but the notebook is quite small, and Bessie’s handwriting (hoof-writing?) is rather large. For example, there might not be enough space to write down all $N+1-K$ minima. For some mysterious reason, Bessie is satisfied with mooing these numbers to the sky when she computes each minimum, so at least that part is not a problem.\n\nThe train is coming soon! Help Bessie compute these $N+1−K$ minima after the train passes twice, making sure she uses her limited notebook space efficiently. Her notebook is divided into $5500$ sections, numbered $0\\sim 5499$ for convenience, and each section can store exactly one integer in the range $[-2^{31} , 2^{31}-1]$. Initially, each section stores the integer $0$.\n\nPlease help Bessie manage her limited notebook space efficiently.\n\nInteractive protocol\n\nThis is an interactive problem; you do not need to use standard (or file) input/output. Specifically, you need to implement the following function, which is used to help Bessie manage her limited notebook space efficiently:\n\n```cpp\nvoid helpBessie(int ID);\n```\n\nWhenever a train car passes by, whether in the morning or in the afternoon, your function will be called with the ID of that car as input.\n\nYour implementation of `helpBessie` can call the following functions:\n\n- `int get(int index)`: Get the integer value recorded at the given index in Bessie’s notebook (_index_).\n- `void set (int index, int value)`: Set the value at the given index (_index_) to the given integer (_value_).\n- `void shoutMinimum (int output)`: Tell Bessie to moo a specified number to the sky.\n- `int getTrainLength()`: Return the number of cars $N$.\n- `int getWindowLength()`: Return the window length $K$.\n- `int getCurrentCarIndex()`: Return the index of the car currently passing by.\n- `int getCurrentPassIndex()`: Return $0$ if Bessie is watching the morning pass, and $1$ for the afternoon pass.\n\nTo help you get started, we provide an initial C/C++ template. Unfortunately, Python and Pascal are not supported for this problem.\n\n```cpp\n#include \"grader.h\"\n\n// If you find it necessary, you may import standard libraries here.\n\nvoid helpBessie(int ID)\n{\n\t// Put your code here.\n}\n```\n\nCall `void shoutMinimum (int output)` to produce output.\n\nThe minima for the windows must be output in order (so the minimum of cars $0,1,\\cdots ,K−1$ must be output before the minimum of cars $1,2,\\cdots ,K$ and so on), but aside from this ordering constraint, your function may output any number of minima during any call. For example, your function may produce no output during some calls and multiple outputs during others.\n\nBessie has amazing short-term memory, so there is no memory usage limit inside the `helpBessie` function other than the standard 256 MB limit. However, between cars, Bessie cannot “remember” anything that does not appear in the notebook. Therefore, between two calls of the function, your program cannot preserve any state except via calls to `get` and `set`.\n\nThis means:\n\nYou are not allowed to define any non-constant global or static variables. Any submission that does so will receive zero credit. Coaches will manually check all submissions to verify compliance with the problem requirements. Since this problem does not require file input/output, using any file I/O in the code is also not allowed.", "inputFormat": "", "outputFormat": "", "hint": "For all testdata, $1\\le N\\le 10^6,0\\le c_i\\le 10^9,1\\le K\\le N$, and the total number of `set` and `get` calls your program makes is limited to $25\\times 10^6$.\n\nProblem by: Dhruv Rohatgi.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Train Tracking P", "background": "鉴于本题存在特殊要求且大部分人**不遵守**，题解通道关闭。如确有正解，请联系管理员单独添加。\n\n1. 你的程序不需要，也不应该包含 `grader.h` 头文件。\n2. 请在程序中加入如下函数声明语句：\n\n```cpp\nint get(int);\nvoid set(int,int);\nvoid shoutMinimum(int);\nint getTrainLength();\nint getWindowLength();\nint getCurrentCarIndex();\nint getCurrentPassIndex();\n```", "description": "每天早晨特快列车会经过农场，开往大城市，每天下午它又会折回来，回到郊区。今天，Bessie 会花时间观察它，早晨和下午都会。\n\nBessie 提前知道，列车有 $N$ 节车厢，方便起见，将其编号为 $0\\sim N-1$。车厢 $i$ 有一个 ID $c_i$。在早晨和下午，所有的数字都是可见的，所以对于每节车厢 Bessie 有两次机会观察它的 ID。也就是说，当列车早晨经过的时候，Bessie 能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。当列车下午驶回的时候，她又一次能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。 \n\nBessie 挑选了一个整数 $K$，她想要求出每个连续的 $K$ 节车厢中最小的 ID。她有一本能够帮助执行计算的笔记本，但是这个笔记本相当小，并且 Bessie 的手写（蹄写？）字相当大。比方说，可能没有足够的空间记下所有 $N+1-K$ 个最小值。由于某些神秘的原因，Bessie 满足于当她算出最小数的时候向天哞出这些数，所以这个问题至少还不成问题。\n\n列车马上就要来了！帮助 Bessie 在列车经过两次之后求出这 $N+1−K$ 个最小数，确保她有效地利用她有限的笔记本空间。她的笔记本被分为 $5500$ 个部分，方便起见编号为 $0\\sim 5499$，每个部分的空间恰好能够记录一个在 $[-2^{31} , 2^{31}-1]$ 之间的整数。最初的时候，每个部分都记录着整数 $0$。\n\n请帮助 Bessie 有效管理她有限的笔记本空间。\n\n### 交互方式\n\n这是一道交互式题目，你不需要使用标准（或文件）输入输出。具体地说，你需要实现下面的函数，这个函数用来帮助 Bessie 有效管理她有限的笔记本空间：\n\n```cpp\nvoid helpBessie(int ID);\n```\n\n每当一节列车车厢经过的时候，无论是在早晨和下午，你的函数都会被调用，函数的输入是这节车厢的 ID。 \n\n你的 `helpBessie` 函数的实现可以调用下面这些函数：\n\n- `int get(int index)`：获取记录在 Bessie 的笔记本上的给定的索引处的整数值（_index_）。\n- `void set (int index, int value)`：设置给定的索引（_index_）处的值为给定的整数值（_value_）。\n- `void shoutMinimum (int output)`：通知 Bessie 向天哞一个指定的数。\n- `int getTrainLength()`：返回列车的车厢数 $N$。\n- `int getWindowLength()`：返回窗口的长度 $K$。\n- `int getCurrentCarIndex()`：返回当前正在通过的车厢编号。\n- `int getCurrentPassIndex()`：如果 Bessie 正在观察早晨的列车返回 $0$，下午的列车返回 $1$。\n\n为了帮助你开始编码，我们为你提供了初始的 C/C++ 模板。遗憾地，这道题目不支持 Python 和 Pascal 语言的程序。\n\n```cpp\n#include \"grader.h\"\n\n// If you find it necessary, you may import standard libraries here.\n\nvoid helpBessie(int ID)\n{\n\t// Put your code here.\n}\n```\n\n调用 `void shoutMinimum (int output)` 函数进行输出。\n\n各个窗口的最小数必须按顺序输出（所以车厢 $0,1,\\cdots ,K−1$ 之中的最小值必须在车厢 $1,2,\\cdots ,K$ 之中的最小值之前输出，等等），但是除了这个顺序的限制之外，你的函数可以在任何一次函数调用中任意多次地输出一些最小值。比如，你的函数可能在某几次调用中不产生任何输出，而在某几次调用中产生多个输出。\n\nBessie 拥有惊人的短时记忆能力，因此在 `helpBessie` 函数中没有任何的内存使用限制，除了要满足常规的 256MB 限制。然而，在车厢与车厢之间，Bessie 不能够「记住」任何不在笔记本中出现过的内容。所以在两次函数调用之间，你的程序除了通过 `get` 和 `set` 函数调用之外不能保存任何的状态。\n\n这意味着：\n\n**不允许定义任何非常量的全局或静态变量。任何如此做的提交会被取消成绩。教练会人工检查所有的提交以验证是否符合题目要求。由于这个问题无需文件输入输出，所以也不允许在代码中使用任何的文件输入输出**。", "inputFormat": "", "outputFormat": "", "hint": "对于全部数据，$1\\le N\\le 10^6,0\\le c_i\\le 10^9,1\\le K\\le N$，你的程序进行的 `set` 调用和 `get` 调用的总次数被限制为 $25\\times 10^6$ 次。\n\n供题：Dhruv Rohatgi", "locale": "zh-CN"}}}
{"pid": "P4374", "type": "P", "difficulty": 5, "samples": [["6 3\n1 2\n1 3\n4 1\n4 5\n6 5\n2 3 7\n3 6 8\n6 4 5", "7\n7\n8\n5\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "线段树", "USACO", "树链剖分"], "title": "[USACO18OPEN] Disruption P", "background": "", "description": "Farmer John 自豪于他所经营的交通发达的农场。这个农场由 $N$ 块牧场（$2 \\leq N \\leq 50,000$）组成，$N-1$ 条双向道路将它们连接起来，每条道路的长度均为 $1$ 单位。Farmer John 注意到，从任何一块牧场到另一块牧场，都能通过一组合适的道路到达。\n\n尽管 FJ 的农场现在是连通的，他担心如果有一条道路被阻断会发生什么，因为这会将农场分为两个不相交的牧场集合，奶牛们只能在每个集合内移动而不能在集合间移动。于是 FJ 又建造了 $M$ 条额外的双向道路（$1 \\leq M \\leq 50,000$），每条道路的长度都是一个至多为 $10^9$ 的正整数。奶牛们仍然可以使用原有的道路进行移动，除非其中的某些被阻断。\n\n如果某条原有的道路被阻断，农场就会被分为两块不相交的区域，那么 FJ 会从他的额外修建的道路中选择一条能够重建这两块区域连通性的道路，取代原来的那条，从而使奶牛们又可以从任何一块牧场去往另一块牧场。\n\n对于农场上每一条原有的道路，帮助 FJ 选出最短的替代道路。", "inputFormat": "输入的第一行包含 $N$ 和 $M$。接下来的 $N-1$ 行，每行用整数 $p$ 和 $q$ 描述了一条原有的道路，其中 $p \\neq q$ 是这条道路连接的两块牧场（在 $1 \\ldots N$ 范围内）。剩下的 $M$ 行，每行用三个整数 $p$、$q$ 和 $r$ 描述了一条额外的道路，其中 $r$ 是这条道路的长度。任何两块牧场之间至多只有一条道路。", "outputFormat": "对原有的 $N-1$ 条道路的每一条，按照它们在输入中出现的顺序，输出如果这条道路被阻断的话，能够重新连接农场的最短替代道路的长度。如果不存在合适的替代道路，输出 $-1$。", "hint": "供题：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Disruption P", "background": "", "description": "Farmer John is proud of his well-connected farm. The farm consists of $N$ pastures ($2 \\leq N \\leq 50,000$) with $N-1$ bidirectional roads connecting them, each of length $1$ unit. Farmer John notices that from any pasture to any other, one can travel via some sequence of roads.\n\nAlthough FJ's farm is currently connected, he worries about what would happen if a road were blocked, since this would split the farm into two disjoint sets of pastures, and the cows could move only within each set but not between sets. So FJ builds $M$ additional bidirectional roads ($1 \\leq M \\leq 50,000$), each with a positive integer length of at most $10^9$. The cows can still use the original roads to travel unless some of them are blocked.\n\nIf one of the original roads is blocked, the farm is divided into two disjoint regions. FJ will then choose one of his additional roads that can restore connectivity between these two regions to replace the original one, so that the cows can again travel from any pasture to any other pasture.\n\nFor each original road on the farm, help FJ pick the shortest replacement road.", "inputFormat": "The first line contains $N$ and $M$. The next $N-1$ lines each describe an original road with integers $p$ and $q$, where $p \\neq q$ are the two pastures it connects (within $1 \\ldots N$). The remaining $M$ lines each describe an additional road with three integers $p$, $q$, and $r$, where $r$ is the road's length. There is at most one road between any two pastures.", "outputFormat": "For each of the original $N-1$ roads, in the order they appear in the input, output the length of the shortest replacement road that can reconnect the farm if that road is blocked. If no suitable replacement road exists, output $-1$.", "hint": "Author: Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Disruption P", "background": "", "description": "Farmer John 自豪于他所经营的交通发达的农场。这个农场由 $N$ 块牧场（$2 \\leq N \\leq 50,000$）组成，$N-1$ 条双向道路将它们连接起来，每条道路的长度均为 $1$ 单位。Farmer John 注意到，从任何一块牧场到另一块牧场，都能通过一组合适的道路到达。\n\n尽管 FJ 的农场现在是连通的，他担心如果有一条道路被阻断会发生什么，因为这会将农场分为两个不相交的牧场集合，奶牛们只能在每个集合内移动而不能在集合间移动。于是 FJ 又建造了 $M$ 条额外的双向道路（$1 \\leq M \\leq 50,000$），每条道路的长度都是一个至多为 $10^9$ 的正整数。奶牛们仍然可以使用原有的道路进行移动，除非其中的某些被阻断。\n\n如果某条原有的道路被阻断，农场就会被分为两块不相交的区域，那么 FJ 会从他的额外修建的道路中选择一条能够重建这两块区域连通性的道路，取代原来的那条，从而使奶牛们又可以从任何一块牧场去往另一块牧场。\n\n对于农场上每一条原有的道路，帮助 FJ 选出最短的替代道路。", "inputFormat": "输入的第一行包含 $N$ 和 $M$。接下来的 $N-1$ 行，每行用整数 $p$ 和 $q$ 描述了一条原有的道路，其中 $p \\neq q$ 是这条道路连接的两块牧场（在 $1 \\ldots N$ 范围内）。剩下的 $M$ 行，每行用三个整数 $p$、$q$ 和 $r$ 描述了一条额外的道路，其中 $r$ 是这条道路的长度。任何两块牧场之间至多只有一条道路。", "outputFormat": "对原有的 $N-1$ 条道路的每一条，按照它们在输入中出现的顺序，输出如果这条道路被阻断的话，能够重新连接农场的最短替代道路的长度。如果不存在合适的替代道路，输出 $-1$。", "hint": "供题：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4375", "type": "P", "difficulty": 5, "samples": [["5\n1\n8\n5\n3\n2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "树状数组", "离散化", "排序"], "title": "[USACO18OPEN] Out of Sorts G", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。\n\n她到目前为止最喜欢的算法是“冒泡排序”。以下是 Bessie 最初的对长度为 $N$ 的数组 $A$ 进行排序的代码实现：\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n\n显然，代码中的 `moo` 指令的作用只是输出“moo”。奇怪的是，Bessie 似乎执着于在她的代码中的不同位置使用这个语句。\n\n在用若干个数组测试了她的代码之后，Bessie 观察到一个有趣的现象：大的元素很快就会被拉到数组末尾，而小的元素需要很长时间“冒泡”到数组的开头（她怀疑这就是这个算法得名的原因）。为了实验和缓解这一问题，Bessie 修改了她的代码，使代码在每次循环中向前再向后各扫描一次，从而无论是大的元素还是小的元素在每一次循环中都有机会被拉较长的一段距离。她的代码现在是这样的：\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = N-2 downto 0:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         sorted = false\n```\n\n给定一个输入数组，请预测 Bessie 修改后的代码会输出多少次“moo”。\n", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来的 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围在 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出“moo”被输出的次数。", "hint": "供题：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Out of Sorts G", "background": "", "description": "Looking toward the possibility of a long-term career beyond the farm, the cow Bessie has started studying algorithms on various online programming websites.\n\nHer favorite algorithm so far is \"bubble sort.\" Below is Bessie's initial code implementation for sorting an array $A$ of length $N$:\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n\nClearly, the `moo` instruction in the code simply outputs \"moo.\" Strangely, Bessie seems fixated on using this statement in different places in her code.\n\nAfter testing her code on several arrays, Bessie noticed an interesting phenomenon: large elements are quickly pulled to the end of the array, while small elements take a long time to \"bubble\" up to the front (she suspects this is why the algorithm has this name). To experiment and ease this issue, Bessie modified her code so that in each loop it scans forward and then backward, giving both large and small elements a chance to move a relatively long distance in each loop. Her code is now as follows:\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = N-2 downto 0:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         sorted = false\n```\n\nGiven an input array, predict how many times Bessie's modified code will output \"moo.\"", "inputFormat": "The first line contains $N$ ($1 \\leq N \\leq 100,000$). The next $N$ lines describe $A[0] \\ldots A[N-1]$, each an integer in the range $0 \\ldots 10^9$. The input numbers are not guaranteed to be distinct.", "outputFormat": "Output the number of times \"moo\" is printed.", "hint": "Problem by Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Out of Sorts G", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。\n\n她到目前为止最喜欢的算法是“冒泡排序”。以下是 Bessie 最初的对长度为 $N$ 的数组 $A$ 进行排序的代码实现：\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n\n显然，代码中的 `moo` 指令的作用只是输出“moo”。奇怪的是，Bessie 似乎执着于在她的代码中的不同位置使用这个语句。\n\n在用若干个数组测试了她的代码之后，Bessie 观察到一个有趣的现象：大的元素很快就会被拉到数组末尾，而小的元素需要很长时间“冒泡”到数组的开头（她怀疑这就是这个算法得名的原因）。为了实验和缓解这一问题，Bessie 修改了她的代码，使代码在每次循环中向前再向后各扫描一次，从而无论是大的元素还是小的元素在每一次循环中都有机会被拉较长的一段距离。她的代码现在是这样的：\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = N-2 downto 0:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         sorted = false\n```\n\n给定一个输入数组，请预测 Bessie 修改后的代码会输出多少次“moo”。\n", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来的 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围在 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出“moo”被输出的次数。", "hint": "供题：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4376", "type": "P", "difficulty": 5, "samples": [["4 3\n3 1 2 3\n2 4 2\n3 3 4 1", "1 4 2 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "二分", "USACO", "图论建模", "拓扑排序"], "title": "[USACO18OPEN] Milking Order G", "background": "", "description": "Farmer John 的 $N$ 头奶牛（$1 \\leq N \\leq 10^5$），编号为 $1 \\ldots N$，最近闲得发慌。因此，她们发展了一个与 Farmer John 每天早上为她们挤牛奶时的排队顺序相关的复杂社会阶层。\n\n经过若干周的研究，Farmer John 对他的奶牛的社会结构总计进行了 $M$ 次观察（$1 \\leq M \\leq 50,000$）。每个观察结果都是某些奶牛的一个有序序列，表示这些奶牛应该按照序列中的顺序进行挤奶。例如，如果 Farmer John 的一次观察结果是序列 $2$、$5$、$1$，那么 Farmer John 应该在给奶牛 $5$ 挤奶之前的某个时刻给奶牛 $2$ 挤奶，并在给奶牛 $1$ 挤奶之前的某个时刻给奶牛 $5$ 挤奶。\n\nFarmer John 的观察结果是按优先级排列的，因此他的目标是最大化 $X$ 的值，使得他的挤奶顺序能够符合前 $X$ 个观察结果描述的状态。当多种挤奶顺序都能符合前 $X$ 个状态时，Farmer John 遵循一个长期以来的传统——编号较小的奶牛的地位高于编号较大的奶牛，因此他会最先给编号最小的奶牛挤奶。更正式地说，如果有多个挤奶顺序符合这些状态，Farmer John 会采用字典序最小的那一个。挤奶顺序 $x$ 的字典序比挤奶顺序 $y$ 小，如果对于某个 $j$，$x_i = y_i$ 对所有 $i < j$ 成立，并且 $x_j < y_j$（即这两个挤奶顺序到某个位置之前完全相同，而在该位置上 $x$ 比 $y$ 小）。\n\n请帮助 Farmer John 确定给奶牛挤奶的最佳顺序。", "inputFormat": "第一行包含 $N$ 和 $M$。接下来的 $M$ 行，每行描述了一个观察结果。第 $i+1$ 行描述了观察结果 $i$，第一个数是观察结果中的奶牛数量 $m_i$，后面是一列 $m_i$ 个整数，给出这次观察中奶牛的顺序。所有 $m_i$ 的总和至多为 $200,000$。", "outputFormat": "输出 $N$ 个空格分隔的整数，表示一个 $1 \\ldots N$ 的排列，为 Farmer John 给他的奶牛们挤奶应该采用的顺序。", "hint": "在这个例子中，Farmer John 有四头奶牛，他的挤奶顺序应该满足以下规则：奶牛 $1$ 在奶牛 $2$ 之前、奶牛 $2$ 在奶牛 $3$ 之前（第一个观察结果），奶牛 $4$ 在奶牛 $2$ 之前（第二个观察结果），奶牛 $3$ 在奶牛 $4$ 之前、奶牛 $4$ 在奶牛 $1$ 之前（第三个观察结果）。前两个观察结果可以同时被满足，但 Farmer John 不能同时满足所有规则，因为这会要求奶牛 $1$ 在奶牛 $3$ 之前，同时奶牛 $3$ 在奶牛 $1$ 之前。\n\n这意味着总共有两种可能的挤奶顺序：$1\\ 4\\ 2\\ 3$ 和 $4\\ 1\\ 2\\ 3$，第一种是字典序较小的。\n\n题目来源：Jay Leeds", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Milking Order G", "background": "", "description": "Farmer John has $N$ cows ($1 \\leq N \\leq 10^5$), numbered $1 \\ldots N$, who have recently gotten bored. They have developed a complex social hierarchy related to the order in which Farmer John milks them each morning.\n\nAfter several weeks of study, Farmer John has made $M$ observations ($1 \\leq M \\leq 50{,}000$) about the social structure of his cows. Each observation is an ordered sequence of certain cows, indicating that these cows should be milked in the order shown by the sequence. For example, if one observation is the sequence $2$, $5$, $1$, then Farmer John should milk cow $2$ sometime before cow $5$, and milk cow $5$ sometime before cow $1$.\n\nThe observations are prioritized, and his goal is to maximize the value $X$ such that his milking order can satisfy the first $X$ observations. When multiple milking orders satisfy the first $X$ observations, Farmer John follows a long tradition: cows with smaller IDs outrank those with larger IDs, so he will milk the smallest-numbered cow first. More formally, if multiple milking orders satisfy these observations, Farmer John uses the lexicographically smallest one. A milking order $x$ is lexicographically smaller than a milking order $y$ if, for some $j$, $x_i = y_i$ holds for all $i < j$, and $x_j < y_j$ (that is, the two orders are identical up to some position, and at that position $x$ is smaller than $y$).\n\nPlease help Farmer John determine the best order in which to milk the cows.", "inputFormat": "The first line contains $N$ and $M$. Each of the next $M$ lines describes one observation. Line $i+1$ describes observation $i$: the first number is the number of cows in the observation, $m_i$, followed by a list of $m_i$ integers giving the order of cows in that observation. The sum of all $m_i$ is at most $200{,}000$.", "outputFormat": "Output $N$ space-separated integers, a permutation of $1 \\ldots N$, giving the order in which Farmer John should milk his cows.", "hint": "In this example, Farmer John has four cows, and his milking order should satisfy the following rules: cow $1$ before cow $2$, and cow $2$ before cow $3$ (first observation); cow $4$ before cow $2$ (second observation); cow $3$ before cow $4$, and cow $4$ before cow $1$ (third observation). The first two observations can be satisfied together, but Farmer John cannot satisfy all rules simultaneously, since that would require cow $1$ before cow $3$ while also having cow $3$ before cow $1$.\n\nThis means there are two possible milking orders: $1\\ 4\\ 2\\ 3$ and $4\\ 1\\ 2\\ 3$, and the first is lexicographically smaller.\n\nProblem source: Jay Leeds.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Milking Order G", "background": "", "description": "Farmer John 的 $N$ 头奶牛（$1 \\leq N \\leq 10^5$），编号为 $1 \\ldots N$，最近闲得发慌。因此，她们发展了一个与 Farmer John 每天早上为她们挤牛奶时的排队顺序相关的复杂社会阶层。\n\n经过若干周的研究，Farmer John 对他的奶牛的社会结构总计进行了 $M$ 次观察（$1 \\leq M \\leq 50,000$）。每个观察结果都是某些奶牛的一个有序序列，表示这些奶牛应该按照序列中的顺序进行挤奶。例如，如果 Farmer John 的一次观察结果是序列 $2$、$5$、$1$，那么 Farmer John 应该在给奶牛 $5$ 挤奶之前的某个时刻给奶牛 $2$ 挤奶，并在给奶牛 $1$ 挤奶之前的某个时刻给奶牛 $5$ 挤奶。\n\nFarmer John 的观察结果是按优先级排列的，因此他的目标是最大化 $X$ 的值，使得他的挤奶顺序能够符合前 $X$ 个观察结果描述的状态。当多种挤奶顺序都能符合前 $X$ 个状态时，Farmer John 遵循一个长期以来的传统——编号较小的奶牛的地位高于编号较大的奶牛，因此他会最先给编号最小的奶牛挤奶。更正式地说，如果有多个挤奶顺序符合这些状态，Farmer John 会采用字典序最小的那一个。挤奶顺序 $x$ 的字典序比挤奶顺序 $y$ 小，如果对于某个 $j$，$x_i = y_i$ 对所有 $i < j$ 成立，并且 $x_j < y_j$（即这两个挤奶顺序到某个位置之前完全相同，而在该位置上 $x$ 比 $y$ 小）。\n\n请帮助 Farmer John 确定给奶牛挤奶的最佳顺序。", "inputFormat": "第一行包含 $N$ 和 $M$。接下来的 $M$ 行，每行描述了一个观察结果。第 $i+1$ 行描述了观察结果 $i$，第一个数是观察结果中的奶牛数量 $m_i$，后面是一列 $m_i$ 个整数，给出这次观察中奶牛的顺序。所有 $m_i$ 的总和至多为 $200,000$。", "outputFormat": "输出 $N$ 个空格分隔的整数，表示一个 $1 \\ldots N$ 的排列，为 Farmer John 给他的奶牛们挤奶应该采用的顺序。", "hint": "在这个例子中，Farmer John 有四头奶牛，他的挤奶顺序应该满足以下规则：奶牛 $1$ 在奶牛 $2$ 之前、奶牛 $2$ 在奶牛 $3$ 之前（第一个观察结果），奶牛 $4$ 在奶牛 $2$ 之前（第二个观察结果），奶牛 $3$ 在奶牛 $4$ 之前、奶牛 $4$ 在奶牛 $1$ 之前（第三个观察结果）。前两个观察结果可以同时被满足，但 Farmer John 不能同时满足所有规则，因为这会要求奶牛 $1$ 在奶牛 $3$ 之前，同时奶牛 $3$ 在奶牛 $1$ 之前。\n\n这意味着总共有两种可能的挤奶顺序：$1\\ 4\\ 2\\ 3$ 和 $4\\ 1\\ 2\\ 3$，第一种是字典序较小的。\n\n题目来源：Jay Leeds", "locale": "zh-CN"}}}
{"pid": "P4377", "type": "P", "difficulty": 5, "samples": [["3 15\n20 21\n10 11\n30 31", "1066\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2018", "二分", "USACO", "背包 DP", "分数规划"], "title": "[USACO18OPEN] Talent Show G", "background": "", "description": "Farmer John 要带着他的 $n$ 头奶牛，方便起见编号为 $1\\ldots n$，到农业展览会上去，参加每年的达牛秀！他的第 $i$ 头奶牛重量为 $w_i$，才艺水平为 $t_i$，两者都是整数。\n\n在到达时，Farmer John 就被今年达牛秀的新规则吓到了：\n\n（一）参加比赛的一组奶牛必须总重量至少为 $W$（这是为了确保是强大的队伍在比赛，而不仅是强大的某头奶牛），并且。\n\n（二）总才艺值与总重量的比值最大的一组获得胜利。\n\nFJ 注意到他的所有奶牛的总重量不小于 $W$，所以他能够派出符合规则（一）的队伍。帮助他确定这样的队伍中能够达到的最佳的才艺与重量的比值。", "inputFormat": "第一行是两个整数，分别表示牛的个数 $n$ 和总重量限制 $W$。\n\n第 $2$ 到 $(n+1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数表示第 $i$ 头奶牛的重量 $w_i$ 和才艺水平 $t_i$。", "outputFormat": "请求出 Farmer 用一组总重量最少为 $W$ 的奶牛最大可能达到的总才艺值与总重量的比值。\n\n如果你的答案是 $A$，输出 $1000A$ 向下取整的值，以使得输出是整数（当问题中的数不是一个整数的时候，向下取整操作在向下舍入到整数的时候去除所有小数部分）。\n\n请注意当问题的答案恰好是整数 $x$ 时，你的程序可能会由于**浮点数精度误差**问题最后得到一个 $x-\\epsilon$ 的答案，向下取整后变为 $x-1$ 导致答案错误。这种情况下你可以在输出答案前给答案加上一个极小的值 $x\\gets x+10^{-k}$ 来避免该问题。", "hint": "#### 样例解释\n\n在这个例子中，总体来看最佳的才艺与重量的比值应该是仅用一头才艺值为 $11$、重量为 $10$ 的奶牛，但是由于我们需要至少 $15$ 单位的重量，最优解最终为使用这头奶牛加上才艺值为 $21$、重量为 $20$ 的奶牛。这样的话才艺与重量的比值为 $\\frac{11+21}{10+20}=\\frac{32}{30} = 1.0666\\dots$，乘以 $1000$ 向下取整之后得到 $1066$。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 250$，$1 \\leq W \\leq 1000$，$1 \\leq w_i \\leq 10^6$，$1 \\leq t_i \\leq 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Talent Show G", "background": "", "description": "Farmer John is taking his $n$ cows, conveniently numbered $1 \\ldots n$, to the agricultural fair to participate in the annual Talent Show. His $i$-th cow has weight $w_i$ and talent $t_i$, both integers.\n\nUpon arrival, Farmer John is alarmed by the new rules for this year's show:\n\n(1) A participating group of cows must have total weight at least $W$ (this is to ensure strong teams compete, not just a single strong cow), and\n\n(2) The group with the maximum ratio of total talent to total weight wins.\n\nFJ notices that the total weight of all his cows is at least $W$, so he can send a team that satisfies rule (1). Help him determine the best achievable ratio of total talent to total weight among such teams.", "inputFormat": "The first line contains two integers, the number of cows $n$ and the weight threshold $W$.\n\nLines $2$ through $(n+1)$ each contain two integers. The integers on line $(i+1)$ give the weight $w_i$ and talent $t_i$ of the $i$-th cow.", "outputFormat": "Compute the maximum possible ratio of total talent to total weight for a group of cows whose total weight is at least $W$.\n\nIf your answer is $A$, output the value of $1000A$ rounded down to an integer (i.e., take the floor; when a number is not an integer, flooring removes all fractional digits).\n\nNote that if the exact answer is an integer $x$, your program may produce $x - \\epsilon$ due to floating-point precision and, after flooring, incorrectly output $x - 1$. In this case, you can add a tiny value before flooring, e.g., $x \\gets x + 10^{-k}$, to avoid this issue.", "hint": "#### Sample Explanation\n\nIn this example, the globally best ratio of talent to weight would be achieved by using only the cow with talent $11$ and weight $10$. However, since we need at least $15$ units of weight, the optimal solution is to use that cow together with the cow of talent $21$ and weight $20$. The resulting ratio is $\\frac{11+21}{10+20}=\\frac{32}{30} = 1.0666\\dots$, which becomes $1066$ after multiplying by $1000$ and taking the floor.\n\n#### Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq n \\leq 250$, $1 \\leq W \\leq 1000$, $1 \\leq w_i \\leq 10^6$, and $1 \\leq t_i \\leq 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Talent Show G", "background": "", "description": "Farmer John 要带着他的 $n$ 头奶牛，方便起见编号为 $1\\ldots n$，到农业展览会上去，参加每年的达牛秀！他的第 $i$ 头奶牛重量为 $w_i$，才艺水平为 $t_i$，两者都是整数。\n\n在到达时，Farmer John 就被今年达牛秀的新规则吓到了：\n\n（一）参加比赛的一组奶牛必须总重量至少为 $W$（这是为了确保是强大的队伍在比赛，而不仅是强大的某头奶牛），并且。\n\n（二）总才艺值与总重量的比值最大的一组获得胜利。\n\nFJ 注意到他的所有奶牛的总重量不小于 $W$，所以他能够派出符合规则（一）的队伍。帮助他确定这样的队伍中能够达到的最佳的才艺与重量的比值。", "inputFormat": "第一行是两个整数，分别表示牛的个数 $n$ 和总重量限制 $W$。\n\n第 $2$ 到 $(n+1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数表示第 $i$ 头奶牛的重量 $w_i$ 和才艺水平 $t_i$。", "outputFormat": "请求出 Farmer 用一组总重量最少为 $W$ 的奶牛最大可能达到的总才艺值与总重量的比值。\n\n如果你的答案是 $A$，输出 $1000A$ 向下取整的值，以使得输出是整数（当问题中的数不是一个整数的时候，向下取整操作在向下舍入到整数的时候去除所有小数部分）。\n\n请注意当问题的答案恰好是整数 $x$ 时，你的程序可能会由于**浮点数精度误差**问题最后得到一个 $x-\\epsilon$ 的答案，向下取整后变为 $x-1$ 导致答案错误。这种情况下你可以在输出答案前给答案加上一个极小的值 $x\\gets x+10^{-k}$ 来避免该问题。", "hint": "#### 样例解释\n\n在这个例子中，总体来看最佳的才艺与重量的比值应该是仅用一头才艺值为 $11$、重量为 $10$ 的奶牛，但是由于我们需要至少 $15$ 单位的重量，最优解最终为使用这头奶牛加上才艺值为 $21$、重量为 $20$ 的奶牛。这样的话才艺与重量的比值为 $\\frac{11+21}{10+20}=\\frac{32}{30} = 1.0666\\dots$，乘以 $1000$ 向下取整之后得到 $1066$。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 250$，$1 \\leq W \\leq 1000$，$1 \\leq w_i \\leq 10^6$，$1 \\leq t_i \\leq 10^3$。", "locale": "zh-CN"}}}
{"pid": "P4378", "type": "P", "difficulty": 3, "samples": [["5\n1\n5\n3\n8\n2", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "树状数组", "排序"], "title": "[USACO18OPEN] Out of Sorts S", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。\n\n她到目前为止最喜欢的算法是“冒泡排序”。这是 Bessie 的对长度为 $N$ 的数组 $A$ 进行排序的奶牛码实现。\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n显然，奶牛码中的“moo”指令的作用只是输出“moo”。奇怪的是，Bessie 看上去执着于在她的代码中的不同位置使用这个语句。\n\n给定一个输入数组，请预测 Bessie 的代码会输出多少次“moo”。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围为 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出“moo”被输出的次数。", "hint": "供题：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Out of Sorts S", "background": "", "description": "With an eye on the possibility of a long-term career off the farm, the cow Bessie has started learning algorithms on various online programming sites.\n\nHer favorite algorithm so far is bubble sort. This is Bessie's cow-code implementation for sorting an array $A$ of length $N$.\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n\nObviously, the 'moo' instruction in the cow-code simply prints 'moo'. Strangely, Bessie seems fixated on using this statement at different places in her code.\n\nGiven an input array, predict how many times Bessie's code will print 'moo'.", "inputFormat": "The first line contains $N$ ($1 \\leq N \\leq 100{,}000$). The next $N$ lines describe $A[0] \\ldots A[N-1]$, each an integer in the range $0 \\ldots 10^9$. The values are not guaranteed to be distinct.", "outputFormat": "Output the number of times 'moo' is printed.", "hint": "Setter: Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Out of Sorts S", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。\n\n她到目前为止最喜欢的算法是“冒泡排序”。这是 Bessie 的对长度为 $N$ 的数组 $A$ 进行排序的奶牛码实现。\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n显然，奶牛码中的“moo”指令的作用只是输出“moo”。奇怪的是，Bessie 看上去执着于在她的代码中的不同位置使用这个语句。\n\n给定一个输入数组，请预测 Bessie 的代码会输出多少次“moo”。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围为 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出“moo”被输出的次数。", "hint": "供题：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4379", "type": "P", "difficulty": 2, "samples": [["5\n7 1 400 2 2", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2018", "USACO", "排序"], "title": "[USACO18OPEN] Lemonade Line S", "background": "", "description": "这是农场上一个炎热的夏日，Farmer John 要给他的 $N$ 头奶牛发柠檬汽水了！所有的 $N$ 头奶牛（编号为 $1 \\dots N$）都喜欢柠檬汽水，只是有些喜欢的程度更高一些。具体来说，奶牛 $i$ 为了获得柠檬汽水，最多愿意排在 $w_i$ 头奶牛之后。现在所有的 $N$ 头奶牛都在田里，但只要 Farmer John 敲响牛铃，这些奶牛就会立刻赶到柠檬汽水站。她们会在 Farmer John 开始分发柠檬汽水之前到达，但没有两头奶牛会在同一时刻到达。此外，当奶牛 $i$ 到达时，当且仅当队伍中至多有 $w_i$ 头奶牛时，她才会加入队伍。\n\nFarmer John 想要提前准备一定量的柠檬汽水，但他不想浪费。排队的奶牛数量可能取决于她们的到达顺序。请帮助他求出在所有可能的到达顺序下，最小的可能排队奶牛数量。\n", "inputFormat": "第一行包含 $N$，第二行包含 $N$ 个用空格分隔的整数 $w_1, w_2, \\dots, w_N$。输入保证 $1 \\leq N \\leq 10^5$，此外对于每头奶牛 $i$，$0 \\leq w_i \\leq 10^9$。", "outputFormat": "输出在所有可能的奶牛到达顺序下，最小的可能排队奶牛数量。", "hint": "在这个情况下，可能最后仅有三头奶牛在队伍中（这也是最小可能值）。假设 $w = 7$ 和 $w = 400$ 的奶牛先到并等在队伍中。然后 $w = 1$ 的奶牛到达并且会离开，因为已经有 $2$ 头奶牛在队伍中了。接着 $w = 2$ 的两头奶牛到达，一头留下排队，另一头离开。\n\n供题：Dhruv Rohatgi", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Lemonade Line S", "background": "", "description": "It is a hot summer day on the farm, and Farmer John is handing out lemonade to his $N$ cows! All $N$ cows (numbered $1 \\dots N$) like lemonade, though some like it more than others. Specifically, cow $i$ is willing to stand behind at most $w_i$ other cows to get lemonade. All $N$ cows are currently out in the field, but as soon as Farmer John rings the cowbell, they will immediately head to the lemonade stand. They will all arrive before Farmer John begins distributing lemonade, and no two cows arrive at the same time. Additionally, when cow $i$ arrives, she joins the line if and only if there are at most $w_i$ cows in the line.\n\nFarmer John wants to prepare some amount of lemonade in advance, but he does not want to waste any. The number of cows who line up may depend on their arrival order. Please help him determine, over all possible arrival orders, the minimum possible number of cows that end up in line.", "inputFormat": "The first line contains $N$. The second line contains $N$ space-separated integers $w_1, w_2, \\dots, w_N$. The input guarantees $1 \\leq N \\leq 10^5$, and for each cow $i$, $0 \\leq w_i \\leq 10^9$.", "outputFormat": "Output the minimum possible number of cows in line over all possible arrival orders.", "hint": "For example, it is possible that only three cows end up in the line (which is also the minimum possible). Suppose the cows with $w = 7$ and $w = 400$ arrive first and wait in line. Then the cow with $w = 1$ arrives and leaves because there are already $2$ cows in line. Next, two cows with $w = 2$ arrive; one stays in line and the other leaves.\n\nProblem setter: Dhruv Rohatgi.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Lemonade Line S", "background": "", "description": "这是农场上一个炎热的夏日，Farmer John 要给他的 $N$ 头奶牛发柠檬汽水了！所有的 $N$ 头奶牛（编号为 $1 \\dots N$）都喜欢柠檬汽水，只是有些喜欢的程度更高一些。具体来说，奶牛 $i$ 为了获得柠檬汽水，最多愿意排在 $w_i$ 头奶牛之后。现在所有的 $N$ 头奶牛都在田里，但只要 Farmer John 敲响牛铃，这些奶牛就会立刻赶到柠檬汽水站。她们会在 Farmer John 开始分发柠檬汽水之前到达，但没有两头奶牛会在同一时刻到达。此外，当奶牛 $i$ 到达时，当且仅当队伍中至多有 $w_i$ 头奶牛时，她才会加入队伍。\n\nFarmer John 想要提前准备一定量的柠檬汽水，但他不想浪费。排队的奶牛数量可能取决于她们的到达顺序。请帮助他求出在所有可能的到达顺序下，最小的可能排队奶牛数量。\n", "inputFormat": "第一行包含 $N$，第二行包含 $N$ 个用空格分隔的整数 $w_1, w_2, \\dots, w_N$。输入保证 $1 \\leq N \\leq 10^5$，此外对于每头奶牛 $i$，$0 \\leq w_i \\leq 10^9$。", "outputFormat": "输出在所有可能的奶牛到达顺序下，最小的可能排队奶牛数量。", "hint": "在这个情况下，可能最后仅有三头奶牛在队伍中（这也是最小可能值）。假设 $w = 7$ 和 $w = 400$ 的奶牛先到并等在队伍中。然后 $w = 1$ 的奶牛到达并且会离开，因为已经有 $2$ 头奶牛在队伍中了。接着 $w = 2$ 的两头奶牛到达，一头留下排队，另一头离开。\n\n供题：Dhruv Rohatgi", "locale": "zh-CN"}}}
{"pid": "P4380", "type": "P", "difficulty": 5, "samples": [["4\n2 3 9 3\n4 9 9 1\n9 9 1 7\n2 1 1 9", "5\n10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "并查集", "枚举", "随机化"], "title": "[USACO18OPEN] Multiplayer Moo S", "background": "", "description": "奶牛们提出了一款创新性的新游戏，令人惊讶的是她们给这款游戏取了个最没创意的名字：“Moo”。  \nMoo 游戏在一个由 $N \\times N$ 个正方形格子组成的棋盘上进行。一头奶牛可以通过大叫一声“哞！”然后把她的数字编号写在这个格子里来占有这个格子。\n\n在游戏结束时，每个格子中都包含一个数。此时，如果一头奶牛创建了一个由连通的格子组成的领域，且该领域的大小不小于其他所有领域，那么这头奶牛就获胜。一个“领域”被定义为一些具有相同数字编号的格子，其中每个格子都直接与另一个同一领域中的格子通过上、下、左或右相邻（对角线不计）。\n\n由于以单牛形式进行游戏有点无聊，奶牛们也对双牛组队进行游戏感兴趣。同一队的两头奶牛可以创建一个领域，但现在领域中的格子可以属于队伍中的任一头奶牛。\n\n给定游戏棋盘的最终状态，请帮助奶牛们计算：  \n1. 任何单头奶牛占有的最大领域包含的格子数量。  \n2. 任何两头奶牛组成的队伍占有的最大领域包含的格子数量。  \n\n注意，两头奶牛占有的领域必须同时包含队伍中两头奶牛的编号，不能仅仅包含一头。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 250$）。接下来的 $N$ 行，每行包含 $N$ 个整数（每个整数在 $0 \\ldots 10^6$ 之间），描述棋盘的最终状态。棋盘中至少出现两种不同的数字。", "outputFormat": "输出的第一行描述任何单头奶牛占有的最大领域大小，第二行描述任何两头奶牛的队伍占有的最大领域大小。", "hint": "在这个例子中，单头奶牛占有的最大领域是由五个 $9$ 组成的。如果编号为 $1$ 和 $9$ 的奶牛组队，她们可以形成一个大小为 $10$ 的领域。\n\n供题：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Multiplayer Moo S", "background": "", "description": "The cows have invented a new game, and surprisingly, they gave it the least creative name: \"Moo\".\nThe Moo game is played on a board consisting of $N \\times N$ square cells. A cow can claim a cell by shouting \"Moo!\" and then writing her numeric ID in that cell.\n\nAt the end of the game, each cell contains a number. At that point, if a cow has created a region of connected cells and that region is at least as large as every other region, then that cow wins. A \"region\" is defined as a set of cells with the same numeric ID, where each cell is directly adjacent (up, down, left, or right) to another cell in the same region (diagonals do not count).\n\nSince playing solo can be a bit boring, the cows are also interested in playing in two-cow teams. Two cows on the same team can form a region, but now the cells in the region may belong to either cow on the team.\n\nGiven the final state of the game board, please help the cows compute:\n1. The number of cells in the largest region owned by any single cow.\n2. The number of cells in the largest region owned by any team of two cows.\n\nNote that a region owned by two cows must contain IDs from both cows on the team; it cannot contain only one cow’s ID.", "inputFormat": "The first line contains $N$ ($1 \\leq N \\leq 250$). Each of the next $N$ lines contains $N$ integers (each in the range $0 \\ldots 10^6$), describing the final state of the board. The board contains at least two distinct numbers.", "outputFormat": "Output two lines: the first line is the size of the largest region owned by any single cow, and the second line is the size of the largest region owned by any two-cow team.", "hint": "In this example, the largest single-cow region consists of five $9$s. If cows with IDs $1$ and $9$ form a team, they can form a region of size $10$.\n\nProblem by: Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Multiplayer Moo S", "background": "", "description": "奶牛们提出了一款创新性的新游戏，令人惊讶的是她们给这款游戏取了个最没创意的名字：“Moo”。  \nMoo 游戏在一个由 $N \\times N$ 个正方形格子组成的棋盘上进行。一头奶牛可以通过大叫一声“哞！”然后把她的数字编号写在这个格子里来占有这个格子。\n\n在游戏结束时，每个格子中都包含一个数。此时，如果一头奶牛创建了一个由连通的格子组成的领域，且该领域的大小不小于其他所有领域，那么这头奶牛就获胜。一个“领域”被定义为一些具有相同数字编号的格子，其中每个格子都直接与另一个同一领域中的格子通过上、下、左或右相邻（对角线不计）。\n\n由于以单牛形式进行游戏有点无聊，奶牛们也对双牛组队进行游戏感兴趣。同一队的两头奶牛可以创建一个领域，但现在领域中的格子可以属于队伍中的任一头奶牛。\n\n给定游戏棋盘的最终状态，请帮助奶牛们计算：  \n1. 任何单头奶牛占有的最大领域包含的格子数量。  \n2. 任何两头奶牛组成的队伍占有的最大领域包含的格子数量。  \n\n注意，两头奶牛占有的领域必须同时包含队伍中两头奶牛的编号，不能仅仅包含一头。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 250$）。接下来的 $N$ 行，每行包含 $N$ 个整数（每个整数在 $0 \\ldots 10^6$ 之间），描述棋盘的最终状态。棋盘中至少出现两种不同的数字。", "outputFormat": "输出的第一行描述任何单头奶牛占有的最大领域大小，第二行描述任何两头奶牛的队伍占有的最大领域大小。", "hint": "在这个例子中，单头奶牛占有的最大领域是由五个 $9$ 组成的。如果编号为 $1$ 和 $9$ 的奶牛组队，她们可以形成一个大小为 $10$ 的领域。\n\n供题：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4381", "type": "P", "difficulty": 5, "samples": [["7\n3 8\n7 2\n4 2\n1 4\n1 9\n3 4\n2 3", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2008", "IOI", "O2优化", "树的直径", "栈", "队列", "基环树"], "title": "[IOI 2008] Island", "background": "", "description": "你准备浏览一个公园，该公园由 $N$ 个岛屿组成，当地管理部门从每个岛屿 $i$ 出发向另外一个岛屿建了一座长度为 $L_i$ 的桥，不过桥是可以双向行走的。同时，每对岛屿之间都有一艘专用的往来两岛之间的渡船。相对于乘船而言，你更喜欢步行。你希望经过的桥的总长度尽可能长，但受到以下的限制：\n\n- 可以自行挑选一个岛开始游览。\n- 任何一个岛都不能游览一次以上。\n- 无论任何时间，你都可以由当前所在的岛 $S$ 去另一个从未到过的岛 $D$。从 $S$ 到 $D$ 有如下方法：\n  - 步行：仅当两个岛之间有一座桥时才有可能。对于这种情况，桥的长度会累加到你步行的总距离中。\n  - 渡船：你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 $S$ 走到 $D$ (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。\n\n注意，你不必游览所有的岛，也可能无法走完所有的桥。\n\n请你编写一个程序，给定 $N$ 座桥以及它们的长度，按照上述的规则，计算你可以走过的桥的长度之和的最大值。", "inputFormat": "第一行包含一个整数 $N$，即公园内岛屿的数目。\n\n随后的 $N$ 行每一行用来表示一个岛。第 $i$ 行由两个以单空格分隔的整数，表示由岛 $i$ 筑的桥。第一个整数表示桥另一端的岛，第二个整数表示该桥的长度 $L_i$。你可以假设对于每座桥，其端点总是位于不同的岛上。", "outputFormat": "仅包含一个整数，即可能的最大步行距离。", "hint": "**样例解释**：\n\n![样例图示](https://cdn.vijos.org/fs/c82895f1d6f84d5756610176662d6ee644c3e55e)\n\n样例 $N=7$ 座桥，分别为 $(1-3), (2-7), (3-4), (4-1), (5-1), (6-3)$ 以及 $(7-2)$。注意连接岛 $2$ 与岛 $7$ 之间有两座不同的桥。\n\n其中一个可以取得最大的步行距离的方法如下：\n\n- 由岛 $5$ 开始。\n- 步行长度为 $9$ 的桥到岛 $1$。\n- 步行长度为 $8$ 的桥到岛 $3$。\n- 步行长度为 $4$ 的桥到岛 $6$。\n- 搭渡船由岛 $6$ 到岛 $7$。\n- 步行长度为 $3$ 的桥到岛 $2$。\n\n最后，你到达岛 $2$，而你的总步行距离为 $9+8+4+3=24$。\n\n只有岛 $4$ 没有去。注意，上述游览结束时，你不能再游览这个岛。更准确地说：\n\n- 你不可以步行去游览，因为没有桥连接岛 $2$ (你现在的岛) 与岛 $4$。\n- 你不可以搭渡船去游览，因为你可由当前所在的岛 $2$ 到达岛 $4$。一个方法是：走 $(2-7)$ 桥，再搭你曾搭过的渡船由岛 $7$ 去岛 $6$，然后走 $(6-3)$ 桥，最后走 $(3-4)$ 桥。\n\n**数据范围**：\n\n对于 $100\\%$ 的数据，$2\\leqslant N\\leqslant 10^6,1\\leqslant L_i\\leqslant 10^8$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2008] Island", "background": "", "description": "You plan to tour a park that consists of $N$ islands. From each island $i$, the local authority has built a bridge to another island, with length $L_i$, and bridges can be walked in both directions. In addition, for every pair of islands there is a dedicated ferry that connects the two. Compared with taking a ferry, you prefer walking. You want the total length of bridges you walk across to be as large as possible, subject to the following rules:\n\n- You may choose any island to start your tour.\n- No island may be visited more than once.\n- At any time, you may move from your current island $S$ to another unvisited island $D$. You may do so in one of the following ways:\n  - Walk: only if there is a bridge directly between the two islands. In this case, the bridge length is added to your total walking distance.\n  - Ferry: you may choose this only if there is no combination of bridges and ferries you have already used that allows you to get from $S$ to $D$. When checking reachability, you should consider all paths, including those that pass through islands you have already visited.\n\nNote that you do not have to visit all the islands, and you might be unable to walk across all the bridges.\n\nWrite a program that, given $N$ bridges and their lengths, computes the maximum possible sum of bridge lengths you can walk under the rules above.", "inputFormat": "The first line contains an integer $N$, the number of islands in the park.\n\nEach of the next $N$ lines describes one island. The $i$-th line contains two integers, separated by a single space, describing the bridge built from island $i$: the first integer is the other endpoint island, and the second integer is the bridge length $L_i$. You may assume that the endpoints of every bridge are always different islands.", "outputFormat": "Output a single integer, the maximum possible walking distance.", "hint": "Sample explanation:\n\n![Sample illustration](https://cdn.vijos.org/fs/c82895f1d6f84d5756610176662d6ee644c3e55e)\n\nIn the sample, $N=7$ bridges are $(1-3)$, $(2-7)$, $(3-4)$, $(4-1)$, $(5-1)$, $(6-3)$, and $(7-2)$. Note that there are two different bridges between islands $2$ and $7$.\n\nOne way to achieve the maximum walking distance is as follows:\n- Start at island $5$.\n- Walk across the bridge of length $9$ to island $1$.\n- Walk across the bridge of length $8$ to island $3$.\n- Walk across the bridge of length $4$ to island $6$.\n- Take the ferry from island $6$ to island $7$.\n- Walk across the bridge of length $3$ to island $2$.\n\nYou end at island $2$, and your total walking distance is $9+8+4+3=24$.\n\nOnly island $4$ is not visited. Note that, at the end of the tour above, you cannot visit that island. More precisely:\n- You cannot walk there because there is no bridge between island $2$ (your current island) and island $4$.\n- You cannot take a ferry there because island $4$ is reachable from your current island $2$. One possible way is: take bridge $(2-7)$, then the previously used ferry from island $7$ to island $6$, then take bridge $(6-3)$, and finally bridge $(3-4)$.\n\nConstraints:\nFor $100\\%$ of the testdata, $2 \\leqslant N \\leqslant 10^6$, $1 \\leqslant L_i \\leqslant 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2008] Island", "background": "", "description": "你准备浏览一个公园，该公园由 $N$ 个岛屿组成，当地管理部门从每个岛屿 $i$ 出发向另外一个岛屿建了一座长度为 $L_i$ 的桥，不过桥是可以双向行走的。同时，每对岛屿之间都有一艘专用的往来两岛之间的渡船。相对于乘船而言，你更喜欢步行。你希望经过的桥的总长度尽可能长，但受到以下的限制：\n\n- 可以自行挑选一个岛开始游览。\n- 任何一个岛都不能游览一次以上。\n- 无论任何时间，你都可以由当前所在的岛 $S$ 去另一个从未到过的岛 $D$。从 $S$ 到 $D$ 有如下方法：\n  - 步行：仅当两个岛之间有一座桥时才有可能。对于这种情况，桥的长度会累加到你步行的总距离中。\n  - 渡船：你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 $S$ 走到 $D$ (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。\n\n注意，你不必游览所有的岛，也可能无法走完所有的桥。\n\n请你编写一个程序，给定 $N$ 座桥以及它们的长度，按照上述的规则，计算你可以走过的桥的长度之和的最大值。", "inputFormat": "第一行包含一个整数 $N$，即公园内岛屿的数目。\n\n随后的 $N$ 行每一行用来表示一个岛。第 $i$ 行由两个以单空格分隔的整数，表示由岛 $i$ 筑的桥。第一个整数表示桥另一端的岛，第二个整数表示该桥的长度 $L_i$。你可以假设对于每座桥，其端点总是位于不同的岛上。", "outputFormat": "仅包含一个整数，即可能的最大步行距离。", "hint": "**样例解释**：\n\n![样例图示](https://cdn.vijos.org/fs/c82895f1d6f84d5756610176662d6ee644c3e55e)\n\n样例 $N=7$ 座桥，分别为 $(1-3), (2-7), (3-4), (4-1), (5-1), (6-3)$ 以及 $(7-2)$。注意连接岛 $2$ 与岛 $7$ 之间有两座不同的桥。\n\n其中一个可以取得最大的步行距离的方法如下：\n\n- 由岛 $5$ 开始。\n- 步行长度为 $9$ 的桥到岛 $1$。\n- 步行长度为 $8$ 的桥到岛 $3$。\n- 步行长度为 $4$ 的桥到岛 $6$。\n- 搭渡船由岛 $6$ 到岛 $7$。\n- 步行长度为 $3$ 的桥到岛 $2$。\n\n最后，你到达岛 $2$，而你的总步行距离为 $9+8+4+3=24$。\n\n只有岛 $4$ 没有去。注意，上述游览结束时，你不能再游览这个岛。更准确地说：\n\n- 你不可以步行去游览，因为没有桥连接岛 $2$ (你现在的岛) 与岛 $4$。\n- 你不可以搭渡船去游览，因为你可由当前所在的岛 $2$ 到达岛 $4$。一个方法是：走 $(2-7)$ 桥，再搭你曾搭过的渡船由岛 $7$ 去岛 $6$，然后走 $(6-3)$ 桥，最后走 $(3-4)$ 桥。\n\n**数据范围**：\n\n对于 $100\\%$ 的数据，$2\\leqslant N\\leqslant 10^6,1\\leqslant L_i\\leqslant 10^8$。\n", "locale": "zh-CN"}}}
{"pid": "P4382", "type": "P", "difficulty": 7, "samples": [["3 5\n2 2\n1 1\n2 2\n1 2\n1 1\n2 2\n1 1\n1 2\n1 2\n2 1\n2 2\n1 1\n0 1\n0 1\n2 2", "2 1\n1 0\n1 2\n0 1\n1 3\n0 1"], ["1 5\n4 3\n2 1 1\n3 1 3\n0 0 1\n3 1 2\n2 3 1\n2 3 3 3", "1 1 3 2\n0 0 0 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "各省省选", "网络流", "O2优化", "枚举", "图论建模"], "title": "[八省联考 2018] 劈配", "background": "一年一度的综艺节目《中国新代码》又开始了。Zayid 从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。", "description": "轻车熟路的 Zayid 顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：\n\n总共 $n$ 名参赛选手（编号从 $1$ 至 $n$ ）每人写出一份代码并介绍自己的梦想。接着 由所有导师对这些选手进行排名。为了避免后续的麻烦，规定**不存在排名并列的情况**。\n\n同时，每名选手都将独立地填写一份志愿表，来对总共 $m$ 位导师（编号从 $1$ 至 $m$ ）作出评价。志愿表上包含了共 $m$ 档志愿。对于每一档志愿，选手被允许填写最多 $C$ 位导师，每位导师最多被每位选手填写**一次**（**放弃某些导师也是被允许的**）。\n\n在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。节目组对“前 $i$ 名的录取结果最优”作出如下定义：\n\n- 前 $1$ 名的录取结果最优，**当且仅当**第 $1$ 名被其最高非空志愿录取（**特别地**，如果第 $1$ 名没有填写志愿表，那么该选手出局）。\n\n- 前 $i$ 名的录取结果最优，当且仅当在前 $i - 1$ 名的录取结果最优的情况下，第 $i$ 名 被其理论可能的最高志愿录取（特别地，如果第 $i$ 名没有填写志愿表，或其所有志愿中的导师战队均已满员，那么该选手出局）。\n\n如果一种方案满足“前 $n$ 名的录取结果最优”，那么我们可以简称这种方案是**最优的**。\n\n举例而言，$2$ 位导师 $\\rm T$ 老师、 $\\rm F$ 老师的战队人数上限分别都是 $1$ 人；$2$ 位选手 Zayid 、DuckD 分列第 $1$ 、 $2$ 名。那么下面 $3$ 种志愿表及其对应的最优录取结果如表中所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/17003.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/17004.png)\n\n可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。\n\n每个人都有一个自己的理想值 $s_i$ ，表示第 $i$ 位同学希望自己被第 $s_i$ 或更高的志愿录取，如果没有，那么他就会非常沮丧。\n\n现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。\n\n对于每一位选手，Zayid 都想知道下面两个问题的答案：\n\n- 在最优的录取方案中，他会被第几志愿录取。\n\n- 在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。\n\n作为《中国新代码》的实力派代码手，Zayid 当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。", "inputFormat": "每个测试点包含多组测试数据，第一行 $2$ 个用空格隔开的非负整数 $T,C$ ，分别表示数据组数、每档志愿最多允许填写的导师数目。\n\n接下来依次描述每组数据，对于每组数据：\n\n- 第 $1$ 行两个用空格隔开的正整数 $n,m$ 。\n\n> $n,m$ 分别表示选手的数量、导师的数量。\n\n- 第 $2$ 行 $m$ 个用空格隔开的正整数：其中第 $i$ 个整数为 $b_i$ 。\n\n> $b_i$ 表示编号为 $i$ 的导师战队人数的上限。\n\n第 $3$ 行至第 $n + 2$ 行，每行 $m$ 个用空格隔开的非负整数：其中第 $i + 2$ 行左起第 $j$ 个数为 $a_{i,j}$ 。\n\n> $a_{i,j}$ 表示编号为 $i$ 的选手将编号为 $j$ 的导师编排在了第 $a_{i,j}$ 志愿。特别地，如果 $a_{i,j}= 0$ ，则表示该选手没有将该导师填入志愿表。\n\n> 在这一部分，保证每行中不存在某一个正数出现超过 $C$ 次（ **$0$ 可能出现超过 $C$ 次**），同时保证所有  $a_{i,j} \\leqslant m$ 。\n\n- 第 $n + 3$ 行 $n$ 个用空格隔开的正整数，其中第 $i$ 个整数为 $s_i$ 。\n\n> $s_i$ 表示编号为 $i$ 的选手的理想值。\n\n> 在这一部分，保证 $s_i \\leqslant m$ 。", "outputFormat": "按顺序输出每组数据的答案。对于每组数据，输出 $2$ 行：\n\n- 第 $1$ 行输出 $n$ 个用空格隔开的正整数，其中第 $i$ 个整数的意义为：\n\n\t在最优的录取方案中，编号为 $i$ 的选手会被该档志愿录取。\n\n> **特别地，如果该选手出局，则这个数为 $m + 1$** 。\n\n- 第 $2$ 行输出 $n$ 个用空格隔开的非负整数，其中第 $i$ 个整数的意义为：\n\n\t使编号为 $i$ 的选手不沮丧，最少需要让他上升的排名数。\n    \n> **特别地，如果该选手一定会沮丧，则这个数为 $i$ 。**", "hint": "- 样例 $1$ 解释\n\n三组数据分别与【题目描述】中的三个表格对应。\n\n对于第 $1$ 组数据：由于选手 $1$ 没有填写第一志愿，所以他一定无法被第一志愿录取，也就一定会沮丧。选手 $2$ 按原排名就不沮丧，因此他不需要提升排名。\n\n对于第 $2$ 组和第 $3$ 组数据： $1$ 号选手都不需要提升排名。而希望被第一志愿录取的 $2$ 号选手都必须升到第 $1$ 名才能如愿。\n\n- 样例 $2$ 解释\n\n$1$ 号选手的第一志愿只填写了 $2$ 号导师，因此 $1$ 号选手必定被 $2$ 号导师录取。\n\n$2$ 号选手的第一志愿只填写了 $3$ 号导师，因此 $2$ 号选手必定被 $3$ 号导师录取。\n\n由于 $2,3$ 号导师均满员，且 $3,4$ 号选手均填写了 $1$ 号导师，因此他们都会被 $1$ 号导师录取。\n\n所以 $1,2$ 号选手均被第 $1$ 志愿录取，$3$ 号选手被第 $3$ 志愿录取， $4$ 号选手被第 $2$ 志愿录取。\n\n由于他们都如愿以偿了，所以他们都不需要提升名次。\n\n\n|测试点编号|$n \\leqslant$|$m \\leqslant$|$C$|其他约定|\n|:----:|:---:|:----:|:----:|:----:|\n|1| $10$|$1$|$=1$|无|\n|2|$10$|$2$|$=2$|$s_i=m$|\n|3|$10$|$3$|$=3$|无|\n|4|$100$|$100$|$=1$|$b_i=1$|\n|5|$100$|$100$|$=1$|无|\n|6|$200$|$200$|$=1$|$b_i=1$|\n|7|$200$|$200$|$=1$|无|\n|8|$100$|$100$|$=10$|无|\n|9|$200$|$200$|$=10$|$b_i=1$|\n|10|$200$|$200$|$=10$|无|\n\n- 对于所有测试点，保证 $ T \\leqslant 5$ 。\n\n- 对于所有测试点钟的所有数据，保证 $ m \\leqslant n \\leqslant 200, b_i \\leqslant n$", "locale": "zh-CN", "translations": {"en": {"title": "[Eight-Province Joint Exam 2018] Pi Pei", "background": "The annual variety show \"China's New Code\" has begun again. Zayid has dreamed of becoming a programmer since childhood. He feels this is a stage to show himself, so he signed up without hesitation.", "description": "Skilled as usual, Zayid smoothly passed the open auditions. The next stage is the mentors' blind selection, with rules as follows:\n\nThere are $n$ contestants in total (numbered from $1$ to $n$). Each writes a piece of code and presents their dream. Then all mentors rank these contestants. To avoid future trouble, it is required that there are no ties in the rankings.\n\nAt the same time, each contestant independently fills out a preference form to evaluate the $m$ mentors (numbered from $1$ to $m$). The form contains $m$ preference tiers. For each tier, the contestant may list at most $C$ mentors, and each mentor may be listed at most once by each contestant (skipping some mentors is allowed).\n\nAfter both sides finish, admissions are carried out. Each mentor has an upper bound on their team size, which means some contestants' higher preferences, or even all their preferences, may not be met. The show defines \"the result for the top $i$ contestants is optimal\" as follows:\n\n- The result for the top $1$ contestant is optimal if and only if contestant $1$ is admitted to their highest nonempty preference (in particular, if contestant $1$ did not submit a preference form, then this contestant is eliminated).\n\n- The result for the top $i$ contestants is optimal if and only if, given that the result for the top $i - 1$ contestants is optimal, contestant $i$ is admitted to the highest preference that is theoretically possible (in particular, if contestant $i$ did not submit a preference form, or if all mentors in their preferences are already full, then this contestant is eliminated).\n\nIf a scheme satisfies \"the result for the top $n$ contestants is optimal,\" we simply call this scheme optimal.\n\nFor example, there are $2$ mentors, Teacher $\\rm T$ and Teacher $\\rm F$, each with a team size cap of $1$; there are $2$ contestants, Zayid and DuckD, ranked $1$ and $2$, respectively. Then the following $3$ preference forms and their corresponding optimal admission results are as shown in the tables:\n\n![](https://cdn.luogu.com.cn/upload/pic/17003.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/17004.png)\n\nIt can be proved that, for the above preference forms, the corresponding schemes are the unique optimal admission results.\n\nEveryone has an ideal value $s_i$, meaning that contestant $i$ hopes to be admitted to their $s_i$-th or better preference; otherwise, they will be very disappointed.\n\nNow all contestants' preference forms and rankings have been published. Coincidentally, each contestant's ranking exactly matches their ID.\n\nFor each contestant, Zayid wants to know the answers to the following two questions:\n\n- In the optimal admission scheme, to which preference tier will they be admitted?\n\n- With other contestants' relative order unchanged, by at least how many ranks must they climb so that they are not disappointed?\n\nAs a top-notch coder on \"China's New Code,\" Zayid certainly solved this problem easily. But he still wants you to compute it again to verify his result.", "inputFormat": "Each test point contains multiple testcases. The first line contains $2$ non-negative integers $T, C$ separated by a space, representing the number of testcases and the maximum number of mentors allowed per preference tier, respectively.\n\nThen for each testcase:\n\n- The first line contains two positive integers $n, m$ separated by a space.\n\n> $n, m$ denote the number of contestants and the number of mentors, respectively.\n\n- The second line contains $m$ positive integers separated by spaces: the $i$-th integer is $b_i$.\n\n> $b_i$ is the team size upper bound of mentor $i$.\n\nLines $3$ to $n + 2$ each contain $m$ non-negative integers: in line $i + 2$, the $j$-th number from the left is $a_{i,j}$.\n\n> $a_{i,j}$ means contestant $i$ placed mentor $j$ as their $a_{i,j}$-th preference. In particular, if $a_{i,j} = 0$, it means this contestant did not include this mentor on the form.\n\n> In this part, it is guaranteed that within each row no positive number appears more than $C$ times ($0$ may appear more than $C$ times), and all $a_{i,j} \\leqslant m$.\n\n- Line $n + 3$ contains $n$ positive integers separated by spaces, where the $i$-th integer is $s_i$.\n\n> $s_i$ is the ideal value of contestant $i$.\n\n> In this part, it is guaranteed that $s_i \\leqslant m$.", "outputFormat": "Output the answers for each testcase in order. For each testcase, output $2$ lines:\n\n- The first line contains $n$ positive integers separated by spaces. The $i$-th integer means:\n\n\tthe preference tier to which contestant $i$ will be admitted in the optimal scheme.\n\n> In particular, if this contestant is eliminated, this number is $m + 1$.\n\n- The second line contains $n$ non-negative integers separated by spaces. The $i$-th integer means:\n\n\tthe minimum number of ranks contestant $i$ must climb so as not to be disappointed.\n    \n> In particular, if this contestant will certainly be disappointed, this number is $i$.", "hint": "- Explanation for Sample $1$:\n\nThe three datasets correspond to the three tables in the Description.\n\nFor the first dataset: because contestant $1$ did not list any first preference, they definitely cannot be admitted to their first preference tier and will definitely be disappointed. Contestant $2$ is not disappointed with the original ranking, so they do not need to improve their rank.\n\nFor the second and third datasets: contestant $1$ does not need to improve their rank. Aiming for first preference, contestant $2$ must rise to rank $1$ to get their wish.\n\n- Explanation for Sample $2$:\n\nContestant $1$ listed only mentor $2$ as first preference, so contestant $1$ must be admitted by mentor $2$.\n\nContestant $2$ listed only mentor $3$ as first preference, so contestant $2$ must be admitted by mentor $3$.\n\nSince mentors $2$ and $3$ are full, and contestants $3$ and $4$ both listed mentor $1$, they will both be admitted by mentor $1$.\n\nTherefore, contestants $1$ and $2$ are both admitted to their $1$-st preference, contestant $3$ is admitted to their $3$-rd preference, and contestant $4$ is admitted to their $2$-nd preference.\n\nSince they all get what they want, none of them needs to improve their rank.\n\n| Test point ID | $n \\leqslant$ | $m \\leqslant$ | $C$ | Other conditions |\n|:----:|:---:|:----:|:----:|:----:|\n| 1 | $10$ | $1$ | $=1$ | None |\n| 2 | $10$ | $2$ | $=2$ | $s_i = m$ |\n| 3 | $10$ | $3$ | $=3$ | None |\n| 4 | $100$ | $100$ | $=1$ | $b_i = 1$ |\n| 5 | $100$ | $100$ | $=1$ | None |\n| 6 | $200$ | $200$ | $=1$ | $b_i = 1$ |\n| 7 | $200$ | $200$ | $=1$ | None |\n| 8 | $100$ | $100$ | $=10$ | None |\n| 9 | $200$ | $200$ | $=10$ | $b_i = 1$ |\n| 10 | $200$ | $200$ | $=10$ | None |\n\n- For all test points, it is guaranteed that $T \\leqslant 5$.\n\n- Across all data of all test points, it is guaranteed that $m \\leqslant n \\leqslant 200, b_i \\leqslant n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[八省联考 2018] 劈配", "background": "一年一度的综艺节目《中国新代码》又开始了。Zayid 从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。", "description": "轻车熟路的 Zayid 顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：\n\n总共 $n$ 名参赛选手（编号从 $1$ 至 $n$ ）每人写出一份代码并介绍自己的梦想。接着 由所有导师对这些选手进行排名。为了避免后续的麻烦，规定**不存在排名并列的情况**。\n\n同时，每名选手都将独立地填写一份志愿表，来对总共 $m$ 位导师（编号从 $1$ 至 $m$ ）作出评价。志愿表上包含了共 $m$ 档志愿。对于每一档志愿，选手被允许填写最多 $C$ 位导师，每位导师最多被每位选手填写**一次**（**放弃某些导师也是被允许的**）。\n\n在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。节目组对“前 $i$ 名的录取结果最优”作出如下定义：\n\n- 前 $1$ 名的录取结果最优，**当且仅当**第 $1$ 名被其最高非空志愿录取（**特别地**，如果第 $1$ 名没有填写志愿表，那么该选手出局）。\n\n- 前 $i$ 名的录取结果最优，当且仅当在前 $i - 1$ 名的录取结果最优的情况下，第 $i$ 名 被其理论可能的最高志愿录取（特别地，如果第 $i$ 名没有填写志愿表，或其所有志愿中的导师战队均已满员，那么该选手出局）。\n\n如果一种方案满足“前 $n$ 名的录取结果最优”，那么我们可以简称这种方案是**最优的**。\n\n举例而言，$2$ 位导师 $\\rm T$ 老师、 $\\rm F$ 老师的战队人数上限分别都是 $1$ 人；$2$ 位选手 Zayid 、DuckD 分列第 $1$ 、 $2$ 名。那么下面 $3$ 种志愿表及其对应的最优录取结果如表中所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/17003.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/17004.png)\n\n可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。\n\n每个人都有一个自己的理想值 $s_i$ ，表示第 $i$ 位同学希望自己被第 $s_i$ 或更高的志愿录取，如果没有，那么他就会非常沮丧。\n\n现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。\n\n对于每一位选手，Zayid 都想知道下面两个问题的答案：\n\n- 在最优的录取方案中，他会被第几志愿录取。\n\n- 在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。\n\n作为《中国新代码》的实力派代码手，Zayid 当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。", "inputFormat": "每个测试点包含多组测试数据，第一行 $2$ 个用空格隔开的非负整数 $T,C$ ，分别表示数据组数、每档志愿最多允许填写的导师数目。\n\n接下来依次描述每组数据，对于每组数据：\n\n- 第 $1$ 行两个用空格隔开的正整数 $n,m$ 。\n\n> $n,m$ 分别表示选手的数量、导师的数量。\n\n- 第 $2$ 行 $m$ 个用空格隔开的正整数：其中第 $i$ 个整数为 $b_i$ 。\n\n> $b_i$ 表示编号为 $i$ 的导师战队人数的上限。\n\n第 $3$ 行至第 $n + 2$ 行，每行 $m$ 个用空格隔开的非负整数：其中第 $i + 2$ 行左起第 $j$ 个数为 $a_{i,j}$ 。\n\n> $a_{i,j}$ 表示编号为 $i$ 的选手将编号为 $j$ 的导师编排在了第 $a_{i,j}$ 志愿。特别地，如果 $a_{i,j}= 0$ ，则表示该选手没有将该导师填入志愿表。\n\n> 在这一部分，保证每行中不存在某一个正数出现超过 $C$ 次（ **$0$ 可能出现超过 $C$ 次**），同时保证所有  $a_{i,j} \\leqslant m$ 。\n\n- 第 $n + 3$ 行 $n$ 个用空格隔开的正整数，其中第 $i$ 个整数为 $s_i$ 。\n\n> $s_i$ 表示编号为 $i$ 的选手的理想值。\n\n> 在这一部分，保证 $s_i \\leqslant m$ 。", "outputFormat": "按顺序输出每组数据的答案。对于每组数据，输出 $2$ 行：\n\n- 第 $1$ 行输出 $n$ 个用空格隔开的正整数，其中第 $i$ 个整数的意义为：\n\n\t在最优的录取方案中，编号为 $i$ 的选手会被该档志愿录取。\n\n> **特别地，如果该选手出局，则这个数为 $m + 1$** 。\n\n- 第 $2$ 行输出 $n$ 个用空格隔开的非负整数，其中第 $i$ 个整数的意义为：\n\n\t使编号为 $i$ 的选手不沮丧，最少需要让他上升的排名数。\n    \n> **特别地，如果该选手一定会沮丧，则这个数为 $i$ 。**", "hint": "- 样例 $1$ 解释\n\n三组数据分别与【题目描述】中的三个表格对应。\n\n对于第 $1$ 组数据：由于选手 $1$ 没有填写第一志愿，所以他一定无法被第一志愿录取，也就一定会沮丧。选手 $2$ 按原排名就不沮丧，因此他不需要提升排名。\n\n对于第 $2$ 组和第 $3$ 组数据： $1$ 号选手都不需要提升排名。而希望被第一志愿录取的 $2$ 号选手都必须升到第 $1$ 名才能如愿。\n\n- 样例 $2$ 解释\n\n$1$ 号选手的第一志愿只填写了 $2$ 号导师，因此 $1$ 号选手必定被 $2$ 号导师录取。\n\n$2$ 号选手的第一志愿只填写了 $3$ 号导师，因此 $2$ 号选手必定被 $3$ 号导师录取。\n\n由于 $2,3$ 号导师均满员，且 $3,4$ 号选手均填写了 $1$ 号导师，因此他们都会被 $1$ 号导师录取。\n\n所以 $1,2$ 号选手均被第 $1$ 志愿录取，$3$ 号选手被第 $3$ 志愿录取， $4$ 号选手被第 $2$ 志愿录取。\n\n由于他们都如愿以偿了，所以他们都不需要提升名次。\n\n\n|测试点编号|$n \\leqslant$|$m \\leqslant$|$C$|其他约定|\n|:----:|:---:|:----:|:----:|:----:|\n|1| $10$|$1$|$=1$|无|\n|2|$10$|$2$|$=2$|$s_i=m$|\n|3|$10$|$3$|$=3$|无|\n|4|$100$|$100$|$=1$|$b_i=1$|\n|5|$100$|$100$|$=1$|无|\n|6|$200$|$200$|$=1$|$b_i=1$|\n|7|$200$|$200$|$=1$|无|\n|8|$100$|$100$|$=10$|无|\n|9|$200$|$200$|$=10$|$b_i=1$|\n|10|$200$|$200$|$=10$|无|\n\n- 对于所有测试点，保证 $ T \\leqslant 5$ 。\n\n- 对于所有测试点钟的所有数据，保证 $ m \\leqslant n \\leqslant 200, b_i \\leqslant n$", "locale": "zh-CN"}}}
{"pid": "P4383", "type": "P", "difficulty": 7, "samples": [["5 1\n1 2 3\n2 3 5\n2 4 -3\n4 5 6", "14"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["动态规划 DP", "2018", "各省省选", "枚举", "凸完全单调性（wqs 二分）", "树的直径", "差分"], "title": "[八省联考 2018] 林克卡特树", "background": "", "description": "小 L 最近沉迷于塞尔达传说：荒野之息（The Legend of Zelda: Breath of The Wild）无法自拔，他尤其喜欢游戏中的迷你挑战。\n\n游戏中有一个叫做 LCT 的挑战，它的规则是这样子的：现在有一个 $N$ 个点的树，每条边有一个整数边权 $v_i$，若 $v_i \\geq 0$，表示走这条边会获得 $v_i$ 的收益；若 $v_i \\lt 0$ ，则表示走这条边需要支付 $-v_i$ 的过路费。小 L 需要控制主角 Link 切掉（Cut）树上的恰好 $K$ 条边，然后再连接 $K$ 条边权为 0 的边，得到一棵新的树。接着，他会选择树上的两个点 $p,q$，并沿着树上连接这两点的简单路径从 $p$ 走到 $q$，并为经过的每条边支付过路费/ 获取相应收益。\n\n海拉鲁大陆之神 TemporaryDO 想考验一下 Link。他告诉 Link，如果 Link 能切掉合适的边、选择合适的路径从而使 总收益 - 总过路费 最大化的话，就把传说中的大师之剑送给他。\n\n小 L 想得到大师之剑，于是他找到了你来帮忙，请你告诉他，Link 能得到的 总收益 - 总过路费 最大是多少。", "inputFormat": "输入第一行包含两个正整数 $N,K$。\n\n接下来 $N - 1$ 行，每行包含三个整数 $x_i,y_i,v_i$，表示第 $i$ 条边连接图中的 $x_i, y_i$ 两点，它的边权为 $v_i$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "### 样例解释\n\n一种可能的最优方案为：切掉 $(2, 4, -3)$ 这条边，连接 $(3, 4, 0)$ 这条边，选择 $(p, q) = (1, 5)$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$k = 0$；\n- 对于另外 $10\\%$ 的数据，$k = 1$；\n- 对于另外 $15\\%$ 的数据，$k = 2$；\n- 对于另外 $25\\%$ 的数据，$k \\leq 100$；\n- 对于其他数据，没有特殊约定。\n\n对于全部的测试数据，保证 $1 \\leq N \\leq 3 \\times 10^5$，$0 \\leq K \\leq 3 \\times 10^5$，$K \\lt N$，$1 \\leq x_i,y_i \\leq N$，$|v_i| \\leq 10^6$。\n\n### 提示\n\n题目并不难。", "locale": "zh-CN", "translations": {"en": {"title": "[Eight-Province Joint Exam 2018] Link-Cut Tree", "background": "", "description": "Little L has recently become obsessed with The Legend of Zelda: Breath of the Wild, and he especially enjoys the mini challenges.\n\nIn the game, there is a challenge called LCT. Its rules are as follows: There is a tree with $N$ nodes. Each edge has an integer weight $v_i$. If $v_i \\geq 0$, traversing this edge yields a gain of $v_i$; if $v_i \\lt 0$, traversing this edge requires paying a toll of $-v_i$. Little L needs to control the protagonist Link to cut exactly $K$ edges from the tree, then connect $K$ new edges each with weight $0$, producing a new tree. Next, he will choose two nodes $p, q$ on the tree, and walk from $p$ to $q$ along the unique simple path connecting them, paying tolls or obtaining gains for each edge he traverses.\n\nThe god of Hyrule, TemporaryDO, wants to test Link. He tells Link that if Link can cut appropriate edges and choose an appropriate path so that the total gain $-$ total toll is maximized, he will give him the legendary Master Sword.\n\nLittle L wants the Master Sword, so he asks you for help. Please tell him the maximum possible value of total gain $-$ total toll that Link can obtain.", "inputFormat": "The first line contains two positive integers $N, K$.\n\nThe next $N - 1$ lines each contain three integers $x_i, y_i, v_i$, indicating that the $i$-th edge connects nodes $x_i$ and $y_i$, and its weight is $v_i$.", "outputFormat": "Output a single integer, the answer.", "hint": "Sample Explanation:\nOne possible optimal plan is: cut edge $(2, 4, -3)$, add edge $(3, 4, 0)$, and choose $(p, q) = (1, 5)$.\n\nConstraints:\n- For $10\\%$ of the testdata, $K = 0$.\n- For another $10\\%$ of the testdata, $K = 1$.\n- For another $15\\%$ of the testdata, $K = 2$.\n- For another $25\\%$ of the testdata, $K \\leq 100$.\n- For the remaining testdata, there are no special constraints.\n\nFor all testdata, it is guaranteed that $1 \\leq N \\leq 3 \\times 10^5$, $0 \\leq K \\leq 3 \\times 10^5$, $K \\lt N$, $1 \\leq x_i, y_i \\leq N$, and $|v_i| \\leq 10^6$.\n\nHint:\nThis problem is not difficult.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[八省联考 2018] 林克卡特树", "background": "", "description": "小 L 最近沉迷于塞尔达传说：荒野之息（The Legend of Zelda: Breath of The Wild）无法自拔，他尤其喜欢游戏中的迷你挑战。\n\n游戏中有一个叫做 LCT 的挑战，它的规则是这样子的：现在有一个 $N$ 个点的树，每条边有一个整数边权 $v_i$，若 $v_i \\geq 0$，表示走这条边会获得 $v_i$ 的收益；若 $v_i \\lt 0$ ，则表示走这条边需要支付 $-v_i$ 的过路费。小 L 需要控制主角 Link 切掉（Cut）树上的恰好 $K$ 条边，然后再连接 $K$ 条边权为 0 的边，得到一棵新的树。接着，他会选择树上的两个点 $p,q$，并沿着树上连接这两点的简单路径从 $p$ 走到 $q$，并为经过的每条边支付过路费/ 获取相应收益。\n\n海拉鲁大陆之神 TemporaryDO 想考验一下 Link。他告诉 Link，如果 Link 能切掉合适的边、选择合适的路径从而使 总收益 - 总过路费 最大化的话，就把传说中的大师之剑送给他。\n\n小 L 想得到大师之剑，于是他找到了你来帮忙，请你告诉他，Link 能得到的 总收益 - 总过路费 最大是多少。", "inputFormat": "输入第一行包含两个正整数 $N,K$。\n\n接下来 $N - 1$ 行，每行包含三个整数 $x_i,y_i,v_i$，表示第 $i$ 条边连接图中的 $x_i, y_i$ 两点，它的边权为 $v_i$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "### 样例解释\n\n一种可能的最优方案为：切掉 $(2, 4, -3)$ 这条边，连接 $(3, 4, 0)$ 这条边，选择 $(p, q) = (1, 5)$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$k = 0$；\n- 对于另外 $10\\%$ 的数据，$k = 1$；\n- 对于另外 $15\\%$ 的数据，$k = 2$；\n- 对于另外 $25\\%$ 的数据，$k \\leq 100$；\n- 对于其他数据，没有特殊约定。\n\n对于全部的测试数据，保证 $1 \\leq N \\leq 3 \\times 10^5$，$0 \\leq K \\leq 3 \\times 10^5$，$K \\lt N$，$1 \\leq x_i,y_i \\leq N$，$|v_i| \\leq 10^6$。\n\n### 提示\n\n题目并不难。", "locale": "zh-CN"}}}
{"pid": "P4384", "type": "P", "difficulty": 7, "samples": [["5 2\n00100\n1 2\n1 3\n", "5\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "2018", "线段树", "倍增", "各省省选", "后缀自动机 SAM"], "title": "[八省联考 2018] 制胡窜", "background": "", "description": "对于一个字符串 $s$，我们定义 $|s|$ 表示 $s$ 的长度。\n\n接着，我们定义 $s_i$ 表示 $s$ 中第 $i$ 个字符，$s_{l,r}$ 表示由 $s$ 中从左往右数，第 $l$ 个字符到第 $r$ 个字符依次连接形成的字符串。特别的，如果 $l \\gt r$，或者 $l \\notin [1, |s|]$，或者 $r \\notin [1, |s|]$，我们可以认为 $s_{l,r}$ 为空串。\n\n给定一个长度为 $n$ 的仅由数字构成的字符串 $s$，现在有 $q$ 次询问，第 $k$ 次询问会给出 $s$ 的一个子串 $s_{l,r}$，请你求出有多少对 $(i, j)$，满足 $1 \\leq i \\lt j \\leq n$，$i + 1 < j$，且 $s_{l,r}$ 出现在 $s_{1,i}$ 中或 $s_{i+1,j-1}$中或 $s_{j,n}$ 中。", "inputFormat": "输入的第一行是两个整数，分别表示字符串长度 $n$ 和询问次数 $q$。\n\n第二行有一个长度为 $n$ 的只包含数字字符的字符串，表示 $s$。\n\n接下来 $q$ 行，每行两个正整数 $l$ 和 $r$，表示此次询问的子串是 $s_{l,r}$。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "|    测试点    |     $n$     |     $q$     |               其它约定                |\n| :----------: | :-------: | :-------: | :-----------------------------------: |\n|     $1$      |   $=50$   |  $=100$   |                  无                   |\n|  $2 \\sim 3$  |  $=300$   |  $=300$   |                  无                   |\n|  $4 \\sim 5$  |  $=2000$  |  $=3000$  |                  无                   |\n|  $6 \\sim 9$  | $=100000$ | $=100000$ | $\\sum \\lvert s_{l,r} \\rvert \\le 10^6$ |\n| $10 \\sim 12$ | $=30000$  | $=50000$  |                  无                   |\n|     $13$     | $=100000$ | $=100000$ |            $s$ 中只有 $0$             |\n| $14 \\sim 20$ | $=100000$ | $=300000$ |                  无                   |\n\n\n对于所有测试数据，$1 \\le n \\le 10^5$，$1 \\le q \\le 3 \\times 10^5$，$1 \\le l \\le r \\le n$，$s$ 中只有数字字符。", "locale": "zh-CN", "translations": {"en": {"title": "[Eight Provinces Joint Exam 2018] Zhi Hu Cuan", "background": "", "description": "For a string $s$, define $|s|$ to denote the length of $s$.\n\nNext, define $s_i$ as the $i$-th character of $s$, and $s_{l,r}$ as the string formed by concatenating, from left to right, the $l$-th through the $r$-th characters of $s$. In particular, if $l \\gt r$, or $l \\notin [1, |s|]$, or $r \\notin [1, |s|]$, we consider $s_{l,r}$ to be the empty string.\n\nGiven a string $s$ of length $n$ consisting only of digits, there are $q$ queries. In the $k$-th query, a substring $s_{l,r}$ of $s$ is given. For this substring, count the number of pairs $(i, j)$ such that $1 \\le i \\lt j \\le n$, $i + 1 < j$, and $s_{l,r}$ occurs in $s_{1,i}$ or in $s_{i+1,j-1}$ or in $s_{j,n}$.", "inputFormat": "The first line contains two integers, the string length $n$ and the number of queries $q$.\n\nThe second line contains a string of length $n$ consisting only of digit characters, representing $s$.\n\nEach of the next $q$ lines contains two positive integers $l$ and $r$, indicating that the queried substring is $s_{l,r}$.", "outputFormat": "For each query, output a single integer on its own line representing the answer.", "hint": "|   Test point   |     $n$     |     $q$     |               Other conditions                |\n| :------------: | :---------: | :---------: | :-------------------------------------------: |\n|       $1$      |    $=50$    |   $=100$    |                     None                      |\n|   $2 \\sim 3$   |   $=300$    |   $=300$    |                     None                      |\n|   $4 \\sim 5$   |   $=2000$   |   $=3000$   |                     None                      |\n|   $6 \\sim 9$   |  $=100000$  |  $=100000$  | $\\sum \\lvert s_{l,r} \\rvert \\le 10^6$        |\n|  $10 \\sim 12$  |   $=30000$  |   $=50000$  |                     None                      |\n|      $13$      |  $=100000$  |  $=100000$  |       The string $s$ contains only $0$.       |\n|  $14 \\sim 20$  |  $=100000$  |  $=300000$  |                     None                      |\n\nFor all testdata, $1 \\le n \\le 10^5$, $1 \\le q \\le 3 \\times 10^5$, $1 \\le l \\le r \\le n$, and $s$ contains only digit characters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[八省联考 2018] 制胡窜", "background": "", "description": "对于一个字符串 $s$，我们定义 $|s|$ 表示 $s$ 的长度。\n\n接着，我们定义 $s_i$ 表示 $s$ 中第 $i$ 个字符，$s_{l,r}$ 表示由 $s$ 中从左往右数，第 $l$ 个字符到第 $r$ 个字符依次连接形成的字符串。特别的，如果 $l \\gt r$，或者 $l \\notin [1, |s|]$，或者 $r \\notin [1, |s|]$，我们可以认为 $s_{l,r}$ 为空串。\n\n给定一个长度为 $n$ 的仅由数字构成的字符串 $s$，现在有 $q$ 次询问，第 $k$ 次询问会给出 $s$ 的一个子串 $s_{l,r}$，请你求出有多少对 $(i, j)$，满足 $1 \\leq i \\lt j \\leq n$，$i + 1 < j$，且 $s_{l,r}$ 出现在 $s_{1,i}$ 中或 $s_{i+1,j-1}$中或 $s_{j,n}$ 中。", "inputFormat": "输入的第一行是两个整数，分别表示字符串长度 $n$ 和询问次数 $q$。\n\n第二行有一个长度为 $n$ 的只包含数字字符的字符串，表示 $s$。\n\n接下来 $q$ 行，每行两个正整数 $l$ 和 $r$，表示此次询问的子串是 $s_{l,r}$。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "|    测试点    |     $n$     |     $q$     |               其它约定                |\n| :----------: | :-------: | :-------: | :-----------------------------------: |\n|     $1$      |   $=50$   |  $=100$   |                  无                   |\n|  $2 \\sim 3$  |  $=300$   |  $=300$   |                  无                   |\n|  $4 \\sim 5$  |  $=2000$  |  $=3000$  |                  无                   |\n|  $6 \\sim 9$  | $=100000$ | $=100000$ | $\\sum \\lvert s_{l,r} \\rvert \\le 10^6$ |\n| $10 \\sim 12$ | $=30000$  | $=50000$  |                  无                   |\n|     $13$     | $=100000$ | $=100000$ |            $s$ 中只有 $0$             |\n| $14 \\sim 20$ | $=100000$ | $=300000$ |                  无                   |\n\n\n对于所有测试数据，$1 \\le n \\le 10^5$，$1 \\le q \\le 3 \\times 10^5$，$1 \\le l \\le r \\le n$，$s$ 中只有数字字符。", "locale": "zh-CN"}}}
{"pid": "P4385", "type": "P", "difficulty": 7, "samples": [["4\n0 0 R\n0 1 B\n1 1 R\n1 0 B", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2009", "线段树", "排序", "COCI（克罗地亚）"], "title": "[CHCI 2009 Final Exam #2] DVAPRAVCA", "background": null, "description": "给定平面上的 $N$ 个点，其中有一些是红点，其他是蓝点。\n\n现在让你找一对平行线（可以不平行于坐标轴），在满足在平行线之间没有蓝点，并且平行线不经过任何一个点的情况下，使得被夹在平行线之间的红点个数最多。你只需要计算夹在这对平行线之间的红点数量。", "inputFormat": "第一行一个整数 $N$，表示总点数。\n\n接下来 $N$ 行，每行两个整数 $x_i,y_i$ 和一个字符 `R`（红色）或者 `B`（蓝色），表示点的坐标和颜色。", "outputFormat": "一个整数表示红点数量。", "hint": "#### 数据规模与约定\n\n对于 $50\\%$ 的数据，$N\\le 350$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 1000$，$|x_i|,|y_i|\\le 10^9$，保证没有三点共线。\n\n#### 说明\n\n翻译自 [Croatian Highschool Competitions In Informatics 2009 Final Exam #2 T1 DVAPRAVCA](https://hsin.hr/2009/final/second_day/tasks.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[CHCI 2009 Final Exam #2] DVAPRAVCA", "background": "", "description": "Given $N$ points in the plane, some are red and the others are blue.\n\nFind a pair of parallel lines (not necessarily parallel to the coordinate axes) such that there are no blue points between the lines, and the lines do not pass through any point. Among all such pairs, maximize the number of red points strictly between the lines. You only need to compute the number of red points that are between the chosen pair of parallel lines.", "inputFormat": "The first line contains an integer $N$, the total number of points.\n\nEach of the next $N$ lines contains two integers $x_i, y_i$ and a character `R` (red) or `B` (blue), specifying the point’s coordinates and color.", "outputFormat": "Output a single integer: the number of red points.", "hint": "Constraints\n\n- For $50\\%$ of the testdata, $N \\le 350$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 1000$, $|x_i|, |y_i| \\le 10^9$, and no three points are collinear.\n\nNotes\n\nTranslated from [Croatian Highschool Competitions In Informatics 2009 Final Exam #2 T1 DVAPRAVCA](https://hsin.hr/2009/final/second_day/tasks.pdf).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CHCI 2009 Final Exam #2] DVAPRAVCA", "background": null, "description": "给定平面上的 $N$ 个点，其中有一些是红点，其他是蓝点。\n\n现在让你找一对平行线（可以不平行于坐标轴），在满足在平行线之间没有蓝点，并且平行线不经过任何一个点的情况下，使得被夹在平行线之间的红点个数最多。你只需要计算夹在这对平行线之间的红点数量。", "inputFormat": "第一行一个整数 $N$，表示总点数。\n\n接下来 $N$ 行，每行两个整数 $x_i,y_i$ 和一个字符 `R`（红色）或者 `B`（蓝色），表示点的坐标和颜色。", "outputFormat": "一个整数表示红点数量。", "hint": "#### 数据规模与约定\n\n对于 $50\\%$ 的数据，$N\\le 350$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 1000$，$|x_i|,|y_i|\\le 10^9$，保证没有三点共线。\n\n#### 说明\n\n翻译自 [Croatian Highschool Competitions In Informatics 2009 Final Exam #2 T1 DVAPRAVCA](https://hsin.hr/2009/final/second_day/tasks.pdf)。", "locale": "zh-CN"}}}
{"pid": "P4386", "type": "P", "difficulty": 7, "samples": [["3\n1 0\n2 0\n4 6\n0 1\n0 2\n1 2\n1 3\n2 3\n3 0", "YES\nNO\nYES"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "各省省选", "上海"], "title": "[SHOI2015] 零件组装机", "background": "", "description": "曾经发明了激光发生器的发明家 SHTSC 又公开了他的新发明：零件组装机——一种可以生产并组装零件的神秘装置。\n\n一个零件是一张顶点由 $0$ 到 $n-1$ 标号的无向图，零件组装机有以下两种功能：\n\n 1. 生产一个仅有一个顶点标号为 $0$ 而没有边的零件。\n\n 2. 组合两个已有的零件 $G_1$、$G_2$，且 $G_2$ 的顶点数 $m$ 大于等于 $G_1$ 的顶点数 $n$ ，得到新的零件 $G$ 。$G$ 的顶点集合是 $G_1,G_2$ 顶点集合的并集，并且 $G_2$ 的顶点 $i(0\\leq i < m)$ 被重新标号为  $n+i$ 。$G$ 的边集是 $G_1,G_2$ 边集的并集再对所有标号为 $a(a \\geq n)$ 的顶点添加一条连接$(a,a \\bmod n)$的无向边。\n\n![](https://cdn.luogu.com.cn/upload/pic/17059.png)\n\n现在 SHTSC 正在思考，对于一个给定的零件，能否由零件组装机生产组装得到。注意：零件是带标号的，这意味着两个零件即使仅有标号不同也被视为不同的零件。为了帮助你理解问题，SHTSC 特地给了你顶点数 $\\le 5$的所有零件的图例。\n\n![](https://cdn.luogu.com.cn/upload/pic/17060.png)", "inputFormat": "第一行一个整数 $t$ ，表示有 $t$ 组数据。\n\n每组数据的第一行有两个整数 $n$，$m$，表示某个带标号的无向图有 $n$ 个从 $0$ 到 $n - 1$ 标号的顶点，以及 $m$ 条边。 接下来 $m$ 行，每行两个整数 $u,v$ ，表示一条从 $u$ 到 $v$ 的无向边。", "outputFormat": "对于每组数据，输出一行。如果这个无向图可以被零件制造机制造，输出 `YES`，否则输出 `NO`。", "hint": "对于 $5\\%$ 的数据，图给定的图联通且 $m = n - 1$；  \n对于另 $15\\%$ 的数据，$n \\leq 5$；  \n对于 $50\\%$ 的数据，$n \\leq 1000$；  \n对于所有测试点，$t \\leq 10$，$n,m \\leq 100000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2015] Parts Assembly Machine", "background": "", "description": "SHTSC, the inventor who once created a laser generator, has now unveiled his new invention: the Parts Assembly Machine — a mysterious device that can produce and assemble parts.\n\nA part is an undirected graph whose vertices are labeled from $0$ to $n-1$, and the machine has the following two functions:\n\n1. Produce a part that has only one vertex labeled $0$ and no edges.\n2. Combine two existing parts $G_1$ and $G_2$, with the number of vertices of $G_2$ being $m$ and greater than or equal to the number of vertices of $G_1$, which is $n$, to obtain a new part $G$. The vertex set of $G$ is the union of the vertex sets of $G_1$ and $G_2$, and vertex $i(0\\leq i < m)$ of $G_2$ is relabeled as $n+i$. The edge set of $G$ is the union of the edge sets of $G_1$ and $G_2$, then for every vertex with label $a(a \\geq n)$, add an undirected edge connecting $(a,a \\bmod n)$.\n\n![](https://cdn.luogu.com.cn/upload/pic/17059.png)\n\nNow SHTSC is wondering whether a given part can be produced by the machine. Note that parts are labeled, which means two parts are considered different even if they only differ by labels. To help you understand the problem, SHTSC has provided diagrams of all parts with number of vertices $\\le 5$.\n\n![](https://cdn.luogu.com.cn/upload/pic/17060.png)", "inputFormat": "The first line contains an integer $t$, the number of test cases.\n\nFor each test case, the first line contains two integers $n$ and $m$, indicating a labeled undirected graph with $n$ vertices labeled from $0$ to $n - 1$ and $m$ edges. Then $m$ lines follow, each containing two integers $u,v$, representing an undirected edge between $u$ and $v$.", "outputFormat": "For each test case, output one line. If the undirected graph can be produced by the Parts Assembly Machine, output `YES`; otherwise, output `NO`.", "hint": "For $5\\%$ of the testdata, the given graph is connected and $m = n - 1$.  \nFor another $15\\%$ of the testdata, $n \\leq 5$.  \nFor $50\\%$ of the testdata, $n \\leq 1000$.  \nFor all test points, $t \\leq 10$, $n, m \\leq 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2015] 零件组装机", "background": "", "description": "曾经发明了激光发生器的发明家 SHTSC 又公开了他的新发明：零件组装机——一种可以生产并组装零件的神秘装置。\n\n一个零件是一张顶点由 $0$ 到 $n-1$ 标号的无向图，零件组装机有以下两种功能：\n\n 1. 生产一个仅有一个顶点标号为 $0$ 而没有边的零件。\n\n 2. 组合两个已有的零件 $G_1$、$G_2$，且 $G_2$ 的顶点数 $m$ 大于等于 $G_1$ 的顶点数 $n$ ，得到新的零件 $G$ 。$G$ 的顶点集合是 $G_1,G_2$ 顶点集合的并集，并且 $G_2$ 的顶点 $i(0\\leq i < m)$ 被重新标号为  $n+i$ 。$G$ 的边集是 $G_1,G_2$ 边集的并集再对所有标号为 $a(a \\geq n)$ 的顶点添加一条连接$(a,a \\bmod n)$的无向边。\n\n![](https://cdn.luogu.com.cn/upload/pic/17059.png)\n\n现在 SHTSC 正在思考，对于一个给定的零件，能否由零件组装机生产组装得到。注意：零件是带标号的，这意味着两个零件即使仅有标号不同也被视为不同的零件。为了帮助你理解问题，SHTSC 特地给了你顶点数 $\\le 5$的所有零件的图例。\n\n![](https://cdn.luogu.com.cn/upload/pic/17060.png)", "inputFormat": "第一行一个整数 $t$ ，表示有 $t$ 组数据。\n\n每组数据的第一行有两个整数 $n$，$m$，表示某个带标号的无向图有 $n$ 个从 $0$ 到 $n - 1$ 标号的顶点，以及 $m$ 条边。 接下来 $m$ 行，每行两个整数 $u,v$ ，表示一条从 $u$ 到 $v$ 的无向边。", "outputFormat": "对于每组数据，输出一行。如果这个无向图可以被零件制造机制造，输出 `YES`，否则输出 `NO`。", "hint": "对于 $5\\%$ 的数据，图给定的图联通且 $m = n - 1$；  \n对于另 $15\\%$ 的数据，$n \\leq 5$；  \n对于 $50\\%$ 的数据，$n \\leq 1000$；  \n对于所有测试点，$t \\leq 10$，$n,m \\leq 100000$。\n", "locale": "zh-CN"}}}
{"pid": "P4387", "type": "P", "difficulty": 3, "samples": [["2\n5\n1 2 3 4 5\n5 4 3 2 1\n4\n1 2 3 4\n2 4 1 3", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "栈"], "title": "【深基15.习9】验证栈序列", "background": null, "description": "给出两个序列 pushed 和 poped 两个序列，其取值从 $1$ 到 $n(n \\le 100000)$。已知入栈序列是 pushed，如果出栈序列有可能是 poped，则输出 `Yes`，否则输出 `No`。请注意，给定的序列一定是一个**排列**（即没有重复数字）。\n\n为了防止骗分，每个测试点有多组数据，不超过 $5$ 组。", "inputFormat": "第一行一个整数 $q$，询问次数。\n\n接下来 $q$ 个询问，对于每个询问：\n\n第一行一个整数 $n$ 表示序列长度；\n\n第二行 $n$ 个整数表示入栈序列；\n\n第三行 $n$ 个整数表示出栈序列；", "outputFormat": "对于每个询问输出答案。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[Deep Basics 15.Exercise 9] Validate Stack Sequences", "background": "", "description": "Given two sequences pushed and poped, whose values range from $1$ to $n$ $(n \\le 100000)$. The push sequence is known to be pushed. If the pop sequence could be poped, output `Yes`; otherwise output `No`. Note that the given sequences are guaranteed to be a **permutation** (i.e., there are no repeated numbers).\n\nTo prevent hacking, each test point contains multiple testdata sets, no more than $5$ sets.", "inputFormat": "The first line contains an integer $q$, the number of queries.\n\nNext come $q$ queries. For each query:\n\nThe first line contains an integer $n$, the length of the sequence.\n\nThe second line contains $n$ integers, the push sequence.\n\nThe third line contains $n$ integers, the pop sequence.", "outputFormat": "For each query, output the answer.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【深基15.习9】验证栈序列", "background": null, "description": "给出两个序列 pushed 和 poped 两个序列，其取值从 $1$ 到 $n(n \\le 100000)$。已知入栈序列是 pushed，如果出栈序列有可能是 poped，则输出 `Yes`，否则输出 `No`。请注意，给定的序列一定是一个**排列**（即没有重复数字）。\n\n为了防止骗分，每个测试点有多组数据，不超过 $5$ 组。", "inputFormat": "第一行一个整数 $q$，询问次数。\n\n接下来 $q$ 个询问，对于每个询问：\n\n第一行一个整数 $n$ 表示序列长度；\n\n第二行 $n$ 个整数表示入栈序列；\n\n第三行 $n$ 个整数表示出栈序列；", "outputFormat": "对于每个询问输出答案。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4388", "type": "P", "difficulty": 5, "samples": [["4", "4"]], "limits": {"time": [350, 350, 350, 350, 350, 350, 350, 350, 350, 350], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "数论", "枚举", "素数判断,质数,筛法", "最大公约数 gcd", "欧拉函数"], "title": "付公主的矩形", "background": "付公主月考炸了，感到非常郁闷。", "description": "为了排解心中的怒气，她造了大量的稻草人来发泄。每天付公主都会把一些稻草人摆成一个 $ R*C $ 的矩形，矩形的每个方格上都有一个稻草人。然后她站在这个矩形的左上角，向矩形的右下角射箭。付公主的箭术过人，她能穿透任意多的稻草人。弓箭经过的方格上的稻草人难逃厄运，报废掉了。看着被毁坏的稻草人，付公主开心了一些。\n\n但是制造稻草人需要大量的金钱，所以付公主不希望坏掉太多的稻草人，所以她每天都选择毁坏掉 $ N $ 个稻草人。付公主还是个喜新厌旧的人，她希望每天能看到一种不同的稻草人摆放矩形。矩形是可以旋转的，即 $ R\\times C $ 和 $ C\\times R $ 等价。她毫不费力地算出了摆放方案数，于是她决定刁难你一下。不甘示弱的你决定写个程序计算这个数来提交付公主的答卷。", "inputFormat": "输入只有一行且只有一个数 $N$（$1\\le N\\le 10^6$），代表每次被毁坏的稻草人数量。", "outputFormat": "一个整数表示总方案数。", "hint": "样例解释：\n![](https://cdn.luogu.com.cn/upload/pic/16262.png)\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Princess Fu's Rectangle", "background": "Princess Fu did poorly in the monthly exam and felt very upset.", "description": "To vent her anger, she made a large number of scarecrows. Every day, Princess Fu arranges some scarecrows into an $ R*C $ rectangle, with one scarecrow on each cell of the grid. Then she stands at the top-left corner and shoots an arrow toward the bottom-right corner of the rectangle. Princess Fu is an excellent archer; she can pierce through any number of scarecrows. Any scarecrow on a cell that the arrow passes through is destroyed. Seeing the ruined scarecrows makes Princess Fu a little happier.\n\nHowever, making scarecrows costs a lot of money, so Princess Fu does not want to destroy too many scarecrows. Therefore, each day she chooses to destroy exactly $ N $ scarecrows. Princess Fu is also fickle; she wants to see a different rectangle arrangement each day. Rectangles are considered up to rotation, i.e., $ R\\times C $ and $ C\\times R $ are equivalent. She easily computed the number of arrangements, and decided to make things difficult for you. Unwilling to admit defeat, you decide to write a program to compute this number and submit it as your answer to Princess Fu.", "inputFormat": "The input consists of a single line with one integer $ N $ ($ 1\\le N\\le 10^6 $), representing the number of scarecrows destroyed each time.", "outputFormat": "Output a single integer representing the total number of arrangements.", "hint": "Sample explanation:\n![](https://cdn.luogu.com.cn/upload/pic/16262.png)\n\nFor $ 40\\% $ of the testdata, $ 1 \\le N \\le 10^4 $.\n\nFor $ 100\\% $ of the testdata, $ 1 \\le N \\le 10^6 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "付公主的矩形", "background": "付公主月考炸了，感到非常郁闷。", "description": "为了排解心中的怒气，她造了大量的稻草人来发泄。每天付公主都会把一些稻草人摆成一个 $ R*C $ 的矩形，矩形的每个方格上都有一个稻草人。然后她站在这个矩形的左上角，向矩形的右下角射箭。付公主的箭术过人，她能穿透任意多的稻草人。弓箭经过的方格上的稻草人难逃厄运，报废掉了。看着被毁坏的稻草人，付公主开心了一些。\n\n但是制造稻草人需要大量的金钱，所以付公主不希望坏掉太多的稻草人，所以她每天都选择毁坏掉 $ N $ 个稻草人。付公主还是个喜新厌旧的人，她希望每天能看到一种不同的稻草人摆放矩形。矩形是可以旋转的，即 $ R\\times C $ 和 $ C\\times R $ 等价。她毫不费力地算出了摆放方案数，于是她决定刁难你一下。不甘示弱的你决定写个程序计算这个数来提交付公主的答卷。", "inputFormat": "输入只有一行且只有一个数 $N$（$1\\le N\\le 10^6$），代表每次被毁坏的稻草人数量。", "outputFormat": "一个整数表示总方案数。", "hint": "样例解释：\n![](https://cdn.luogu.com.cn/upload/pic/16262.png)\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P4389", "type": "P", "difficulty": 6, "samples": [["2 4\n1 2", "1\n2\n2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "背包 DP", "生成函数", "快速傅里叶变换 FFT"], "title": "付公主的背包", "background": "付公主有一个可爱的背包qwq\n\n", "description": "这个背包最多可以装 $10^5$ 大小的东西\n\n付公主有 $n$ 种商品，她要准备出摊了\n\n每种商品体积为 $v_i$，都有无限件\n\n给定 $m$，对于 $s\\in [1,m]$，请你回答用这些商品恰好装 $s$ 体积的方案数\n", "inputFormat": "第一行两个正整数 $n,m$。\n第二行 $n$ 个正整数，表示每种商品的体积。\n", "outputFormat": "输出 $m$ 行，第 $i$ 行代表 $s=i$ 时方案数，对 $998244353$ 取模。", "hint": "【数据范围】  \n对于 $30\\%$ 的数据，$1\\le n,m \\le 3000$；  \n对于 $60\\%$ 的数据，纯随机生成；   \n对于 $100\\%$ 的数据， $1\\le n,m \\le 10^5$，$1\\le v_i \\le m$。", "locale": "zh-CN", "translations": {"en": {"title": "Princess Fu's Backpack", "background": "Princess Fu has a cute backpack qwq.", "description": "This backpack can hold a total size of at most $10^5$.\n\nPrincess Fu has $n$ types of goods and she is about to set up a stall.\n\nEach type has volume $v_i$, and there are infinitely many pieces available.\n\nGiven $m$, for $s \\in [1,m]$, please answer the number of ways to fill exactly volume $s$ using these goods.", "inputFormat": "The first line contains two positive integers $n, m$.\nThe second line contains $n$ positive integers, representing the volume of each type of good.", "outputFormat": "Output $m$ lines, where the $i$-th line represents the number of ways when $s = i$, taken modulo $998244353$.", "hint": "Constraints  \nFor 30% of the testdata, $1 \\le n, m \\le 3000$.  \nFor 60% of the testdata, purely randomly generated.  \nFor 100% of the testdata, $1 \\le n, m \\le 10^5$, $1 \\le v_i \\le m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "付公主的背包", "background": "付公主有一个可爱的背包qwq\n\n", "description": "这个背包最多可以装 $10^5$ 大小的东西\n\n付公主有 $n$ 种商品，她要准备出摊了\n\n每种商品体积为 $v_i$，都有无限件\n\n给定 $m$，对于 $s\\in [1,m]$，请你回答用这些商品恰好装 $s$ 体积的方案数\n", "inputFormat": "第一行两个正整数 $n,m$。\n第二行 $n$ 个正整数，表示每种商品的体积。\n", "outputFormat": "输出 $m$ 行，第 $i$ 行代表 $s=i$ 时方案数，对 $998244353$ 取模。", "hint": "【数据范围】  \n对于 $30\\%$ 的数据，$1\\le n,m \\le 3000$；  \n对于 $60\\%$ 的数据，纯随机生成；   \n对于 $100\\%$ 的数据， $1\\le n,m \\le 10^5$，$1\\le v_i \\le m$。", "locale": "zh-CN"}}}
{"pid": "P4390", "type": "P", "difficulty": 6, "samples": [["0 4\n1 2 3 3\n2 1 1 3 3\n1 2 2 2\n2 2 2 3 4\n3", "3\n5\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "树状数组", "cdq 分治", "分治", "排序", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2007] Mokia 摩基亚", "background": "", "description": "摩尔瓦多的移动电话公司摩基亚（Mokia）设计出了一种新的用户定位系统。和其他的定位系统一样，它能够迅速回答任何形如 “用户 C 的位置在哪？” 的问题，精确到毫米。但其真正高科技之处在于，它能够回答形如 “给定区域内有多少名用户？” 的问题。\n\n在定位系统中，世界被认为是一个 $w\\times w$ 的正方形区域，由 $1\\times 1$ 的方格组成。每个方格都有一个坐标 $(x, y)$，$1\\leq x,y\\leq w$。坐标的编号从 $1$ 开始。对于一个 $4\\times 4$ 的正方形，就有 $1\\leq x\\leq 4$，$1\\leq y\\leq 4$（如图）：\n\n![](https://cdn.luogu.com.cn/upload/pic/17271.png)\n\n请帮助 Mokia 公司编写一个程序来计算在某个矩形区域内有多少名用户。", "inputFormat": "有三种命令，意义如下：\n\n|命令|参数|意义|\n|:-:|:-:|:-:|\n|$0$|$w$|初始化一个全零矩阵。本命令仅开始时出现一次。|\n|$1$|$x\\ y\\ a$|向方格 $(x, y)$ 中添加 $a$ 个用户。$a$ 是正整数。|\n|$2$|$x_1\\ y_1\\ x_2\\ y_2$|查询 $x_1\\leq x\\leq x_2$，$y_1\\leq y\\leq y_2$ 所规定的矩形中的用户数量。|\n|$3$|无参数|结束程序。本命令仅结束时出现一次。|\n\n输入共若干行，每行有若干个整数，表示一个命令。", "outputFormat": "对所有命令 $2$，输出一个一行整数，即当前询问矩形内的用户数量。", "hint": "#### 数据规模与约定\n\n\n对于 $100\\%$ 的数据，保证：\n- $1\\leq w\\leq 2\\times 10 ^ 6$。\n- $1\\leq x_1\\leq x_2\\leq w$，$1\\leq y_1\\leq y_2\\leq w$，$1\\leq x,y\\leq w$，$0<a\\leq 10000$。\n- 命令 $1$ 不超过 $160000$ 个。\n- 命令 $2$ 不超过 $10000$ 个。", "locale": "zh-CN", "translations": {"en": {"title": "[BalkanOI 2007] Mokia", "background": "", "description": "The mobile phone company Mokia in Morvado has designed a new user localization system. Like other localization systems, it can quickly answer any question of the form “Where is user C?”, accurate to the millimeter. But its truly high-tech feature is that it can answer questions like “How many users are there in a given area?”.\n\nIn this localization system, the world is considered a $w\\times w$ square region, composed of $1\\times 1$ cells. Each cell has a coordinate $(x, y)$, $1\\leq x,y\\leq w$. Coordinates are 1-indexed. For a $4\\times 4$ square, we have $1\\leq x\\leq 4$, $1\\leq y\\leq 4$ (see the figure).\n\n![](https://cdn.luogu.com.cn/upload/pic/17271.png)\n\nPlease help Mokia write a program to compute how many users are in a rectangular region.", "inputFormat": "There are three types of commands with the following meanings:\n\n| Command | Parameters | Meaning |\n|:-:|:-:|:-:|\n| $0$ | $w$ | Initialize an all-zero matrix. This command appears exactly once at the beginning. |\n| $1$ | $x\\ y\\ a$ | Add $a$ users to cell $(x, y)$. $a$ is a positive integer. |\n| $2$ | $x_1\\ y_1\\ x_2\\ y_2$ | Query the number of users in the rectangle defined by $x_1\\leq x\\leq x_2$, $y_1\\leq y\\leq y_2$. |\n| $3$ | none | End the program. This command appears exactly once at the end. |\n\nThe input consists of multiple lines. Each line contains several integers representing one command.", "outputFormat": "For every command $2$, output one integer on a separate line: the number of users currently in the queried rectangle.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n- $1\\leq w\\leq 2\\times 10 ^ 6$.\n- $1\\leq x_1\\leq x_2\\leq w$, $1\\leq y_1\\leq y_2\\leq w$, $1\\leq x,y\\leq w$, $0<a\\leq 10000$.\n- The number of command $1$ does not exceed $160000$.\n- The number of command $2$ does not exceed $10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalkanOI 2007] Mokia 摩基亚", "background": "", "description": "摩尔瓦多的移动电话公司摩基亚（Mokia）设计出了一种新的用户定位系统。和其他的定位系统一样，它能够迅速回答任何形如 “用户 C 的位置在哪？” 的问题，精确到毫米。但其真正高科技之处在于，它能够回答形如 “给定区域内有多少名用户？” 的问题。\n\n在定位系统中，世界被认为是一个 $w\\times w$ 的正方形区域，由 $1\\times 1$ 的方格组成。每个方格都有一个坐标 $(x, y)$，$1\\leq x,y\\leq w$。坐标的编号从 $1$ 开始。对于一个 $4\\times 4$ 的正方形，就有 $1\\leq x\\leq 4$，$1\\leq y\\leq 4$（如图）：\n\n![](https://cdn.luogu.com.cn/upload/pic/17271.png)\n\n请帮助 Mokia 公司编写一个程序来计算在某个矩形区域内有多少名用户。", "inputFormat": "有三种命令，意义如下：\n\n|命令|参数|意义|\n|:-:|:-:|:-:|\n|$0$|$w$|初始化一个全零矩阵。本命令仅开始时出现一次。|\n|$1$|$x\\ y\\ a$|向方格 $(x, y)$ 中添加 $a$ 个用户。$a$ 是正整数。|\n|$2$|$x_1\\ y_1\\ x_2\\ y_2$|查询 $x_1\\leq x\\leq x_2$，$y_1\\leq y\\leq y_2$ 所规定的矩形中的用户数量。|\n|$3$|无参数|结束程序。本命令仅结束时出现一次。|\n\n输入共若干行，每行有若干个整数，表示一个命令。", "outputFormat": "对所有命令 $2$，输出一个一行整数，即当前询问矩形内的用户数量。", "hint": "#### 数据规模与约定\n\n\n对于 $100\\%$ 的数据，保证：\n- $1\\leq w\\leq 2\\times 10 ^ 6$。\n- $1\\leq x_1\\leq x_2\\leq w$，$1\\leq y_1\\leq y_2\\leq w$，$1\\leq x,y\\leq w$，$0<a\\leq 10000$。\n- 命令 $1$ 不超过 $160000$ 个。\n- 命令 $2$ 不超过 $10000$ 个。", "locale": "zh-CN"}}}
{"pid": "P4391", "type": "P", "difficulty": 4, "samples": [["8\ncabcabca", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2009", "前缀和", "KMP 算法", "BalticOI（波罗的海）"], "title": "[BalticOI 2009] Radio Transmission 无线传输", "background": "", "description": "给你一个字符串 $s_1$，它是由某个字符串 $s_2$ 不断自我连接形成的（保证至少重复 $2$ 次）。但是字符串 $s_2$ 是不确定的，现在只想知道它的最短长度是多少。", "inputFormat": "第一行一个整数 $L$，表示给出字符串的长度。 \n\n第二行给出字符串 $s_1$ 的一个子串，全由小写字母组成。  ", "outputFormat": "仅一行，表示 $s_2$ 的最短长度。", "hint": "#### 样例输入输出 1 解释\n对于样例，我们可以利用 $\\texttt{abc}$ 不断自我连接得到 $\\texttt{abcabcabcabc}$，读入的 $\\texttt{cabcabca}$，是它的子串。\n\n#### 规模与约定\n对于全部的测试点，保证 $1\\le L \\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2009] Radio Transmission", "background": "", "description": "You are given a string $s_1$ that is formed by repeatedly concatenating some string $s_2$ (guaranteed to repeat at least $2$ times). However, $s_2$ is unknown. You only need to determine the shortest possible length of $s_2$.", "inputFormat": "The first line contains an integer $L$, which is the length of the given string.\n\nThe second line contains a substring of $s_1$, consisting entirely of lowercase letters.", "outputFormat": "Output a single line containing the shortest length of $s_2$.", "hint": "#### Explanation for Sample Input/Output 1\nFor the sample, we can obtain $\\texttt{abcabcabcabc}$ by repeatedly concatenating $\\texttt{abc}$. The input $\\texttt{cabcabca}$ is its substring.\n\n#### Constraints\nFor all test points, it is guaranteed that $1 \\le L \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2009] Radio Transmission 无线传输", "background": "", "description": "给你一个字符串 $s_1$，它是由某个字符串 $s_2$ 不断自我连接形成的（保证至少重复 $2$ 次）。但是字符串 $s_2$ 是不确定的，现在只想知道它的最短长度是多少。", "inputFormat": "第一行一个整数 $L$，表示给出字符串的长度。 \n\n第二行给出字符串 $s_1$ 的一个子串，全由小写字母组成。  ", "outputFormat": "仅一行，表示 $s_2$ 的最短长度。", "hint": "#### 样例输入输出 1 解释\n对于样例，我们可以利用 $\\texttt{abc}$ 不断自我连接得到 $\\texttt{abcabcabcabc}$，读入的 $\\texttt{cabcabca}$，是它的子串。\n\n#### 规模与约定\n对于全部的测试点，保证 $1\\le L \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4392", "type": "P", "difficulty": 3, "samples": [["7 2 0\n0 1 1 2 3 2 2", "2\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2007", "线段树", "树状数组", "单调队列", "ST 表", "BalticOI（波罗的海）"], "title": "[BalticOI 2007] Sound 静音问题", "background": "", "description": "数字录音中，声音是用表示空气压力的数字序列描述的，序列中的每个值称为一个采样，每个采样之间间隔一定的时间。 \n\n很多声音处理任务都需要将录到的声音分成由静音隔开的几段非静音段。为了避免分成过多或者过少的非静音段，静音通常是这样定义的：$m$ 个采样的序列，该序列中采样的最大值和最小值之差不超过一个特定的阈值 $c$。 \n\n请你写一个程序，检测 $n$ 个采样中的静音。", "inputFormat": "第一行有三个整数 $n,m,c$（$1\\le n\\le10^6$，$1\\le m\\le10^4$，$0\\le c\\le10^4$），分别表示总的采样数、静音的长度和静音中允许的最大噪音程度。\n\n第 $2$ 行 $n$ 个整数 $a_i$（$0\\le a_i\\le 10^6$），表示声音的每个采样值，每两个整数之间用空格隔开。", "outputFormat": "列出了所有静音的起始位置 $i$（$i$ 满足$\\max\\{a_i,a_{i+1}\\cdots a_{i+m-1}\\}-\\min\\{a_i,a_{i+1}\\cdots a_{i+m-1}\\}\\le c$），每行表示一段静音的起始位置，按照出现的先后顺序输出。如果没有静音则输出 `NONE`。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2007] Sound Silence Problem", "background": "", "description": "In digital audio recording, sound is represented by a sequence of numbers describing air pressure, with each value called a sample, and adjacent samples separated by equal time intervals.\n\nMany audio processing tasks need to split the recorded sound into non-silent segments separated by silence. To avoid producing too many or too few non-silent segments, silence is defined as follows: a sequence of $m$ samples in which the difference between the maximum and the minimum sample values does not exceed a given threshold $c$.\n\nWrite a program to detect silence within $n$ samples.", "inputFormat": "The first line contains three integers $n, m, c$ ($1 \\le n \\le 10^6$, $1 \\le m \\le 10^4$, $0 \\le c \\le 10^4$), denoting the total number of samples, the length of a silence segment, and the maximum allowed noise level within a silence segment.\n\nThe second line contains $n$ integers $a_i$ ($0 \\le a_i \\le 10^6$), the value of each sample, separated by spaces.", "outputFormat": "List all starting positions $i$ of silence segments (i.e., those $i$ such that $\\max\\{a_i, a_{i+1}, \\ldots, a_{i+m-1}\\} - \\min\\{a_i, a_{i+1}, \\ldots, a_{i+m-1}\\} \\le c$). Output one starting position per line, in order of appearance. If there is no silence, output `NONE`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2007] Sound 静音问题", "background": "", "description": "数字录音中，声音是用表示空气压力的数字序列描述的，序列中的每个值称为一个采样，每个采样之间间隔一定的时间。 \n\n很多声音处理任务都需要将录到的声音分成由静音隔开的几段非静音段。为了避免分成过多或者过少的非静音段，静音通常是这样定义的：$m$ 个采样的序列，该序列中采样的最大值和最小值之差不超过一个特定的阈值 $c$。 \n\n请你写一个程序，检测 $n$ 个采样中的静音。", "inputFormat": "第一行有三个整数 $n,m,c$（$1\\le n\\le10^6$，$1\\le m\\le10^4$，$0\\le c\\le10^4$），分别表示总的采样数、静音的长度和静音中允许的最大噪音程度。\n\n第 $2$ 行 $n$ 个整数 $a_i$（$0\\le a_i\\le 10^6$），表示声音的每个采样值，每两个整数之间用空格隔开。", "outputFormat": "列出了所有静音的起始位置 $i$（$i$ 满足$\\max\\{a_i,a_{i+1}\\cdots a_{i+m-1}\\}-\\min\\{a_i,a_{i+1}\\cdots a_{i+m-1}\\}\\le c$），每行表示一段静音的起始位置，按照出现的先后顺序输出。如果没有静音则输出 `NONE`。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4393", "type": "P", "difficulty": 3, "samples": [["3\n1\n2\n3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2007", "线段树", "BalticOI（波罗的海）"], "title": "[BalticOI 2007] Sequence 序列问题", "background": "", "description": "对于一个给定的序列 $a _ 1, \\cdots, a _ n$，我们对它进行一个操作 $\\text{reduce}(i)$，该操作将数列中的元素 $a _ i$ 和 $a _ {i+1}$ 用一个元素 $\\max(a _ i,a _ {i+1})$ 替代，这样得到一个比原来序列短的新序列。这一操作的代价是 $\\max(a _ i,a _ {i+1})$。进行 $n-1$ 次该操作后，可以得到一个长度为 $1$ 的序列。\n\n我们的任务是计算代价最小的 $\\text{reduce}$ 操作步骤，将给定的序列变成长度为 $1$ 的序列。", "inputFormat": "第一行为一个整数 $n$（$1 \\leq n \\leq 10 ^6$），表示给定序列的长度。\n\n接下来的 $n$ 行，每行一个整数 $a _ i$（$0 \\leq a _ i \\leq 10 ^ 9$），为序列中的元素。", "outputFormat": "只有一行，为一个整数，即将序列变成一个元素的最小代价。 \n", "hint": "### 数据规模与约定\n\n- 对于 $30\\%$ 的测试数据，$n\\le 500$； \n- 对于 $50\\%$ 的测试数据，$n \\le 20000$；\n- 对于 $100\\%$ 的测试数据，$1 \\le n \\le 10^6$，$0 \\le a_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2007] Sequence Problem", "background": "", "description": "Given a sequence $a _ 1, \\cdots, a _ n$, we perform an operation $\\text{reduce}(i)$ that replaces the two elements $a _ i$ and $a _ {i+1}$ with a single element $\\max(a _ i,a _ {i+1})$, producing a new sequence shorter than the original. The cost of this operation is $\\max(a _ i,a _ {i+1})$. After performing this operation $n-1$ times, we obtain a sequence of length $1$.\n\nOur task is to compute the sequence of $\\text{reduce}$ operations with the minimum total cost to turn the given sequence into a sequence of length $1$.", "inputFormat": "The first line contains an integer $n$ ($1 \\leq n \\leq 10 ^6$), the length of the given sequence.\n\nThe next $n$ lines each contain an integer $a _ i$ ($0 \\leq a _ i \\leq 10 ^ 9$), the elements of the sequence.", "outputFormat": "Output a single line with one integer: the minimum total cost to reduce the sequence to a single element.", "hint": "- For $30\\%$ of the testdata, $n\\le 500$.\n- For $50\\%$ of the testdata, $n \\le 20000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^6$, $0 \\le a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2007] Sequence 序列问题", "background": "", "description": "对于一个给定的序列 $a _ 1, \\cdots, a _ n$，我们对它进行一个操作 $\\text{reduce}(i)$，该操作将数列中的元素 $a _ i$ 和 $a _ {i+1}$ 用一个元素 $\\max(a _ i,a _ {i+1})$ 替代，这样得到一个比原来序列短的新序列。这一操作的代价是 $\\max(a _ i,a _ {i+1})$。进行 $n-1$ 次该操作后，可以得到一个长度为 $1$ 的序列。\n\n我们的任务是计算代价最小的 $\\text{reduce}$ 操作步骤，将给定的序列变成长度为 $1$ 的序列。", "inputFormat": "第一行为一个整数 $n$（$1 \\leq n \\leq 10 ^6$），表示给定序列的长度。\n\n接下来的 $n$ 行，每行一个整数 $a _ i$（$0 \\leq a _ i \\leq 10 ^ 9$），为序列中的元素。", "outputFormat": "只有一行，为一个整数，即将序列变成一个元素的最小代价。 \n", "hint": "### 数据规模与约定\n\n- 对于 $30\\%$ 的测试数据，$n\\le 500$； \n- 对于 $50\\%$ 的测试数据，$n \\le 20000$；\n- 对于 $100\\%$ 的测试数据，$1 \\le n \\le 10^6$，$0 \\le a_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4394", "type": "P", "difficulty": 3, "samples": [["4\n1 3 2 4", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "排序", "背包 DP"], "title": "选举", "background": "", "description": "Byteland 国的居民最近一直为议会选举投票。现在，当结果公布的时候，党派不得不决定联合组建政府。 \n\n每个党派都会获得议会中的一定席位。联合政府由这些党派中的一部分组成，他们在议会中的席位数之和**严格大于**总席位数的一半。对于联合政府来说，席位越多越好。\n\n一个**过剩**的联合政府是指联合政府中的一个党派被移出后，剩余的联合政府在国会中仍有过半数的席位。\n\n请写一个程序能够找到一个在议会中有着**最大可能席位数**且**不过剩**的联合政府。", "inputFormat": "标准输出的第一行包含一个整数 $n$，表示参加选举的党派数。党派被从 $1$ 到 $n$ 编号。\n\n第二行包含 $n$ 个非负整数 $a_1,\\dots ,a_n$，被一个空格隔开，$a_i$ 是第 $i$ 个党派获得的席位数。你可以假设国会中的中的总席位数为小于等于 $10^5$ 的正整数。", "outputFormat": "包含一个整数，表示最大可能席位数。", "hint": "样例解释：选择第二个政党和第四个。\n\n对于全部数据，$1\\le n\\le 300$。", "locale": "zh-CN", "translations": {"en": {"title": "Election", "background": "", "description": "The residents of Byteland have recently voted in a parliamentary election. Now, as the results are announced, the parties must decide on forming a coalition government.\n\nEach party obtains a certain number of seats in the parliament. A coalition government consists of a subset of these parties whose total number of seats is **strictly greater than** half of all seats. For a coalition, having more seats is better.\n\nAn **excessive** coalition is one in which, after removing one party from the coalition, the remaining coalition still holds a majority of seats in the parliament.\n\nWrite a program to find a coalition with the **maximum possible** number of seats in the parliament that is **not excessive**.", "inputFormat": "The first line of standard input contains an integer $ n $, the number of parties in the election. The parties are numbered from $ 1 $ to $ n $.\n\nThe second line contains $ n $ non-negative integers $ a_1, \\dots, a_n $ separated by single spaces, where $ a_i $ is the number of seats won by the $ i $-th party. You may assume that the total number of seats in the parliament is a positive integer not exceeding $ 10^5 $.", "outputFormat": "Output a single integer: the maximum possible number of seats.", "hint": "Sample explanation: choose the second and the fourth party.\n\nConstraints: For all testdata, $ 1 \\le n \\le 300 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "选举", "background": "", "description": "Byteland 国的居民最近一直为议会选举投票。现在，当结果公布的时候，党派不得不决定联合组建政府。 \n\n每个党派都会获得议会中的一定席位。联合政府由这些党派中的一部分组成，他们在议会中的席位数之和**严格大于**总席位数的一半。对于联合政府来说，席位越多越好。\n\n一个**过剩**的联合政府是指联合政府中的一个党派被移出后，剩余的联合政府在国会中仍有过半数的席位。\n\n请写一个程序能够找到一个在议会中有着**最大可能席位数**且**不过剩**的联合政府。", "inputFormat": "标准输出的第一行包含一个整数 $n$，表示参加选举的党派数。党派被从 $1$ 到 $n$ 编号。\n\n第二行包含 $n$ 个非负整数 $a_1,\\dots ,a_n$，被一个空格隔开，$a_i$ 是第 $i$ 个党派获得的席位数。你可以假设国会中的中的总席位数为小于等于 $10^5$ 的正整数。", "outputFormat": "包含一个整数，表示最大可能席位数。", "hint": "样例解释：选择第二个政党和第四个。\n\n对于全部数据，$1\\le n\\le 300$。", "locale": "zh-CN"}}}
{"pid": "P4395", "type": "P", "difficulty": 4, "samples": [["10 \n7 5 \n1 2 \n1 7 \n8 9 \n4 1 \n9 7 \n5 6 \n10 2 \n9 3", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2003", "树形 DP", "BalticOI（波罗的海）"], "title": "[BalticOI 2003] Gem 气垫车", "background": "", "description": "给出一棵树，要求你为树上的结点标上权值，权值可以是任意的正整数。\n\n唯一的限制条件是相邻的两个结点不能标上相同的权值，要求一种方案，使得整棵树的总价值最小。", "inputFormat": "先给出一个数字 $N$ 代表树上有 $N$ 个点，$N \\le 10000$。\n\n下面 $N-1$ 行，代表两个结点 $u,v(1\\le u,v\\le N)$ 相连。", "outputFormat": "最小的总权值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2003] Gem Hovercraft", "background": "", "description": "Given a tree, assign a weight to each node. The weight can be any positive integer.\n\nThe only constraint is that two adjacent nodes cannot have the same weight. Find an assignment that minimizes the total weight of the entire tree.", "inputFormat": "The first line contains an integer $N$ representing the number of nodes in the tree, with $N \\le 10000$.\n\nEach of the next $N-1$ lines indicates that two nodes $u,v(1\\le u,v\\le N)$ are connected by an edge.", "outputFormat": "The minimum possible total weight.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2003] Gem 气垫车", "background": "", "description": "给出一棵树，要求你为树上的结点标上权值，权值可以是任意的正整数。\n\n唯一的限制条件是相邻的两个结点不能标上相同的权值，要求一种方案，使得整棵树的总价值最小。", "inputFormat": "先给出一个数字 $N$ 代表树上有 $N$ 个点，$N \\le 10000$。\n\n下面 $N-1$ 行，代表两个结点 $u,v(1\\le u,v\\le N)$ 相连。", "outputFormat": "最小的总权值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4396", "type": "P", "difficulty": 6, "samples": [["3 4\n1 2 2\n1 2 1 3\n1 2 1 1\n1 3 1 3\n2 3 2 3", "2 2\n1 1\n3 2\n2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "莫队", "各省省选", "树状数组", "安徽", "cdq 分治", "可持久化线段树", "分块"], "title": "[AHOI2013] 作业", "background": "", "description": "此时己是凌晨两点，刚刚做了 Codeforces 的小 A 掏出了英语试卷。英语作业其实不算多，一个小时刚好可以做完。然后是一个小时可以做完的数学作业，接下来是分别都是一个小时可以做完的化学，物理，语文……小 A 压力巨大。\n\n这时小 A 碰见了一道非常恶心的数学题，给定了一个长度为 $n$ 的数列和若干个询问，每个询问是关于数列的区间表示数列的第 $l$ 个数到第 $r$ 个数)，首先你要统计该区间内大于等于 $a$，小于等于 $b$ 的数的个数，其次是所有大于等于 $a$，小于等于 $b$ 的，且在该区间中出现过的数值的个数。\n\n小 A 望着那数万的数据规模几乎绝望，只能向大神您求救，请您帮帮他吧。", "inputFormat": "第一行两个整数 $n,m$\n\n接下来 $n$ 个不超过 $10^5$ 的正整数表示数列\n\n接下来 $m$ 行，每行四个整数 $l,r,a,b$，具体含义参见题意。\n", "outputFormat": "输出 $m$ 行，分别对应每个询问，输出两个数，分别为在 $l$ 到 $r$ 这段区间中大小在 $[a,b]$ 中的数的个数，以及大于等于 $a$，小于等于 $b$ 的，且在该区间中出现过的数值的个数（具体可以参考样例）。\n", "hint": "$N\\leq 100000,M\\leq 100000$，读入的数字均为 $[1,10^5]$ 内的正整数。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2013] Homework", "background": "", "description": "It is already 2 a.m. After finishing some Codeforces problems, Xiao A pulled out the English test paper. The English homework is not much; it takes exactly one hour to finish. Then there is math homework that also takes one hour, followed by chemistry, physics, Chinese, and so on, each of which also takes one hour. Xiao A feels enormous pressure.\n\nAt this moment, Xiao A ran into a very nasty math problem: given a sequence of length $n$ and several queries, each query is on an interval of the sequence (from the $l$-th number to the $r$-th number). First, you need to count how many numbers in this interval are greater than or equal to $a$ and less than or equal to $b$. Second, you need to count how many distinct values are greater than or equal to $a$ and less than or equal to $b$ and appear in this interval.\n\nFacing testdata of tens of thousands in scale, Xiao A is almost desperate and can only ask you, the expert, for help. Please help him.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next $n$ positive integers, each not exceeding $10^5$, form the sequence.\n\nThen there are $m$ lines. Each line contains four integers $l, r, a, b$; see the statement for their meanings.", "outputFormat": "Output $m$ lines, one for each query. For each query, output two numbers: the number of elements in the interval $[l, r]$ whose values lie in $[a, b]$, and the number of distinct values that are greater than or equal to $a$ and less than or equal to $b$ and appear in this interval (see the sample).", "hint": "$N \\le 100000, M \\le 100000$. All read numbers are positive integers in $[1, 10^5]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2013] 作业", "background": "", "description": "此时己是凌晨两点，刚刚做了 Codeforces 的小 A 掏出了英语试卷。英语作业其实不算多，一个小时刚好可以做完。然后是一个小时可以做完的数学作业，接下来是分别都是一个小时可以做完的化学，物理，语文……小 A 压力巨大。\n\n这时小 A 碰见了一道非常恶心的数学题，给定了一个长度为 $n$ 的数列和若干个询问，每个询问是关于数列的区间表示数列的第 $l$ 个数到第 $r$ 个数)，首先你要统计该区间内大于等于 $a$，小于等于 $b$ 的数的个数，其次是所有大于等于 $a$，小于等于 $b$ 的，且在该区间中出现过的数值的个数。\n\n小 A 望着那数万的数据规模几乎绝望，只能向大神您求救，请您帮帮他吧。", "inputFormat": "第一行两个整数 $n,m$\n\n接下来 $n$ 个不超过 $10^5$ 的正整数表示数列\n\n接下来 $m$ 行，每行四个整数 $l,r,a,b$，具体含义参见题意。\n", "outputFormat": "输出 $m$ 行，分别对应每个询问，输出两个数，分别为在 $l$ 到 $r$ 这段区间中大小在 $[a,b]$ 中的数的个数，以及大于等于 $a$，小于等于 $b$ 的，且在该区间中出现过的数值的个数（具体可以参考样例）。\n", "hint": "$N\\leq 100000,M\\leq 100000$，读入的数字均为 $[1,10^5]$ 内的正整数。", "locale": "zh-CN"}}}
{"pid": "P4397", "type": "P", "difficulty": 5, "samples": [["42", "3\n20 26 41"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "各省省选", "吉林", "枚举", "深度优先搜索 DFS", "素数判断,质数,筛法"], "title": "[JLOI2014] 聪明的燕姿", "background": "> 阴天傍晚车窗外\n>\n> 未来有一个人在等待\n>\n> 向左向右向前看\n>\n> 爱要拐几个弯才来\n>\n> 我遇见谁会有怎样的对白\n>\n> 我等的人他在多远的未来\n>\n> 我听见风来自地铁和人海\n>\n> 我排着队拿着爱的号码牌", "description": "城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。\n\n可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。\n\n所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。", "inputFormat": "输入包含 $k$ 组数据。\n\n对于每组数据，输入包含一个号码牌 $S$。", "outputFormat": "对于每组数据，输出有两行，第一行包含一个整数 $m$，表示有 $m$ 个等的人。\n\n第二行包含相应的 $m$ 个数，表示所有等的人的号码牌。\n\n特别地，当某组数据出现 $m=0$，即不存在满足题意的号码牌时，该组数据不应输出第二行（只应输出第一行的 $0$）。\n\n注意：你输出的号码牌必须按照升序排列。", "hint": "对于 $100\\%$ 的数据，$k\\leqslant100$，$S\\leqslant2\\times10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2014] Smart Yanzi", "background": "> Outside the car window on a cloudy evening.\n>\n> Someone is waiting in the future.\n>\n> Look left, right, and forward.\n>\n> Love takes a few turns before it arrives.\n>\n> Whom will I meet, and what kind of conversation will we have.\n>\n> How far in the future is the one I'm waiting for.\n>\n> I hear the wind coming from the subway and the sea of people.\n>\n> I stand in line holding a number for love.", "description": "In the city, people always hold number tickets, keep searching, and keep matching, yet no one knows whom they are waiting for.\n\nBut Yanzi is different. Yanzi knows whom she is waiting for, because she is good at math. Yanzi discovered a magical algorithm: suppose the number on her ticket is $S$, then the sum of all positive divisors of the number on the other person's ticket must equal $S$.\n\nSo Yanzi always searches through subways and crowds holding her number ticket to find numbers (Hey! Is this really reliable?), but she is busy singing \"Green Light\" and wants to ask you to write a program to quickly find everyone she is waiting for.", "inputFormat": "The input contains $k$ test cases.\n\nFor each test case, the input consists of a single integer $S$.", "outputFormat": "For each test case, output two lines. The first line contains an integer $m$, denoting there are $m$ people she is waiting for.\n\nThe second line contains the corresponding $m$ numbers, which are the number tickets of all those people.\n\nIn particular, when $m=0$, i.e., no number satisfies the requirement, that test case should not output the second line (only output the single line $0$).\n\nNote: The numbers you output must be in ascending order.", "hint": "For $100\\%$ of the testdata, $k \\leqslant 100$, $S \\leqslant 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2014] 聪明的燕姿", "background": "> 阴天傍晚车窗外\n>\n> 未来有一个人在等待\n>\n> 向左向右向前看\n>\n> 爱要拐几个弯才来\n>\n> 我遇见谁会有怎样的对白\n>\n> 我等的人他在多远的未来\n>\n> 我听见风来自地铁和人海\n>\n> 我排着队拿着爱的号码牌", "description": "城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。\n\n可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。\n\n所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。", "inputFormat": "输入包含 $k$ 组数据。\n\n对于每组数据，输入包含一个号码牌 $S$。", "outputFormat": "对于每组数据，输出有两行，第一行包含一个整数 $m$，表示有 $m$ 个等的人。\n\n第二行包含相应的 $m$ 个数，表示所有等的人的号码牌。\n\n特别地，当某组数据出现 $m=0$，即不存在满足题意的号码牌时，该组数据不应输出第二行（只应输出第一行的 $0$）。\n\n注意：你输出的号码牌必须按照升序排列。", "hint": "对于 $100\\%$ 的数据，$k\\leqslant100$，$S\\leqslant2\\times10^9$。", "locale": "zh-CN"}}}
{"pid": "P4398", "type": "P", "difficulty": 3, "samples": [["3\n1 2 3\n4 5 6\n7 8 9\n5 6 7\n8 9 1\n2 3 4", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "各省省选", "江苏", "枚举", "哈希 hashing"], "title": "[JSOI2008] Blue Mary的战役地图", "background": null, "description": "Blue Mary 最近迷上了玩 Starcraft（星际争霸）的 RPG 游戏。她正在设法寻找更多的战役地图以进一步提高自己的水平。\n \n由于 Blue Mary 的技术已经达到了一定的高度,因此，对于用同一种打法能够通过的战役地图，她只需要玩一张，她就能了解这一类战役的打法，然后她就没有兴趣再玩儿这一类地图了。而网上流传的地图有很多都是属于同一种打法，因此 Blue Mary 需要你写一个程序，来帮助她判断哪些地图是属于同一类的。 \n\n具体来说，Blue Mary 已经将战役地图编码为 $n \\times n$ 的矩阵，矩阵的每个格子里面是一个 $32$ 位（有符号）正整数。对于两个矩阵，他们的相似程度定义为他们的最大公共正方形矩阵的边长。两个矩阵的相似程度越大，这两张战役地图就越有可能是属于同一类的。", "inputFormat": "第一行包含一个正整数 $n$。 \n\n以下 $n$ 行，每行包含 $n$ 个正整数，表示第一张战役地图的代表矩阵。 \n\n再以下 $n$ 行，每行包含 $n$ 个正整数，表示第二张战役地图的代表矩阵。", "outputFormat": "仅包含一行。这一行仅有一个正整数，表示这两个矩阵的相似程度。", "hint": "#### 样例解释： \n\n子矩阵：$\n\\begin{bmatrix}\n  5 & 6 \\\\\n  8 & 9 \\\\\n\\end{bmatrix}\n$ 为两个地图的最大公共矩阵。\n\n约定：$n \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Blue Mary's Campaign Map", "background": "", "description": "Blue Mary has recently become hooked on playing StarCraft RPGs. She is trying to find more campaign maps to further improve her skills.\n\nSince Blue Mary has reached a certain skill level, for campaign maps that can be cleared using the same strategy, she only needs to play one of them to learn that type of strategy, and then she loses interest in other maps of the same type. Many maps circulating online share the same strategy, so Blue Mary needs you to write a program to help her determine which maps belong to the same type.\n\nSpecifically, Blue Mary has encoded each campaign map as an $n \\times n$ matrix, where each cell contains a positive 32-bit (signed) integer. For two matrices, their similarity is defined as the side length of their largest common square submatrix. The greater the similarity between two matrices, the more likely the two campaign maps are of the same type.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe next $n$ lines each contain $n$ positive integers, representing the matrix of the first campaign map.\n\nThe following $n$ lines each contain $n$ positive integers, representing the matrix of the second campaign map.", "outputFormat": "Output a single line containing one positive integer, which is the similarity between the two matrices.", "hint": "Sample explanation:\n\nSubmatrix: $\n\\begin{bmatrix}\n  5 & 6 \\\\\n  8 & 9 \\\\\n\\end{bmatrix}\n$ is the largest common submatrix of the two maps.\n\nConstraints: $n \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] Blue Mary的战役地图", "background": null, "description": "Blue Mary 最近迷上了玩 Starcraft（星际争霸）的 RPG 游戏。她正在设法寻找更多的战役地图以进一步提高自己的水平。\n \n由于 Blue Mary 的技术已经达到了一定的高度,因此，对于用同一种打法能够通过的战役地图，她只需要玩一张，她就能了解这一类战役的打法，然后她就没有兴趣再玩儿这一类地图了。而网上流传的地图有很多都是属于同一种打法，因此 Blue Mary 需要你写一个程序，来帮助她判断哪些地图是属于同一类的。 \n\n具体来说，Blue Mary 已经将战役地图编码为 $n \\times n$ 的矩阵，矩阵的每个格子里面是一个 $32$ 位（有符号）正整数。对于两个矩阵，他们的相似程度定义为他们的最大公共正方形矩阵的边长。两个矩阵的相似程度越大，这两张战役地图就越有可能是属于同一类的。", "inputFormat": "第一行包含一个正整数 $n$。 \n\n以下 $n$ 行，每行包含 $n$ 个正整数，表示第一张战役地图的代表矩阵。 \n\n再以下 $n$ 行，每行包含 $n$ 个正整数，表示第二张战役地图的代表矩阵。", "outputFormat": "仅包含一行。这一行仅有一个正整数，表示这两个矩阵的相似程度。", "hint": "#### 样例解释： \n\n子矩阵：$\n\\begin{bmatrix}\n  5 & 6 \\\\\n  8 & 9 \\\\\n\\end{bmatrix}\n$ 为两个地图的最大公共矩阵。\n\n约定：$n \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P4399", "type": "P", "difficulty": 5, "samples": [["1 2 3 4 5 6", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "江苏"], "title": "[JSOI2008] Blue Mary的职员分配", "background": null, "description": "由于 Blue Mary 呕心沥血的管理，Blue Mary 的网络公司蒸蒸日上。现在一共拥有了 $n$ 名职员，可惜没有任何的金钱和声誉。平均每名每天职员都可以给公司带来 $x$ 单位金钱或者 $y$ 单位声誉（名利不能双全）。并且可以花费 $z$ 单位的金钱在人才交易市场发布广告招聘职员，每次发布广告三天以后就会招聘到一名职员，并且必须在发布广告并且招聘到职员的那一天才能发布下一次广告。 \n\nBlue Mary 计划以最快的时间获得至少 $A$ 单位金钱和至少 $B$ 单位声誉，请你计算一下他至少需要多少时间才能达到他的目标。", "inputFormat": "输入有且仅有一行，包含六个整数 $n,x,y,z,A$ 和 $B$，意义如题目描述所述。", "outputFormat": "要求输出一行，包含一个整数，表示 Blue Mary 至少需要多少时间才能达到他的目标。", "hint": "提示：\n\n$1 \\le n,x,y,z,A,B \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Blue Mary's Staff Allocation", "background": "", "description": "Thanks to Blue Mary’s dedicated management, Blue Mary’s Internet company is thriving. It currently has $n$ employees, but no money or reputation. On average, each employee can bring the company $x$ units of money or $y$ units of reputation per day (they cannot produce both at the same time). You can spend $z$ units of money to post a recruitment advertisement on the talent market; exactly three days after posting, one employee will be hired. Moreover, you may post the next advertisement only on the day when the hired employee arrives (i.e., exactly three days after a previous ad).\n\nBlue Mary plans to obtain at least $A$ units of money and at least $B$ units of reputation in the shortest possible time. Please compute the minimum time she needs to reach this goal.", "inputFormat": "The input contains exactly one line with six integers $n, x, y, z, A$ and $B$, as described above.", "outputFormat": "Output one line with a single integer, the minimum time Blue Mary needs to achieve the goal.", "hint": "Constraints: $1 \\le n, x, y, z, A, B \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] Blue Mary的职员分配", "background": null, "description": "由于 Blue Mary 呕心沥血的管理，Blue Mary 的网络公司蒸蒸日上。现在一共拥有了 $n$ 名职员，可惜没有任何的金钱和声誉。平均每名每天职员都可以给公司带来 $x$ 单位金钱或者 $y$ 单位声誉（名利不能双全）。并且可以花费 $z$ 单位的金钱在人才交易市场发布广告招聘职员，每次发布广告三天以后就会招聘到一名职员，并且必须在发布广告并且招聘到职员的那一天才能发布下一次广告。 \n\nBlue Mary 计划以最快的时间获得至少 $A$ 单位金钱和至少 $B$ 单位声誉，请你计算一下他至少需要多少时间才能达到他的目标。", "inputFormat": "输入有且仅有一行，包含六个整数 $n,x,y,z,A$ 和 $B$，意义如题目描述所述。", "outputFormat": "要求输出一行，包含一个整数，表示 Blue Mary 至少需要多少时间才能达到他的目标。", "hint": "提示：\n\n$1 \\le n,x,y,z,A,B \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P4400", "type": "P", "difficulty": 6, "samples": [["3 3 5\n1 2 1\n2 3 5\n3 1 4\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "江苏"], "title": "[JSOI2008] Blue Mary的旅行", "background": "", "description": "在一段时间之后，网络公司终于有了一定的知名度，也开始收到一些订单，其中最大的一宗来自 B 市。\n\nBlue Mary 决定亲自去签下这份订单。为了节省旅行经费，他的某个金融顾问建议只购买 U 航空公司的机票。 U 航空公司的所有航班每天都只有一班，并且都是上午出发当天下午到达的，所以他们每人每天只能坐一班飞机。\n\n经过调查，他们得到了 U 航空公司经营的所有航班的详细信息，这包括每一航班的出发地，目的地以及最多能买到的某一天出发的票数。(注意: 对于一个确定的航班，无论是哪一天，他们最多能买到的那一天出发的票数都是相同的）。\n\nBlue Mary 注意到他们一定可以只乘坐 U 航空公司的航班就从 A 市到达 B 市，但是，由于每一航班能买到的票的数量的限制，他们所有人可能不能在同一天到达 B 市。\n\n所以现在 Blue Mary 需要你的帮助，设计一个旅行方案使得最后到达B市的人的到达时间最早。", "inputFormat": "第一行包含 $3$ 个正整数 $N$，$M$ 和 $T$。  \n题目中会出现的所有城市分别编号为 $1,2,\\dots,N$，其中城市 A 编号一定为 $1$，城市 B 编号一定为 $N$。  \nU 公司一共有 $M$ 条（单向）航班。而连 Blue Mary 在内，公司一共有 $T$ 个人要从 A 市前往 B 市。\n\n以下 $M$ 行，每行包含3个正整数 $x,y,z,$ 表示 U 公司的每一条航班的出发地，目的地以及 Blue Mary 最多能够买到的这一航班某一天出发的票数。(即：无论是哪一天，Blue Mary 最多只能买到 $z$ 张 U 航空公司的从城市 $x$ 出发到城市 $y$ 的机票)。\n\n输入保证从一个城市到另一个城市的单向航班最多只有一个。", "outputFormat": "仅有一行，包含一个正整数，表示最后到达 B 市的人的最早到达时间。假设他们第一次乘飞机的那一天是第一天。", "hint": "对于 $100\\%$ 的数据，$2\\le N\\le 50,1\\le M\\le 2450,1\\le T,z\\le 50,1\\le x,y\\le N,x\\neq y$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Blue Mary's Trip", "background": "", "description": "After some time, the network company finally gained some recognition and started receiving orders, the biggest of which came from city B.\n\nBlue Mary decided to personally go and sign this order. To save travel expenses, one of his financial advisors suggested buying tickets only from U Airlines. All flights of U Airlines operate once per day, departing in the morning and arriving in the afternoon of the same day, so each person can take at most one flight per day.\n\nAfter investigation, they obtained detailed information on all flights operated by U Airlines, including each flight’s origin, destination, and the maximum number of tickets that can be bought for departures on any single day. (Note: For a given flight, the maximum number of tickets they can buy for departures on any day is the same across all days.)\n\nBlue Mary noticed that they can indeed travel from city A to city B using only U Airlines’ flights. However, due to the ticket limits on each flight, it may be impossible for all of them to arrive in city B on the same day.\n\nTherefore, Blue Mary needs your help to design a travel plan that makes the arrival day of the last person to reach city B as early as possible.", "inputFormat": "The first line contains $3$ positive integers $N$, $M$ and $T$.  \nAll cities that appear in the problem are numbered $1, 2, \\dots, N$, where city A is numbered $1$, and city B is numbered $N$.  \nU Airlines has $M$ directed flights in total. Including Blue Mary, the company has $T$ people who need to travel from city A to city B.\n\nThe following $M$ lines each contain $3$ positive integers $x, y, z$, indicating the origin, destination, and the maximum number of tickets that Blue Mary can buy for that flight on any given day. (That is, regardless of the day, Blue Mary can buy at most $z$ tickets for the U Airlines flight from city $x$ to city $y$.)\n\nIt is guaranteed that between any ordered pair of cities, there is at most one directed flight.", "outputFormat": "Output a single line with one positive integer, the earliest possible day on which the last person arrives in city B. Assume the first day they take a flight is day $1$.", "hint": "For $100\\%$ of the testdata, $2 \\le N \\le 50$, $1 \\le M \\le 2450$, $1 \\le T, z \\le 50$, $1 \\le x, y \\le N$, $x \\ne y$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] Blue Mary的旅行", "background": "", "description": "在一段时间之后，网络公司终于有了一定的知名度，也开始收到一些订单，其中最大的一宗来自 B 市。\n\nBlue Mary 决定亲自去签下这份订单。为了节省旅行经费，他的某个金融顾问建议只购买 U 航空公司的机票。 U 航空公司的所有航班每天都只有一班，并且都是上午出发当天下午到达的，所以他们每人每天只能坐一班飞机。\n\n经过调查，他们得到了 U 航空公司经营的所有航班的详细信息，这包括每一航班的出发地，目的地以及最多能买到的某一天出发的票数。(注意: 对于一个确定的航班，无论是哪一天，他们最多能买到的那一天出发的票数都是相同的）。\n\nBlue Mary 注意到他们一定可以只乘坐 U 航空公司的航班就从 A 市到达 B 市，但是，由于每一航班能买到的票的数量的限制，他们所有人可能不能在同一天到达 B 市。\n\n所以现在 Blue Mary 需要你的帮助，设计一个旅行方案使得最后到达B市的人的到达时间最早。", "inputFormat": "第一行包含 $3$ 个正整数 $N$，$M$ 和 $T$。  \n题目中会出现的所有城市分别编号为 $1,2,\\dots,N$，其中城市 A 编号一定为 $1$，城市 B 编号一定为 $N$。  \nU 公司一共有 $M$ 条（单向）航班。而连 Blue Mary 在内，公司一共有 $T$ 个人要从 A 市前往 B 市。\n\n以下 $M$ 行，每行包含3个正整数 $x,y,z,$ 表示 U 公司的每一条航班的出发地，目的地以及 Blue Mary 最多能够买到的这一航班某一天出发的票数。(即：无论是哪一天，Blue Mary 最多只能买到 $z$ 张 U 航空公司的从城市 $x$ 出发到城市 $y$ 的机票)。\n\n输入保证从一个城市到另一个城市的单向航班最多只有一个。", "outputFormat": "仅有一行，包含一个正整数，表示最后到达 B 市的人的最早到达时间。假设他们第一次乘飞机的那一天是第一天。", "hint": "对于 $100\\%$ 的数据，$2\\le N\\le 50,1\\le M\\le 2450,1\\le T,z\\le 50,1\\le x,y\\le N,x\\neq y$。", "locale": "zh-CN"}}}
{"pid": "P4401", "type": "P", "difficulty": 4, "samples": [["6\nMBMFFB", "12"], ["16\nMMBMBBBBMMMMMBMB", "29"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [18000, 18000, 18000, 18000, 18000, 18000, 18000, 18000, 18000, 18000, 18000, 18000]}, "tags": ["动态规划 DP", "2007", "IOI"], "title": "[IOI 2007] Miners 矿工配餐", "background": "", "description": "现有两个煤矿，每个煤矿都雇用一组矿工。采煤工作很辛苦，所以矿工们需要良好饮食。每当一辆食品车到达煤矿时，矿工们便会产出一定数量的煤。\n\n有三种类型的食品车：肉车，鱼车和面包车。\n矿工们喜欢变化的食谱。如果提供的食品能够不断变化，他们的产煤量将会增加。每当一个新的食品车到达煤矿时，矿工们就会比较这种新的食品和前两次（或者少于两次，如果前面运送食品的次数不足两次）的食品，并且：\n\n- 如果这几次食品车都是同一类型的食品，则矿工们产出一个单位的煤。\n- 如果这几次食品车中有两种不同类型的食品，则矿工们产出两个单位的煤。\n- 如果这几次食品车中有三种不同类型的食品，则矿工们产出三个单位的煤。\n\n预先已知食品车的类型及其被配送的顺序。通过确定哪车食品送到哪个煤矿可以影响产煤量。食品车不能被拆分，每个食品车必须被全部送到一个或另一个煤矿。两个煤矿也并不要求接收相同数量的食品车（事实上，也允许将所有食品车都送到一个煤矿）。\n\n给出食品车的类型及其被配送的顺序，要求你写一个程序，确定哪个食品车应被送到煤矿 $1$，哪个食品车应被送到煤矿 $2$，以使得两个煤矿的产煤量的总和最大。", "inputFormat": "输入的第一行包含一个整数 $N (1 ≤ N ≤ 100 000)$,  表示食品车的数目。\n\n第二行包含一个由 $N$ 个字符组成的字符串，按照配送顺序依次表示食品车配送的食品的类型。每个字符是以下三个大写字母之一：`M`（表示肉类），`F`（表示鱼类）或 `B`（表示面包）。", "outputFormat": "输出一个整数，表示最大的总产煤量。", "hint": "在样例 $1$ 中，可以按照如下的顺序运送食品车：煤矿 $1$，煤矿 $1$，煤矿 $2$，煤矿 $2$，煤矿 $1$，煤矿 $2$，依次产生的产煤量为 $1, 2, 1, 2, 3$ 和 $3$ 个单位，一共是 $12$ 个单位。\n\n还有其它运送方式也能产生上述最大总和的产煤量。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2007] Miners - Meal Assignment", "background": "", "description": "There are two coal mines, each employing a group of miners. Mining is hard work, so the miners need good meals. Whenever a food truck arrives at a mine, the miners produce some amount of coal.\n\nThere are three types of food trucks: meat truck, fish truck, and bread truck. Miners like variety in their meals. If the food keeps changing, their coal output increases. Whenever a new food truck arrives at a mine, the miners compare this new food type with the previous two (or fewer if fewer than two deliveries have occurred at that mine), and:\n\n- If these deliveries are all the same food type, the miners produce $1$ unit of coal.\n- If there are exactly two different food types among these deliveries, the miners produce $2$ units of coal.\n- If there are three different food types among these deliveries, the miners produce $3$ units of coal.\n\nThe types of food trucks and their delivery order are known in advance. By deciding which truck goes to which mine, you can influence the coal output. A food truck cannot be split; each truck must be sent entirely to one mine or the other. The two mines do not need to receive the same number of trucks (indeed, it is allowed to send all trucks to a single mine).\n\nGiven the types of food trucks and their delivery order, write a program to decide which truck should be sent to mine $1$ and which to mine $2$ so that the total coal output of the two mines is maximized.", "inputFormat": "The first line contains an integer $N$ $(1 \\le N \\le 100000)$, the number of food trucks.\n\nThe second line contains a string of $N$ characters, in delivery order, representing the type of food carried by each truck. Each character is one of the following three uppercase letters: `M` (meat), `F` (fish), or `B` (bread).", "outputFormat": "Output a single integer: the maximum total coal output.", "hint": "In sample $1$, you can deliver the trucks in the following sequence: mine $1$, mine $1$, mine $2$, mine $2$, mine $1$, mine $2$, producing $1, 2, 1, 2, 3$, and $3$ units respectively, for a total of $12$ units.\n\nOther delivery plans can also achieve this maximum total.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2007] Miners 矿工配餐", "background": "", "description": "现有两个煤矿，每个煤矿都雇用一组矿工。采煤工作很辛苦，所以矿工们需要良好饮食。每当一辆食品车到达煤矿时，矿工们便会产出一定数量的煤。\n\n有三种类型的食品车：肉车，鱼车和面包车。\n矿工们喜欢变化的食谱。如果提供的食品能够不断变化，他们的产煤量将会增加。每当一个新的食品车到达煤矿时，矿工们就会比较这种新的食品和前两次（或者少于两次，如果前面运送食品的次数不足两次）的食品，并且：\n\n- 如果这几次食品车都是同一类型的食品，则矿工们产出一个单位的煤。\n- 如果这几次食品车中有两种不同类型的食品，则矿工们产出两个单位的煤。\n- 如果这几次食品车中有三种不同类型的食品，则矿工们产出三个单位的煤。\n\n预先已知食品车的类型及其被配送的顺序。通过确定哪车食品送到哪个煤矿可以影响产煤量。食品车不能被拆分，每个食品车必须被全部送到一个或另一个煤矿。两个煤矿也并不要求接收相同数量的食品车（事实上，也允许将所有食品车都送到一个煤矿）。\n\n给出食品车的类型及其被配送的顺序，要求你写一个程序，确定哪个食品车应被送到煤矿 $1$，哪个食品车应被送到煤矿 $2$，以使得两个煤矿的产煤量的总和最大。", "inputFormat": "输入的第一行包含一个整数 $N (1 ≤ N ≤ 100 000)$,  表示食品车的数目。\n\n第二行包含一个由 $N$ 个字符组成的字符串，按照配送顺序依次表示食品车配送的食品的类型。每个字符是以下三个大写字母之一：`M`（表示肉类），`F`（表示鱼类）或 `B`（表示面包）。", "outputFormat": "输出一个整数，表示最大的总产煤量。", "hint": "在样例 $1$ 中，可以按照如下的顺序运送食品车：煤矿 $1$，煤矿 $1$，煤矿 $2$，煤矿 $2$，煤矿 $1$，煤矿 $2$，依次产生的产煤量为 $1, 2, 1, 2, 3$ 和 $3$ 个单位，一共是 $12$ 个单位。\n\n还有其它运送方式也能产生上述最大总和的产煤量。", "locale": "zh-CN"}}}
{"pid": "P4402", "type": "P", "difficulty": 6, "samples": [["6\n3 4 5 1 6 2", "4 6 4 5 6 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "平衡树", "ICPC", "CERC"], "title": "[CERC2007] robotic sort 机械排序", "background": "", "description": "SORT 公司是一个专门为人们提供排序服务的公司，该公司的宗旨是：“顺序是最美丽的”。他们的工作是通过一系列移动，将某些物品按顺序摆好。他们的工作规定只能使用如下方法排序：\n\n![](https://cdn.luogu.com.cn/upload/pic/17272.png)\n\n先找到编号最小的物品的位置 $P_1$，将区间 $[1,P_1]$ 反转，再找到编号第二小的物品的位置 $P_2$，将区间 $[2,P_2]$ 反转.........\n\n上图是有 $6$ 个物品的例子，编号最小的一个是在第 $4$ 个位置。因此，最开始把前面 $4$ 个物品反转，第二小的物品在最后一个位置，所以下一个操作是把 $2\\sim 6$ 的物品反转，第三步操作是把 $3\\sim 4$ 的物品进行反转……\n\n在数据中可能存在有相同的编号，如果有多个相同的编号，则按输入的原始次序操作。", "inputFormat": "输入共两行，第一行为一个整数 $N(1\\leq N\\leq 10^5)$，表示物品的个数。\n\n第二行为 $N$ 个用空格隔开的整数，表示 $N$ 个物品最初排列的编号 $A_i(0\\leq A_i\\leq 10^7)$。", "outputFormat": "输出共一行，$N$ 个用空格隔开的正整数 $P_1,P_2,P_3\\cdots,P_n$，$P_i$ 表示第 $i$ 次操作前第 $i$ 小的物品所在的位置。\n\n注意：如果第 $i$ 次操作前，第 $i$ 小的物品己经在正确的位置 $P_i$ 上，我们将区间 $[P_i,P_i]$ 反转（单个物品）。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2007] Robotic Sort", "background": "", "description": "SORT is a company that provides sorting services with the motto: \"Order is the most beautiful.\" Their job is to arrange certain items in order through a sequence of moves. The work rule allows only the following method to sort:\n\n![](https://cdn.luogu.com.cn/upload/pic/17272.png)\n\nFirst find the position of the smallest-labeled item, denoted $P_1$, then reverse the segment $[1, P_1]$. Next find the position of the second smallest item, denoted $P_2$, and reverse the segment $[2, P_2]$... and so on.\n\nThe figure shows an example with $6$ items. The smallest item is at position $4$. Therefore, we first reverse the first $4$ items. The second smallest item is at the last position, so the next operation is to reverse items $2 \\sim 6$. The third step is to reverse items $3 \\sim 4$...\n\nThere may be duplicate labels in the input. If multiple items have the same label, operate on them according to their original input order.", "inputFormat": "The input has two lines. The first line contains an integer $N (1 \\leq N \\leq 10^5)$, the number of items.\n\nThe second line contains $N$ space-separated integers, the initial labels $A_i (0 \\leq A_i \\leq 10^7)$ of the $N$ items.", "outputFormat": "Output a single line with $N$ space-separated positive integers $P_1, P_2, P_3 \\cdots, P_N$, where $P_i$ is the position of the $i$-th smallest item before the $i$-th operation.\n\nNote: If before the $i$-th operation the $i$-th smallest item is already at the correct position $P_i$, we reverse the segment $[P_i, P_i]$ (a single item).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2007] robotic sort 机械排序", "background": "", "description": "SORT 公司是一个专门为人们提供排序服务的公司，该公司的宗旨是：“顺序是最美丽的”。他们的工作是通过一系列移动，将某些物品按顺序摆好。他们的工作规定只能使用如下方法排序：\n\n![](https://cdn.luogu.com.cn/upload/pic/17272.png)\n\n先找到编号最小的物品的位置 $P_1$，将区间 $[1,P_1]$ 反转，再找到编号第二小的物品的位置 $P_2$，将区间 $[2,P_2]$ 反转.........\n\n上图是有 $6$ 个物品的例子，编号最小的一个是在第 $4$ 个位置。因此，最开始把前面 $4$ 个物品反转，第二小的物品在最后一个位置，所以下一个操作是把 $2\\sim 6$ 的物品反转，第三步操作是把 $3\\sim 4$ 的物品进行反转……\n\n在数据中可能存在有相同的编号，如果有多个相同的编号，则按输入的原始次序操作。", "inputFormat": "输入共两行，第一行为一个整数 $N(1\\leq N\\leq 10^5)$，表示物品的个数。\n\n第二行为 $N$ 个用空格隔开的整数，表示 $N$ 个物品最初排列的编号 $A_i(0\\leq A_i\\leq 10^7)$。", "outputFormat": "输出共一行，$N$ 个用空格隔开的正整数 $P_1,P_2,P_3\\cdots,P_n$，$P_i$ 表示第 $i$ 次操作前第 $i$ 小的物品所在的位置。\n\n注意：如果第 $i$ 次操作前，第 $i$ 小的物品己经在正确的位置 $P_i$ 上，我们将区间 $[P_i,P_i]$ 反转（单个物品）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4403", "type": "P", "difficulty": 3, "samples": [["3 \n2 \n1 10 1 \n2 10 1 \n2 \n1 10 1 \n1 10 1 \n4 \n1 10 1 \n4 4 1 \n1 5 1 \n6 10 1 ", "1 1 \nPoor QIN Teng:( \n4 3 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "倍增", "二分", "北京"], "title": "[BJWC2008] 秦腾与教学评估", "background": null, "description": "在秦腾进入北京大学学习的第一个学期，就不幸遇到了前所未有的教学评估。\n\n在教学评估期间，同学们被要求八点起床，十一点回宿舍睡觉，不准旷课，上课不准迟到，上课不准睡觉……甚至连著名的北大三角地也在教学评估期间被以影响校容的理由被拆除。这些“变态”规定令习惯了自由自在随性生活学习的北大同学叫苦不迭。\n\n这一天又到了星期五，一大早就是秦腾最不喜欢的高等代数课。可是因为是教学评估时期，不能迟到，于是他在八点五分的时候挣扎着爬出了宿舍，希望能赶快混进在八点钟已经上课了的教室。\n\n可是，刚一出宿舍楼门他就傻眼了：从宿舍到教学楼的路上已经站满了教学评估团的成员。他们的目的就是抓住像他这样迟到的学生，扣除学校的分数。\n\n秦腾当然不能让评估团得逞。他经过观察发现，整个评估团分成了 $N$ 个小组，每个小组的成员都分布在从宿舍楼到教学楼的路上的某一段，并且同一小组的成员间的距离是相等的。于是，我们可以用三个整数 $S,E,D$ 来描述评估团的小组：既该小组的成员在从宿舍到教学楼的路上的 $:S,S+D,S+2D,\\ldots,S+KD(K \\in \\mathbb Z,S+KD\\le E,S+(K+1)D>E)$ 位置。\n\n观察到了教学评估团的这一特点，又经过了认真的思考，秦腾想出了对策 $:$ 如果在路上的某一位置有奇数个教学评估团成员，他就可以运用调虎离山，声东击西，隔山打牛，暗度陈仓等方法，以这一地点为突破口到达教学楼。\n\n但是由于教学评估团的成员的十分狡猾，成员位置安排的设计极其精妙，导致在整条路上几乎没有这样的位置出现。即使由于安排不慎重出现了这样的位置，最多也仅有一个。\n\n现在秦腾观察出了所有小组的安排，但是由于整个教学评估团的人数太多，他实在看不出这样的位置是否存在。\n\n现在，你的任务是写一个程序，帮助他做出判断。", "inputFormat": "输入文件的第一行为一个整数 $T$。\n\n接下来输入 $T$ 组相互独立的测试数据。\n\n每组测试数据的第一行包含一个整数，代表 $N$。\n\n接下来的 $N$ 行，每行三个整数 $S_i,E_i,D_i$，代表第 $i$ 个小组对应的三个参数。", "outputFormat": "对于每个测试数据，如果题目中所求的位置不存在，既任意位置都有偶数个教学评估团的成员存在，在输出文件的中打印一行:`Poor QIN Teng:(`。\n\n否则打印两个整数 $\\text{Posi},\\text{Count}$，代表在唯一的位置 $\\text{Posi}$，有 $\\text{Count}$ 个教学评估团的成员。\n\n根据题意，$\\text{Count}$ 应为奇数。", "hint": "数据范围：\n\n- 教学评估团的总人数不大于 $10^8$；\n- $S_i\\le E_i$；\n- $1\\le T\\le 5$；\n- $N\\le 2 \\times 10^5$；\n- $0\\le S_i,E_i,D_i\\le 2^{31}-1$；\n- 输入文件的大小不大于 2048 KB。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2008] Qin Teng and the Teaching Evaluation", "background": "", "description": "In his first semester at Peking University, Qin Teng unfortunately encountered an unprecedented teaching evaluation.\n\nDuring the evaluation, students were required to get up at 8 a.m., return to the dormitory at 11 p.m., were not allowed to skip classes, not allowed to be late, not allowed to sleep in class... Even the famous Triangle Area of PKU was demolished during the evaluation on the grounds that it affected the campus appearance. These \"absurd\" rules made students who were used to a free and easy life miserable.\n\nIt was Friday again, and early in the morning was Qin Teng’s least favorite Advanced Algebra class. But since it was the evaluation period, he could not be late, so at 8:05 he struggled out of the dorm, hoping to slip into the classroom that had already started at 8:00.\n\nHowever, as soon as he left the dormitory building, he was stunned: the road from the dormitory to the teaching building was already lined with members of the evaluation team. Their goal was to catch late students like him and deduct points from the university.\n\nOf course, Qin Teng could not let them succeed. He observed that the entire evaluation team was divided into $N$ groups. The members of each group were distributed on some segment of the road from the dormitory to the teaching building, and the distances between members of the same group were equal. Thus, we can describe a group with three integers $S,E,D$: the members of this group are located at $:S,S+D,S+2D,\\ldots,S+KD(K \\in \\mathbb Z,S+KD\\le E,S+(K+1)D>E)$ along the road.\n\nSeeing this pattern and thinking carefully, Qin Teng came up with a countermeasure: if there is a position on the road with an odd number of evaluation team members, he can use tricks such as \"diaohu lishan\", \"shengdong xixi\", \"geshan daniu\", and \"andu chencang\" to break through at that spot and reach the teaching building.\n\nBut the members were very cunning, and their arrangement was extremely clever, so that such a position hardly appeared on the whole road. Even if, by accident, such a position did appear, there would be at most one.\n\nNow that Qin Teng has observed all the groups’ arrangements, he still cannot tell whether such a position exists because there are too many people.\n\nYour task is to write a program to help him decide.", "inputFormat": "The first line contains an integer $T$.\n\nThen $T$ independent testdata follow.\n\nFor each piece of testdata, the first line contains an integer $N$.\n\nEach of the next $N$ lines contains three integers $S_i,E_i,D_i$, representing the three parameters of the $i$-th group.", "outputFormat": "For each testdata, if the required position does not exist, i.e., every position has an even number of evaluation team members, print one line: `Poor QIN Teng:(`.\n\nOtherwise, print two integers $\\text{Posi},\\text{Count}$, meaning that at the unique position $\\text{Posi}$ there are $\\text{Count}$ evaluation team members.\n\nAccording to the statement, $\\text{Count}$ should be odd.", "hint": "Constraints:\n\n- The total number of evaluation team members is not greater than $10^8$.\n- $S_i \\le E_i$.\n- $1 \\le T \\le 5$.\n- $N \\le 2 \\times 10^5$.\n- $0 \\le S_i,E_i,D_i \\le 2^{31}-1$.\n- The size of the input file is not greater than 2048 KB.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2008] 秦腾与教学评估", "background": null, "description": "在秦腾进入北京大学学习的第一个学期，就不幸遇到了前所未有的教学评估。\n\n在教学评估期间，同学们被要求八点起床，十一点回宿舍睡觉，不准旷课，上课不准迟到，上课不准睡觉……甚至连著名的北大三角地也在教学评估期间被以影响校容的理由被拆除。这些“变态”规定令习惯了自由自在随性生活学习的北大同学叫苦不迭。\n\n这一天又到了星期五，一大早就是秦腾最不喜欢的高等代数课。可是因为是教学评估时期，不能迟到，于是他在八点五分的时候挣扎着爬出了宿舍，希望能赶快混进在八点钟已经上课了的教室。\n\n可是，刚一出宿舍楼门他就傻眼了：从宿舍到教学楼的路上已经站满了教学评估团的成员。他们的目的就是抓住像他这样迟到的学生，扣除学校的分数。\n\n秦腾当然不能让评估团得逞。他经过观察发现，整个评估团分成了 $N$ 个小组，每个小组的成员都分布在从宿舍楼到教学楼的路上的某一段，并且同一小组的成员间的距离是相等的。于是，我们可以用三个整数 $S,E,D$ 来描述评估团的小组：既该小组的成员在从宿舍到教学楼的路上的 $:S,S+D,S+2D,\\ldots,S+KD(K \\in \\mathbb Z,S+KD\\le E,S+(K+1)D>E)$ 位置。\n\n观察到了教学评估团的这一特点，又经过了认真的思考，秦腾想出了对策 $:$ 如果在路上的某一位置有奇数个教学评估团成员，他就可以运用调虎离山，声东击西，隔山打牛，暗度陈仓等方法，以这一地点为突破口到达教学楼。\n\n但是由于教学评估团的成员的十分狡猾，成员位置安排的设计极其精妙，导致在整条路上几乎没有这样的位置出现。即使由于安排不慎重出现了这样的位置，最多也仅有一个。\n\n现在秦腾观察出了所有小组的安排，但是由于整个教学评估团的人数太多，他实在看不出这样的位置是否存在。\n\n现在，你的任务是写一个程序，帮助他做出判断。", "inputFormat": "输入文件的第一行为一个整数 $T$。\n\n接下来输入 $T$ 组相互独立的测试数据。\n\n每组测试数据的第一行包含一个整数，代表 $N$。\n\n接下来的 $N$ 行，每行三个整数 $S_i,E_i,D_i$，代表第 $i$ 个小组对应的三个参数。", "outputFormat": "对于每个测试数据，如果题目中所求的位置不存在，既任意位置都有偶数个教学评估团的成员存在，在输出文件的中打印一行:`Poor QIN Teng:(`。\n\n否则打印两个整数 $\\text{Posi},\\text{Count}$，代表在唯一的位置 $\\text{Posi}$，有 $\\text{Count}$ 个教学评估团的成员。\n\n根据题意，$\\text{Count}$ 应为奇数。", "hint": "数据范围：\n\n- 教学评估团的总人数不大于 $10^8$；\n- $S_i\\le E_i$；\n- $1\\le T\\le 5$；\n- $N\\le 2 \\times 10^5$；\n- $0\\le S_i,E_i,D_i\\le 2^{31}-1$；\n- 输入文件的大小不大于 2048 KB。", "locale": "zh-CN"}}}
{"pid": "P4404", "type": "P", "difficulty": 6, "samples": [["6 2\n1 2 3 1 2 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "各省省选", "离散化", "江苏", "优先队列"], "title": "[JSOI2010] 缓存交换", "background": "感谢 @ACdreamer 贡献数据", "description": "在计算机中，CPU 只能和高速缓存 Cache 直接交换数据。当所需的内存单元不在 Cache 中时，则需要从主存里把数据调入 Cache。此时，如果 Cache 容量已满，则必须先从中删除一个。 \n\n例如，当前 Cache 容量为 $3$，且已经有编号为 $10$ 和 $20$ 的主存单元。 \n此时，CPU 访问编号为 $10$ 的主存单元，Cache 命中。 \n\n接着，CPU访问编号为 $21$ 的主存单元，那么只需将该主存单元移入 Cache 中，造成一次缺失（Cache Miss）。 \n\n接着，CPU访问编号为 $31$ 的主存单元，则必须从 Cache 中换出一块，才能将编号为 $31$ 的主存单元移入 Cache，假设我们移出了编号为 $10$ 的主存单元。 \n\n接着，CPU再次访问编号为 $10$ 的主存单元，则又引起了一次缺失。我们看到，如果在上一次删除时，删除其他的单元，则可以避免本次访问的缺失。 \n\n在现代计算机中，往往采用 LRU（最近最少使用）的算法来进行 Cache 调度——可是，从上一个例子就能看出，这并不是最优的算法。 \n对于一个固定容量的空 Cache 和连续的若干主存访问请求，聪聪想知道如何在每次 Cache 缺失时换出正确的主存单元，以达到最少的 Cache 缺失次数。", "inputFormat": "输入文件第一行包含两个整数 $N$ 和 $M$ （$1 \\le M \\le N \\le 10^5$），分别代表了主存访问的次数和 Cache 的容量。 \n\n第二行包含了N个空格分开的正整数，按访问请求先后顺序给出了每个主存块的编号（不超过 $10^9$）。", "outputFormat": "输出一行，为 Cache 缺失次数的最小值。", "hint": "在第 $4$ 次缺失时将 $3$ 号单元换出 Cache。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2010] Cache Replacement", "background": "Thanks to @ACdreamer for contributing the testdata.", "description": "In a computer, the CPU can exchange data directly only with the Cache. When the required main memory block is not in the Cache, the data must be brought in from main memory. If the Cache is already full at that time, one block must be removed first.\n\nFor example, suppose the Cache capacity is $3$, and it currently holds main memory blocks numbered $10$ and $20$.  \nNow, the CPU accesses block $10$, which is a cache hit.\n\nNext, the CPU accesses block $21$, so we just bring that block into the Cache, causing one cache miss.\n\nThen, the CPU accesses block $31$, so one block must be evicted from the Cache before bringing block $31$ in. Suppose we evict block $10$.\n\nAfter that, the CPU accesses block $10$ again, which causes another miss. We can see that if we had evicted a different block the previous time, we could have avoided this miss.\n\nModern computers often use the LRU (Least Recently Used) algorithm for Cache management—but as the example shows, it is not optimal.  \nGiven an empty Cache with fixed capacity and a sequence of main memory access requests, Congcong wants to know which block to evict on each cache miss to minimize the total number of cache misses.", "inputFormat": "The first line contains two integers $N$ and $M$ ($1 \\le M \\le N \\le 10^5$), representing the number of main memory accesses and the capacity of the Cache.\n\nThe second line contains $N$ space-separated positive integers, giving the ID of each main memory block in access order (each does not exceed $10^9$).", "outputFormat": "Output one line: the minimum possible number of cache misses.", "hint": "On the $4$-th miss, evict block number $3$ from the Cache.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2010] 缓存交换", "background": "感谢 @ACdreamer 贡献数据", "description": "在计算机中，CPU 只能和高速缓存 Cache 直接交换数据。当所需的内存单元不在 Cache 中时，则需要从主存里把数据调入 Cache。此时，如果 Cache 容量已满，则必须先从中删除一个。 \n\n例如，当前 Cache 容量为 $3$，且已经有编号为 $10$ 和 $20$ 的主存单元。 \n此时，CPU 访问编号为 $10$ 的主存单元，Cache 命中。 \n\n接着，CPU访问编号为 $21$ 的主存单元，那么只需将该主存单元移入 Cache 中，造成一次缺失（Cache Miss）。 \n\n接着，CPU访问编号为 $31$ 的主存单元，则必须从 Cache 中换出一块，才能将编号为 $31$ 的主存单元移入 Cache，假设我们移出了编号为 $10$ 的主存单元。 \n\n接着，CPU再次访问编号为 $10$ 的主存单元，则又引起了一次缺失。我们看到，如果在上一次删除时，删除其他的单元，则可以避免本次访问的缺失。 \n\n在现代计算机中，往往采用 LRU（最近最少使用）的算法来进行 Cache 调度——可是，从上一个例子就能看出，这并不是最优的算法。 \n对于一个固定容量的空 Cache 和连续的若干主存访问请求，聪聪想知道如何在每次 Cache 缺失时换出正确的主存单元，以达到最少的 Cache 缺失次数。", "inputFormat": "输入文件第一行包含两个整数 $N$ 和 $M$ （$1 \\le M \\le N \\le 10^5$），分别代表了主存访问的次数和 Cache 的容量。 \n\n第二行包含了N个空格分开的正整数，按访问请求先后顺序给出了每个主存块的编号（不超过 $10^9$）。", "outputFormat": "输出一行，为 Cache 缺失次数的最小值。", "hint": "在第 $4$ 次缺失时将 $3$ 号单元换出 Cache。", "locale": "zh-CN"}}}
{"pid": "P4405", "type": "P", "difficulty": 6, "samples": [["10 5\n2 2 2 1 1 1 1 1 1 2", "0 1 0 1 0 1 0 1 0 2 0 1 0 2 0 1 0 1 0 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "浙江"], "title": "[ZJOI2009] 硬币游戏", "background": "", "description": "Orez很喜欢玩游戏，他最近发明了一款硬币游戏。他在桌子的边缘上划分出2*n个位置并按顺时针把它们标号为1，2，……，2n，然后把n个硬币放在标号为奇数的位置上。\n\n接下来每次按如下操作：在任意两个硬币之间放上一个硬币，然后将原来的硬币拿走；所放硬币的正反面由它两边的两个硬币决定，若两个硬币均为正面朝上或反面朝上，则所放硬币为正面朝上，否则为反面朝上。 那么操作T次之后桌子边缘上硬币的情况会是怎样的呢？", "inputFormat": "文件的第一行包含两个整数n和T。\n\n 接下的一行包含n个整数，表示最开始桌面边缘的硬币摆放情况，第i个整数ai表示第i个硬币摆放在2*i-1个位置上，ai=1表示正面朝上，ai=2表示反面朝上。\n", "outputFormat": "文件仅包含一行，为2n个整数，其中第i个整数bi桌面边缘的第i个位置上硬币的情况，bi=1表示正面朝上，bi=2表示反面朝上，bi=0表示没有硬币。\n", "hint": "30%的数据 n≤1000 T≤1000\n\n100%的数据 n≤100000 T≤2^60\n\n样例解释\n```\n20202010101010101020\n01010201010101010201\n10102020101010102020\n01020102010101020102\n20202020201010202020\n01010101020102010101\n```", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2009] Coin Game", "background": "", "description": "Orez likes playing games, and he recently invented a coin game. He divides the edge of a table into $2n$ positions and labels them clockwise as $1, 2, \\ldots, 2n$, then places $n$ coins on the positions with odd labels.\n\nEach operation is as follows: place one coin between any two coins, and then remove those two original coins. The side of the newly placed coin is determined by the two coins on its sides. If both coins are heads up or both are tails up, the new coin is heads up; otherwise, it is tails up. After performing the operation $T$ times, what will the configuration of coins along the edge of the table be.", "inputFormat": "The first line contains two integers $n$ and $T$.\n\nThe next line contains $n$ integers, describing the initial arrangement of coins along the edge. The $i$-th integer $a_i$ gives the state of the coin placed at position $2i-1$, where $a_i = 1$ means heads up and $a_i = 2$ means tails up.", "outputFormat": "Output a single line with $2n$ integers. The $i$-th integer $b_i$ is the state at position $i$ along the edge of the table, where $b_i = 1$ means heads up, $b_i = 2$ means tails up, and $b_i = 0$ means there is no coin.", "hint": "30% of the testdata: $n \\le 1000$, $T \\le 1000$.\n\n100% of the testdata: $n \\le 100000$, $T \\le 2^{60}$.\n\nSample explanation.\n```\n20202010101010101020\n01010201010101010201\n10102020101010102020\n01020102010101020102\n20202020201010202020\n01010101020102010101\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2009] 硬币游戏", "background": "", "description": "Orez很喜欢玩游戏，他最近发明了一款硬币游戏。他在桌子的边缘上划分出2*n个位置并按顺时针把它们标号为1，2，……，2n，然后把n个硬币放在标号为奇数的位置上。\n\n接下来每次按如下操作：在任意两个硬币之间放上一个硬币，然后将原来的硬币拿走；所放硬币的正反面由它两边的两个硬币决定，若两个硬币均为正面朝上或反面朝上，则所放硬币为正面朝上，否则为反面朝上。 那么操作T次之后桌子边缘上硬币的情况会是怎样的呢？", "inputFormat": "文件的第一行包含两个整数n和T。\n\n 接下的一行包含n个整数，表示最开始桌面边缘的硬币摆放情况，第i个整数ai表示第i个硬币摆放在2*i-1个位置上，ai=1表示正面朝上，ai=2表示反面朝上。\n", "outputFormat": "文件仅包含一行，为2n个整数，其中第i个整数bi桌面边缘的第i个位置上硬币的情况，bi=1表示正面朝上，bi=2表示反面朝上，bi=0表示没有硬币。\n", "hint": "30%的数据 n≤1000 T≤1000\n\n100%的数据 n≤100000 T≤2^60\n\n样例解释\n```\n20202010101010101020\n01010201010101010201\n10102020101010102020\n01020102010101020102\n20202020201010202020\n01010101020102010101\n```", "locale": "zh-CN"}}}
{"pid": "P4406", "type": "P", "difficulty": 6, "samples": [["2\n0.0 0.0 2.0 0.0 1.0 1.0\n1.0 0.0 3.0 0.0 2.0 1.0", "1.75"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2005", "重庆", "各省省选", "枚举", "排序", "扫描线"], "title": "[CQOI2005] 三角形面积并", "background": "[加强版链接](https://www.luogu.com.cn/problem/P13338)", "description": "给出 $n$ 个三角形，求它们并的面积。", "inputFormat": "第一行为 $n(n \\leq 100)$， 即三角形的个数。\n\n以下 $n$ 行，每行 $6$ 个实数 $x_1$, $y_1$, $x_2$, $y_2$, $x_3$, $y_3$，代表三角形的顶点坐标。坐标均为不超过 $10^6$ 的实数，输入数据保留 $1$ 位小数。", "outputFormat": "输出并的面积 $u$, 保留两位小数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2005] Union Area of Triangles", "background": "[Link to the enhanced version](https://www.luogu.com.cn/problem/P13338).", "description": "Given $n$ triangles, compute the area of their union.", "inputFormat": "The first line contains $n$ ($n \\leq 100$), the number of triangles.\nEach of the next $n$ lines contains $6$ real numbers $x_1$, $y_1$, $x_2$, $y_2$, $x_3$, $y_3$, representing the coordinates of the triangle's vertices. All coordinates are real numbers not exceeding $10^6$, and the input numbers are given with $1$ decimal place.", "outputFormat": "Output the union area $u$, to two decimal places.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2005] 三角形面积并", "background": "[加强版链接](https://www.luogu.com.cn/problem/P13338)", "description": "给出 $n$ 个三角形，求它们并的面积。", "inputFormat": "第一行为 $n(n \\leq 100)$， 即三角形的个数。\n\n以下 $n$ 行，每行 $6$ 个实数 $x_1$, $y_1$, $x_2$, $y_2$, $x_3$, $y_3$，代表三角形的顶点坐标。坐标均为不超过 $10^6$ 的实数，输入数据保留 $1$ 位小数。", "outputFormat": "输出并的面积 $u$, 保留两位小数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4407", "type": "P", "difficulty": 5, "samples": [["4 3\nabcd\nabcde\naabc\nabced\nabcd\nabc\nabcdd", "-1\n2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2009", "各省省选", "江苏", "枚举", "深度优先搜索 DFS", "字典树 Trie"], "title": "[JSOI2009] 电子字典", "background": "", "description": "\n人们在英文字典中查找某个单词的时候可能不知道该单词的完整拼法，而只知道该单词的一个错误的近似拼法，这时人们可能陷入困境，为了查找一个单词而浪费大量的时间。带有模糊查询功能的电子字典能够从一定程度上解决这一问题：用户只要输入一个字符串，电子字典就返回与该单词编辑距离最小的几个单词供用户选择。\n\n字符串 $a$ 与字符串 $b$ 的编辑距离是指：允许对 $a$ 或 $b$ 串进行下列“编辑”操作，将 $a$ 变为 $b$ 或 $b$ 变为 $a$，最少“编辑”次数即为距离。\n\n1. 删除串中某个位置的字母；\n2. 添加一个字母到串中某个位置；\n3. 替换串中某一位置的一个字母为另一个字母。\n\nJSOI 团队正在开发一款电子字典，你需要帮助团队实现一个用于模糊查询功能的计数部件：对于一个待查询字符串，如果它是单词，则返回 $-1$；如果它不是单词，则返回字典中有多少个单词与它的编辑距离为 $1$。", "inputFormat": "第一行包含两个正整数 $N$ 和 $M$。\n\n接下来的 $N$ 行，每行一个字符串，第 $i+1$ 行为单词 $W_i$，单词长度在 $1$ 至 $20$ 之间。\n\n再接下来 $M$ 行，每行一个字符串，第 $i+N+1$ 表示一个待查字符串 $Q_i$。待查字符串长度在 $1$ 至 $20$ 之间。$W_i$ 和 $Q_i$ 均由小写字母构成，文件中不包含多余空格。", "outputFormat": "输出应包括 $M$ 行，第 $i$ 行为一个整数 $X_i$：\n\n- $X_i = -1$ 表示 $Q_i$ 为字典中的单词；\n\n- 否则 $X_i$ 表示与 $Q_i$ 编辑距离为 $1$ 的单词的个数。", "hint": "### 样例解释\n\n- `abcd` 在单词表中出现过；\n- `abc` 与单词 `abcd`、`aabc` 的编辑距离都是 $1$；\n- `abcdd` 与单词 `abcd`、`abcde`、`abced` 的编辑距离都是 $1$。\n\n### 数据范围与约定\n\n- 所有单词互不相同，但是查询字符串可能有重复；\n- 对 $50\\%$ 的数据范围，$N,M\\le 10^3$；\n- 对 $100\\%$ 的数据范围，$N,M\\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Electronic Dictionary", "background": "", "description": "When looking up a word in an English dictionary, people may not know the exact spelling and only know an incorrect approximate spelling. This can be frustrating and waste a lot of time. An electronic dictionary with fuzzy search can help: the user enters a string, and the dictionary returns a few words with the minimum edit distance to that string for the user to choose from.\n\nThe edit distance between string $a$ and string $b$ is defined as the minimum number of the following editing operations needed to transform $a$ into $b$ or $b$ into $a$:\n\n1. Delete a letter at some position in the string.\n2. Insert a letter at some position in the string.\n3. Replace the letter at some position in the string with another letter.\n\nThe JSOI team is developing an electronic dictionary. You need to help implement a counting module for the fuzzy search function: for a query string, if it is a word, return $-1$; if it is not a word, return how many words in the dictionary have edit distance $1$ from it.", "inputFormat": "The first line contains two positive integers $N$ and $M$.\n\nThe next $N$ lines each contain one string; the $(i+1)$-th line is the word $W_i$, with length from $1$ to $20$.\n\nThen the next $M$ lines each contain one string; the $(i+N+1)$-th line is the query string $Q_i$. The length of each query string is from $1$ to $20$. Each of $W_i$ and $Q_i$ consists of lowercase letters. There are no extra spaces in the input.", "outputFormat": "Output $M$ lines. The $i$-th line contains an integer $X_i$:\n- $X_i = -1$ means $Q_i$ is a word in the dictionary.\n- Otherwise, $X_i$ is the number of dictionary words whose edit distance from $Q_i$ is $1$.", "hint": "Sample explanation:\n- `abcd` appears in the word list.\n- The edit distance between `abc` and each of `abcd` and `aabc` is $1$.\n- The edit distance between `abcdd` and each of `abcd`, `abcde`, and `abced` is $1$.\n\nConstraints and Notes:\n- All words are distinct, but query strings may repeat.\n- For $50\\%$ of the constraints, $N, M \\le 10^3$.\n- For $100\\%$ of the constraints, $N, M \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 电子字典", "background": "", "description": "\n人们在英文字典中查找某个单词的时候可能不知道该单词的完整拼法，而只知道该单词的一个错误的近似拼法，这时人们可能陷入困境，为了查找一个单词而浪费大量的时间。带有模糊查询功能的电子字典能够从一定程度上解决这一问题：用户只要输入一个字符串，电子字典就返回与该单词编辑距离最小的几个单词供用户选择。\n\n字符串 $a$ 与字符串 $b$ 的编辑距离是指：允许对 $a$ 或 $b$ 串进行下列“编辑”操作，将 $a$ 变为 $b$ 或 $b$ 变为 $a$，最少“编辑”次数即为距离。\n\n1. 删除串中某个位置的字母；\n2. 添加一个字母到串中某个位置；\n3. 替换串中某一位置的一个字母为另一个字母。\n\nJSOI 团队正在开发一款电子字典，你需要帮助团队实现一个用于模糊查询功能的计数部件：对于一个待查询字符串，如果它是单词，则返回 $-1$；如果它不是单词，则返回字典中有多少个单词与它的编辑距离为 $1$。", "inputFormat": "第一行包含两个正整数 $N$ 和 $M$。\n\n接下来的 $N$ 行，每行一个字符串，第 $i+1$ 行为单词 $W_i$，单词长度在 $1$ 至 $20$ 之间。\n\n再接下来 $M$ 行，每行一个字符串，第 $i+N+1$ 表示一个待查字符串 $Q_i$。待查字符串长度在 $1$ 至 $20$ 之间。$W_i$ 和 $Q_i$ 均由小写字母构成，文件中不包含多余空格。", "outputFormat": "输出应包括 $M$ 行，第 $i$ 行为一个整数 $X_i$：\n\n- $X_i = -1$ 表示 $Q_i$ 为字典中的单词；\n\n- 否则 $X_i$ 表示与 $Q_i$ 编辑距离为 $1$ 的单词的个数。", "hint": "### 样例解释\n\n- `abcd` 在单词表中出现过；\n- `abc` 与单词 `abcd`、`aabc` 的编辑距离都是 $1$；\n- `abcdd` 与单词 `abcd`、`abcde`、`abced` 的编辑距离都是 $1$。\n\n### 数据范围与约定\n\n- 所有单词互不相同，但是查询字符串可能有重复；\n- 对 $50\\%$ 的数据范围，$N,M\\le 10^3$；\n- 对 $100\\%$ 的数据范围，$N,M\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P4408", "type": "P", "difficulty": 5, "samples": [["4 3\n1 2 1\n2 3 1\n3 4 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2003", "NOI", "枚举", "树的直径"], "title": "[NOI2003] 逃学的小孩 / 数据生成器", "background": null, "description": "Chris 家的电话铃响起了，里面传出了 Chris 的老师焦急的声音：“喂，是 Chris 的家长吗？你们的孩子又没来上课，不想参加考试了吗？”一听说要考试，Chris 的父母就心急如焚，他们决定在尽量短的时间内找到 Chris。他们告诉 Chris 的老师：“根据以往的经验，Chris 现在必然躲在朋友 Shermie 或 Yashiro 家里偷玩《拳皇》游戏。现在，我们就从家出发去找 Chris，一旦找到，我们立刻给您打电话。”说完砰的一声把电话挂了。\n\nChris 居住的城市由 $N$ 个居住点和若干条连接居住点的双向街道组成，经过街道 $x$ 需花费 $T_{x}$ 分钟。可以保证，任意两个居住点间有且仅有一条通路。Chris 家在点 $C$，Shermie 和 Yashiro 分别住在点 $A$ 和点 $B$。Chris 的老师和 Chris 的父母都有城市地图，但 Chris 的父母知道点 $A$、$B$、$C$ 的具体位置而 Chris 的老师不知。\n\n为了尽快找到 Chris，Chris 的父母会遵守以下两条规则：\n\n1. 如果 $A$ 距离 $C$ 比 $B$ 距离 $C$ 近，那么 Chris 的父母先去 Shermie 家寻找 Chris，如果找不到，Chris 的父母再去 Yashiro 家；反之亦然。\n2. Chris 的父母总沿着两点间唯一的通路行走。\n\n显然，Chris 的老师知道 Chris 的父母在寻找 Chris 的过程中会遵守以上两条规则，但由于他并不知道 $A$、$B$、$C$ 的具体位置，所以现在他希望你告诉他，最坏情况下 Chris的父母要耗费多长时间才能找到 Chris？", "inputFormat": "输入文件第一行是两个整数 $N$ 和 $M$，分别表示居住点总数和街道总数。\n\n以下 $M$ 行，每行给出一条街道的信息。第 $i+1$ 行包含整数 $U_{i}$、$V_{i}$、$T_{i}$，表示街道 $i$ 连接居住点 $U_{i}$ 和 $V_{i}$，并且经过街道 $i$ 需花费 $T_{i}$ 分钟。街道信息不会重复给出。", "outputFormat": "输出文件仅包含整数 $T$，即最坏情况下 Chris 的父母需要花费 $T$ 分钟才能找到 Chris。", "hint": "对于 $100\\%$ 的数据，$3 \\le N \\le 2\\times 10^5$，$1 \\le U_{i},V_{i} \\le N$，$0 \\le T_{i} \\le 10^{9}$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2003] Truant Child / Data Generator", "background": "", "description": "The phone at Chris's home rang, and Chris's teacher spoke anxiously: \"Hello, is this Chris's parent? Your child skipped class again. Does he not want to take the exam?\" Hearing about an exam, Chris's parents became very worried. They decided to find Chris in the shortest possible time. They told the teacher: \"Based on past experience, Chris must be hiding at his friend Shermie or Yashiro's home, secretly playing The King of Fighters. Now, we'll set out from home to find Chris. As soon as we find him, we'll call you.\" With a bang, they hung up.\n\nChris's city consists of $N$ residential points and several undirected streets connecting them. It takes $T_{x}$ minutes to traverse street $x$. It is guaranteed that between any two residential points there is exactly one path. Chris's home is at point $C$, and Shermie and Yashiro live at points $A$ and $B$, respectively. Both the teacher and Chris's parents have the city map, but only Chris's parents know the exact locations of $A$, $B$, and $C$; the teacher does not.\n\nTo find Chris as quickly as possible, Chris's parents will follow these two rules:\n\n1. If the distance from $A$ to $C$ is shorter than the distance from $B$ to $C$, then Chris's parents will first go to Shermie's home to look for Chris. If he is not there, they will then go to Yashiro's home; and vice versa.\n2. Chris's parents always walk along the unique path between two points.\n\nClearly, the teacher knows that Chris's parents will follow the above two rules during their search. However, since he does not know the exact locations of $A$, $B$, and $C$, he would like you to tell him: in the worst case, how long will it take Chris's parents to find Chris?", "inputFormat": "The first line of the input contains two integers $N$ and $M$, representing the total number of residential points and the total number of streets, respectively.\n\nEach of the next $M$ lines describes one street. Line $i+1$ contains integers $U_{i}$, $V_{i}$, and $T_{i}$, indicating that street $i$ connects residential points $U_{i}$ and $V_{i}$, and it takes $T_{i}$ minutes to traverse street $i$. No street information is given more than once.", "outputFormat": "Output a single integer $T$, the number of minutes Chris's parents will need in the worst case to find Chris.", "hint": "For $100\\%$ of the testdata, $3 \\le N \\le 2\\times 10^5$, $1 \\le U_{i},V_{i} \\le N$, $0 \\le T_{i} \\le 10^{9}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2003] 逃学的小孩 / 数据生成器", "background": null, "description": "Chris 家的电话铃响起了，里面传出了 Chris 的老师焦急的声音：“喂，是 Chris 的家长吗？你们的孩子又没来上课，不想参加考试了吗？”一听说要考试，Chris 的父母就心急如焚，他们决定在尽量短的时间内找到 Chris。他们告诉 Chris 的老师：“根据以往的经验，Chris 现在必然躲在朋友 Shermie 或 Yashiro 家里偷玩《拳皇》游戏。现在，我们就从家出发去找 Chris，一旦找到，我们立刻给您打电话。”说完砰的一声把电话挂了。\n\nChris 居住的城市由 $N$ 个居住点和若干条连接居住点的双向街道组成，经过街道 $x$ 需花费 $T_{x}$ 分钟。可以保证，任意两个居住点间有且仅有一条通路。Chris 家在点 $C$，Shermie 和 Yashiro 分别住在点 $A$ 和点 $B$。Chris 的老师和 Chris 的父母都有城市地图，但 Chris 的父母知道点 $A$、$B$、$C$ 的具体位置而 Chris 的老师不知。\n\n为了尽快找到 Chris，Chris 的父母会遵守以下两条规则：\n\n1. 如果 $A$ 距离 $C$ 比 $B$ 距离 $C$ 近，那么 Chris 的父母先去 Shermie 家寻找 Chris，如果找不到，Chris 的父母再去 Yashiro 家；反之亦然。\n2. Chris 的父母总沿着两点间唯一的通路行走。\n\n显然，Chris 的老师知道 Chris 的父母在寻找 Chris 的过程中会遵守以上两条规则，但由于他并不知道 $A$、$B$、$C$ 的具体位置，所以现在他希望你告诉他，最坏情况下 Chris的父母要耗费多长时间才能找到 Chris？", "inputFormat": "输入文件第一行是两个整数 $N$ 和 $M$，分别表示居住点总数和街道总数。\n\n以下 $M$ 行，每行给出一条街道的信息。第 $i+1$ 行包含整数 $U_{i}$、$V_{i}$、$T_{i}$，表示街道 $i$ 连接居住点 $U_{i}$ 和 $V_{i}$，并且经过街道 $i$ 需花费 $T_{i}$ 分钟。街道信息不会重复给出。", "outputFormat": "输出文件仅包含整数 $T$，即最坏情况下 Chris 的父母需要花费 $T$ 分钟才能找到 Chris。", "hint": "对于 $100\\%$ 的数据，$3 \\le N \\le 2\\times 10^5$，$1 \\le U_{i},V_{i} \\le N$，$0 \\le T_{i} \\le 10^{9}$。", "locale": "zh-CN"}}}
{"pid": "P4409", "type": "P", "difficulty": 5, "samples": [["4\n2\n2\n1\n1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "递推", "2006", "二分", "各省省选", "浙江"], "title": "[ZJOI2006] 皇帝的烦恼", "background": null, "description": "经过多年的杀戮，秦皇终于统一了中国。为了抵御外来的侵略，他准备在国土边境安置 $n$ 名将军。\n\n不幸的是这 $n$ 名将军羽翼渐丰，开始展露他们的狼子野心了。他们拒绝述职、拒绝接受皇帝的圣旨。秦皇已经准备好了秘密处决这些无礼的边防大将。不过为防兵变，他决定先授予这些将军一些勋章，为自己赢得战略时间。\n\n将军们听说他们即将被授予勋章都很开心，他们纷纷上书表示感谢。第 $i$ 个将军要求得到 $a_i$ 枚不同颜色的勋章。但是这些将军都很傲气，如果两个相邻的将军拥有颜色相同的勋章他们就会认为皇帝不尊重他们，会立即造反（编号为 $i$ 的将军和编号为 $i+1$ 的将军相邻；因为他们驻扎的边境可以类似看成一个圆形，所以编号 $1$ 和编号 $n$ 的将军也相邻）。\n\n皇帝不得不满足每个将军的要求，但对他们的飞扬跋扈感到很气愤。于是皇帝决定铸造尽量少种类的勋章来满足这些狂妄者的要求。请问他至少要铸造多少种颜色的勋章？", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行每行一个整数 $a_i$，表示第 $i$ 个将军要求得到多少种勋章。", "outputFormat": "输出一个整数，即最少需要多少种勋章。", "hint": "$1 \\leq n \\leq 2 \\times 10^4$，$1 \\leq a_i  \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2006] The Emperor's Trouble", "background": "", "description": "After years of warfare, the First Emperor of Qin finally unified China. To defend against foreign invasions, he plans to station $n$ generals along the borders.\n\nUnfortunately, these $n$ generals have grown powerful and begun to reveal their ambitions. They refuse to report for duty or accept imperial edicts. The emperor has prepared to secretly execute these insolent frontier commanders. However, to prevent a mutiny, he decides to first award them some medals to buy time.\n\nThe generals are delighted to hear they will be awarded medals and each sends a letter of thanks. The $i$-th general requests $a_i$ medals of different colors. However, the generals are proud: if two adjacent generals possess medals of the same color, they will consider it disrespectful and immediately rebel (generals numbered $i$ and $i+1$ are adjacent; because their border garrisons can be regarded as forming a circle, generals $1$ and $n$ are also adjacent).\n\nThe emperor must satisfy each general’s request, but he is furious at their arrogance. He decides to cast as few colors of medals as possible to meet their demands. What is the minimum number of medal colors he needs to cast?", "inputFormat": "The first line contains an integer $n$.\n\nThe next $n$ lines each contain an integer $a_i$, the number of different colors of medals requested by the $i$-th general.", "outputFormat": "Output a single integer, the minimum number of colors required.", "hint": "$1 \\leq n \\leq 2 \\times 10^4$, $1 \\leq a_i \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2006] 皇帝的烦恼", "background": null, "description": "经过多年的杀戮，秦皇终于统一了中国。为了抵御外来的侵略，他准备在国土边境安置 $n$ 名将军。\n\n不幸的是这 $n$ 名将军羽翼渐丰，开始展露他们的狼子野心了。他们拒绝述职、拒绝接受皇帝的圣旨。秦皇已经准备好了秘密处决这些无礼的边防大将。不过为防兵变，他决定先授予这些将军一些勋章，为自己赢得战略时间。\n\n将军们听说他们即将被授予勋章都很开心，他们纷纷上书表示感谢。第 $i$ 个将军要求得到 $a_i$ 枚不同颜色的勋章。但是这些将军都很傲气，如果两个相邻的将军拥有颜色相同的勋章他们就会认为皇帝不尊重他们，会立即造反（编号为 $i$ 的将军和编号为 $i+1$ 的将军相邻；因为他们驻扎的边境可以类似看成一个圆形，所以编号 $1$ 和编号 $n$ 的将军也相邻）。\n\n皇帝不得不满足每个将军的要求，但对他们的飞扬跋扈感到很气愤。于是皇帝决定铸造尽量少种类的勋章来满足这些狂妄者的要求。请问他至少要铸造多少种颜色的勋章？", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行每行一个整数 $a_i$，表示第 $i$ 个将军要求得到多少种勋章。", "outputFormat": "输出一个整数，即最少需要多少种勋章。", "hint": "$1 \\leq n \\leq 2 \\times 10^4$，$1 \\leq a_i  \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4410", "type": "P", "difficulty": 6, "samples": [["6 7\n1 2\n2 3\n3 4\n4 1\n3 6\n3 5\n5 6\n20 10 30 15 20 10", "50"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "各省省选", "湖南", "Tarjan", "仙人掌", "基环树", "圆方树"], "title": "[HNOI2009] 无归岛", "background": "", "description": "Neverland 是个神奇的地方，它由一些岛屿环形排列组成，每个岛上都生活着之中与众不同的物种。\n\n但是这些物种都有一个共同的生活习性：对于同一个岛上的任意两个生物，他们有且仅有一个公共朋友，即对同一岛上的任意两个生物 a 和 b 有且仅有一个生物 c 既是 a 的朋友也是 b 的朋友，当然某些岛上也可能会只有一个生物孤单地生活着。\n\n这一习性有一个明显的好处，当两个生物发生矛盾的时候，他们可以请那个唯一的公共朋友来裁决谁对谁错。 另外，岛与岛之间也有交流，具体来说，每个岛都会挑选出一个最聪明的生物做代表，然后这个生物与他相邻的两个岛的代表成为朋友。 \n\n不幸运的是，A 世界准备入侵 Neverland，作为 Neverland 的守护者，Lostmonkey 想知道在一种比较坏的情况下 Neverland 的战斗力。因为和朋友并肩作战，能力会得到提升，所以 Lostmonkey 想知道在不选出一对朋友的情况下Neverland的最大战斗力。即选出一些生物，且没有一对生物是朋友，并且要求它们的战斗力之和最大。", "inputFormat": "第一行包含用空格隔开的两个整数 $n$ 和 $m$，分别表示 Neverland 的生物种数和朋友对数。\n\n接下来的 $m$ 行描述所有朋友对，具体来说，每行包含用空格隔开的两个整数 $a$ 和 $b$，表示生物 $a$ 和生物 $b$ 是朋友（每对朋友只出现一次）。第 $m+2$ 行包含用空格隔开的 $n$ 个整数，其中第 $i$ 个整数表示生物 $i$ 的战斗力 $A_i$。", "outputFormat": "仅包含一个整数，表示满足条件的最大战斗力。", "hint": "**【样例说明】**\n\n有四个岛，生物 $1$ 在 $1$ 号岛，生物 $2$ 在 $2$ 号岛，生物 $3$、$5$、$6$ 在 $3$ 号岛，生物 $4$ 在 $4$ 号岛。\n\n输入数据保证 $4≤n≤100000$，$1 \\le a,b \\le n$，$1 \\le m \\le 200000$，$-1000 \\le A_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2009] No-Return Island", "background": "", "description": "Neverland is a magical place made up of several islands arranged in a ring. Each island is home to a distinct species, and creatures live on these islands.\n\nAll these species share a common social habit: for any two creatures on the same island, they have exactly one common friend. That is, for any two creatures $a$ and $b$ on the same island, there exists exactly one creature $c$ who is a friend of both $a$ and $b$. Of course, some islands may have only one creature living alone.\n\nThere is also communication between islands. Specifically, each island chooses the smartest creature as its representative, and this representative becomes friends with the representatives of its two neighboring islands.\n\nUnfortunately, World A plans to invade Neverland. As its guardian, Lostmonkey wants to know Neverland’s fighting power in a relatively unfavorable situation. Fighting alongside friends increases ability, so Lostmonkey wants to know the maximum fighting power without selecting any pair of friends. In other words, select some creatures such that no two selected creatures are friends, and maximize the sum of their battle power.", "inputFormat": "The first line contains two integers $n$ and $m$ separated by a space, denoting the number of creatures in Neverland and the number of friend pairs.\n\nEach of the next $m$ lines describes a friend pair. Specifically, each line contains two integers $a$ and $b$ separated by a space, indicating that creature $a$ and creature $b$ are friends (each friend pair appears exactly once). The $(m+2)$-th line contains $n$ integers separated by spaces, where the $i$-th integer denotes the battle power $A_i$ of creature $i$.", "outputFormat": "Output a single integer, the maximum total battle power satisfying the condition.", "hint": "Sample explanation:\nThere are four islands. Creature $1$ is on island $1$, creature $2$ is on island $2$, creatures $3$, $5$, $6$ are on island $3$, and creature $4$ is on island $4$.\n\nConstraints:\n$4 \\le n \\le 100000$, $1 \\le a, b \\le n$, $1 \\le m \\le 200000$, $-1000 \\le A_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2009] 无归岛", "background": "", "description": "Neverland 是个神奇的地方，它由一些岛屿环形排列组成，每个岛上都生活着之中与众不同的物种。\n\n但是这些物种都有一个共同的生活习性：对于同一个岛上的任意两个生物，他们有且仅有一个公共朋友，即对同一岛上的任意两个生物 a 和 b 有且仅有一个生物 c 既是 a 的朋友也是 b 的朋友，当然某些岛上也可能会只有一个生物孤单地生活着。\n\n这一习性有一个明显的好处，当两个生物发生矛盾的时候，他们可以请那个唯一的公共朋友来裁决谁对谁错。 另外，岛与岛之间也有交流，具体来说，每个岛都会挑选出一个最聪明的生物做代表，然后这个生物与他相邻的两个岛的代表成为朋友。 \n\n不幸运的是，A 世界准备入侵 Neverland，作为 Neverland 的守护者，Lostmonkey 想知道在一种比较坏的情况下 Neverland 的战斗力。因为和朋友并肩作战，能力会得到提升，所以 Lostmonkey 想知道在不选出一对朋友的情况下Neverland的最大战斗力。即选出一些生物，且没有一对生物是朋友，并且要求它们的战斗力之和最大。", "inputFormat": "第一行包含用空格隔开的两个整数 $n$ 和 $m$，分别表示 Neverland 的生物种数和朋友对数。\n\n接下来的 $m$ 行描述所有朋友对，具体来说，每行包含用空格隔开的两个整数 $a$ 和 $b$，表示生物 $a$ 和生物 $b$ 是朋友（每对朋友只出现一次）。第 $m+2$ 行包含用空格隔开的 $n$ 个整数，其中第 $i$ 个整数表示生物 $i$ 的战斗力 $A_i$。", "outputFormat": "仅包含一个整数，表示满足条件的最大战斗力。", "hint": "**【样例说明】**\n\n有四个岛，生物 $1$ 在 $1$ 号岛，生物 $2$ 在 $2$ 号岛，生物 $3$、$5$、$6$ 在 $3$ 号岛，生物 $4$ 在 $4$ 号岛。\n\n输入数据保证 $4≤n≤100000$，$1 \\le a,b \\le n$，$1 \\le m \\le 200000$，$-1000 \\le A_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P4411", "type": "P", "difficulty": 5, "samples": [["5 6 \n7 16 9 24 6", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2010", "北京"], "title": "[BJWC2010] 取数游戏", "background": "", "description": "小 C 刚学了辗转相除法，正不亦乐乎，这小 P 又出来捣乱，给小 C 留了个 难题。 给 $N$ 个数，用 $a_1,a_2, \\cdots ,a_n$来表示。现在小 P 让小 C 依次取数，第一个数可以 随意取。假使目前取得 $a_j$，下一个数取$a_k(k>j)$，则$a_k$必须满足$\\mathrm{gcd}(a_j,a_k)≥L$。 \n\n到底要取多少个数呢？自然是越多越好！ 不用多说，这不仅是给小 C 的难题，也是给你的难题。", "inputFormat": "第一行包含两个数$N$ 和 $L$。 接下来一行，有 $N$ 个数用空格隔开，依次是 $a_1,a_2,\\cdots ,a_n$。", "outputFormat": "仅包含一行一个数，表示按上述取法，最多可以取的数的个数。", "hint": "### 样例解释\n\n选取 $3$个数$16,24,6$。$\\mathrm{gcd}(16,24)=8$，$\\mathrm{gcd}(6,24)=6$。 \n\n### 数据范围\n\n30% 的数据$N≤1000$；   \n100% 的数据 $N≤50 000,2≤L≤a_i≤1 000 000$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2010] Number Picking Game", "background": "", "description": "Xiao C has just learned the Euclidean algorithm and is enjoying it, but Xiao P comes to make trouble and leaves Xiao C with a hard problem. You are given $N$ numbers, denoted by $a_1, a_2, \\cdots, a_n$. Now Xiao P asks Xiao C to pick numbers one by one in order. The first number can be chosen arbitrarily. Suppose the current number is $a_j$. To pick the next number $a_k$ with $k > j$, the number $a_k$ must satisfy $\\mathrm{gcd}(a_j, a_k) \\ge L$.\n\nHow many numbers should be picked? Naturally, as many as possible. Needless to say, this is not only a challenge for Xiao C, but also for you.", "inputFormat": "The first line contains two numbers $N$ and $L$.  \nThe second line contains $N$ numbers separated by spaces: $a_1, a_2, \\cdots, a_n$.", "outputFormat": "Output a single line with one number, the maximum count of numbers that can be picked according to the rule.", "hint": "### Sample Explanation\nPick $3$ numbers: $16, 24, 6$. $\\mathrm{gcd}(16, 24) = 8$, $\\mathrm{gcd}(6, 24) = 6$.\n\n### Constraints\nFor 30% of the testdata, $N \\le 1000$.  \nFor 100% of the testdata, $N \\le 50\\,000$, $2 \\le L \\le a_i \\le 1\\,000\\,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2010] 取数游戏", "background": "", "description": "小 C 刚学了辗转相除法，正不亦乐乎，这小 P 又出来捣乱，给小 C 留了个 难题。 给 $N$ 个数，用 $a_1,a_2, \\cdots ,a_n$来表示。现在小 P 让小 C 依次取数，第一个数可以 随意取。假使目前取得 $a_j$，下一个数取$a_k(k>j)$，则$a_k$必须满足$\\mathrm{gcd}(a_j,a_k)≥L$。 \n\n到底要取多少个数呢？自然是越多越好！ 不用多说，这不仅是给小 C 的难题，也是给你的难题。", "inputFormat": "第一行包含两个数$N$ 和 $L$。 接下来一行，有 $N$ 个数用空格隔开，依次是 $a_1,a_2,\\cdots ,a_n$。", "outputFormat": "仅包含一行一个数，表示按上述取法，最多可以取的数的个数。", "hint": "### 样例解释\n\n选取 $3$个数$16,24,6$。$\\mathrm{gcd}(16,24)=8$，$\\mathrm{gcd}(6,24)=6$。 \n\n### 数据范围\n\n30% 的数据$N≤1000$；   \n100% 的数据 $N≤50 000,2≤L≤a_i≤1 000 000$。", "locale": "zh-CN"}}}
{"pid": "P4412", "type": "P", "difficulty": 6, "samples": [["6 9\n1 2 2\n1 3 2\n2 3 3\n3 4 3\n1 5 1\n2 6 3\n4 5 4\n4 6 7\n5 6 6\n1 3\n2 3\n3 4\n4 5\n4 6", "8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "各省省选", "上海"], "title": "[SHOI2004] 最小生成树", "background": null, "description": "给定一个简单图 $G=\\langle V.E.W\\rangle$，$V$ 为顶点集合，$E$ 为边的集合（无重边，即任意两个顶点之间至多只有一条边)，$W$ 为定义在 $E$ 上的权函数（值为整数)。给出其上的一棵生成树 $T$，现在要求用最小的代价修改 $W$，使得 $T$ 是 $G$ 上的一棵最小生成树（一个图可以有多棵最小生成树，只要 $T$ 的边权和最小即可)。对于任意一条边 $e \\in E$ 修改方法为：\n\n- 增加 $e$ 的权值，即令 $W'(e)=W(e)+\\Delta(e)$，则修改该边的代价为 $\\Delta(e)$\n- 减小 $e$ 的权值，即令 $W'(e)=W(e)-\\Delta(e)$，则修改该边的代价为 $\\Delta(e)$\n- 不改变 $e$ 的权，即 $W'(e)=W(e)$，修改代价为 $\\Delta(e)=0$。\n\n请注意：修改后的权函数 $W'$ 的值域也为整数。\n\n总的修改代价记为 $S=\\sum\\limits_{e \\in E} \\Delta(e)$。", "inputFormat": "第一行为 $N,M$，其中 $N$ 表示顶点的数目，$M$ 表示边的数目。顶点的编号为 $1,2,3,\\cdots,N-1,N$。\n\n接下来的 $M$ 行，每行三个整数 $U_i,V_i,W_i$，表示顶点 $U_i$ 与 $V_i$ 之间有一条边，其权值为 $W_i$。\n\n所有的边在输入中会且仅会出现一次。再接着 $N-1$ 行，每行两个整数 $X_i,Y_i$，表示顶点 $X_i$ 与 $Y_i$ 之间的边是 $T$ 的一条边。", "outputFormat": "输出最小的 $S$。", "hint": "边 $(4,6)$ 的权由 $7$ 修改为 $3$，代价为 $4$；  \n边 $(1,2)$ 的权由 $2$ 修改为 $3$，代价为 $1$；  \n边 $(1,5)$ 的权由 $1$ 修改为 $4$，代价为 $3$；  \n\n所以总代价为 $4+1+3=8$。\n\n$1 \\le N \\le 50,1 \\le M \\le 1500,1 \\le W_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2004] Minimum Spanning Tree", "background": "", "description": "Given a simple graph $G=\\langle V, E, W \\rangle$, where $V$ is the set of vertices, $E$ is the set of edges (no multiple edges; i.e., there is at most one edge between any two vertices), and $W$ is an integer-valued weight function defined on $E$. A spanning tree $T$ on $G$ is given. Modify $W$ with the minimum total cost so that $T$ becomes a minimum spanning tree on $G$ (a graph may have multiple minimum spanning trees; it suffices that the sum of edge weights of $T$ is minimum). For any edge $e \\in E$, the modification rules are:\n\n- Increase the weight of $e$: set $W'(e) = W(e) + \\Delta(e)$, and the cost to modify this edge is $\\Delta(e)$.\n- Decrease the weight of $e$: set $W'(e) = W(e) - \\Delta(e)$, and the cost to modify this edge is $\\Delta(e)$.\n- Do not change the weight of $e$: set $W'(e) = W(e)$, with modification cost $\\Delta(e)=0$.\n\nNote: The modified weight function $W'$ also takes integer values.\n\nThe total modification cost is $S = \\sum\\limits_{e \\in E} \\Delta(e)$.", "inputFormat": "The first line contains $N, M$, where $N$ is the number of vertices and $M$ is the number of edges. Vertices are numbered $1, 2, 3, \\dots, N-1, N$.\n\nThe next $M$ lines each contain three integers $U_i, V_i, W_i$, indicating there is an edge between vertices $U_i$ and $V_i$ with weight $W_i$.\n\nEach edge appears exactly once in the input. Then, the next $N-1$ lines each contain two integers $X_i, Y_i$, indicating that the edge between $X_i$ and $Y_i$ is an edge of $T$.", "outputFormat": "Output the minimum $S$.", "hint": "Edge $(4,6)$ has its weight changed from $7$ to $3$, with cost $4$;  \nedge $(1,2)$ has its weight changed from $2$ to $3$, with cost $1$;  \nedge $(1,5)$ has its weight changed from $1$ to $4$, with cost $3$.\n\nTherefore, the total cost is $4+1+3=8$.\n\nConstraints: $1 \\le N \\le 50$, $1 \\le M \\le 1500$, $1 \\le W_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2004] 最小生成树", "background": null, "description": "给定一个简单图 $G=\\langle V.E.W\\rangle$，$V$ 为顶点集合，$E$ 为边的集合（无重边，即任意两个顶点之间至多只有一条边)，$W$ 为定义在 $E$ 上的权函数（值为整数)。给出其上的一棵生成树 $T$，现在要求用最小的代价修改 $W$，使得 $T$ 是 $G$ 上的一棵最小生成树（一个图可以有多棵最小生成树，只要 $T$ 的边权和最小即可)。对于任意一条边 $e \\in E$ 修改方法为：\n\n- 增加 $e$ 的权值，即令 $W'(e)=W(e)+\\Delta(e)$，则修改该边的代价为 $\\Delta(e)$\n- 减小 $e$ 的权值，即令 $W'(e)=W(e)-\\Delta(e)$，则修改该边的代价为 $\\Delta(e)$\n- 不改变 $e$ 的权，即 $W'(e)=W(e)$，修改代价为 $\\Delta(e)=0$。\n\n请注意：修改后的权函数 $W'$ 的值域也为整数。\n\n总的修改代价记为 $S=\\sum\\limits_{e \\in E} \\Delta(e)$。", "inputFormat": "第一行为 $N,M$，其中 $N$ 表示顶点的数目，$M$ 表示边的数目。顶点的编号为 $1,2,3,\\cdots,N-1,N$。\n\n接下来的 $M$ 行，每行三个整数 $U_i,V_i,W_i$，表示顶点 $U_i$ 与 $V_i$ 之间有一条边，其权值为 $W_i$。\n\n所有的边在输入中会且仅会出现一次。再接着 $N-1$ 行，每行两个整数 $X_i,Y_i$，表示顶点 $X_i$ 与 $Y_i$ 之间的边是 $T$ 的一条边。", "outputFormat": "输出最小的 $S$。", "hint": "边 $(4,6)$ 的权由 $7$ 修改为 $3$，代价为 $4$；  \n边 $(1,2)$ 的权由 $2$ 修改为 $3$，代价为 $1$；  \n边 $(1,5)$ 的权由 $1$ 修改为 $4$，代价为 $3$；  \n\n所以总代价为 $4+1+3=8$。\n\n$1 \\le N \\le 50,1 \\le M \\le 1500,1 \\le W_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P4413", "type": "P", "difficulty": 1, "samples": [["11 15", "19"], ["4 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2006", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #2] R2", "background": "", "description": "The number S is called the mean of two numbers R1 and R2 if S is equal to (R1+R2)/2. Mirko's birthday present for Slavko was two integers R1 and R2. Slavko promptly calculated their mean which also happened to be an integer but then lost R2! Help Slavko restore R2.", "inputFormat": "The first and only line of input contains two integers R1 and S, both between -1000 and 1000.", "outputFormat": "Output R2 on a single line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #2] R2", "background": "", "description": "The number S is called the mean of two numbers R1 and R2 if S is equal to (R1+R2)/2. Mirko's birthday present for Slavko was two integers R1 and R2. Slavko promptly calculated their mean which also happened to be an integer but then lost R2! Help Slavko restore R2.", "inputFormat": "The first and only line of input contains two integers R1 and S, both between -1000 and 1000.", "outputFormat": "Output R2 on a single line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #2] R2", "background": "", "description": "如果数 S 等于 $(R1 + R2) / 2$，那么 S 就被称为两个数 R1 和 R2 的平均数。Mirko 送给 Slavko 的生日礼物是两个整数 R1 和 R2。Slavko 迅速计算了它们的平均数，这个平均数恰好也是一个整数，但随后他丢失了 R2！请帮助 Slavko 恢复 R2。", "inputFormat": "输入的第一行包含两个整数 R1 和 S，范围均为 -1000 到 1000。", "outputFormat": "输出 R2，单独占一行。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4414", "type": "P", "difficulty": 1, "samples": [["1 5 3\nABC", "1 3 5"], ["6 4 2\nCAB", "6 2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2006", "排序", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #2] ABC", "background": "", "description": "You will be given three integers A, B and C. The numbers will not be given in that exact order, but we do know that A is less than B and B less than C.\nIn order to make for a more pleasant viewing, we want to rearrange them in the given order.", "inputFormat": "The first line contains three positive integers A, B and C, not necessarily in that order. All three numbers will be less than or equal to 100.\nThe second line contains three uppercase letters 'A', 'B' and 'C' (with no spaces between them) representing the desired order.", "outputFormat": "Output the A, B and C in the desired order on a single line, separated by single spaces.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #2] ABC", "background": "", "description": "You will be given three integers A, B and C. The numbers will not be given in that exact order, but we do know that A is less than B and B less than C.\nIn order to make for a more pleasant viewing, we want to rearrange them in the given order.", "inputFormat": "The first line contains three positive integers A, B and C, not necessarily in that order. All three numbers will be less than or equal to 100.\nThe second line contains three uppercase letters 'A', 'B' and 'C' (with no spaces between them) representing the desired order.", "outputFormat": "Output the A, B and C in the desired order on a single line, separated by single spaces.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #2] ABC", "background": null, "description": "三个整数分别为 $A,B,C$。这三个数字不会按照这样的顺序给你，但它们始终满足条件：$A < B < C$。为了看起来更加简洁明了，我们希望你可以按照给定的顺序重新排列它们。", "inputFormat": "第一行包含三个正整数 $A,B,C$，不一定是按这个顺序。这三个数字都小于或等于 $100$。第二行包含三个大写字母 $A$、$B$ 和 $C$（它们之间**没有**空格）表示所需的顺序。", "outputFormat": "在一行中输出 $A$，$B$ 和 $C$，用一个 ` `（空格）隔开。\n\n感谢 @smartzzh 提供的翻译", "hint": "注意此题数据的换行符为 `\\r\\n`。", "locale": "zh-CN"}}}
{"pid": "P4415", "type": "P", "difficulty": 2, "samples": [["3 3\nABC\nDEF\n0", "CBADEF"], ["3 3\nABC\nDEF\n2", "CDBEAF"], ["3 4\nJLA\nCRUO\n3", "CARLUJO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2006", "枚举", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #2] KOLONE", "background": "", "description": "When moving, ants form rows so that each ant except the first is behind another ant. It is not widely known what happens when two rows of ants moving in opposite directions run into each other in a passage too narrow for both rows to pass through. One theory says that, in that situation, ants will jump over each other.\nFrom the moment the rows meet, each second every ant jumps over (or gets jumped over, as they agree upon) the ant in front of himself so that the two ants swap places, but only if the other ant is moving in the opposite direction. Find the order of the ants after T seconds.", "inputFormat": "The first line contains two integers N1 and N2, the numbers of ants in the first and second rows, respectively.\nThe next two rows contain the orders of ants in the first and second row (first to last). Each ant is uniquely determined by an uppercase letter of the English alphabet (this letter is unique between both rows).\nThe last line of input contains the integer T (0 ≤ T ≤ 50).", "outputFormat": "Output the order of the ants after T seconds on a single line. Our viewpoint is such that the first row of ants comes from our left side and the other one from our right side.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #2] KOLONE", "background": "", "description": "When moving, ants form rows so that each ant except the first is behind another ant. It is not widely known what happens when two rows of ants moving in opposite directions run into each other in a passage too narrow for both rows to pass through. One theory says that, in that situation, ants will jump over each other.\nFrom the moment the rows meet, each second every ant jumps over (or gets jumped over, as they agree upon) the ant in front of himself so that the two ants swap places, but only if the other ant is moving in the opposite direction. Find the order of the ants after T seconds.", "inputFormat": "The first line contains two integers N1 and N2, the numbers of ants in the first and second rows, respectively.\nThe next two rows contain the orders of ants in the first and second row (first to last). Each ant is uniquely determined by an uppercase letter of the English alphabet (this letter is unique between both rows).\nThe last line of input contains the integer T (0 ≤ T ≤ 50).", "outputFormat": "Output the order of the ants after T seconds on a single line. Our viewpoint is such that the first row of ants comes from our left side and the other one from our right side.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #2] KOLONE", "background": "", "description": "当蚂蚁移动时，蚂蚁排成一行，每个蚂蚁除了第一个蚂蚁都在另一个蚂蚁后面。众所周知，当两排蚂蚁在相反的方向上移动时，在一条太窄的通道中，两排都不能通过。一种理论认为，在这种情况下，蚂蚁会跳过对方。每隔一段时间，每一个蚂蚁都会跳过（或跳过去，就像他们同意的一样）蚂蚁在自己前面，这样两个蚂蚁交换位置，但是只有当另一只蚂蚁朝相反的方向移动时。在T秒后找到蚂蚁的顺序。", "inputFormat": "第一行包含两个整数N1和N2，分别在第一行和第二行中的蚂蚁的数量。接下来的两行包含第一行和第二行中的蚂蚁顺序（第一到最后一行）。每一个蚂蚁都是由一个大写字母（英文字母）唯一决定的（这两个字母在两行之间是唯一的）。输入的最后一行包含整数T(T小于50）。", "outputFormat": "在一条线上输出T秒后蚂蚁的顺序。我们的观点是，第一排蚂蚁来自我们的左侧，另一个来自我们的右侧。\n\n感谢@心之所爱 提供的翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4416", "type": "P", "difficulty": 6, "samples": [["2 2\n1 1 3 3\n5 6 10 10\n3 3 1\n5 1 2\n", "1\n0"], ["3 3\n1 1 7 7\n2 2 6 6\n3 3 5 5\n4 4 1\n2 6 2\n4 7 3\n", "3\n2\n1"], ["1 3\n1 1 7 7\n2 6 2\n4 7 3\n4 4 1\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "线段树", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #1] Plahte", "background": "", "description": "Little Donald decided to wash all N of his white sheets one day. After washing them, he put them to dry on the ground in his backyard. Donald placed the sheets so that ** none of them touch on the tips or the sides and that none of their sides intersect​**, but it is possible that he placed smaller sheets on top of bigger ones, or that a sheet is completely covering another sheet. After doing this, Donald went to bed.\n\nDonald’s friend Kim somehow got the information that Donald is drying his sheets and\ndecided to mess with him. He found a paintball gun from his father in the attic. Along with the\ngun, there were M paintball balls in different colours, but it is possible that there were more\nballs having the same colour. As soon as Donald fell asleep, Kim walked into his backyard\nand started shooting the sheets with his paintball gun. We all know that sheets bleed, so\nwhen Kim shoots the topmost sheet, that sheet would bleed the color of the ball down to all\nof the sheets beneath it. After Kim used all the balls, he happily left Donald’s backyard.\n\nWhen Donald woke up and went to get his sheets, shock ensued. On most of Donald’s\nsheets, there was a number of new colours. Since Donald is very interested in correct data,\nand he’s in shock and not able to think, he is asking you to tell him the number of new\ncolours on each sheet.\n\nWe can represent Donald’s backyard as an infinite coordinate system, and the sheets as\nrectangles parallel to the coordinate axes. Kim’s shots can be represented as points in that\nsystem.\n\nPlease note: it is possible that Kim’s shot missed all the sheets, but coordinates of each shot\nare unique.\n", "inputFormat": "The first line of input contains the positive integers N (1 ≤ N ≤ 80 000), the number of sheets,\nand M (1 ≤ M ≤ 80 000), the number of paintball balls.\n\nThe $i^{th}$ of the following N lines contains four numbers: the coordinates of the lower left corner $A_i$, $B_i$ (1 ≤ $A_i$, $B_i$ ≤ $10^9$) and the upper right corner $C_i$, $D_i$, (1 ≤ $C_i$, $D_i$ ≤ $10^9$) of the $i^{th}$ sheet.\n\nThe $j^{th}$ of the following M lines contains the coordinates where Kim’s $j^{th}$ shot landed $X_j$, $Y_j$ (1 ≤$X_j$, $Y_j$ ≤ $10^9$), and $K_j$(1 ≤ $K_j$ ≤ $10^9$), the colour label of the $j^{th}$ ball.\n", "outputFormat": "The $i^{th}$ of N lines must contain the number of new colours on the $i^{th}$ sheet.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17380.png)", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #1] Plahte", "background": "", "description": "Little Donald decided to wash all N of his white sheets one day. After washing them, he put them to dry on the ground in his backyard. Donald placed the sheets so that ** none of them touch on the tips or the sides and that none of their sides intersect​**, but it is possible that he placed smaller sheets on top of bigger ones, or that a sheet is completely covering another sheet. After doing this, Donald went to bed.\n\nDonald’s friend Kim somehow got the information that Donald is drying his sheets and\ndecided to mess with him. He found a paintball gun from his father in the attic. Along with the\ngun, there were M paintball balls in different colours, but it is possible that there were more\nballs having the same colour. As soon as Donald fell asleep, Kim walked into his backyard\nand started shooting the sheets with his paintball gun. We all know that sheets bleed, so\nwhen Kim shoots the topmost sheet, that sheet would bleed the color of the ball down to all\nof the sheets beneath it. After Kim used all the balls, he happily left Donald’s backyard.\n\nWhen Donald woke up and went to get his sheets, shock ensued. On most of Donald’s\nsheets, there was a number of new colours. Since Donald is very interested in correct data,\nand he’s in shock and not able to think, he is asking you to tell him the number of new\ncolours on each sheet.\n\nWe can represent Donald’s backyard as an infinite coordinate system, and the sheets as\nrectangles parallel to the coordinate axes. Kim’s shots can be represented as points in that\nsystem.\n\nPlease note: it is possible that Kim’s shot missed all the sheets, but coordinates of each shot\nare unique.\n", "inputFormat": "The first line of input contains the positive integers N (1 ≤ N ≤ 80 000), the number of sheets,\nand M (1 ≤ M ≤ 80 000), the number of paintball balls.\n\nThe $i^{th}$ of the following N lines contains four numbers: the coordinates of the lower left corner $A_i$, $B_i$ (1 ≤ $A_i$, $B_i$ ≤ $10^9$) and the upper right corner $C_i$, $D_i$, (1 ≤ $C_i$, $D_i$ ≤ $10^9$) of the $i^{th}$ sheet.\n\nThe $j^{th}$ of the following M lines contains the coordinates where Kim’s $j^{th}$ shot landed $X_j$, $Y_j$ (1 ≤$X_j$, $Y_j$ ≤ $10^9$), and $K_j$(1 ≤ $K_j$ ≤ $10^9$), the colour label of the $j^{th}$ ball.\n", "outputFormat": "The $i^{th}$ of N lines must contain the number of new colours on the $i^{th}$ sheet.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17380.png)", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #1] Plahte", "background": "", "description": "小唐纳德决定有一天清洗他所有的 N 张白色床单。洗完后，他把它们放在后院的地上晾干。唐纳德放置床单的方式是**它们的边缘或角落都不接触，且没有边缘相交**，但可能会有小床单放在大床单上，或者一张床单完全覆盖另一张床单。做完这些后，唐纳德就去睡觉了。\n\n唐纳德的朋友金姆不知怎么得知唐纳德正在晾床单，决定捉弄他。他从阁楼上找到了父亲的一个彩弹枪。和枪一起的，还有 M 颗不同颜色的彩弹球，但可能有多个球是相同颜色的。唐纳德一睡着，金姆就走进他的后院，开始用彩弹枪射击床单。我们都知道床单会渗色，所以当金姆射击最上面的床单时，那张床单会将彩弹的颜色渗透到下面所有的床单上。金姆用完所有的球后，开心地离开了唐纳德的后院。\n\n当唐纳德醒来去收床单时，他大吃一惊。唐纳德的许多床单上都有一些新的颜色。由于唐纳德对准确的数据非常感兴趣，而他被惊吓得无法思考，他请求你告诉他每张床单上的新颜色数量。\n\n我们可以将唐纳德的后院表示为一个无限的坐标系，床单表示为与坐标轴平行的矩形。金姆的射击可以表示为该坐标系中的点。\n\n请注意：金姆的射击可能会错过所有床单，但每次射击的坐标是唯一的。", "inputFormat": "输入的第一行包含正整数 N（1 ≤ N ≤ 80 000），表示床单的数量，和 M（1 ≤ M ≤ 80 000），表示彩弹球的数量。\n\n接下来的 N 行中的第 $i$ 行包含四个数字：第 $i$ 张床单的左下角坐标 $A_i$，$B_i$（1 ≤ $A_i$，$B_i$ ≤ $10^9$）和右上角坐标 $C_i$，$D_i$（1 ≤ $C_i$，$D_i$ ≤ $10^9$）。\n\n接下来的 M 行中的第 $j$ 行包含金姆的第 $j$ 次射击落点的坐标 $X_j$，$Y_j$（1 ≤ $X_j$，$Y_j$ ≤ $10^9$），以及第 $j$ 颗球的颜色标记 $K_j$（1 ≤ $K_j$ ≤ $10^9$）。", "outputFormat": "输出的第 $i$ 行必须包含第 $i$ 张床单上的新颜色数量。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17380.png)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4417", "type": "P", "difficulty": 4, "samples": [["2 2\n..\n..", "7"], ["4 4\nX.XX\nX..X\n..X.\n..XX", "9"], ["3 3\nX.X\n.X.\nX.X", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #2] STOL", "background": "", "description": "Mirko has bought an apartment and wants to invite to dinner as many people as possible to celebrate with him. For this he needs a large rectangular wooden table for which he will sit down with his guests. The number of people a table can accommodate is equal to its perimeter (the sum of the lengths of all four sides). Mirko wants to buy a table such that it fits in his apartment and that as many people as possible can sit down with him for dinner. The table must be placed so that its edges are parallel to the edges of the apartment.\nGiven the layout of the apartment, find the number of people Mirko can invite to dinner.", "inputFormat": "The first line contains two integers R and C (1 ≤ R, S ≤ 400), the dimensions of the apartment.\nEach of the following R rows contains exactly S characters (without spaces), whether a square is free ('.') or blocked ('X').\nMirko can put his table only in free squares.", "outputFormat": "Output the number of guests Mirko can invite to dinner after he buys his table on a single line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #2] STOL", "background": "", "description": "Mirko has bought an apartment and wants to invite to dinner as many people as possible to celebrate with him. For this he needs a large rectangular wooden table for which he will sit down with his guests. The number of people a table can accommodate is equal to its perimeter (the sum of the lengths of all four sides). Mirko wants to buy a table such that it fits in his apartment and that as many people as possible can sit down with him for dinner. The table must be placed so that its edges are parallel to the edges of the apartment.\nGiven the layout of the apartment, find the number of people Mirko can invite to dinner.", "inputFormat": "The first line contains two integers R and C (1 ≤ R, S ≤ 400), the dimensions of the apartment.\nEach of the following R rows contains exactly S characters (without spaces), whether a square is free ('.') or blocked ('X').\nMirko can put his table only in free squares.", "outputFormat": "Output the number of guests Mirko can invite to dinner after he buys his table on a single line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #2] STOL", "background": "", "description": "米尔科买了一套别墅，他想要邀请尽量多的人和他一起庆祝。他需要一张大的木质矩形桌子来让他和他的嘉宾坐下。每张桌子可容纳的人数等于它的周长（四边长度的总和）。米尔科想要买一张即可在他的公寓里放下，也可以坐下尽量多的人和他一起享用晚餐的桌子。桌子必须放置成四条边都与公寓的墙平行的样子。题目给出公寓内部的布局，请问米尔科最多可以邀请多少人吃晚餐。", "inputFormat": "第一行包含两个整数R和S（1<=R,S<=400),代表公寓的尺寸（R为宽，S为长），以下的R行中每一行都包含了S个准确的字符（没有空格），代表这个正方形区域是没有东西的('.') ，还是有东西的('X')，米尔科只等把桌子发在没有东西的正方形区域里。", "outputFormat": "输出米尔科在放下他的桌子后能够邀请来吃晚餐的人数\n\n感谢@marcoolmap 提供的翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4418", "type": "P", "difficulty": 5, "samples": [["6\n0 0 1 0\n0 0 0 1\n1 0 1 1\n0 1 1 1\n0 0 1 1\n1 0 0 1", "8"], ["4\n5 1 7 1\n1 1 5 1\n4 0 4 4\n7 0 3 4", "1"], ["3\n2 2 3 2\n3 2 3 3\n3 3 2 3", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2006", "叉积", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #2] STRAZA", "background": "", "description": "Near a military base there is a system of trenches, modeled as line segments on a plane. During nighttime, when most soldiers are fast asleep, three guards stand watch of the trenches. Two guards can see each other if there is a trench (or a row of trenches) along the entire straight line segment between them and there is no third guard on that line segment.\nFor security reasons, the guards must be placed so that each guard sees the other two. How many ways can they be placed?", "inputFormat": "The first line contains the integer N (1 ≤ N ≤ 20), the number of trenches. Each of the next N lines contains the description of one trench: four positive integers X1, Y1, X2, Y2 (all less than or equal to 1000), where X1 and Y1 are coordinates of one end, while X2 and Y2 are coordinates of the other end of the trench.\nTrenches in the input may overlap and share endpoints.", "outputFormat": "Output the number of ways the guards can be placed on a single line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2006/2007 #2] STRAZA", "background": "", "description": "Near a military base there is a system of trenches, modeled as line segments on a plane. During nighttime, when most soldiers are fast asleep, three guards stand watch of the trenches. Two guards can see each other if there is a trench (or a row of trenches) along the entire straight line segment between them and there is no third guard on that line segment.\nFor security reasons, the guards must be placed so that each guard sees the other two. How many ways can they be placed?", "inputFormat": "The first line contains the integer N (1 ≤ N ≤ 20), the number of trenches. Each of the next N lines contains the description of one trench: four positive integers X1, Y1, X2, Y2 (all less than or equal to 1000), where X1 and Y1 are coordinates of one end, while X2 and Y2 are coordinates of the other end of the trench.\nTrenches in the input may overlap and share endpoints.", "outputFormat": "Output the number of ways the guards can be placed on a single line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #2] STRAZA", "background": "", "description": "在军事基地附近有一个战壕场，其中的战壕以平面上的线段为模型。在夜间，当大多数士兵熟睡的时候，三个警卫站在战壕旁边。如果在它们之间的整个直线段上有一条战壕（或一排战壕），且该直线段上没有第三警卫，那么两个警卫可以看到彼此。出于安全原因，必须安排警卫，以便每名警卫看到另外两名警卫。它们有多少种被安排的方式？", "inputFormat": "第一行包含整数n（1≤n≤20），战壕的数目。接下来的n行中的每一行都包含一个战壕的描述：四个正整数X1,Y1,X2,Y2（都小于或等于1000），其中X1和Y1是一端的坐标，而X2和Y2是战壕另一端的坐标。输入中的战壕可能重叠并共享端点。", "outputFormat": "在这一行中，有多少种安排警卫的方式。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4419", "type": "P", "difficulty": 2, "samples": [["6\n2\n3\n2\n3\n2\n3\n", "DOSTA "], ["1\n10\n", "VUCI"], ["2\n5\n6", "VUCI"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["模拟", "2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #1] Cezar", "background": "", "description": "Little Caesar likes card games. Everytime he comes to Zagreb, he plays blackjack, the famous card game, with his friends.\n\nIn this game, the player draws cards while the sum of the cards in his hand is less than or equal to 21 or until he says “DOSTA” (Croatian for “STOP”).\n\nAt the beginning of the game, there are 52 cards in the deck, thirteen ranks of each of the four suits. The card ranks are two, three, …, ten, Jack, Queen, King and Ace. The card values are the following: the cards with numbers on them are worth that number (e.g., “nine” is 9), the cards with pictures (Jack, Queen, and King) are worth 10, whereas the Ace is worth 11.\n\nCaesar has found himself in an interesting situation. During the game, he already drew N cards whose sum is less than or equal to 21 and is now having second thoughts about drawing one more card or not. Let’s assume X is the difference from the sum of the cards so\nfar to 21. Everybody knows that you don’t draw a card if the number of the remaining cards in the deck whose value is greater than X is greater than or equal to the number of the remaining cards in the deck whose value is less than or equal to X.\n\nSince Caesar is having a difficult time calculating whether he needs to draw another card or not, he’s asking you to do it for him.\n", "inputFormat": "The first line of input contains the positive integer N (1 ≤ N ≤ 52), the number of cards Caesar has drawn so far.\n\nEach of the following N lines contains a single positive integer, the value of the $i^{th}$ card Caesar drew.", "outputFormat": "If Caesar should draw another card, output “VUCI” (Croatian for “DRAW”), otherwise output “DOSTA” (Croatian for “STOP”).", "hint": "Clarification​ ​of​ ​the​ ​first​ ​test​ ​case:\n\nThe sum of the already drawn cards is 15, and the difference X to 21 is 6. The number of cards in the\ndeck with a value greater than 6 is 32 (4 Aces, 4 Kings, 4 Queens, 4 Jacks, 4 tens, 4 nines, 4 eights, and 4 sevens), whereas the number of cards in the deck with a value less than or equal to 6 is 14 (one two, one three, 4 fours, 4 fives, and 4 sixes).", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #1] Cezar", "background": "", "description": "Little Caesar likes card games. Everytime he comes to Zagreb, he plays blackjack, the famous card game, with his friends.\n\nIn this game, the player draws cards while the sum of the cards in his hand is less than or equal to 21 or until he says “DOSTA” (Croatian for “STOP”).\n\nAt the beginning of the game, there are 52 cards in the deck, thirteen ranks of each of the four suits. The card ranks are two, three, …, ten, Jack, Queen, King and Ace. The card values are the following: the cards with numbers on them are worth that number (e.g., “nine” is 9), the cards with pictures (Jack, Queen, and King) are worth 10, whereas the Ace is worth 11.\n\nCaesar has found himself in an interesting situation. During the game, he already drew N cards whose sum is less than or equal to 21 and is now having second thoughts about drawing one more card or not. Let’s assume X is the difference from the sum of the cards so\nfar to 21. Everybody knows that you don’t draw a card if the number of the remaining cards in the deck whose value is greater than X is greater than or equal to the number of the remaining cards in the deck whose value is less than or equal to X.\n\nSince Caesar is having a difficult time calculating whether he needs to draw another card or not, he’s asking you to do it for him.\n", "inputFormat": "The first line of input contains the positive integer N (1 ≤ N ≤ 52), the number of cards Caesar has drawn so far.\n\nEach of the following N lines contains a single positive integer, the value of the $i^{th}$ card Caesar drew.", "outputFormat": "If Caesar should draw another card, output “VUCI” (Croatian for “DRAW”), otherwise output “DOSTA” (Croatian for “STOP”).", "hint": "Clarification​ ​of​ ​the​ ​first​ ​test​ ​case:\n\nThe sum of the already drawn cards is 15, and the difference X to 21 is 6. The number of cards in the\ndeck with a value greater than 6 is 32 (4 Aces, 4 Kings, 4 Queens, 4 Jacks, 4 tens, 4 nines, 4 eights, and 4 sevens), whereas the number of cards in the deck with a value less than or equal to 6 is 14 (one two, one three, 4 fours, 4 fives, and 4 sixes).", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #1] Cezar", "background": "", "description": "小凯撒喜欢玩纸牌游戏，每次他去萨格勒布（克罗地亚的首都 ——译者注）都会和他的朋友们玩 $21$ 点，这是一种很流行的纸牌游戏。\n\n这个游戏的规则是，在纸牌点数之和小于 $21$ 点之前可以连续抓牌，如果决定不抓牌，则喊 `DOSTA`（克罗地亚语“停止”的意思）。\n\n游戏开始时，桌面有 $52$ 张牌 —— $13$ 种不同牌面的牌，每种有 $4$ 个花色。牌面分别是 $2,3,\\dots,\\text J,\\text Q,\\text K,\\text A$。它们的点数计算规则是：牌面上的数字就是点数（比如，$9$ 的点数就是 $9$），特殊地，$\\text J,\\text Q,\\text K$ 都算 $10$ 点，$\\text A$ 算 $11$ 点。\n\n凯撒认为游戏的乐趣在于，当抓了 $N$ 张牌之后，如果点数之和小于或等于 $21$，他就要思考是否要再多抓一张。假设 $X$ 是已抓牌点数之和与 $21$ 之间相差的点数值，我们知道，如果桌面上的剩余牌中点数大于 $X$ 的纸牌数量比小于等于 $X$ 的纸牌数量要多，或两者一样多，那就不应该再抓牌了。\n\n因为凯撒并不擅于计算是否需要抓牌，所以他请你帮他计算和决策。", "inputFormat": "第一行输入一个正整数 $N$（$1 \\le N \\le 52$），表示凯撒已经抓牌的张数。\n\n接下来 $N$ 行每行一个正整数，第 $i$ 个正整数是他抓的第 $i$ 张牌点数值。", "outputFormat": "如果凯撒应该继续抓牌，输出 `VUCI`（克罗地亚语“抓牌”的意思），否则输出 `DOSTA`（克罗地亚语“停止”的意思）。\n\n**【样例解释】**\n\n第一个样例： 已经抓的 $6$ 张牌的总点数是 $15$，它与 $21$ 的差 $X$ 是 $6$。桌面上剩余牌中比 $6$ 大的牌有 $32$ 张（分别是 $4$ 张 $\\text A$、$4$ 张 $\\text K$、$4$ 张 $\\text Q$、$4$ 张 $\\text J$、$4$ 张 $10$、$4$ 张 $9$、$4$ 张 $8$、$4$ 张 $7$），而比 $6$ 小的牌有 $14$ 张（分别是 $1$ 张 $2$、$1$ 张 $3$、$4$ 张 $4$、$4$ 张 $5$、$4$ 张 $6$），所以决定不再抓牌，输出 `DOSTA`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4420", "type": "P", "difficulty": 2, "samples": [["4 5\naaaa.\n.bb..\n.bbxx\n...xx\n", "2\n1\n0\n0\n0\n"], ["4 5\n.aab.\naabb.\n.cbaa\ncccaa\n", "1\n0\n1\n1\n1\n"], ["5 7\n.c.....\nccdddd.\ncaabbcc\naabbacc\n...aaa.\n", "1\n1\n2\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #1] Tetris", "background": "", "description": "Ivica is a passionate computer scientist. He recently started working on his first computer game: a clone of the popular Tetris. Although he’s far from being finished, his program supports placing five different Tetris figures shown in the image below in a matrix. Before placing it in the Tetris matrix, the figure can be rotated by 90 degrees an arbitrary number of times and coloured. Additionally, the current version of the game doesn’t support placing the figure if that would mean it goes out of the matrix boundaries or overlaps with another existing figure in the matrix.\n\n![](https://cdn.luogu.com.cn/upload/pic/17376.png)\n\nWhile Ivica was in school, his sister Marica started the game and randomly rotated, coloured and placed the figures in a way that the adjacent figures are coloured differently. Two figures are adjacent if they share a common side or touch in the tip.\n\nWhen Ivica came back to his computer, he found the game running with the figures his sister placed. He wants to know how many of which figures there are in the Tetris matrix and he is asking you to help him solve this problem while he’s busy with improving the game.\n", "inputFormat": "The first line of input contains positive integers N and M (1 ≤ N, M ≤ 10) that represent the number of rows and columns of the Tetris matrix.\n\nEach of the following N lines contains M characters that represent the matrix. Each character can be ‘.’ (dot) that represents a blank space or a lowercase letter of the English alphabet that represents a part of the figure. Different letters represent different colours, and the parts\nof the same figure are coloured the same.\n", "outputFormat": "You must output exactly five rows. The $i^{th}$ line must contain the number of appearances of\nthe $i^{th}$ figure in the game of Tetris.\n", "hint": "In test cases worth 20% of total points, only the first figure will appear.\n\nIn test cases worth an additional 20% of total points, only the first two figures will appear.\n\nIn test cases worth an additional 20% of total points, only the first three figures will appear.\n\nIn test cases worth an additional 20% of total points, only the first four figures will appear.\n\n![](https://cdn.luogu.com.cn/upload/pic/17377.png)", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #1] Tetris", "background": "", "description": "Ivica is a passionate computer scientist. He recently started working on his first computer game: a clone of the popular Tetris. Although he’s far from being finished, his program supports placing five different Tetris figures shown in the image below in a matrix. Before placing it in the Tetris matrix, the figure can be rotated by 90 degrees an arbitrary number of times and coloured. Additionally, the current version of the game doesn’t support placing the figure if that would mean it goes out of the matrix boundaries or overlaps with another existing figure in the matrix.\n\n![](https://cdn.luogu.com.cn/upload/pic/17376.png)\n\nWhile Ivica was in school, his sister Marica started the game and randomly rotated, coloured and placed the figures in a way that the adjacent figures are coloured differently. Two figures are adjacent if they share a common side or touch in the tip.\n\nWhen Ivica came back to his computer, he found the game running with the figures his sister placed. He wants to know how many of which figures there are in the Tetris matrix and he is asking you to help him solve this problem while he’s busy with improving the game.\n", "inputFormat": "The first line of input contains positive integers N and M (1 ≤ N, M ≤ 10) that represent the number of rows and columns of the Tetris matrix.\n\nEach of the following N lines contains M characters that represent the matrix. Each character can be ‘.’ (dot) that represents a blank space or a lowercase letter of the English alphabet that represents a part of the figure. Different letters represent different colours, and the parts\nof the same figure are coloured the same.\n", "outputFormat": "You must output exactly five rows. The $i^{th}$ line must contain the number of appearances of\nthe $i^{th}$ figure in the game of Tetris.\n", "hint": "In test cases worth 20% of total points, only the first figure will appear.\n\nIn test cases worth an additional 20% of total points, only the first two figures will appear.\n\nIn test cases worth an additional 20% of total points, only the first three figures will appear.\n\nIn test cases worth an additional 20% of total points, only the first four figures will appear.\n\n![](https://cdn.luogu.com.cn/upload/pic/17377.png)", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #1] Tetris", "background": "", "description": "Ivica是一位激情昂扬的计算机科学家。他最近开始研究他的第一个电脑游戏：流行于当下的俄罗斯方块的克隆。尽管他还远未完成，但他的研究计划却支持将下图中显示的五种不同的俄罗斯方块图形放在一个矩阵中。在将它放入俄罗斯方块矩阵之前，图形可以旋转90度任意次数并着色。此外，当前版本的游戏不支持放置俄罗斯方块图形，如果这意味着它将超出矩阵边界或与矩阵中的另一个现有图形重叠。\n\n![](https://cdn.luogu.org/upload/pic/17376.png)\n\n当Ivica在学校时，他的妹妹Marica开始游戏并随机旋转，着色并放置俄罗斯方块图形，使相邻的那一些俄罗斯方块颜色不同。如果它们在共用一个共同的侧面或两两相触，则两个图形相邻。（PS：【译者注】当然，一个点｛角｝不算）\n\n当Ivica回到他的电脑后，他发现游戏正在运行着他妹妹放置的俄罗斯方块图形。他想知道俄罗斯方块矩阵中有多少数字，他要求你在他忙于改进游戏时帮助他解决这个问题。", "inputFormat": "第一行输入包含正整数N和M（1≤N，M≤10），表示俄罗斯方块矩阵的行数和列数。\n\n以下N行中的每一行包含表示矩阵的M个字符。每个角色都可以是'.' （点）表示空格或英文字母的小写字母，代表图的一部分。不同的字母代表不同的颜色，同一图的部分颜色相同。", "outputFormat": "你必须输出五行。第 $i^{th}$ \n 行需要包含$i^{th}$ \n 图中方块的游戏的出现次数。\n \n\n## 说明\n\n20％的测试样例中，只有一个数字。\n\n在测试案例中，总价值额外增加20％（也就是40%），只会出现两个数字。\n\n在测试案例中，总价值额外增加20％（当然，也就是60%），出现三个数字。\n\n在测试案例中，总价值额外增加20％，（嗯嗯就是80%），会出现前四个数字\n\n![](https://cdn.luogu.org/upload/pic/17377.png)  \n翻译贡献者UID：118559", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4421", "type": "P", "difficulty": 4, "samples": [["3\naaa\naa\nabb\n", "1"], ["3\nx\nx\nxy\n", "4"], ["5\nmir\nmirta\nta\nir\nt\n", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["字符串", "2017", "哈希 hashing", "AC 自动机", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #1] Lozinke", "background": "", "description": "Recently, there has been a breach of user information from the mega-popular social network Secret Network. Among the confidential information are the passwords of all users.\n\nMihael, a young student who has been exploring computer security lately, found the whole thing really interesting. While experimenting with the social network, he found another security breach! When you input any string of characters that contains a substring equal to the actual password, the login will be successful. For example, if the user whose password is abc inputs one of the strings abc, abcd or imaabcnema, the system will successfully log him in, whereas the login will fail for axbc.\n\nMihael wants to know how many ordered pairs of different users exist such that the first user, using their own password, can login as the second user.", "inputFormat": "The first line of input contains the positive integer N (1 ≤ N ≤ 20 000), the number of users.\n\nEach of the following N lines contains the user passwords. The passwords consist of at least one and at most 10 lowercase letters of the English alphabet.", "outputFormat": "The first and only line of output must contains the number of ordered pairs from the task.", "hint": "Clarification​ ​of​ ​the​ ​second​ ​test​ ​case:\n\nThe first user can login as the second user, the second user can login as the first, and the third user can login as both the first and the second user.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #1] Lozinke", "background": "", "description": "Recently, there has been a breach of user information from the mega-popular social network Secret Network. Among the confidential information are the passwords of all users.\n\nMihael, a young student who has been exploring computer security lately, found the whole thing really interesting. While experimenting with the social network, he found another security breach! When you input any string of characters that contains a substring equal to the actual password, the login will be successful. For example, if the user whose password is abc inputs one of the strings abc, abcd or imaabcnema, the system will successfully log him in, whereas the login will fail for axbc.\n\nMihael wants to know how many ordered pairs of different users exist such that the first user, using their own password, can login as the second user.", "inputFormat": "The first line of input contains the positive integer N (1 ≤ N ≤ 20 000), the number of users.\n\nEach of the following N lines contains the user passwords. The passwords consist of at least one and at most 10 lowercase letters of the English alphabet.", "outputFormat": "The first and only line of output must contains the number of ordered pairs from the task.", "hint": "Clarification​ ​of​ ​the​ ​second​ ​test​ ​case:\n\nThe first user can login as the second user, the second user can login as the first, and the third user can login as both the first and the second user.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #1] Lozinke", "background": "", "description": "最近，超级流行的社交网络 Secret Network 发生了用户信息泄露事件。其中包含所有用户的密码。\n\nMihael 是一名最近在研究计算机安全的年轻学生，他发现整个事件非常有趣。在对社交网络进行实验时，他发现了另一个安全漏洞！当你输入任何包含与实际密码相同的子字符串的字符序列时，登录将会成功。例如，如果用户的密码是 abc，输入字符串 abc、abcd 或 imaabcnema，系统将成功登录，而对于 axbc，登录将失败。\n\nMihael 想知道存在多少对不同用户的有序对，使得第一个用户可以使用他们自己的密码登录为第二个用户。", "inputFormat": "输入的第一行包含正整数 $N$（$1 \\leq N \\leq 20000$），表示用户的数量。\n\n接下来的 $N$ 行中的每一行包含用户的密码。密码由至少一个、最多 10 个小写英文字母组成。", "outputFormat": "输出的第一行必须包含任务中有序对的数量。", "hint": "第二个测试用例的说明：\n\n第一个用户可以作为第二个用户登录，第二个用户可以作为第一个用户登录，第三个用户可以作为第一个和第二个用户登录。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4422", "type": "P", "difficulty": 5, "samples": [["3 4\nM 10 3\nM 5 1\nD 20 2\nD 5 1\n", "3\n1\n"], ["10 10\nM 20 10\nD 1 9\nM 2 3\nD 17 10\nM 20 2\nD 8 2\nM 40 1\nD 25 2\nM 33 9\nD 37 9\n", "-1\n-1\n3\n2\n9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["模拟", "2017", "线段树", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #1] Deda", "background": "", "description": "Little Marica is making up a ~~nonsensical~~ unusual fairy tale and is telling to her grandfather who keeps interrupting her and asking her ~~stupid~~ intriguing questions.\n\nIn Marica’s fairy tale, $N$ children, denoted with numbers from $1$ to $N$ by their age (from the youngest denoted with $1$, to the oldest denoted with $N$), embarked on a train ride. The train leaves from the station $0$ and stops in order at stations $1, 2, 3 \\dots$ to infinity.\n\nEach of the following Marica’s statements is of the form: “$At\\  stop\\ X, child\\ A\\ got\\ out$”, where the order of these statements is completely arbitrary. In other words, it does not depend on the station order. Her grandfather sometimes asks a question of the form: “$\\textit{ Based on the statements so far, of the children denoted with a number greater than or equal}\\allowbreak\\textit{ to B, who is the youngest child that rode for Y or less stops?}$” If at the moment the grandfather asks the question it hasn’t been said so far that a child is getting off the train, we assume that the child is riding for an infinite amount of stops.\n\nMarica must give a correct answer to each of her grandfather’s questions, otherwise the grandfather will get mad and go to sleep. The answer must be correct in the moment when the grandfather asks the question, while it can change later given Marica’s new statements, but that doesn’t matter. Write a program that tracks Marica’s statements and answers her grandfather’s questions.", "inputFormat": "The first line of input contains the positive integers $N$ and $Q$ $(2 \\le N, Q \\le 2 \\times 10^{5})$, the number of children and the number of statements. Each of the following $Q$ lines describes:\n\n- either Marica’s statement of the form `M X A`, where $M$ denotes Marica, and $X$ and $A$ are positive integers $(1 \\le X \\le 10^{9}, 1 \\le A \\le N)$ from the task,\n- or her grandfather’s question of the form `D Y B`, where $D$ denotes the grandfather, and $Y$ and $B$ are positive integers $(1 \\le Y \\le 10^{9}, 1 \\le B \\le N)$ from the task.\n\nAll of Marica’s statements correspond to different children and at least one line in the input is her grandfather’s question.", "outputFormat": "For each grandfather’s question, output the number of the required child in its own line. If no such child exists, output `-1`.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #1] Deda", "background": "", "description": "Little Marica is making up a ~~nonsensical~~ unusual fairy tale and is telling to her grandfather who keeps interrupting her and asking her ~~stupid~~ intriguing questions.\n\nIn Marica’s fairy tale, $N$ children, denoted with numbers from $1$ to $N$ by their age (from the youngest denoted with $1$, to the oldest denoted with $N$), embarked on a train ride. The train leaves from the station $0$ and stops in order at stations $1, 2, 3 \\dots$ to infinity.\n\nEach of the following Marica’s statements is of the form: “$At\\  stop\\ X, child\\ A\\ got\\ out$”, where the order of these statements is completely arbitrary. In other words, it does not depend on the station order. Her grandfather sometimes asks a question of the form: “$\\textit{ Based on the statements so far, of the children denoted with a number greater than or equal}\\allowbreak\\textit{ to B, who is the youngest child that rode for Y or less stops?}$” If at the moment the grandfather asks the question it hasn’t been said so far that a child is getting off the train, we assume that the child is riding for an infinite amount of stops.\n\nMarica must give a correct answer to each of her grandfather’s questions, otherwise the grandfather will get mad and go to sleep. The answer must be correct in the moment when the grandfather asks the question, while it can change later given Marica’s new statements, but that doesn’t matter. Write a program that tracks Marica’s statements and answers her grandfather’s questions.", "inputFormat": "The first line of input contains the positive integers $N$ and $Q$ $(2 \\le N, Q \\le 2 \\times 10^{5})$, the number of children and the number of statements. Each of the following $Q$ lines describes:\n\n- either Marica’s statement of the form `M X A`, where $M$ denotes Marica, and $X$ and $A$ are positive integers $(1 \\le X \\le 10^{9}, 1 \\le A \\le N)$ from the task,\n- or her grandfather’s question of the form `D Y B`, where $D$ denotes the grandfather, and $Y$ and $B$ are positive integers $(1 \\le Y \\le 10^{9}, 1 \\le B \\le N)$ from the task.\n\nAll of Marica’s statements correspond to different children and at least one line in the input is her grandfather’s question.", "outputFormat": "For each grandfather’s question, output the number of the required child in its own line. If no such child exists, output `-1`.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #1] Deda", "background": "", "description": "### 题面描述\n小马里卡正在创作一个奇妙的童话故事。她一边编故事，一边讲给她的爷爷听。爷爷可高兴了，于是问了她一些有趣的问题。\n\n在小马里卡的故事中，有 $N$ 个年龄分别为 $1$~$N$ 岁的孩子（最小的为 $1$ 岁，最大的为 $N$ 岁）。有一天，她们一起乘火车出去旅行。铁路线上有好多个车站，分别以 $0, 1, 2, 3 \\dots$ 编号。其中第 $0$ 站为始发站，火车每到一个车站都会停下来逗留一段时间。每个孩子都可以在选择自己喜欢的车站下车。\n\n小马里卡喜欢这样讲述她的故事：“在第 $X$ 站，年龄为 $A$ 岁的孩子下车了。”不过小马里卡的习惯非常不好，她讲述故事的顺序是完全随机的。换句话说，$X$ 是不单调的。爷爷知道小马里卡的坏习惯，所以他喜欢时不时问一些有趣的问题来找小马里的麻烦。问题是这样的：“年龄大于等于 $B$ 且在第 $Y$ 站（包含第 $Y$ 站）以前下车的最年轻的小孩是多大？”\n\n小马里卡必须正确回答爷爷的问题，否则爷爷会因生气而睡觉。值得注意的是，小马里卡的答案必须在当时是正确的。虽然小马里卡在随后的讲述中可能会改变问题的答案，但这都是无关紧要的。\n\n小马里卡对自己的坏习惯十分无奈。由于故事的顺序过于杂乱，小马里卡根本无法正确回答爷爷的问题。于是她找到了聪明的你。请帮小马里卡编写一个程序，动态追踪她的讲述，并回答爷爷的问题。", "inputFormat": "输入的第一行包含两个正整数 $N,Q\\ (2 \\le N,Q \\le 2 \\times 10^{5})$，分别代表孩子的数量和语句的数量。\n\n接下来 $Q$ 行，每行一个语句。语句的格式为 `M X A` 或 `D Y B`，分别代表小马里卡的讲述和爷爷的问题。其中 `M`、`D` 为大写字母，$X$、$Y$、$A$、$B$ $(1 \\le X,Y \\le 10^{9},1 \\le A,B \\le N)$ 分别为一个正整数。其意义请见【题面描述】。题目中保证至少有一个 `D`。", "outputFormat": "对于每一个问题 `D` 输出一个答案。答案为一个整数。如果爷爷的问题无解，请输出 `-1`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4423", "type": "P", "difficulty": 6, "samples": [["4\n1 1\n2 3\n3 3\n3 4", "3.414214\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "递归", "北京", "分治", "排序"], "title": "[BJWC2011] 最小三角形", "background": "", "description": "Xaviera 现在遇到了一个有趣的问题。\n\n平面上有 $N$ 个点，Xaviera 想找出周长最小的三角形。\n\n由于点非常多，分布也非常乱，所以 Xaviera 想请你来解决这个问题。\n\n为了减小问题的难度，这里的三角形也包括共线的三点。", "inputFormat": "第一行包含一个整数 $N$ 表示点的个数。\n\n接下来 $N$ 行每行有两个整数，表示这个点的坐标。", "outputFormat": "输出只有一行，包含一个 $6$ 位小数，为周长最短的三角形的周长（四舍五入）。", "hint": "对于所有数据，$3 \\leq N \\leq 2\\times 10^5$", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2011] Minimum Triangle", "background": "", "description": "Xaviera has encountered an interesting problem.\n\nThere are $N$ points on the plane. Xaviera wants to find the triangle with the minimum perimeter.\n\nBecause there are many points and they are distributed irregularly, Xaviera asks you to solve this problem.\n\nTo reduce the difficulty, triangles also include three collinear points.", "inputFormat": "The first line contains an integer $N$ representing the number of points.\n\nThe next $N$ lines each contain two integers, representing the coordinates of a point.", "outputFormat": "Output a single line containing the minimum triangle perimeter, rounded to $6$ decimal places.", "hint": "Constraints: For all testdata, $3 \\leq N \\leq 2\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2011] 最小三角形", "background": "", "description": "Xaviera 现在遇到了一个有趣的问题。\n\n平面上有 $N$ 个点，Xaviera 想找出周长最小的三角形。\n\n由于点非常多，分布也非常乱，所以 Xaviera 想请你来解决这个问题。\n\n为了减小问题的难度，这里的三角形也包括共线的三点。", "inputFormat": "第一行包含一个整数 $N$ 表示点的个数。\n\n接下来 $N$ 行每行有两个整数，表示这个点的坐标。", "outputFormat": "输出只有一行，包含一个 $6$ 位小数，为周长最短的三角形的周长（四舍五入）。", "hint": "对于所有数据，$3 \\leq N \\leq 2\\times 10^5$", "locale": "zh-CN"}}}
{"pid": "P4424", "type": "P", "difficulty": 7, "samples": [["5 5 1\n01110\n11011\n10000\n01010\n00100\n00100", "6"], ["10 10 3\n0100011011\n0110100101\n1100010100\n0111000110\n1100011110\n0001110100\n0001101110\n0110100001\n1110001010\n0010011101\n0110011111\n1101001010\n0010001001", "69\n0\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "各省省选", "安徽", "湖南", "排序", "进制", "位运算"], "title": "[HNOI/AHOI2018] 寻宝游戏", "background": "", "description": "某大学每年都会有一次 Mystery Hunt 的活动，玩家需要根据设置的线索解谜，找到宝藏的位置，前一年获胜的队伍可以获得这一年出题的机会。\n\n作为新生的你，对这个活动非常感兴趣。你每天都要从西向东经过教学楼一条很长的走廊，这条走廊是如此的长，以至于它被人戏称为 infinite corridor。一次，你经过这条走廊时注意到在走廊的墙壁上隐藏着 $n$ 个**等长的**二进制的数字，长度均为 $m$。你从西向东将这些数字记录了下来，形成一个含有 $n$ 个数的二进制数组 $a_1,a_2,...,a_n$。\n\n很快，在最新的一期的 Voo Doo 杂志上，你发现了 $q$ 个长度也为 $m$ 的二进制数 $r_1,r_2,...,r_q$。\n\n聪明的你很快发现了这些数字的含义。\n\n保持数组 $a_1,a_2,...,a_n$ 的元素顺序不变，你可以在它们之间插入 $\\land$（按位与运算）或者 $\\lor$（按位或运算）。例如：$11011\\land 00111=00011$，$11011\\lor 00111=11111$。\n\n你需要插入 $n$ 个运算符，相邻两个数之前恰好一个，在**第一个数的左边**还有一个。**如果我们在第一个运算符的左边补入一个 0**，这就形成了一个运算式，我们可以计算它的值。与往常一样，运算顺序是**从左到右**。有趣的是，出题人已经告诉你这个值的可能的集合—— Voo Doo 杂志里的那些二进制数 $r_1,r_2,...,r_q$，而解谜的方法，就是对 $r_1,r_2,...,r_q$ 中的每一个值 $r_i$，分别计算出**有多少种方法填入这 $n$ 个计算符**，使的这个运算式的值是 $r_i$。\n\n然而，infinite corridor 真的很长，这意味着数据范围可能非常大。因此，答案也可能非常大，但是你发现由于谜题的特殊性，你只需要求答案模 $1000000007$ 的值。", "inputFormat": "第一行三个数 $n,m,q$，含义如题所述。\n\n接下来 $n$ 行，其中第 $i$ 行有一个长度为 $m$ 的二进制数，**左边是最高位**，表示 $a_i$。\n\n接下来 $q$ 行，其中第 $i$ 行有一个长度为 $m$ 的二进制数，**左边是最高位**，表示 $r_i$。", "outputFormat": "输出 $q$ 行，每行一个数，其中的 $i$ 行表示对于 $r_i$ 的答案。", "hint": "对于 $10\\%$ 的数据，$n \\le 20, m \\le 30, q = 1$；\n\n对于另外 $20\\%$ 的数据，$n \\le 1000, m \\le 16$；\n\n对于另外 $40\\%$ 的数据，$n \\le 500, m \\le 1000$；\n\n对于全部的数据 $1\\leq n\\leq 1000,1\\leq m\\leq 5000,1\\leq q\\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI/AHOI2018] Treasure Hunt", "background": "", "description": "At a certain university, there is an annual Mystery Hunt. Players must solve puzzles using given clues to find the treasure, and the previous year's winning team earns the right to write the problems for the current year.\n\nAs a freshman, you are very interested in this event. Every day you walk from west to east through a very long corridor in the teaching building. The corridor is so long that people jokingly call it the \"infinite corridor.\" One day, as you pass through the corridor, you notice that there are $n$ hidden binary numbers of equal length on the corridor wall, all of length $m$. You record these numbers from west to east, forming a binary array of $n$ numbers $a_1,a_2,...,a_n$.\n\nSoon, in the latest issue of the Voo Doo magazine, you discover $q$ binary numbers of length $m$, namely $r_1,r_2,...,r_q$.\n\nYou quickly figure out the meaning of these numbers.\n\nKeeping the order of the array $a_1,a_2,...,a_n$ unchanged, you may insert $\\land$ (bitwise AND) or $\\lor$ (bitwise OR) between them. For example: $11011\\land 00111=00011$, $11011\\lor 00111=11111$.\n\nYou need to insert $n$ operators: exactly one between each pair of adjacent numbers, and one more to the left of the first number. If we put a $0$ to the left of the first operator, this forms an expression whose value we can compute. As usual, the evaluation order is from left to right. Interestingly, the setter has already told you the possible set of resulting values — the binary numbers $r_1,r_2,...,r_q$ in the Voo Doo magazine. The way to solve the puzzle is: for each value $r_i$ among $r_1,r_2,...,r_q$, compute how many ways there are to fill in these $n$ operators so that the expression evaluates to $r_i$.\n\nHowever, the infinite corridor is truly long, which means the ranges may be very large. Therefore, the answers may also be very large, but due to the special nature of the puzzle, you only need to output the answers modulo $1000000007$.", "inputFormat": "The first line contains three integers $n,m,q$, as described.\n\nThe next $n$ lines: the $i$-th line contains a binary number of length $m$, with the most significant bit on the left, representing $a_i$.\n\nThe next $q$ lines: the $i$-th line contains a binary number of length $m$, with the most significant bit on the left, representing $r_i$.", "outputFormat": "Output $q$ lines, one integer per line. The $i$-th line is the answer for $r_i$.", "hint": "Constraints:\n- For $10\\%$ of the testdata, $n \\le 20$, $m \\le 30$, $q = 1$.\n- For an additional $20\\%$ of the testdata, $n \\le 1000$, $m \\le 16$.\n- For an additional $40\\%$ of the testdata, $n \\le 500$, $m \\le 1000$.\n- For all testdata, $1 \\le n \\le 1000$, $1 \\le m \\le 5000$, $1 \\le q \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI/AHOI2018] 寻宝游戏", "background": "", "description": "某大学每年都会有一次 Mystery Hunt 的活动，玩家需要根据设置的线索解谜，找到宝藏的位置，前一年获胜的队伍可以获得这一年出题的机会。\n\n作为新生的你，对这个活动非常感兴趣。你每天都要从西向东经过教学楼一条很长的走廊，这条走廊是如此的长，以至于它被人戏称为 infinite corridor。一次，你经过这条走廊时注意到在走廊的墙壁上隐藏着 $n$ 个**等长的**二进制的数字，长度均为 $m$。你从西向东将这些数字记录了下来，形成一个含有 $n$ 个数的二进制数组 $a_1,a_2,...,a_n$。\n\n很快，在最新的一期的 Voo Doo 杂志上，你发现了 $q$ 个长度也为 $m$ 的二进制数 $r_1,r_2,...,r_q$。\n\n聪明的你很快发现了这些数字的含义。\n\n保持数组 $a_1,a_2,...,a_n$ 的元素顺序不变，你可以在它们之间插入 $\\land$（按位与运算）或者 $\\lor$（按位或运算）。例如：$11011\\land 00111=00011$，$11011\\lor 00111=11111$。\n\n你需要插入 $n$ 个运算符，相邻两个数之前恰好一个，在**第一个数的左边**还有一个。**如果我们在第一个运算符的左边补入一个 0**，这就形成了一个运算式，我们可以计算它的值。与往常一样，运算顺序是**从左到右**。有趣的是，出题人已经告诉你这个值的可能的集合—— Voo Doo 杂志里的那些二进制数 $r_1,r_2,...,r_q$，而解谜的方法，就是对 $r_1,r_2,...,r_q$ 中的每一个值 $r_i$，分别计算出**有多少种方法填入这 $n$ 个计算符**，使的这个运算式的值是 $r_i$。\n\n然而，infinite corridor 真的很长，这意味着数据范围可能非常大。因此，答案也可能非常大，但是你发现由于谜题的特殊性，你只需要求答案模 $1000000007$ 的值。", "inputFormat": "第一行三个数 $n,m,q$，含义如题所述。\n\n接下来 $n$ 行，其中第 $i$ 行有一个长度为 $m$ 的二进制数，**左边是最高位**，表示 $a_i$。\n\n接下来 $q$ 行，其中第 $i$ 行有一个长度为 $m$ 的二进制数，**左边是最高位**，表示 $r_i$。", "outputFormat": "输出 $q$ 行，每行一个数，其中的 $i$ 行表示对于 $r_i$ 的答案。", "hint": "对于 $10\\%$ 的数据，$n \\le 20, m \\le 30, q = 1$；\n\n对于另外 $20\\%$ 的数据，$n \\le 1000, m \\le 16$；\n\n对于另外 $40\\%$ 的数据，$n \\le 500, m \\le 1000$；\n\n对于全部的数据 $1\\leq n\\leq 1000,1\\leq m\\leq 5000,1\\leq q\\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P4425", "type": "P", "difficulty": 7, "samples": [["5 3 0\n1 2 3 4 5\n3 5\n5 0\n1 4", "5\n7\n6\n7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "线段树", "各省省选", "安徽", "湖南", "枚举", "栈"], "title": "[HNOI/AHOI2018] 转盘", "background": null, "description": "一次小 G 和小 H 准备去聚餐，但是由于太麻烦了于是题面简化如下：\n\n一个转盘上有摆成一圈的 $n$ 个物品（编号 $1\\sim n$），其中的 $i$ 个物品会在 $T_i$ 时刻出现。\n\n在 $0$ 时刻时，小 G 可以任选 $n$ 个物品中的一个，我们将其编号为 $s_0$。并且如果 $i$ 时刻选择了物品 $s_i$，那么 $i+1$ 时刻可以继续选择当前物品或选择下一个物品。当 $s_i$ 为 $n$ 时，下一个物品为物品 $1$，否则为物品 $s_{i}+1$。在每一时刻（包括 $0$ 时刻），如果小 G 选择的物品已经出现了，那么小 G 将会标记它。小 H 想知道，在物品选择的最优策略下，小 G 什么时候能标记所有物品？\n\n但麻烦的是，物品的出现时间会不时修改。我们将其描述为 $m$ 次修改，每次修改将改变其中一个物品的出现时间。每次修改后，你也需求出当前局面的答案。对于其中部分测试点，小 H 还追加了强制在线的要求。", "inputFormat": "第一行三个非负整数 $n$、$m$、$p$，代表一共有 $n$ 个物品，$m$ 次修改。$p$ 只有 $0$ 或 $1$ 两种取值，强制在线时 $p$ 为 $1$，否则 $p$ 为 $0$。\n\n接下来一行，有 $n$ 个**非负整数**，第 $i$ 个数 $T_i$ 代表物品 $i$ 的出现时间。\n\n接下来 $m$ 行，每行两个非负整数 $x$、$y$，代表一次修改及询问。修改方式如下：\n\n1. 如果 $p=0$，则表示物品 $x$ 的出现时间 $T_x$ 修改为 $y$。\n\n2. 如果 $p=1$，则先将 $x$ 和 $y$ 分别异或 $LastAns$，得到 $x'$ 和 $y'$，然后将物品 $x'$ 的出现时间 $T_{x'}$ 修改为 $y'$。其中的 $LastAns$ 是前一个询问的结果；特别的，第一次修改时 $LastAns$ 为初始局面的答案。\n\n保证输入合法。", "outputFormat": "第一行一个整数，代表初始局面的答案。\n\n接下来 $m$ 行每行一个整数，分别代表每次修改后的答案。", "hint": "【**数据范围**】\n\n::cute-table[]{tuack}\n| 测试点编号 | $n$ | $m$ | $T _ i / T _ x$ | $p$ |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | $\\le 10$ | $\\le 10$ | $\\le 10$ | $=0$ |\n| 2 | $\\le 1000$ | $=0$ | $\\le 1000$ | ^ |\n| 3 | $\\le 100000$ | ^ | $\\le 100000$ | ^ |\n| 4 | $\\le 5000$ | $\\le 5000$ | ^ | ^ |\n| 5 | $\\le 80000$ | $\\le 80000$ | ^ | ^ |\n| 6 | ^ | ^ | ^ | $=1$ |\n| 7 | $\\le 90000$ | $\\le 90000$ | ^ | $=0$ |\n| 8 | ^ | ^ | ^ | $=1$ |\n| 9 | $\\le 100000$ | $\\le 100000$ | ^ | $=0$ |\n| 10 | ^ | ^ | ^ | $=1$| \n\n对于所有数据，保证 $3 \\le n \\le 10 ^ 5$，$0 \\le m \\le 10 ^ 5$，$0 \\le T _ i / T _ x \\le 10 ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI/AHOI2018] Turntable", "background": "", "description": "Xiao G and Xiao H plan to have a dinner, but to keep things simple, the statement is as follows:\n\nThere is a turntable with $n$ items arranged in a circle (numbered $1 \\sim n$). The $i$-th item appears at time $T_i$.\n\nAt time $0$, Xiao G can choose any one of the $n$ items; denote it by $s_0$. If at time $i$ he chooses item $s_i$, then at time $i+1$ he can either keep the current item or move to the next item. When $s_i$ equals $n$, the next item is item $1$; otherwise it is item $s_i + 1$. At every time (including time $0$), if the item Xiao G chooses has already appeared, then he will mark it. Xiao H wants to know, under the optimal strategy of choosing items, when can Xiao G mark all items.\n\nHowever, the appearance times of items will be modified from time to time. We describe this as $m$ modifications, each changing the appearance time of one item. After each modification, you must also output the answer for the current state. For some test points, Xiao H also imposes a forced online constraint.", "inputFormat": "The first line contains three non-negative integers $n$, $m$, and $p$, meaning there are $n$ items and $m$ modifications. The value of $p$ is either $0$ or $1$; when $p = 1$, the problem is forced online; otherwise $p = 0$.\n\nThe next line contains $n$ non-negative integers. The $i$-th number $T_i$ is the appearance time of item $i$.\n\nEach of the next $m$ lines contains two non-negative integers $x$ and $y$, representing one modification and its query. The modification works as follows:\n1. If $p = 0$, set the appearance time of item $x$ to $y$, i.e., $T_x \\leftarrow y$.\n2. If $p = 1$, first XOR $x$ and $y$ with LastAns respectively to obtain $x'$ and $y'$, then set $T_{x'} \\leftarrow y'$. Here LastAns is the result of the previous query; in particular, for the first modification, LastAns is the answer for the initial state.\n\nIt is guaranteed that the input is valid.", "outputFormat": "Output one integer on the first line, the answer for the initial state.\n\nThen output $m$ lines, each containing one integer, the answer after each modification.", "hint": "【Constraints】\n\n::cute-table[]{tuack}\n| Test point id | $n$ | $m$ | $T_i / T_x$ | $p$ |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | $\\le 10$ | $\\le 10$ | $\\le 10$ | $=0$ |\n| 2 | $\\le 1000$ | $=0$ | $\\le 1000$ | ^ |\n| 3 | $\\le 100000$ | ^ | $\\le 100000$ | ^ |\n| 4 | $\\le 5000$ | $\\le 5000$ | ^ | ^ |\n| 5 | $\\le 80000$ | $\\le 80000$ | ^ | ^ |\n| 6 | ^ | ^ | ^ | $=1$ |\n| 7 | $\\le 90000$ | $\\le 90000$ | ^ | $=0$ |\n| 8 | ^ | ^ | ^ | $=1$ |\n| 9 | $\\le 100000$ | $\\le 100000$ | ^ | $=0$ |\n| 10 | ^ | ^ | ^ | $=1$| \n\nFor all testdata, it is guaranteed that $3 \\le n \\le 10^5$, $0 \\le m \\le 10^5$, and $0 \\le T_i / T_x \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI/AHOI2018] 转盘", "background": null, "description": "一次小 G 和小 H 准备去聚餐，但是由于太麻烦了于是题面简化如下：\n\n一个转盘上有摆成一圈的 $n$ 个物品（编号 $1\\sim n$），其中的 $i$ 个物品会在 $T_i$ 时刻出现。\n\n在 $0$ 时刻时，小 G 可以任选 $n$ 个物品中的一个，我们将其编号为 $s_0$。并且如果 $i$ 时刻选择了物品 $s_i$，那么 $i+1$ 时刻可以继续选择当前物品或选择下一个物品。当 $s_i$ 为 $n$ 时，下一个物品为物品 $1$，否则为物品 $s_{i}+1$。在每一时刻（包括 $0$ 时刻），如果小 G 选择的物品已经出现了，那么小 G 将会标记它。小 H 想知道，在物品选择的最优策略下，小 G 什么时候能标记所有物品？\n\n但麻烦的是，物品的出现时间会不时修改。我们将其描述为 $m$ 次修改，每次修改将改变其中一个物品的出现时间。每次修改后，你也需求出当前局面的答案。对于其中部分测试点，小 H 还追加了强制在线的要求。", "inputFormat": "第一行三个非负整数 $n$、$m$、$p$，代表一共有 $n$ 个物品，$m$ 次修改。$p$ 只有 $0$ 或 $1$ 两种取值，强制在线时 $p$ 为 $1$，否则 $p$ 为 $0$。\n\n接下来一行，有 $n$ 个**非负整数**，第 $i$ 个数 $T_i$ 代表物品 $i$ 的出现时间。\n\n接下来 $m$ 行，每行两个非负整数 $x$、$y$，代表一次修改及询问。修改方式如下：\n\n1. 如果 $p=0$，则表示物品 $x$ 的出现时间 $T_x$ 修改为 $y$。\n\n2. 如果 $p=1$，则先将 $x$ 和 $y$ 分别异或 $LastAns$，得到 $x'$ 和 $y'$，然后将物品 $x'$ 的出现时间 $T_{x'}$ 修改为 $y'$。其中的 $LastAns$ 是前一个询问的结果；特别的，第一次修改时 $LastAns$ 为初始局面的答案。\n\n保证输入合法。", "outputFormat": "第一行一个整数，代表初始局面的答案。\n\n接下来 $m$ 行每行一个整数，分别代表每次修改后的答案。", "hint": "【**数据范围**】\n\n::cute-table[]{tuack}\n| 测试点编号 | $n$ | $m$ | $T _ i / T _ x$ | $p$ |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | $\\le 10$ | $\\le 10$ | $\\le 10$ | $=0$ |\n| 2 | $\\le 1000$ | $=0$ | $\\le 1000$ | ^ |\n| 3 | $\\le 100000$ | ^ | $\\le 100000$ | ^ |\n| 4 | $\\le 5000$ | $\\le 5000$ | ^ | ^ |\n| 5 | $\\le 80000$ | $\\le 80000$ | ^ | ^ |\n| 6 | ^ | ^ | ^ | $=1$ |\n| 7 | $\\le 90000$ | $\\le 90000$ | ^ | $=0$ |\n| 8 | ^ | ^ | ^ | $=1$ |\n| 9 | $\\le 100000$ | $\\le 100000$ | ^ | $=0$ |\n| 10 | ^ | ^ | ^ | $=1$| \n\n对于所有数据，保证 $3 \\le n \\le 10 ^ 5$，$0 \\le m \\le 10 ^ 5$，$0 \\le T _ i / T _ x \\le 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P4426", "type": "P", "difficulty": 7, "samples": [["3 2\n1 2\n2 3", "5"], ["6 8\n1 2\n1 3\n1 4\n2 4\n3 5\n4 5\n4 6\n1 6", "16"], ["12 18\n12 6\n3 11\n8 6\n2 9\n10 4\n1 8\n6 2\n11 5\n10 6\n12 2\n9 3\n7 6\n2 7\n3 2\n7 3\n5 6\n2 11\n12 1", "248"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "并查集", "各省省选", "安徽", "湖南", "枚举", "虚树", "动态 DP", "全局平衡二叉树"], "title": "[HNOI/AHOI2018] 毒瘤", "background": "", "description": "从前有一名毒瘤。\n\n毒瘤最近发现了量产毒瘤题的奥秘。考虑如下类型的数据结构题：给出一个数组，要求支持若干种奇奇怪怪的修改操作（比如区间加一个数，或者区间开平方），并支持询问区间和。毒瘤考虑了 $n$ 个这样的修改操作，并编号为 $1\\sim n$。当毒瘤要出数据结构题的时候，他就将这些修改操作中选若干个出来，然后出成一道题。\n\n当然了，这样出的题有可能不可做。通过精妙的数学推理，毒瘤揭露了这些修改操作的关系：有 $m$ 对“互相排斥”的修改操作，第 $i$ 对是第 $u_i$ 个操作和第 $v_i$ 个操作。当一道题同时含有 $u_i$ 和 $v_i$ 这两个操作时，这道题就会变得不可做。另一方面，一道题中不包含任何“互相排斥”的修改操作时，这个题就是可做的。此外，毒瘤还发现了一个规律：$m-n$ 是一个很小的数字，且任意两个修改操作都是连通的。两个修改操作 $a,b$ 是连通的，当且仅当存在若干操作 $t_0,t_1,\\cdots,t_l$，使得 $t_0=a,t_l=b$，且对 $1\\leq i\\leq l$，$t_{i-1}$ 和 $t_i$ 都是“互相排斥”的修改操作。\n\n一对“互相排斥”的修改操作称为互斥对。现在毒瘤想知道，给定值 $n$ 和 $m$ 个互斥对，他共能出出多少道可做的不同的数据结构题。两道数据结构题是不同的，当且仅当有一个修改操作在其中一道题中存在，而在另一道题中不存在。", "inputFormat": "第一行为正整数 $n,m$。\n\n接下来 $m$ 行，每行两个正整数 $u,v$，代表一对“互相排斥”的修改操作。", "outputFormat": "输出一行一个整数，代表毒瘤可以出的可做的不同的“互相排斥”的修改操作的个数。这个数可能很大，所以只输出模 $998244353$ 后的值。", "hint": "#### 样例一说明\n\n可做的题包括 $\\varnothing,\\{1\\},\\{2\\},\\{3\\},\\{1,3\\}$。注意，**空集是合法的数据结构题**。\n\n#### 数据范围\n\n![](https://cdn.luogu.com.cn/upload/pic/17511.png)", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI/AHOI2018] Duliu", "background": "", "description": "There was once a \"Duliu\" (pinyin).\n\nDuliu recently discovered the secret to mass-producing \"duliu\" problems. Consider a data-structure problem of the following type: given an array, you need to support several quirky update operations (for example, adding a number to a range, or taking the square root on a range), and support querying range sums. Duliu considered $n$ such update operations, numbered $1\\sim n$. When Duliu wants to set a data-structure problem, he selects some of these update operations and turns them into a problem.\n\nOf course, such a problem might be unsolvable. Through clever mathematical reasoning, Duliu revealed the relationships among these update operations: there are $m$ pairs of mutually exclusive update operations, and the $i$-th pair is the $u_i$-th operation and the $v_i$-th operation. When a problem contains both $u_i$ and $v_i$, the problem becomes unsolvable. On the other hand, if a problem contains no mutually exclusive pairs, then the problem is solvable. In addition, Duliu discovered a pattern: $m-n$ is a small number, and any two update operations are connected. Two update operations $a, b$ are connected if and only if there exist operations $t_0, t_1, \\cdots, t_l$ such that $t_0 = a$, $t_l = b$, and for $1 \\le i \\le l$, $t_{i-1}$ and $t_i$ are mutually exclusive.\n\nA pair of mutually exclusive update operations is called an exclusive pair. Now Duliu wants to know, given $n$ and the $m$ exclusive pairs, how many different solvable data-structure problems he can set. Two data-structure problems are different if and only if there exists an update operation that appears in one but not in the other.", "inputFormat": "The first line contains positive integers $n, m$.\n\nThe next $m$ lines each contain two positive integers $u, v$, representing a pair of mutually exclusive update operations.", "outputFormat": "Output a single integer on one line, representing the number of solvable different data-structure problems that Duliu can set. This number can be large, so output it modulo $998244353$.", "hint": "#### Explanation for Sample 1\n\nThe solvable problems include $\\varnothing, \\{1\\}, \\{2\\}, \\{3\\}, \\{1, 3\\}$. Note that the empty set is a valid data-structure problem.\n\n#### Constraints\n\n![](https://cdn.luogu.com.cn/upload/pic/17511.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI/AHOI2018] 毒瘤", "background": "", "description": "从前有一名毒瘤。\n\n毒瘤最近发现了量产毒瘤题的奥秘。考虑如下类型的数据结构题：给出一个数组，要求支持若干种奇奇怪怪的修改操作（比如区间加一个数，或者区间开平方），并支持询问区间和。毒瘤考虑了 $n$ 个这样的修改操作，并编号为 $1\\sim n$。当毒瘤要出数据结构题的时候，他就将这些修改操作中选若干个出来，然后出成一道题。\n\n当然了，这样出的题有可能不可做。通过精妙的数学推理，毒瘤揭露了这些修改操作的关系：有 $m$ 对“互相排斥”的修改操作，第 $i$ 对是第 $u_i$ 个操作和第 $v_i$ 个操作。当一道题同时含有 $u_i$ 和 $v_i$ 这两个操作时，这道题就会变得不可做。另一方面，一道题中不包含任何“互相排斥”的修改操作时，这个题就是可做的。此外，毒瘤还发现了一个规律：$m-n$ 是一个很小的数字，且任意两个修改操作都是连通的。两个修改操作 $a,b$ 是连通的，当且仅当存在若干操作 $t_0,t_1,\\cdots,t_l$，使得 $t_0=a,t_l=b$，且对 $1\\leq i\\leq l$，$t_{i-1}$ 和 $t_i$ 都是“互相排斥”的修改操作。\n\n一对“互相排斥”的修改操作称为互斥对。现在毒瘤想知道，给定值 $n$ 和 $m$ 个互斥对，他共能出出多少道可做的不同的数据结构题。两道数据结构题是不同的，当且仅当有一个修改操作在其中一道题中存在，而在另一道题中不存在。", "inputFormat": "第一行为正整数 $n,m$。\n\n接下来 $m$ 行，每行两个正整数 $u,v$，代表一对“互相排斥”的修改操作。", "outputFormat": "输出一行一个整数，代表毒瘤可以出的可做的不同的“互相排斥”的修改操作的个数。这个数可能很大，所以只输出模 $998244353$ 后的值。", "hint": "#### 样例一说明\n\n可做的题包括 $\\varnothing,\\{1\\},\\{2\\},\\{3\\},\\{1,3\\}$。注意，**空集是合法的数据结构题**。\n\n#### 数据范围\n\n![](https://cdn.luogu.com.cn/upload/pic/17511.png)", "locale": "zh-CN"}}}
{"pid": "P4427", "type": "P", "difficulty": 4, "samples": [["5\n1 2\n1 3\n2 4\n2 5\n2\n1 4 5\n5 4 45", "33\n503245989"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "倍增", "各省省选", "北京", "O2优化", "深度优先搜索 DFS", "最近公共祖先 LCA", "树链剖分", "前缀和", "差分"], "title": "[BJOI2018] 求和", "background": "", "description": "master 对树上的求和非常感兴趣。他生成了一棵有根树，并且希望多次询问这棵树上一段路径上所有节点深度的 $k$ 次方和，而且每次的 $k$ 可能是不同的。此处节点深度的定义是这个节点到根的路径上的边数。他把这个问题交给了 pupil，但 pupil 并不会这么复杂的操作，你能帮他解决吗？", "inputFormat": "第一行包含一个正整数 $n$，表示树的节点数。\n\n之后 $n-1$ 行每行两个空格隔开的正整数 $i, j$，表示树上的一条连接点 $i$ 和点 $j$ 的边。\n\n之后一行一个正整数 $m$，表示询问的数量。\n\n之后每行三个空格隔开的正整数 $i, j, k$，表示询问从点 $i$ 到点 $j$ 的路径上所有节点深度的 $k$ 次方和。由于这个结果可能非常大，输出其对 $998244353$ 取模的结果。\n\n树的节点从 $1$ 开始标号，其中 $1$ 号节点为树的根。", "outputFormat": "对于每组数据输出一行一个正整数表示取模后的结果。\n", "hint": "### 样例解释\n\n以下用 $d (i)$ 表示第 $i$ 个节点的深度。\n\n对于样例中的树，有 $d (1) = 0, d (2) = 1, d (3) = 1, d (4) = 2, d (5) = 2$。\n\n因此第一个询问答案为 $(2^5 + 1^5 + 0^5) \\bmod 998244353 = 33$，第二个询问答案为$(2^{45} + 1^{45} + 2^{45}) \\bmod 998244353 = 503245989$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，$1 \\leq n,m \\leq 100$。\n\n对于 $60\\%$ 的数据，$1 \\leq n,m \\leq 1000$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 300000$，$1 \\leq k \\leq 50$。\n\n另外存在 5 个不计分的 hack 数据。\n\n### 提示\n\n数据规模较大，请注意使用较快速的输入输出方式。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2018] Sum", "background": "", "description": "master is very interested in sums on trees. He generated a rooted tree and wants to query, multiple times, the sum of the $k$-th power of the depths of all nodes on a path, and $k$ may be different each time. Here, the depth of a node is defined as the number of edges on the path from this node to the root. He handed this problem to pupil, but pupil does not know how to perform such complex operations. Can you help him?", "inputFormat": "The first line contains a positive integer $n$, the number of nodes in the tree.\n\nEach of the next $n - 1$ lines contains two space-separated positive integers $i, j$, indicating an edge between nodes $i$ and $j$ in the tree.\n\nThe next line contains a positive integer $m$, the number of queries.\n\nEach of the next $m$ lines contains three space-separated positive integers $i, j, k$, representing a query asking for the sum of the $k$-th power of the depths of all nodes on the path from node $i$ to node $j$. Since the result can be very large, output it modulo $998244353$.\n\nNodes are numbered starting from $1$, and node $1$ is the root.", "outputFormat": "For each query, output one line with a single integer, the result modulo $998244353$.", "hint": "Sample Explanation\n\nLet $d (i)$ denote the depth of node $i$.\n\nFor the sample tree, $d (1) = 0, d (2) = 1, d (3) = 1, d (4) = 2, d (5) = 2$.\n\nTherefore, the answer to the first query is $(2^5 + 1^5 + 0^5) \\bmod 998244353 = 33$; the answer to the second query is $(2^{45} + 1^{45} + 2^{45}) \\bmod 998244353 = 503245989$.\n\nConstraints\n\n- For $30\\%$ of the testdata, $1 \\leq n, m \\leq 100$.\n- For $60\\%$ of the testdata, $1 \\leq n, m \\leq 1000$.\n- For $100\\%$ of the testdata, $1 \\leq n, m \\leq 300000$, $1 \\leq k \\leq 50$.\n\nAdditionally, there are $5$ unscored hack testdata.\n\nTip\n\nThe input size is large; please use fast I/O.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2018] 求和", "background": "", "description": "master 对树上的求和非常感兴趣。他生成了一棵有根树，并且希望多次询问这棵树上一段路径上所有节点深度的 $k$ 次方和，而且每次的 $k$ 可能是不同的。此处节点深度的定义是这个节点到根的路径上的边数。他把这个问题交给了 pupil，但 pupil 并不会这么复杂的操作，你能帮他解决吗？", "inputFormat": "第一行包含一个正整数 $n$，表示树的节点数。\n\n之后 $n-1$ 行每行两个空格隔开的正整数 $i, j$，表示树上的一条连接点 $i$ 和点 $j$ 的边。\n\n之后一行一个正整数 $m$，表示询问的数量。\n\n之后每行三个空格隔开的正整数 $i, j, k$，表示询问从点 $i$ 到点 $j$ 的路径上所有节点深度的 $k$ 次方和。由于这个结果可能非常大，输出其对 $998244353$ 取模的结果。\n\n树的节点从 $1$ 开始标号，其中 $1$ 号节点为树的根。", "outputFormat": "对于每组数据输出一行一个正整数表示取模后的结果。\n", "hint": "### 样例解释\n\n以下用 $d (i)$ 表示第 $i$ 个节点的深度。\n\n对于样例中的树，有 $d (1) = 0, d (2) = 1, d (3) = 1, d (4) = 2, d (5) = 2$。\n\n因此第一个询问答案为 $(2^5 + 1^5 + 0^5) \\bmod 998244353 = 33$，第二个询问答案为$(2^{45} + 1^{45} + 2^{45}) \\bmod 998244353 = 503245989$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，$1 \\leq n,m \\leq 100$。\n\n对于 $60\\%$ 的数据，$1 \\leq n,m \\leq 1000$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 300000$，$1 \\leq k \\leq 50$。\n\n另外存在 5 个不计分的 hack 数据。\n\n### 提示\n\n数据规模较大，请注意使用较快速的输入输出方式。", "locale": "zh-CN"}}}
{"pid": "P4428", "type": "P", "difficulty": 6, "samples": [["4\n1 0 1 0\n3\n2 1 3\n1 3\n2 3 4", "2\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "线段树", "各省省选", "树状数组", "北京", "O2优化", "构造"], "title": "[BJOI2018] 二进制", "background": null, "description": "pupil 发现对于一个十进制数，无论怎么将其的数字重新排列，均不影响其是不是 $3$ 的倍数。他想研究对于二进制，是否也有类似的性质。\n\n于是他生成了一个长为 $n$ 的二进制串，希望你对于这个二进制串的一个子区间，能求出其有多少位置不同的连续子串，满足在重新排列后（可包含前导 $0$）是一个 $3$ 的倍数。\n\n两个位置不同的子区间指开始位置不同或结束位置不同。\n\n由于他想尝试尽量多的情况，他有时会修改串中的一个位置，并且会进行多次询问。", "inputFormat": "输入第一行包含一个正整数 $n$，表示二进制数的长度。\n\n之后一行 $n$ 个空格隔开的整数，保证均是 $0$ 或 $1$，表示该二进制串。\n\n之后一行一个整数 $m$ ，表示询问和修改的总次数。\n\n之后 $m$ 行每行为 ```1 i```，表示 pupil 修改了串的第 $i$ 个位置（$0$ 变成 $1$ 或 $1$ 变成 $0$），或 ```2 l r```，表示 pupil 询问的子区间是 $[l,r]$。\n\n串的下标从 $1$ 开始。", "outputFormat": "对于每次询问，输出一行一个整数表示对应该询问的结果。", "hint": "### 样例解释\n\n对于第一个询问，区间 $[2,2]$ 只有数字 $0$，是 $3$ 的倍数，区间 $[1,3]$ 可以重排成 $011_{(2)} = 3_{(10)}$，是 $3$ 的倍数，其他区间均不能重排成 $3$ 的倍数。\n\n对于第二个询问，全部三个区间均能重排成 $3$ 的倍数（注意 $00$ 也是合法的）。\n\n### 数据范围\n\n对于$20\\%$ 的数据，$1 \\leq n,m \\leq 100$。\n\n对于$50\\%$ 的数据，$1 \\leq n,m \\leq 5000$。\n\n对于$100\\%$ 的数据，$1 \\leq n,m \\leq 100000$，$l \\leq r$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2018] Binary", "background": "", "description": "pupil found that for a decimal number, no matter how its digits are rearranged, it does not affect whether it is a multiple of $3$. He wants to study whether there is a similar property for binary.\n\nSo he generated a binary string of length $n$, and hopes that for a subinterval of this binary string, you can find how many position-distinct contiguous substrings satisfy that after rearrangement (leading zeros are allowed), the result is a multiple of $3$.\n\nTwo position-distinct subintervals are defined as having different starting positions or different ending positions.\n\nSince he wants to try as many cases as possible, he will sometimes modify one position in the string and will make multiple queries.", "inputFormat": "The first line contains a positive integer $n$, the length of the binary number.\n\nThe second line contains $n$ space-separated integers, each being $0$ or $1$, representing the binary string.\n\nThe third line contains an integer $m$, the total number of queries and modifications.\n\nEach of the following $m$ lines is either ```1 i```, meaning pupil toggles the $i$-th position of the string ($0$ becomes $1$ or $1$ becomes $0$), or ```2 l r```, meaning pupil queries the subinterval $[l,r]$.\n\nThe string is $1$-indexed.", "outputFormat": "For each query, output one line with one integer representing the answer to that query.", "hint": "Sample Explanation:\n- For the first query, the interval $[2,2]$ contains only the digit $0$, which is a multiple of $3$. The interval $[1,3]$ can be rearranged into $011_{(2)} = 3_{(10)}$, which is a multiple of $3$. All other intervals cannot be rearranged into a multiple of $3$.\n- For the second query, all three intervals can be rearranged into multiples of $3$ (note that $00$ is also valid).\n\nConstraints:\n- For $20\\%$ of the testdata, $1 \\leq n,m \\leq 100$.\n- For $50\\%$ of the testdata, $1 \\leq n,m \\leq 5000$.\n- For $100\\%$ of the testdata, $1 \\leq n,m \\leq 100000$, $l \\leq r$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2018] 二进制", "background": null, "description": "pupil 发现对于一个十进制数，无论怎么将其的数字重新排列，均不影响其是不是 $3$ 的倍数。他想研究对于二进制，是否也有类似的性质。\n\n于是他生成了一个长为 $n$ 的二进制串，希望你对于这个二进制串的一个子区间，能求出其有多少位置不同的连续子串，满足在重新排列后（可包含前导 $0$）是一个 $3$ 的倍数。\n\n两个位置不同的子区间指开始位置不同或结束位置不同。\n\n由于他想尝试尽量多的情况，他有时会修改串中的一个位置，并且会进行多次询问。", "inputFormat": "输入第一行包含一个正整数 $n$，表示二进制数的长度。\n\n之后一行 $n$ 个空格隔开的整数，保证均是 $0$ 或 $1$，表示该二进制串。\n\n之后一行一个整数 $m$ ，表示询问和修改的总次数。\n\n之后 $m$ 行每行为 ```1 i```，表示 pupil 修改了串的第 $i$ 个位置（$0$ 变成 $1$ 或 $1$ 变成 $0$），或 ```2 l r```，表示 pupil 询问的子区间是 $[l,r]$。\n\n串的下标从 $1$ 开始。", "outputFormat": "对于每次询问，输出一行一个整数表示对应该询问的结果。", "hint": "### 样例解释\n\n对于第一个询问，区间 $[2,2]$ 只有数字 $0$，是 $3$ 的倍数，区间 $[1,3]$ 可以重排成 $011_{(2)} = 3_{(10)}$，是 $3$ 的倍数，其他区间均不能重排成 $3$ 的倍数。\n\n对于第二个询问，全部三个区间均能重排成 $3$ 的倍数（注意 $00$ 也是合法的）。\n\n### 数据范围\n\n对于$20\\%$ 的数据，$1 \\leq n,m \\leq 100$。\n\n对于$50\\%$ 的数据，$1 \\leq n,m \\leq 5000$。\n\n对于$100\\%$ 的数据，$1 \\leq n,m \\leq 100000$，$l \\leq r$。", "locale": "zh-CN"}}}
{"pid": "P4429", "type": "P", "difficulty": 7, "samples": [["3\n6 9\n1 2\n1 4\n1 6\n3 2\n3 4\n3 6\n5 2\n5 4\n5 6\n2 1\n1 2\n3 3\n1 2\n1 3\n2 3", "NO\nYES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "2018", "各省省选", "北京", "O2优化", "排序", "拓扑排序", "构造"], "title": "[BJOI2018] 染色", "background": "", "description": "pupil 喜欢给图的顶点染颜色。有一天，master 想刁难他，于是给了他一个无重边和自环的无向图，并且对每个点分别给了一个大小为 $2$ 的颜色集合，pupil 只能从这个集合中选一种颜色给这个点染色。master 希望 pupil 的染色方案使得没有两个有边相连的点被染了相同的颜色。\n\n现在 pupil 想知道，是否无论 master 的颜色集合是什么，他均有办法按照要求染色。", "inputFormat": "输入包含多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n之后每组数据第一行两个空格隔开的整数 $n,m$，表示这个无向图的点数和边数。\n\n之后 $m$ 行，每行两个空格隔开的正整数 $i,j$，表示图中的一条连接点 $i$ 和点 $j$ 的边。\n\n图的节点从 $1$ 开始标号。", "outputFormat": "对于每组数据，如果 pupil 无论如何均能染色，输出一行一个字符串 `YES`，否则输出一行一个字符串 `NO`。", "hint": "### 样例解释\n\n对于第一组数据，如果第一个点和第二个点的集合为 $\\{A,B\\}$，第三个点和第四个点的集合为 $\\{A,C\\}$，第五个点和第六个点的集合为 $\\{B,C\\}$，\n则奇数点至少使用了两种颜色，偶数点至少使用了两种颜色，因此至少有一个奇数点和一个偶数点颜色相同。但每两个奇数点和每两个偶数点之间均有边，\n因此无法满足“没有两个有边相连的点被染了相同的颜色”。\n\n对于第二组数据，无论两个集合是什么，第一个点随便染它的集合中的其中一种颜色，第二个点染它的集合中某个与第一个点不同的颜色即可。\n\n对于第三组数据，如果三个点的集合均是 $\\{A,B\\}$，那么无法满足“没有两个有边相连的点被染了相同的颜色”。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$1 \\leq n \\leq 3$；\n- 对于 $20\\%$ 的数据，$1 \\leq n \\leq 6$；\n- 对于 $50\\%$ 的数据，$1 \\leq n \\leq 1000$，$0 \\leq m \\leq 2000$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 10000$，$0 \\leq m \\leq 20000$，$1 \\leq T \\leq 10$。\n- 另外存在 5 个不计分的 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2018] Coloring", "background": "", "description": "pupil likes coloring the vertices of a graph. One day, master wanted to make things difficult and gave him a simple undirected graph (no multiple edges or self-loops). For each vertex, master assigned a color set of size $2$, and pupil can only choose one color from that set for the vertex. master wants pupil’s coloring to be such that no two vertices connected by an edge are colored with the same color.\n\nNow pupil wants to know whether, no matter what color sets master assigns, he can always color the graph as required.", "inputFormat": "The input contains multiple test cases.\n\nThe first line contains a positive integer $T$, the number of test cases.\n\nFor each test case, the first line contains two space-separated integers $n, m$, the number of vertices and edges in the undirected graph.\n\nThen follow $m$ lines, each containing two space-separated positive integers $i, j$, indicating an edge between vertices $i$ and $j$.\n\nVertices are numbered from $1$.", "outputFormat": "For each test case, if pupil can always color the graph regardless of the assigned color sets, output a line with the string `YES`; otherwise, output a line with the string `NO`.", "hint": "Sample explanation.\n\nFor the first test case, if the sets for the first and second vertices are $\\{A, B\\}$, for the third and fourth vertices are $\\{A, C\\}$, and for the fifth and sixth vertices are $\\{B, C\\}$, then the odd-indexed vertices must use at least two colors, and the even-indexed vertices must use at least two colors. Therefore, at least one odd-indexed vertex and one even-indexed vertex share the same color. But there is an edge between every pair of odd-indexed vertices and between every pair of even-indexed vertices, so the requirement “no two adjacent vertices share the same color” cannot be satisfied.\n\nFor the second test case, regardless of the two sets, color the first vertex with any color from its set, and color the second vertex with a color from its set that is different from the first vertex’s color.\n\nFor the third test case, if all three vertices have the set $\\{A, B\\}$, then the requirement “no two adjacent vertices share the same color” cannot be satisfied.\n\nConstraints:\n- For $10\\%$ of the testdata, $1 \\leq n \\leq 3$.\n- For $20\\%$ of the testdata, $1 \\leq n \\leq 6$.\n- For $50\\%$ of the testdata, $1 \\leq n \\leq 1000$, $0 \\leq m \\leq 2000$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 10000$, $0 \\leq m \\leq 20000$, $1 \\leq T \\leq 10$.\n- There are also $5$ unscored hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2018] 染色", "background": "", "description": "pupil 喜欢给图的顶点染颜色。有一天，master 想刁难他，于是给了他一个无重边和自环的无向图，并且对每个点分别给了一个大小为 $2$ 的颜色集合，pupil 只能从这个集合中选一种颜色给这个点染色。master 希望 pupil 的染色方案使得没有两个有边相连的点被染了相同的颜色。\n\n现在 pupil 想知道，是否无论 master 的颜色集合是什么，他均有办法按照要求染色。", "inputFormat": "输入包含多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n之后每组数据第一行两个空格隔开的整数 $n,m$，表示这个无向图的点数和边数。\n\n之后 $m$ 行，每行两个空格隔开的正整数 $i,j$，表示图中的一条连接点 $i$ 和点 $j$ 的边。\n\n图的节点从 $1$ 开始标号。", "outputFormat": "对于每组数据，如果 pupil 无论如何均能染色，输出一行一个字符串 `YES`，否则输出一行一个字符串 `NO`。", "hint": "### 样例解释\n\n对于第一组数据，如果第一个点和第二个点的集合为 $\\{A,B\\}$，第三个点和第四个点的集合为 $\\{A,C\\}$，第五个点和第六个点的集合为 $\\{B,C\\}$，\n则奇数点至少使用了两种颜色，偶数点至少使用了两种颜色，因此至少有一个奇数点和一个偶数点颜色相同。但每两个奇数点和每两个偶数点之间均有边，\n因此无法满足“没有两个有边相连的点被染了相同的颜色”。\n\n对于第二组数据，无论两个集合是什么，第一个点随便染它的集合中的其中一种颜色，第二个点染它的集合中某个与第一个点不同的颜色即可。\n\n对于第三组数据，如果三个点的集合均是 $\\{A,B\\}$，那么无法满足“没有两个有边相连的点被染了相同的颜色”。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$1 \\leq n \\leq 3$；\n- 对于 $20\\%$ 的数据，$1 \\leq n \\leq 6$；\n- 对于 $50\\%$ 的数据，$1 \\leq n \\leq 1000$，$0 \\leq m \\leq 2000$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 10000$，$0 \\leq m \\leq 20000$，$1 \\leq T \\leq 10$。\n- 另外存在 5 个不计分的 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P4430", "type": "P", "difficulty": 4, "samples": [["4", "96"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [165536, 165536, 165536, 165536, 165536, 165536, 165536, 165536, 165536, 165536, 165536]}, "tags": ["数学", "生成树", "线性代数", "Prüfer 序列"], "title": "小猴打架", "background": "", "description": "一开始森林里面有 $N$ 只互不相识的小猴子，它们经常打架，但打架的双方都必须不是好朋友。每次打完架后，打架的双方以及它们的好朋友就会互相认识，成为好朋友。经过 $N-1$ 次打架之后，整个森林的小猴都会成为好朋友。   \n现在的问题是，总共有多少种不同的打架过程。   \n比如当 $N=3$ 时，就有 $\\{1-2,1-3\\}\\{1-2,2-3\\}\\{1-3,1-2\\}\\{1-3,2-3\\}\\{2-3,1-2\\}\\{2-3,1-3\\}$ 六种不同的打架过程。 \n", "inputFormat": "一个整数 $N$。 ", "outputFormat": "一行，方案数 $\\bmod 9999991$。 ", "hint": "$50\\%$ 的数据 $N\\le 10^3$。  \n$100\\%$ 的数据 $N\\le10^6$。 ", "locale": "zh-CN", "translations": {"en": {"title": "Little Monkeys Fight", "background": "", "description": "Initially, there are $N$ little monkeys in the forest who do not know each other. They often fight, but the two sides in a fight must not be good friends. After each fight, the two fighters and their respective good friends will get to know each other and become good friends with each other. After $N - 1$ fights, all the monkeys in the forest will become good friends.\nThe question is: how many different fighting processes are there in total.\nFor example, when $N = 3$, there are six different fighting processes: {1-2, 1-3} {1-2, 2-3} {1-3, 1-2} {1-3, 2-3} {2-3, 1-2} {2-3, 1-3}.", "inputFormat": "A single integer $N$.", "outputFormat": "One line: the number of ways $\\bmod 9999991$.", "hint": "- 50% of the testdata $N \\le 10^3$.\n- 100% of the testdata $N \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小猴打架", "background": "", "description": "一开始森林里面有 $N$ 只互不相识的小猴子，它们经常打架，但打架的双方都必须不是好朋友。每次打完架后，打架的双方以及它们的好朋友就会互相认识，成为好朋友。经过 $N-1$ 次打架之后，整个森林的小猴都会成为好朋友。   \n现在的问题是，总共有多少种不同的打架过程。   \n比如当 $N=3$ 时，就有 $\\{1-2,1-3\\}\\{1-2,2-3\\}\\{1-3,1-2\\}\\{1-3,2-3\\}\\{2-3,1-2\\}\\{2-3,1-3\\}$ 六种不同的打架过程。 \n", "inputFormat": "一个整数 $N$。 ", "outputFormat": "一行，方案数 $\\bmod 9999991$。 ", "hint": "$50\\%$ 的数据 $N\\le 10^3$。  \n$100\\%$ 的数据 $N\\le10^6$。 ", "locale": "zh-CN"}}}
{"pid": "P4431", "type": "P", "difficulty": 2, "samples": [["2\n1 10\n10 1\n", "0\n0"], ["3\n1 1\n3 3\n3 4\n", "0\n4\n4"], ["2\n5 8\n6 4", "8\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["搜索", "2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #2] ​Košnja", "background": "", "description": "Mirko wants to buy land on which he will build a house for his family. So far, he’s seen K pieces of land. Each of them is in the shape of a rectangle and we can think of it as a matrix with N rows and M columns, N × M fields in total.\n\nMirko is aware that, before construction begins, the property needs to be regularly maintained and the lawn needs to be mowed. Because of this, Mirko bought a lawn mower. In order to mow the entire lawn of N rows and M columns, he needs to go over each field at least once. He can start from any field facing one of the four main directions (up, down, left, and right). His lawn mower can only go forwards (to the adjacent field facing the current direction) or make a 90 degree turn. Additionally, because of his own safety, Mirko can only use the lawn mower on his land, so he cannot leave the matrix.\n\nSince making the lawn mower turn isn’t simple, Mirko wants to mow the lawn with the minimal amount of turns. For each piece of land he saw so far, Mirko wants to know the minimal number of turns he can make so that the entire lawn is mowed. Help Mirko solve this problem.", "inputFormat": "The first line of input contains the positive integer K (1 ≤ K ≤ 50 000), the number from the task.\n\nEach of the following K lines contains two positive integers N and M (1 ≤ N, M ≤ 1 000 000), the numbers from the task.\n", "outputFormat": "For each piece of land Mirko saw so far, output in a separate line the minimal amount of turns he can take so that the entire lawn is mowed.\n", "hint": "In test cases worth 50% of total points, Mirko will see only one piece of land. The dimensions of this piece of land will be smaller than 500.\n\n**Clarification​ ​of​ ​the​ ​first​ ​test​ ​case:**\n\nThe first piece of land can be mowed without making any turns if he starts from the field in the first column of the table, faced to the right and only going forwards. A similar idea applies for the second piece of land.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #2] ​Košnja", "background": "", "description": "Mirko wants to buy land on which he will build a house for his family. So far, he’s seen K pieces of land. Each of them is in the shape of a rectangle and we can think of it as a matrix with N rows and M columns, N × M fields in total.\n\nMirko is aware that, before construction begins, the property needs to be regularly maintained and the lawn needs to be mowed. Because of this, Mirko bought a lawn mower. In order to mow the entire lawn of N rows and M columns, he needs to go over each field at least once. He can start from any field facing one of the four main directions (up, down, left, and right). His lawn mower can only go forwards (to the adjacent field facing the current direction) or make a 90 degree turn. Additionally, because of his own safety, Mirko can only use the lawn mower on his land, so he cannot leave the matrix.\n\nSince making the lawn mower turn isn’t simple, Mirko wants to mow the lawn with the minimal amount of turns. For each piece of land he saw so far, Mirko wants to know the minimal number of turns he can make so that the entire lawn is mowed. Help Mirko solve this problem.", "inputFormat": "The first line of input contains the positive integer K (1 ≤ K ≤ 50 000), the number from the task.\n\nEach of the following K lines contains two positive integers N and M (1 ≤ N, M ≤ 1 000 000), the numbers from the task.\n", "outputFormat": "For each piece of land Mirko saw so far, output in a separate line the minimal amount of turns he can take so that the entire lawn is mowed.\n", "hint": "In test cases worth 50% of total points, Mirko will see only one piece of land. The dimensions of this piece of land will be smaller than 500.\n\n**Clarification​ ​of​ ​the​ ​first​ ​test​ ​case:**\n\nThe first piece of land can be mowed without making any turns if he starts from the field in the first column of the table, faced to the right and only going forwards. A similar idea applies for the second piece of land.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #2] ​Košnja", "background": "", "description": "**题目大意：**\n\n给定一个$n*m$的矩阵，每次你可以选择前进一格或转弯（90度），求在不出这个矩阵的情况下遍历全部格点所需最少转弯次数。有多组数据", "inputFormat": "第一行一个整数$k$，表示数据组数\n\n以下$k$行，每行两个整数$n,m$，表示矩阵大小", "outputFormat": "输出一个整数，即最少转弯次数\n\n感谢@守望 提供翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4432", "type": "P", "difficulty": 2, "samples": [["4 5\nzagreb\nsplit\nzadar\nsisak\nz\ns\ns\nz\nz\n", "zadar\nsisak\nsplit\nzagreb\nzadar\n"], ["5 3\nlondon\nrim\npariz\nmoskva\nsarajevo\np\nr\np\n", "pariz\nrim\npariz\n"], ["1 3\nzagreb\nz\nz\nz\n", "zagreb\nzagreb\nzagreb"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["字符串", "2017", "排序", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #2] ​​ZigZag", "background": "", "description": "Zig and Zag are playing a word game. Zig says one letter, and Zag says a word that starts\nwith that letter. However, the word needs to be from the allowed word list and such that Zag\nalready said it the least amount of times. If the word choice is ambiguous, then Zag will\nchoose the one that is lexicographically smaller (sooner in the alphabet). For each Zig’s\nletter, it will be possible to choose a word.\n\nLet there be a list consisting of exactly K distinct words and an array of N letters that Zig has\ngiven. Write a program that will, based on the input, output an array of N words that Zag said\nduring the game.\n", "inputFormat": "The first line of input contains positive integers K (1 ≤ K ≤ 100 000) and N (1 ≤ N ≤ 100 000)\nfrom the task.\n\nEach of the following K lines contains a single word consisting of lowercase letters of the\nEnglish alphabet not longer than 21 characters.\n\nEach of the following N lines contains a single lowercase letter of the English alphabet.\n", "outputFormat": "You must output N lines, each containing a single word from the task.\n", "hint": "In test cases worth 60% of total points, it will hold that N and K are smaller than 500.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #2] ​​ZigZag", "background": "", "description": "Zig and Zag are playing a word game. Zig says one letter, and Zag says a word that starts\nwith that letter. However, the word needs to be from the allowed word list and such that Zag\nalready said it the least amount of times. If the word choice is ambiguous, then Zag will\nchoose the one that is lexicographically smaller (sooner in the alphabet). For each Zig’s\nletter, it will be possible to choose a word.\n\nLet there be a list consisting of exactly K distinct words and an array of N letters that Zig has\ngiven. Write a program that will, based on the input, output an array of N words that Zag said\nduring the game.\n", "inputFormat": "The first line of input contains positive integers K (1 ≤ K ≤ 100 000) and N (1 ≤ N ≤ 100 000)\nfrom the task.\n\nEach of the following K lines contains a single word consisting of lowercase letters of the\nEnglish alphabet not longer than 21 characters.\n\nEach of the following N lines contains a single lowercase letter of the English alphabet.\n", "outputFormat": "You must output N lines, each containing a single word from the task.\n", "hint": "In test cases worth 60% of total points, it will hold that N and K are smaller than 500.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #2] ​​ZigZag", "background": "", "description": "Zig和Zag正在玩文字游戏。Zig说了一个字母，而Zag说了一个以该字母开头的单词。但是这个词需要出现在给出的单词列表中，并且被是相同首字母中使用的次数最少的单词。如果单词的选择不明确(即相同首字母中使用的次数最少的单词不止一个)，那么Zag会选择字典序较小的字母。输入保证对于每个Zig的字母，都有可以选择的单词。\n\n假设有一个由K个不同的单词组成的列表和一个Zig给出的N个字母组成的列表。编写一个程序，根据输入，输出Zag在游戏过程中说出的N个单词。", "inputFormat": "第一行输入包含来自的正整数K（1≤K≤100 000）和N（1≤N≤100 000）。\n\n以下K行是K个单词，由小写英文字母组成，不超过21个字母。\n\n以下N行是Zig说的N个小写英文字母。", "outputFormat": "N行，分别对应N个Zig的询问。\n\n感谢@K_Vin 提供的翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4433", "type": "P", "difficulty": 7, "samples": [["6 3\n2 1 6\n1 1 5 1 2\n2 1 6\n", "0\n3"], ["4 5\n1 1 4 3 4\n2 1 1\n2 2 2\n2 3 3\n2 4 4\n", "3\n2\n1\n0"], ["4 4\n1 1 4 7 9\n2 1 4\n1 1 4 1 1\n2 1 4\n", "16\n0"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["数学", "2009", "线段树", "递归", "COCI（克罗地亚）", "类欧几里得算法"], "title": "[COCI 2009/2010 #1] ALADIN", "background": "", "description": "给你 $n$ 个盒子，有 $q$ 个操作，操作有两种：\n\n- 第一种操作输入格式为 `1 L R A B`，表示将编号为 $L$ 到 $R$ 的盒子里的石头数量变为 $(X-L+1) \\times A \\bmod B$，其中 $X$ 为盒子的编号。\n- 第二种操作输入格式为 `2 L R`，表示查询编号为 $L$ 到 $R$ 的盒子里的石头总数。", "inputFormat": "第一行有两个数字 $n$（$1 \\leq n \\leq 10^9$），$q$ （$1 \\leq q \\leq 5 \\times 10^4$）。\n\n接下来 $q$ 行表示询问操作。", "outputFormat": "对于每个第二种操作，输出石头总数。", "hint": "- 对于 $30\\%$ 的数据，$n, q \\leq 10^3$；\n- 对于 $70\\%$ 的数据，$q \\leq 10^3$。\n\n对于 $100\\%$ 的数据，$1\\leq A,B\\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2009/2010 #1] ALADIN", "background": "", "description": "You are given $n$ boxes and $q$ operations of two types:\n\n- Type 1 operation with input format `1 L R A B`: for each box $X$ with $L \\leq X \\leq R$, set its number of stones to $(X - L + 1) \\times A \\bmod B$, where $X$ is the index of the box.\n- Type 2 operation with input format `2 L R`: query the total number of stones in boxes numbered $L$ through $R$.", "inputFormat": "The first line contains two integers $n$ ($1 \\leq n \\leq 10^9$) and $q$ ($1 \\leq q \\leq 5 \\times 10^4$).\n\nThe next $q$ lines describe the operations.", "outputFormat": "For each type 2 operation, output the total number of stones.", "hint": "- For $30\\%$ of the testdata, $n, q \\leq 10^3$.\n- For $70\\%$ of the testdata, $q \\leq 10^3$.\n- For $100\\%$ of the testdata, $1 \\leq A, B \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2009/2010 #1] ALADIN", "background": "", "description": "给你 $n$ 个盒子，有 $q$ 个操作，操作有两种：\n\n- 第一种操作输入格式为 `1 L R A B`，表示将编号为 $L$ 到 $R$ 的盒子里的石头数量变为 $(X-L+1) \\times A \\bmod B$，其中 $X$ 为盒子的编号。\n- 第二种操作输入格式为 `2 L R`，表示查询编号为 $L$ 到 $R$ 的盒子里的石头总数。", "inputFormat": "第一行有两个数字 $n$（$1 \\leq n \\leq 10^9$），$q$ （$1 \\leq q \\leq 5 \\times 10^4$）。\n\n接下来 $q$ 行表示询问操作。", "outputFormat": "对于每个第二种操作，输出石头总数。", "hint": "- 对于 $30\\%$ 的数据，$n, q \\leq 10^3$；\n- 对于 $70\\%$ 的数据，$q \\leq 10^3$。\n\n对于 $100\\%$ 的数据，$1\\leq A,B\\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4434", "type": "P", "difficulty": 5, "samples": [["4 1\n1 2\n2 3\n3 4\n2 4", "4"], ["7 2\n1 2\n1 3\n4 2\n2 5\n6 5\n5 7\n1 7\n2 6\n", "8"], ["4 3\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #2] ​​Usmjeri", "background": "", "description": "We are given a tree with N nodes denoted with different positive integers from 1 to N.\nAdditionally, you are given M node pairs from the tree in the form of ($a_1$\n, $b_1$\n), ($a_2$\n, $b_2$\n), …, ($a_M$\n,\n$b_M$\n).\n\nWe need to direct each edge of the tree so that for each given node pair ($a_i$\n, $b_i$\n) there is a\npath from $a_i$\nto $b_i$ or from $b_i$\nto $a_i$\n. How many different ways are there to achieve this?\nSince the solution can be quite large, determine it modulo $10^{9}+7$.\n", "inputFormat": "The first line of input contains the positive integers N and M (1 ≤ N, M ≤ $3*10^5$), the number of\nnodes in the tree and the number of given node pairs, respectively.\n\nEach of the following N - 1 lines contains two positive integers, the labels of the nodes\nconnected with an edge.\n\nThe $i_{th}$ of the following M lines contains two different positive integers $a_{i}$ and $b_{i}$\n, the labels of\nthe nodes from the $i_{th}$ node pair. All node pairs will be mutually different.\n", "outputFormat": "You must output a single line containing the total number of different ways to direct the\nedges of the tree that meet the requirement from the task, modulo $10^{9}+7$.\n", "hint": "In test cases worth 20% of total points, the given tree will be a chain. In other words, node i\nwill be connected with an edge to node i + 1 for all i < N.\n\nIn additional test cases worth 40% of total points, it will hold N, M ≤ $5*10^3$.\n\nA tree is a graph that consists of N nodes and N - 1 edges such that there exists a path from each\nnode to each other node.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #2] ​​Usmjeri", "background": "", "description": "We are given a tree with N nodes denoted with different positive integers from 1 to N.\nAdditionally, you are given M node pairs from the tree in the form of ($a_1$\n, $b_1$\n), ($a_2$\n, $b_2$\n), …, ($a_M$\n,\n$b_M$\n).\n\nWe need to direct each edge of the tree so that for each given node pair ($a_i$\n, $b_i$\n) there is a\npath from $a_i$\nto $b_i$ or from $b_i$\nto $a_i$\n. How many different ways are there to achieve this?\nSince the solution can be quite large, determine it modulo $10^{9}+7$.\n", "inputFormat": "The first line of input contains the positive integers N and M (1 ≤ N, M ≤ $3*10^5$), the number of\nnodes in the tree and the number of given node pairs, respectively.\n\nEach of the following N - 1 lines contains two positive integers, the labels of the nodes\nconnected with an edge.\n\nThe $i_{th}$ of the following M lines contains two different positive integers $a_{i}$ and $b_{i}$\n, the labels of\nthe nodes from the $i_{th}$ node pair. All node pairs will be mutually different.\n", "outputFormat": "You must output a single line containing the total number of different ways to direct the\nedges of the tree that meet the requirement from the task, modulo $10^{9}+7$.\n", "hint": "In test cases worth 20% of total points, the given tree will be a chain. In other words, node i\nwill be connected with an edge to node i + 1 for all i < N.\n\nIn additional test cases worth 40% of total points, it will hold N, M ≤ $5*10^3$.\n\nA tree is a graph that consists of N nodes and N - 1 edges such that there exists a path from each\nnode to each other node.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #2] ​​Usmjeri", "background": null, "description": "我们有一棵包含 $N$ 个节点的树，这些节点用从 $1$ 到 $N$ 的不同正整数表示。此外，给定树中的 $M$ 对节点，形式为 $(a_1, b_1), (a_2, b_2), \\ldots, (a_M, b_M)$。\n\n我们需要为树的每条边指定一个方向，使得对于每一对给定的节点对 $(a_i, b_i)$，存在从 $a_i$ 到 $b_i$ 或从 $b_i$ 到 $a_i$ 的路径。我们需要计算有多少种不同的方法可以实现这一点。由于结果可能非常大，需对 $10^9+7$ 取模。", "inputFormat": "输入的第一行包含正整数 $N$ 和 $M(1 \\leq N, M \\leq 3 \\times 10^5)$，分别表示树中的节点数和给定的节点对数。\n\n接下来的 $N - 1$ 行中，每行包含两个正整数，表示一条边所连接的两个顶点编号。\n\n接下来的 $M$ 行中的第 $i$ 行包含两个不同的正整数 $a_i$ 和 $b_i$，表示第 $i$ 对节点的编号。所有节点对都是互不相同的。", "outputFormat": "你需要输出一个单独的行，包含满足题目要求的树的边的不同方向方法总数，对 $10^9+7$ 取模。", "hint": "### 数据规模与约定\n\n* 对于 $20\\%$ 的数据，满足树是一条链，即 $\\forall i<N$，保证 $i$ 和 $i+1$ 有连边。\n* 对于另外 $40\\%$ 的数据，$1\\le N,M\\le 5\\times10^3$。\n* 对于 $100\\%$ 的数据，$1\\le N,M\\le 3\\times10^5$。\n\n树的定义：一个包含 $N$ 个节点和 $N-1$ 条边的无向图，满足任两个节点之间都存在一条路径。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4435", "type": "P", "difficulty": 6, "samples": [["5 1\n8 4 3 9 1\n2 2 5\n", "4"], ["5 3\n2 3 6 4 1\n2 1 4\n1 3 1\n2 3 5\n", "6\n1\n"], ["4 3\n2 2 2 2\n2 1 4\n1 2 3\n2 1 4\n", "10\n5"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "分治", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #2] ​​Garaža", "background": "", "description": "Lately, Slavko’s been studying sequences of natural numbers. He finds a sequence\ninteresting if the greatest common divisor of all the elements from the sequence is greater\nthan 1.\n\nYesterday, he found a sequence consisting of N natural numbers in his garage. Since he\nwas really bored, he decided to keep himself occupied by asking simple queries. Each query\ncan be one of the two types:\n\n1. Change the value at position X in the sequence to V.\n\n2. Determine the number of interesting contiguous subarrays contained in the interval\n[L, R] of the sequence.\n", "inputFormat": "The first line of input contains the numbers N and Q (1 ≤ N, Q ≤ $10^5$\n), representing the\nnumber of elements in the sequence and the number of queries, respectively.\n\nThe following line contains N natural numbers $A_i$\n(1 ≤ $A_i$ ≤ $10^9$\n) that represent the numbers in\nthe initial sequence.\n\nEach of the following Q lines contains a query of the following form:\n\n - The first number in the line can be 1 or 2 and represents the type of the query.\n - If the query is of type 1, two numbers follow, X (1 ≤ X ≤ N) and V (1 ≤ V ≤ $10^9$\n) from\nthe task.\n - If the query is of type 2, two numbers follow, L and R (1 ≤ L ≤ R ≤ N) that represent\nthe left and right interval boundary.\n", "outputFormat": "For each query of type 2, output the number of interesting contiguous subarrays from the\ntask.\n", "hint": "**Clarification​ ​of​ ​the​ ​first​ ​test​ ​case:**\n\nThe interval from the $2_{nd}$ to the $5_{th}$ position consists of numbers (4, 3, 9, 1). In it, the following are\ninteresting contiguous subarrays (denoted with square brackets):\n**[4]**​ 3 9 1, 4 **[3]​** ​9 1, 4 3 **[9]**​ 1, 4 **[3​ ​9]​** 1", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #2] ​​Garaža", "background": "", "description": "Lately, Slavko’s been studying sequences of natural numbers. He finds a sequence\ninteresting if the greatest common divisor of all the elements from the sequence is greater\nthan 1.\n\nYesterday, he found a sequence consisting of N natural numbers in his garage. Since he\nwas really bored, he decided to keep himself occupied by asking simple queries. Each query\ncan be one of the two types:\n\n1. Change the value at position X in the sequence to V.\n\n2. Determine the number of interesting contiguous subarrays contained in the interval\n[L, R] of the sequence.\n", "inputFormat": "The first line of input contains the numbers N and Q (1 ≤ N, Q ≤ $10^5$\n), representing the\nnumber of elements in the sequence and the number of queries, respectively.\n\nThe following line contains N natural numbers $A_i$\n(1 ≤ $A_i$ ≤ $10^9$\n) that represent the numbers in\nthe initial sequence.\n\nEach of the following Q lines contains a query of the following form:\n\n - The first number in the line can be 1 or 2 and represents the type of the query.\n - If the query is of type 1, two numbers follow, X (1 ≤ X ≤ N) and V (1 ≤ V ≤ $10^9$\n) from\nthe task.\n - If the query is of type 2, two numbers follow, L and R (1 ≤ L ≤ R ≤ N) that represent\nthe left and right interval boundary.\n", "outputFormat": "For each query of type 2, output the number of interesting contiguous subarrays from the\ntask.\n", "hint": "**Clarification​ ​of​ ​the​ ​first​ ​test​ ​case:**\n\nThe interval from the $2_{nd}$ to the $5_{th}$ position consists of numbers (4, 3, 9, 1). In it, the following are\ninteresting contiguous subarrays (denoted with square brackets):\n**[4]**​ 3 9 1, 4 **[3]​** ​9 1, 4 3 **[9]**​ 1, 4 **[3​ ​9]​** 1", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #2] ​​Garaža", "background": "", "description": "最近，Slavko 一直在研究自然数序列。他认为一个序列是有趣的，如果序列中所有元素的最大公约数大于 1。\n\n昨天，他在车库里找到了一个由 N 个自然数组成的序列。由于他感到非常无聊，他决定通过提出简单的查询来打发时间。每个查询可以是以下两种类型之一：\n\n1. 将序列中位置 X 的值更改为 V。\n\n2. 确定序列中区间 [L, R] 内包含的有趣连续子数组的数量。", "inputFormat": "输入的第一行包含数字 N 和 Q (1 ≤ N, Q ≤ $10^5$)，分别表示序列中的元素数量和查询的数量。\n\n接下来的行包含 N 个自然数 $A_i$ (1 ≤ $A_i$ ≤ $10^9$)，表示初始序列中的数字。\n\n接下来的 Q 行中的每一行包含一个查询，格式如下：\n\n- 行中的第一个数字可以是 1 或 2，表示查询的类型。\n- 如果查询是类型 1，后面跟着两个数字 X (1 ≤ X ≤ N) 和 V (1 ≤ V ≤ $10^9$)。\n- 如果查询是类型 2，后面跟着两个数字 L 和 R (1 ≤ L ≤ R ≤ N)，表示左边界和右边界。", "outputFormat": "对于每个类型 2 的查询，输出任务中有趣的连续子数组的数量。", "hint": "**第一个测试用例的说明：**\n\n从第 $2$ 个位置到第 $5$ 个位置的区间由数字 (4, 3, 9, 1) 组成。在其中，有以下有趣的连续子数组（用方括号表示）：**[4]** 3 9 1, 4 **[3]** 9 1, 4 3 **[9]** 1, 4 **[3 9]** 1。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4436", "type": "P", "difficulty": 6, "samples": [["5 4 5 \n1 3\n2 2 \n3 1\n4 4\n2 5\n3 5\n4 5 \n2 1\n3 1", "YES\nNO\nYES\nYES\nNO"], ["7 5 4\n2 2\n3 3 \n4 2 \n5 3 \n6 6\n2 1\n3 4\n3 7\n4 5", "YES\nYES\nNO\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "各省省选", "安徽", "湖南", "枚举", "剪枝", "强连通分量", "栈"], "title": "[HNOI/AHOI2018] 游戏", "background": "", "description": "一次小G和小H在玩寻宝游戏，有 $n$ 个房间排成一列，编号为 $1,2,\\cdots,n$ ，相邻的房间之间都有一道门。其中一部分门上锁（因此需要有对应的钥匙才能开门），其余的门都能直接打开。现在小G告诉了小H每把锁的钥匙在哪个房间里（**每把锁有且只有一把钥匙与之对应**），并作出 $p$ 次指示：第 $i$ 次让小H从第 $S_i$ 个房间出发到 $T_i$ 个房间里。但是小G有时会故意在指令中放入死路，而小H也不想浪费多余的体力去尝试，于是想事先调查清楚每次的指令是否会存在一条通路。\n\n你是否能为小H作出解答呢？", "inputFormat": "第一行三个数字： $n,m,p$ ，代表有 $n$ 个房间， $m$ 道门上了锁，以及 $p$ 个询问。接下来$m$行，每行两个数字 $x,y$ 代表 $x$ 到 $x+1$ 的钥匙在房间 $y$ 。接下来 $p$ 行，其中第$i$行是两个整数 $S_i$，$T_i$，代表一次询问", "outputFormat": "输出 $p$ 行，每行一个`YES`或`NO`，分别代表能或不能到达。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17503.png)\n\n$1\\le n,p\\le 10^6$ ， $0\\le m <n$ ， $1\\le x,y,S_i,T_i<n$ 保证 $x$ 不重复", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI/AHOI2018] Game", "background": "", "description": "Xiao G and Xiao H are playing a treasure-hunting game. There are $n$ rooms in a line, numbered $1,2,\\cdots,n$, with a door between each pair of adjacent rooms. Some doors are locked (so they require the corresponding keys to open), and the remaining doors can be opened directly. Xiao G tells Xiao H which room contains the key for each lock (each lock has exactly one corresponding key), and then gives $p$ instructions: for the $i$-th one, Xiao H is asked to go from room $S_i$ to room $T_i$. However, Xiao G may intentionally include dead ends in the instructions, and Xiao H does not want to waste extra energy trying, so he wants to determine in advance whether a path exists for each instruction.\n\nCan you answer for Xiao H?", "inputFormat": "The first line contains three integers $n, m, p$, representing that there are $n$ rooms, $m$ locked doors, and $p$ queries. The next $m$ lines each contain two integers $x, y$, meaning that the key for the lock between rooms $x$ and $x+1$ is located in room $y$. The next $p$ lines follow, where the $i$-th line contains two integers $S_i, T_i$, representing one query.", "outputFormat": "Output $p$ lines, each containing `YES` or `NO`, indicating whether it is reachable.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17503.png)\n\nConstraints\n\n$1 \\le n, p \\le 10^6$, $0 \\le m < n$, $1 \\le x, y, S_i, T_i < n$. It is guaranteed that $x$ is not repeated.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI/AHOI2018] 游戏", "background": "", "description": "一次小G和小H在玩寻宝游戏，有 $n$ 个房间排成一列，编号为 $1,2,\\cdots,n$ ，相邻的房间之间都有一道门。其中一部分门上锁（因此需要有对应的钥匙才能开门），其余的门都能直接打开。现在小G告诉了小H每把锁的钥匙在哪个房间里（**每把锁有且只有一把钥匙与之对应**），并作出 $p$ 次指示：第 $i$ 次让小H从第 $S_i$ 个房间出发到 $T_i$ 个房间里。但是小G有时会故意在指令中放入死路，而小H也不想浪费多余的体力去尝试，于是想事先调查清楚每次的指令是否会存在一条通路。\n\n你是否能为小H作出解答呢？", "inputFormat": "第一行三个数字： $n,m,p$ ，代表有 $n$ 个房间， $m$ 道门上了锁，以及 $p$ 个询问。接下来$m$行，每行两个数字 $x,y$ 代表 $x$ 到 $x+1$ 的钥匙在房间 $y$ 。接下来 $p$ 行，其中第$i$行是两个整数 $S_i$，$T_i$，代表一次询问", "outputFormat": "输出 $p$ 行，每行一个`YES`或`NO`，分别代表能或不能到达。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17503.png)\n\n$1\\le n,p\\le 10^6$ ， $0\\le m <n$ ， $1\\le x,y,S_i,T_i<n$ 保证 $x$ 不重复", "locale": "zh-CN"}}}
{"pid": "P4437", "type": "P", "difficulty": 6, "samples": [["3 \n0 1 1 \n5 7 3 ", "32"], ["3 \n2 3 1 \n1 2 3 ", "-1"], ["10 \n6 6 10 1 7 0 0 1 7 7 \n16 3 10 20 5 14 17 17 16 13 ", "809"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2018", "各省省选", "安徽", "湖南"], "title": "[HNOI/AHOI2018] 排列", "background": null, "description": "给定 $n$ 个整数 $a_1,a_2,\\dots,a_n,0\\le a_i\\le n$，以及 $n$ 个整数 $w_1,w_2,\\dots,w_n$。称 $a_1,a_2,\\dots,a_n$ 的一个排列 $a_{p_1},a_{p_2},\\dots,a_{p_n}$ 为 $a_1,a_2,\\dots,a_n$ 的一个合法排列，当且仅当该排列满足：对于任意的 $k$ 和任意的 $j$，如果 $j\\le k$，那么 $a_{p_j}$ 不等于 $p_k$。（换句话说就是：对于任意的 $k$ 和任意的 $j$，如果 $p_k$ 等于 $a_{p_j}$，那么 $k<j$。）定义这个合法排列的权值为 $w_{p_1}+2w_{p_2}+\\dots+nw_{p_n}$。\n\n你需要求出在所有合法排列中的最大权值。如果不存在合法排列，输出 $-1$。 \n\n样例解释中给出了合法排列和非法排列的实例。", "inputFormat": "第一行一个整数 $n$。 \n\n接下来一行 $n$ 个整数，表示 $a_1,a_2,\\dots,a_n$。接下来一行 $n$ 个整数，表示 $w_1,w_2,\\dots,w_n$。", "outputFormat": "输出一个整数表示答案。", "hint": "### 【样例解释 1】\n对于 $a_1=0,a_2=1,a_3=1$，其排列有：\n- $a_1=0,a_2=1,a_3=1$，是合法排列，排列的权值是 $1\\times 5+2\\times 7+3\\times 3=28$；\n- $a_2=1,a_1=0,a_3=1$，是非法排列，因为 $a_{p_2}$ 等于 $p_2$；\n- $a_1=0,a_3=1,a_2=1$，是合法排列，排列的权值是 $1\\times 5+2\\times 3+3\\times 7=32$；\n- $a_3=1,a_1=0,a_2=1$，是非法排列，因为 $a_{p_1}$ 等于 $p_2$；\n- $a_2=1,a_3=1,a_1=0$，是非法排列，因为 $a_{p_1}$ 等于 $p_3$；\n- $a_3=1,a_2=1,a_1=0$，是非法排列，因为 $a_{p_1}$ 等于 $p_3$。\n\n因此该题输出最大权值 $32$。 \n### 【样例解释 2】 \n对于 $a_1=2,a_2=3,a_3=1$，其排列有：\n- $a_1=2,a_2=3,a_3=1$，是非法排列，因为 $a_{p_1}$ 等于 $p_2$；\n- $a_2=3,a_1=2,a_3=1$，是非法排列，因为 $a_{p_1}$ 等于 $p_3$； \n- $a_1=2,a_3=1,a_2=3$，是非法排列，因为 $a_{p_1}$ 等于 $p_3$；  \n- $a_3=1,a_1=2,a_2=3$，是非法排列，因为 $a_{p_2}$ 等于 $p_3$； \n- $a_2=3,a_3=1,a_1=2$，是非法排列，因为 $a_{p_2}$ 等于 $p_3$； \n- $a_3=1,a_2=3,a_1=2$，是非法排列，因为 $a_{p_1}$ 等于 $p_3$。\n\n因此该题没有合法排列。 \n\n### 【数据范围】 \n- 对于前 $20\\%$ 的数据，$1\\le n\\le 10$。\n- 对于前 $40\\%$ 的数据，$1\\le n\\le  15$。\n- 对于前 $60\\%$ 的数据，$1\\le n\\le 1000$。  \n- 对于前 $80\\%$ 的数据，$1\\le n\\le 10^5$。  \n- 对于 $100\\%$ 的数据，$1\\le n\\le 5\\times10^5$，$0\\le a_i\\le n$，$1\\le w_i\\le10^9$，所有 $w_i$ 的和不超过 $1.5×10^{13}$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI/AHOI2018] Permutation", "background": "", "description": "Given $n$ integers $a_1, a_2, \\dots, a_n, 0 \\le a_i \\le n$, and $n$ integers $w_1, w_2, \\dots, w_n$. Call a permutation $a_{p_1}, a_{p_2}, \\dots, a_{p_n}$ of $a_1, a_2, \\dots, a_n$ a valid permutation of $a_1, a_2, \\dots, a_n$ if and only if it satisfies: for any $k$ and any $j$, if $j \\le k$, then $a_{p_j} \\ne p_k$. (In other words: for any $k$ and any $j$, if $p_k = a_{p_j}$, then $k < j$.) Define the weight of this valid permutation as $w_{p_1} + 2 w_{p_2} + \\dots + n w_{p_n}$.\n\nYou need to find the maximum weight among all valid permutations. If no valid permutation exists, output $-1$.\n\nThe sample explanations include examples of valid and invalid permutations.", "inputFormat": "The first line contains an integer $n$.\n\nThe next line contains $n$ integers, denoting $a_1, a_2, \\dots, a_n$. The following line contains $n$ integers, denoting $w_1, w_2, \\dots, w_n$.", "outputFormat": "Output a single integer representing the answer.", "hint": "### Sample Explanation 1\nFor $a_1 = 0, a_2 = 1, a_3 = 1$, its permutations are:\n- $a_1 = 0, a_2 = 1, a_3 = 1$, this is a valid permutation, and its weight is $1\\times 5 + 2\\times 7 + 3\\times 3 = 28$;\n- $a_2 = 1, a_1 = 0, a_3 = 1$, this is an invalid permutation because $a_{p_2}$ equals $p_2$;\n- $a_1 = 0, a_3 = 1, a_2 = 1$, this is a valid permutation, and its weight is $1\\times 5 + 2\\times 3 + 3\\times 7 = 32$;\n- $a_3 = 1, a_1 = 0, a_2 = 1$, this is an invalid permutation because $a_{p_1}$ equals $p_2$;\n- $a_2 = 1, a_3 = 1, a_1 = 0$, this is an invalid permutation because $a_{p_1}$ equals $p_3$;\n- $a_3 = 1, a_2 = 1, a_1 = 0$, this is an invalid permutation because $a_{p_1}$ equals $p_3$.\n\nTherefore, the maximum weight is $32$.\n\n### Sample Explanation 2\nFor $a_1 = 2, a_2 = 3, a_3 = 1$, its permutations are:\n- $a_1 = 2, a_2 = 3, a_3 = 1$, this is an invalid permutation because $a_{p_1}$ equals $p_2$;\n- $a_2 = 3, a_1 = 2, a_3 = 1$, this is an invalid permutation because $a_{p_1}$ equals $p_3$;\n- $a_1 = 2, a_3 = 1, a_2 = 3$, this is an invalid permutation because $a_{p_1}$ equals $p_3$;\n- $a_3 = 1, a_1 = 2, a_2 = 3$, this is an invalid permutation because $a_{p_2}$ equals $p_3$;\n- $a_2 = 3, a_3 = 1, a_1 = 2$, this is an invalid permutation because $a_{p_2}$ equals $p_3$;\n- $a_3 = 1, a_2 = 3, a_1 = 2$, this is an invalid permutation because $a_{p_1}$ equals $p_3$.\n\nTherefore, there is no valid permutation.\n\n### Constraints\n- For the first $20\\%$ of the testdata, $1 \\le n \\le 10$.\n- For the first $40\\%$ of the testdata, $1 \\le n \\le 15$.\n- For the first $60\\%$ of the testdata, $1 \\le n \\le 1000$.\n- For the first $80\\%$ of the testdata, $1 \\le n \\le 10^5$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 5\\times 10^5$, $0 \\le a_i \\le n$, $1 \\le w_i \\le 10^9$, and the sum of all $w_i$ does not exceed $1.5\\times 10^{13}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI/AHOI2018] 排列", "background": null, "description": "给定 $n$ 个整数 $a_1,a_2,\\dots,a_n,0\\le a_i\\le n$，以及 $n$ 个整数 $w_1,w_2,\\dots,w_n$。称 $a_1,a_2,\\dots,a_n$ 的一个排列 $a_{p_1},a_{p_2},\\dots,a_{p_n}$ 为 $a_1,a_2,\\dots,a_n$ 的一个合法排列，当且仅当该排列满足：对于任意的 $k$ 和任意的 $j$，如果 $j\\le k$，那么 $a_{p_j}$ 不等于 $p_k$。（换句话说就是：对于任意的 $k$ 和任意的 $j$，如果 $p_k$ 等于 $a_{p_j}$，那么 $k<j$。）定义这个合法排列的权值为 $w_{p_1}+2w_{p_2}+\\dots+nw_{p_n}$。\n\n你需要求出在所有合法排列中的最大权值。如果不存在合法排列，输出 $-1$。 \n\n样例解释中给出了合法排列和非法排列的实例。", "inputFormat": "第一行一个整数 $n$。 \n\n接下来一行 $n$ 个整数，表示 $a_1,a_2,\\dots,a_n$。接下来一行 $n$ 个整数，表示 $w_1,w_2,\\dots,w_n$。", "outputFormat": "输出一个整数表示答案。", "hint": "### 【样例解释 1】\n对于 $a_1=0,a_2=1,a_3=1$，其排列有：\n- $a_1=0,a_2=1,a_3=1$，是合法排列，排列的权值是 $1\\times 5+2\\times 7+3\\times 3=28$；\n- $a_2=1,a_1=0,a_3=1$，是非法排列，因为 $a_{p_2}$ 等于 $p_2$；\n- $a_1=0,a_3=1,a_2=1$，是合法排列，排列的权值是 $1\\times 5+2\\times 3+3\\times 7=32$；\n- $a_3=1,a_1=0,a_2=1$，是非法排列，因为 $a_{p_1}$ 等于 $p_2$；\n- $a_2=1,a_3=1,a_1=0$，是非法排列，因为 $a_{p_1}$ 等于 $p_3$；\n- $a_3=1,a_2=1,a_1=0$，是非法排列，因为 $a_{p_1}$ 等于 $p_3$。\n\n因此该题输出最大权值 $32$。 \n### 【样例解释 2】 \n对于 $a_1=2,a_2=3,a_3=1$，其排列有：\n- $a_1=2,a_2=3,a_3=1$，是非法排列，因为 $a_{p_1}$ 等于 $p_2$；\n- $a_2=3,a_1=2,a_3=1$，是非法排列，因为 $a_{p_1}$ 等于 $p_3$； \n- $a_1=2,a_3=1,a_2=3$，是非法排列，因为 $a_{p_1}$ 等于 $p_3$；  \n- $a_3=1,a_1=2,a_2=3$，是非法排列，因为 $a_{p_2}$ 等于 $p_3$； \n- $a_2=3,a_3=1,a_1=2$，是非法排列，因为 $a_{p_2}$ 等于 $p_3$； \n- $a_3=1,a_2=3,a_1=2$，是非法排列，因为 $a_{p_1}$ 等于 $p_3$。\n\n因此该题没有合法排列。 \n\n### 【数据范围】 \n- 对于前 $20\\%$ 的数据，$1\\le n\\le 10$。\n- 对于前 $40\\%$ 的数据，$1\\le n\\le  15$。\n- 对于前 $60\\%$ 的数据，$1\\le n\\le 1000$。  \n- 对于前 $80\\%$ 的数据，$1\\le n\\le 10^5$。  \n- 对于 $100\\%$ 的数据，$1\\le n\\le 5\\times10^5$，$0\\le a_i\\le n$，$1\\le w_i\\le10^9$，所有 $w_i$ 的和不超过 $1.5×10^{13}$。", "locale": "zh-CN"}}}
{"pid": "P4438", "type": "P", "difficulty": 4, "samples": [["6 \n2 3 \n4 5 \n-1 -2 \n-3 -4 \n-5 -6 \n1 2 3 \n1 3 2 \n2 1 3 \n2 3 1 \n3 1 2 \n3 2 1", "54"], ["9 \n2 -2 \n3 -3 \n4 -4 \n5 -5 \n6 -6 \n7 -7 \n8 -8 \n-1 -9 \n1 60 1 \n1 60 1 \n1 60 1 \n1 60 1 \n1 60 1 \n1 60 1 \n1 60 1 \n1 60 1 \n1 60 1", "548"], ["12 \n2 4 \n5 3 \n-7 10 \n11 9 \n-1 6 \n8 7 \n-6 -10 \n-9 -4\n-12 -5 \n-2 -3 \n-8 -11 \n53 26 491 \n24 58 190 \n17 37 356 \n15 51 997 \n30 19 398 \n3 45 27 \n52 55 838 \n16 18 931 \n58 24 212 \n43 25 198 \n54 15 172 \n34 5 524", "5744902\n \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2018", "各省省选", "安徽", "湖南", "深度优先搜索 DFS", "树形 DP"], "title": "[HNOI/AHOI2018] 道路", "background": null, "description": "W 国的交通呈一棵树的形状。W 国一共有 $n-1$ 个城市和 $n$ 个乡村，其中城市从 $1$ 到 $n-1$ 编号，乡村从 $1$ 到 $n$ 编号，且 $1$ 号城市是首都。道路都是单向的，本题中我们只考虑从乡村通往首都的道路网络。\n\n对于每一个城市，恰有一条公路和一条铁路通向这座城市。对于城市 $i$， 通向该城市的道路（公路或铁路）的起点，要么是一个乡村，要么是一个编号比 $i$ 大的城市。没有道路通向任何乡村。除了首都以外，从任何城市或乡村出发只有一条道路；首都没有往外的道路。从任何乡村出发，沿着唯一往外的道路走，总可以到达首都。\n\nW 国的国王小 W 获得了一笔资金，他决定用这笔资金来改善交通。由于资金有限，小 W 只能翻修 $n-1$ 条道路。小 W 决定对每个城市翻修恰好一条通向它的道路，即从公路和铁路中选择一条并进行翻修。小 W 希望从乡村通向城市可以尽可能地便利，于是根据人口调查的数据，小 W 对每个乡村制定了三个参数，编号为 $i$ 的乡村的三个参数是 $a_i$，$b_i$ 和 $c_i$。假设从编号为 $i$ 的乡村走到首都一共需要经过 $x$ 条未翻修的公路与 $y$ 条未翻修的铁路，那么该乡村的不便利值为：\n\n$$c_i \\cdot (a_i + x) \\cdot (b_i + y)$$\n\n在给定的翻修方案下，每个乡村的不便利值相加的和为该翻修方案的不便利值。 翻修 $n-1$ 条道路有很多方案，其中不便利值最小的方案称为最优翻修方案，小 W 自然希望找到最优翻修方案，请你帮助他求出这个最优翻修方案的不便利值。", "inputFormat": "第一行为正整数 $n$。 \n\n接下来 $n - 1$ 行，每行描述一个城市。其中第 $i$ 行包含两个数 $s_i,t_i$。$s_i$ 表示通向第 $i$ 座城市的公路的起点，$t_i$ 表示通向第 $i$ 座城市的铁路的起点。如果$s_i>0$，那么存在一条从第 $s_i$ 座城市通往第 $i$ 座城市的公路，否则存在一条从第 $-s_i$ 个乡村通往第 $i$ 座城市的公路；$t_i$ 类似地，如果 $t_i > 0$，那么存在一条从第 $t_i$ 座城市通往第 $i$ 座城市的铁路，否则存在一条从第 $-t_i$ 个乡村通往第 $i$ 座城市的铁路。 \n\n接下来 $n$ 行，每行描述一个乡村。其中第 $i$ 行包含三个数 $a_i,b_i,c_i$，其意义如题面所示。", "outputFormat": "输出一行一个整数，表示最优翻修方案的不便利值。", "hint": "【样例解释 1】 \n\n![](https://cdn.luogu.com.cn/upload/pic/17506.png)\n\n如图所示，我们分别用蓝色、黄色节点表示城市、乡村；用绿色、红色箭头分别表示 公路、铁路；用加粗箭头表示翻修的道路。 \n\n一种不便利值等于 $54$ 的方法是：翻修通往城市 $2$ 和城市 $5$ 的铁路，以及通往其他城市的 公路。用 $\\rightarrow$ 和 $\\Rightarrow$ 表示公路和铁路，用 $∗\\rightarrow$ 和 $∗\\Rightarrow$ 表示翻修的公路和铁路，那么： \n\n编号为 $1$ 的乡村到达首都的路线为：$-1 ∗\\rightarrow 3 \\Rightarrow 1$，经过 $0$ 条未翻修公路和 $1$ 条未翻修铁路，代价为 $3 \\times (1 + 0) \\times (2 + 1) = 9$；  \n\n编号为 $2$ 的乡村到达首都的路线为：$-2 \\Rightarrow 3 \\Rightarrow 1$，经过 $0$ 条未翻修公路和 $2$ 条未翻修铁路，代价为 $2 \\times (1 + 0) \\times (3 + 2) = 10$；  \n编号为 $3$ 的乡村到达首都的路线为：$-3 ∗\\rightarrow 4 \\rightarrow 2 ∗\\rightarrow 1$，经过 $1$ 条未翻修公路和 $0$ 条未翻修铁路，代价为 $3 \\times (2 + 1) \\times (1 + 0) = 9$；  \n\n编号为 $4$ 的乡村到达首都的路线为：$-4 \\Rightarrow 4 \\rightarrow 2 ∗\\rightarrow 1$，经过 $1$ 条未翻修公路和 $1$ 条未翻修铁路，代价为 $1 \\times (2 + 1) \\times (3 + 1) = 12$；\n\n编号为 $5$ 的乡村到达首都的路线为：$-5 \\rightarrow 5 ∗\\Rightarrow 2 ∗\\rightarrow 1$，经过 $1$ 条未翻修公路和 $0$ 条未翻修铁路，代价为 $2 \\times (3 + 1) \\times (1 + 0) = 8$；  \n\n编号为 $6$ 的乡村到达首都的路线为：$-6 ∗\\Rightarrow 5 ∗\\Rightarrow 2 ∗\\rightarrow 1$，经过 $0$ 条未翻修公路和 $0$ 条未翻修铁路，代价为 $1 \\times (3 + 0) \\times (2 + 0) = 6$；  \n\n总的不便利值为 $9 + 10 + 9 + 12 + 8 + 6 = 54$。可以证明这是本数据的最优解。 \n\n【样例解释 2】 \n\n在这个样例中，显然应该翻修所有公路。\n\n\n【数据范围】 \n一共 $20$ 组数据，编号为 $1 \\sim 20$。 \n对于编号 $\\le 4$ 的数据，$n \\le 20$；  \n对于编号为 $5 \\sim 8$ 的数据，$a_i,b_i,c_i \\le 5$，$n \\le 50$；  \n对于编号为 $9 \\sim 12$ 的数据，$n \\le 2000$；  \n对于所有的数据，$n \\le 20000$，$1 \\le a_i,b_i \\le 60$，$1 \\le c_i \\le 10^9$，$s_i,t_i$ 是 $[-n,-1] \\cup (i,n - 1]$ 内的整数，任意乡村可以通过不超过 $40$ 条道路到达首都。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI/AHOI2018] Roads", "background": "", "description": "The transportation network of Country W forms a tree. There are $n - 1$ cities and $n$ villages in total; cities are numbered $1$ to $n - 1$, villages are numbered $1$ to $n$, and city $1$ is the capital. All roads are one-way; in this problem we only consider the road network from villages towards the capital.\n\nFor each city, there is exactly one highway and one railway leading into this city. For city $i$, the starting point of a road (highway or railway) that leads to city $i$ is either a village, or a city whose index is greater than $i$. No roads lead into any village. Except for the capital, every city or village has exactly one outgoing road; the capital has no outgoing road. Starting from any village and following the unique outgoing road, you will eventually reach the capital.\n\nKing W of Country W has obtained some funds to improve transportation. Due to limited funds, he can renovate $n - 1$ roads. He will renovate exactly one incoming road for each city, i.e., for each city he chooses either its highway or its railway to renovate. To make travel from villages to the capital as convenient as possible, based on census data he sets three parameters for each village. For village $i$, the parameters are $a_i$, $b_i$, and $c_i$. Suppose that starting from village $i$ and going to the capital, you pass through $x$ unrenovated highways and $y$ unrenovated railways. Then the inconvenience value of this village is:\n$$c_i \\cdot (a_i + x) \\cdot (b_i + y)$$\n\nUnder a given renovation plan, the sum of inconvenience values over all villages is the inconvenience value of that plan. Among all ways to renovate $n - 1$ roads, the plan with the minimum total inconvenience is called the optimal renovation plan. King W wants this optimal plan. Please compute the total inconvenience of the optimal renovation plan.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe next $n - 1$ lines each describe a city. The $i$-th of these lines contains two numbers $s_i, t_i$. Here $s_i$ is the starting point of the highway that leads to city $i$, and $t_i$ is the starting point of the railway that leads to city $i$. If $s_i > 0$, then there is a highway from city $s_i$ to city $i$; otherwise there is a highway from village $-s_i$ to city $i$. Similarly, if $t_i > 0$, then there is a railway from city $t_i$ to city $i$; otherwise there is a railway from village $-t_i$ to city $i$.\n\nThe next $n$ lines each describe a village. The $i$-th of these lines contains three numbers $a_i, b_i, c_i$, as defined above.", "outputFormat": "Output one line with a single integer: the total inconvenience of the optimal renovation plan.", "hint": "Sample Explanation 1.\n\n![](https://cdn.luogu.com.cn/upload/pic/17506.png)\n\nIn the figure, blue and yellow nodes denote cities and villages, respectively; green and red arrows denote highways and railways, respectively; bold arrows denote renovated roads.\n\nOne plan with total inconvenience equal to $54$ is: renovate the railways leading to city $2$ and city $5$, and renovate the highways leading to all other cities. Using $\\rightarrow$ and $\\Rightarrow$ to denote highway and railway, and $∗\\rightarrow$ and $∗\\Rightarrow$ to denote renovated highway and renovated railway, respectively, we have:\n\nThe route for village $1$ to reach the capital is: $-1 ∗\\rightarrow 3 \\Rightarrow 1$, passing $0$ unrenovated highways and $1$ unrenovated railway, with cost $3 \\times (1 + 0) \\times (2 + 1) = 9$.\n\nThe route for village $2$ to reach the capital is: $-2 \\Rightarrow 3 \\Rightarrow 1$, passing $0$ unrenovated highways and $2$ unrenovated railways, with cost $2 \\times (1 + 0) \\times (3 + 2) = 10$.\n\nThe route for village $3$ to reach the capital is: $-3 ∗\\rightarrow 4 \\rightarrow 2 ∗\\rightarrow 1$, passing $1$ unrenovated highway and $0$ unrenovated railways, with cost $3 \\times (2 + 1) \\times (1 + 0) = 9$.\n\nThe route for village $4$ to reach the capital is: $-4 \\Rightarrow 4 \\rightarrow 2 ∗\\rightarrow 1$, passing $1$ unrenovated highway and $1$ unrenovated railway, with cost $1 \\times (2 + 1) \\times (3 + 1) = 12$.\n\nThe route for village $5$ to reach the capital is: $-5 \\rightarrow 5 ∗\\Rightarrow 2 ∗\\rightarrow 1$, passing $1$ unrenovated highway and $0$ unrenovated railways, with cost $2 \\times (3 + 1) \\times (1 + 0) = 8$.\n\nThe route for village $6$ to reach the capital is: $-6 ∗\\Rightarrow 5 ∗\\Rightarrow 2 ∗\\rightarrow 1$, passing $0$ unrenovated highways and $0$ unrenovated railways, with cost $1 \\times (3 + 0) \\times (2 + 0) = 6$.\n\nThe total inconvenience is $9 + 10 + 9 + 12 + 8 + 6 = 54$. It can be proven that this is the optimal answer for this testdata.\n\nSample Explanation 2.\n\nIn this sample, it is obvious that all highways should be renovated.\n\nConstraints\n\n- There are in total $20$ sets of testdata, numbered $1$ to $20$.\n- For sets with index $\\le 4$, $n \\le 20$.\n- For sets with index $5 \\sim 8$, $a_i, b_i, c_i \\le 5$, $n \\le 50$.\n- For sets with index $9 \\sim 12$, $n \\le 2000$.\n- For all sets, $n \\le 20000$, $1 \\le a_i, b_i \\le 60$, $1 \\le c_i \\le 10^9$, $s_i, t_i$ are integers in $[-n, -1] \\cup (i, n - 1]$, and from any village the capital is reachable via no more than $40$ roads.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI/AHOI2018] 道路", "background": null, "description": "W 国的交通呈一棵树的形状。W 国一共有 $n-1$ 个城市和 $n$ 个乡村，其中城市从 $1$ 到 $n-1$ 编号，乡村从 $1$ 到 $n$ 编号，且 $1$ 号城市是首都。道路都是单向的，本题中我们只考虑从乡村通往首都的道路网络。\n\n对于每一个城市，恰有一条公路和一条铁路通向这座城市。对于城市 $i$， 通向该城市的道路（公路或铁路）的起点，要么是一个乡村，要么是一个编号比 $i$ 大的城市。没有道路通向任何乡村。除了首都以外，从任何城市或乡村出发只有一条道路；首都没有往外的道路。从任何乡村出发，沿着唯一往外的道路走，总可以到达首都。\n\nW 国的国王小 W 获得了一笔资金，他决定用这笔资金来改善交通。由于资金有限，小 W 只能翻修 $n-1$ 条道路。小 W 决定对每个城市翻修恰好一条通向它的道路，即从公路和铁路中选择一条并进行翻修。小 W 希望从乡村通向城市可以尽可能地便利，于是根据人口调查的数据，小 W 对每个乡村制定了三个参数，编号为 $i$ 的乡村的三个参数是 $a_i$，$b_i$ 和 $c_i$。假设从编号为 $i$ 的乡村走到首都一共需要经过 $x$ 条未翻修的公路与 $y$ 条未翻修的铁路，那么该乡村的不便利值为：\n\n$$c_i \\cdot (a_i + x) \\cdot (b_i + y)$$\n\n在给定的翻修方案下，每个乡村的不便利值相加的和为该翻修方案的不便利值。 翻修 $n-1$ 条道路有很多方案，其中不便利值最小的方案称为最优翻修方案，小 W 自然希望找到最优翻修方案，请你帮助他求出这个最优翻修方案的不便利值。", "inputFormat": "第一行为正整数 $n$。 \n\n接下来 $n - 1$ 行，每行描述一个城市。其中第 $i$ 行包含两个数 $s_i,t_i$。$s_i$ 表示通向第 $i$ 座城市的公路的起点，$t_i$ 表示通向第 $i$ 座城市的铁路的起点。如果$s_i>0$，那么存在一条从第 $s_i$ 座城市通往第 $i$ 座城市的公路，否则存在一条从第 $-s_i$ 个乡村通往第 $i$ 座城市的公路；$t_i$ 类似地，如果 $t_i > 0$，那么存在一条从第 $t_i$ 座城市通往第 $i$ 座城市的铁路，否则存在一条从第 $-t_i$ 个乡村通往第 $i$ 座城市的铁路。 \n\n接下来 $n$ 行，每行描述一个乡村。其中第 $i$ 行包含三个数 $a_i,b_i,c_i$，其意义如题面所示。", "outputFormat": "输出一行一个整数，表示最优翻修方案的不便利值。", "hint": "【样例解释 1】 \n\n![](https://cdn.luogu.com.cn/upload/pic/17506.png)\n\n如图所示，我们分别用蓝色、黄色节点表示城市、乡村；用绿色、红色箭头分别表示 公路、铁路；用加粗箭头表示翻修的道路。 \n\n一种不便利值等于 $54$ 的方法是：翻修通往城市 $2$ 和城市 $5$ 的铁路，以及通往其他城市的 公路。用 $\\rightarrow$ 和 $\\Rightarrow$ 表示公路和铁路，用 $∗\\rightarrow$ 和 $∗\\Rightarrow$ 表示翻修的公路和铁路，那么： \n\n编号为 $1$ 的乡村到达首都的路线为：$-1 ∗\\rightarrow 3 \\Rightarrow 1$，经过 $0$ 条未翻修公路和 $1$ 条未翻修铁路，代价为 $3 \\times (1 + 0) \\times (2 + 1) = 9$；  \n\n编号为 $2$ 的乡村到达首都的路线为：$-2 \\Rightarrow 3 \\Rightarrow 1$，经过 $0$ 条未翻修公路和 $2$ 条未翻修铁路，代价为 $2 \\times (1 + 0) \\times (3 + 2) = 10$；  \n编号为 $3$ 的乡村到达首都的路线为：$-3 ∗\\rightarrow 4 \\rightarrow 2 ∗\\rightarrow 1$，经过 $1$ 条未翻修公路和 $0$ 条未翻修铁路，代价为 $3 \\times (2 + 1) \\times (1 + 0) = 9$；  \n\n编号为 $4$ 的乡村到达首都的路线为：$-4 \\Rightarrow 4 \\rightarrow 2 ∗\\rightarrow 1$，经过 $1$ 条未翻修公路和 $1$ 条未翻修铁路，代价为 $1 \\times (2 + 1) \\times (3 + 1) = 12$；\n\n编号为 $5$ 的乡村到达首都的路线为：$-5 \\rightarrow 5 ∗\\Rightarrow 2 ∗\\rightarrow 1$，经过 $1$ 条未翻修公路和 $0$ 条未翻修铁路，代价为 $2 \\times (3 + 1) \\times (1 + 0) = 8$；  \n\n编号为 $6$ 的乡村到达首都的路线为：$-6 ∗\\Rightarrow 5 ∗\\Rightarrow 2 ∗\\rightarrow 1$，经过 $0$ 条未翻修公路和 $0$ 条未翻修铁路，代价为 $1 \\times (3 + 0) \\times (2 + 0) = 6$；  \n\n总的不便利值为 $9 + 10 + 9 + 12 + 8 + 6 = 54$。可以证明这是本数据的最优解。 \n\n【样例解释 2】 \n\n在这个样例中，显然应该翻修所有公路。\n\n\n【数据范围】 \n一共 $20$ 组数据，编号为 $1 \\sim 20$。 \n对于编号 $\\le 4$ 的数据，$n \\le 20$；  \n对于编号为 $5 \\sim 8$ 的数据，$a_i,b_i,c_i \\le 5$，$n \\le 50$；  \n对于编号为 $9 \\sim 12$ 的数据，$n \\le 2000$；  \n对于所有的数据，$n \\le 20000$，$1 \\le a_i,b_i \\le 60$，$1 \\le c_i \\le 10^9$，$s_i,t_i$ 是 $[-n,-1] \\cup (i,n - 1]$ 内的整数，任意乡村可以通过不超过 $40$ 条道路到达首都。", "locale": "zh-CN"}}}
{"pid": "P4439", "type": "P", "difficulty": 1, "samples": [["3\nC\nZ\nP\n", "4"], ["6\nC\nC\nP\nC\nZ\nZ", "5"], ["6\nB\nB\nB\nB\nB\nB", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #3] Aron", "background": "", "description": "The holiday season is near! Aron wants to get gifts for his friends in Zagreb, so in order to get them on time, he visited a famous toy store in London. After picking out the gifts, he went to the register and discovered that there were already N people in line. Luckily, he noticed that there were groups of people standing in line, in addition to individual customers. A group of people consists of a customer and their friends waiting for them to complete the purchase.\nThe moment when the customer is done, they and their friends leave the line.\n\nThe people considered a group are standing one behind the other and are wearing shirts of matching colour. Two adjacent groups, adjacent individuals or adjacent individual and a group, will never be wearing shirts of the same colour.\n\nWrite a program that will, given the data on the people standing in line, output which person in line Aron is.\n", "inputFormat": "The first line of input contains the positive integer N (1 ≤ N ≤ 25) from the task.\nEach of the following N lines contains a single character, an uppercase letter of the English alphabet that represents the shirt colour of the $i^{th}$ person in line.\n", "outputFormat": "You must output the required number from the task.\n", "hint": "**Clarification​ ​of​ ​the​ ​second​ ​test​ ​case:**\n\nFirst in line is the group consisting of two people in red shirts. Second in line is an individual in the blue shirt, third in line is an individual in the red shirt, and fourth in line is a group in green shirts. This makes Aron fifth in line.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #3] Aron", "background": "", "description": "The holiday season is near! Aron wants to get gifts for his friends in Zagreb, so in order to get them on time, he visited a famous toy store in London. After picking out the gifts, he went to the register and discovered that there were already N people in line. Luckily, he noticed that there were groups of people standing in line, in addition to individual customers. A group of people consists of a customer and their friends waiting for them to complete the purchase.\nThe moment when the customer is done, they and their friends leave the line.\n\nThe people considered a group are standing one behind the other and are wearing shirts of matching colour. Two adjacent groups, adjacent individuals or adjacent individual and a group, will never be wearing shirts of the same colour.\n\nWrite a program that will, given the data on the people standing in line, output which person in line Aron is.\n", "inputFormat": "The first line of input contains the positive integer N (1 ≤ N ≤ 25) from the task.\nEach of the following N lines contains a single character, an uppercase letter of the English alphabet that represents the shirt colour of the $i^{th}$ person in line.\n", "outputFormat": "You must output the required number from the task.\n", "hint": "**Clarification​ ​of​ ​the​ ​second​ ​test​ ​case:**\n\nFirst in line is the group consisting of two people in red shirts. Second in line is an individual in the blue shirt, third in line is an individual in the red shirt, and fourth in line is a group in green shirts. This makes Aron fifth in line.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #3] Aron", "background": null, "description": "节日季节快到了！Aron 想为他在 Zagreb 的朋友们准备礼物，为了及时拿到礼物，他去了伦敦的一家著名玩具店。在挑选好礼物后，他来到收银台，发现已经有 N 个人在排队。幸运的是，他注意到除了单独的顾客外，还有一群人站在队伍中。一群人由一位顾客及其朋友组成，他们在等待顾客完成购买。当顾客完成购买时，他们和他们的朋友就会离开队伍。\n\n被认为是一组的人是一个接一个站着的，并且穿着颜色相同的衬衫。相邻的两组、相邻的个人或相邻的个人和一组，永远不会穿着相同颜色的衬衫。\n\n编写一个程序，给定排队人群的数据，输出 Aron 在队伍中的位置。", "inputFormat": "输入的第一行包含一个正整数 $N$（$1 \\le N \\le 25$），表示任务中的人数。接下来的 $N$ 行中的每一行包含一个大写字母，表示第 $i^{th}$ 个人的衬衫颜色。", "outputFormat": "你必须输出任务中要求的号码。", "hint": "**第二个测试用例的说明：**\n\n排在第一的是由两名穿红色衬衫的人组成的组。第二个是穿蓝色衬衫的个人，第三个是穿红色衬衫的个人，第四个是穿绿色衬衫的组。这使得 Aron 排在第五。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4440", "type": "P", "difficulty": 2, "samples": [["kileanimal\n2\n2 2 7 7\n1 4 6 7\n", "DA\nNE"], ["abababba\n2\n3 5 1 3\n1 2 7 8\n", "DA\nDA\n"], ["vodevovode\n2\n5 8 3 6\n2 5 3 6\n", "NE\nDA\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "枚举", "前缀和", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #3] Programiranje", "background": "", "description": "Little Leticija is preparing for a programming exam. Even though she has solved a lot of tasks, there’s one still left unsolved, so she is asking you for help. You are given the word S and Q queries. In each query, you are given positive integers A, B, C and D. Let’s say that word X consists of letters between positions A and B in word S, and word Y from letters between positions C and D in word S. For each query, you must answer if it is possible to somehow rearrange the letters in word Y and obtain word X.\n", "inputFormat": "The first line of input contains the word S (1 ≤ |S| ≤ 50 000). |S| denotes the number of characters in word S, which consists of lowercase letters of the English alphabet. The second line of input contains the positive integer Q (1 ≤ Q ≤ 50 000).\n\nEach of the following Q lines contains four integers A, B, C i D (1 ≤ A ≤ B ≤ |S| and 1 ≤ C ≤ D ≤ |S| ) from the task.\n", "outputFormat": "For each query, output “DA” (Croatian for yes) if it is possible, and “NE” (Croatian for no) if it is not.\n", "hint": "In test cases worth 50% of total points, it will hold: 1 ≤ |S| ≤ 1000 and 1 ≤ Q ≤ 1000.\n\n**Clarification​ ​of​ ​the​ ​third​ ​test​ ​case:**\n\nIn the first query, X=”vovo”, and Y=”devo”. In the second query, X=”odev”, and Y=”devo”.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #3] Programiranje", "background": "", "description": "Little Leticija is preparing for a programming exam. Even though she has solved a lot of tasks, there’s one still left unsolved, so she is asking you for help. You are given the word S and Q queries. In each query, you are given positive integers A, B, C and D. Let’s say that word X consists of letters between positions A and B in word S, and word Y from letters between positions C and D in word S. For each query, you must answer if it is possible to somehow rearrange the letters in word Y and obtain word X.\n", "inputFormat": "The first line of input contains the word S (1 ≤ |S| ≤ 50 000). |S| denotes the number of characters in word S, which consists of lowercase letters of the English alphabet. The second line of input contains the positive integer Q (1 ≤ Q ≤ 50 000).\n\nEach of the following Q lines contains four integers A, B, C i D (1 ≤ A ≤ B ≤ |S| and 1 ≤ C ≤ D ≤ |S| ) from the task.\n", "outputFormat": "For each query, output “DA” (Croatian for yes) if it is possible, and “NE” (Croatian for no) if it is not.\n", "hint": "In test cases worth 50% of total points, it will hold: 1 ≤ |S| ≤ 1000 and 1 ≤ Q ≤ 1000.\n\n**Clarification​ ​of​ ​the​ ​third​ ​test​ ​case:**\n\nIn the first query, X=”vovo”, and Y=”devo”. In the second query, X=”odev”, and Y=”devo”.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #3] Programiranje", "background": "", "description": "Little Leticija 正在准备编程考试。虽然她已经解决了很多任务，但还有一个任务尚未解决，于是她向你寻求帮助。\n\n有一个单词 $S$ 和 $Q$ 次询问。在每次询问中，给出正整数 $A$、$B$、$C$ 和 $D$。假设单词 $X$ 由单词 $S$ 中位置 $A$ 和 $B$ 及其之间的字母组成，而单词 $Y$ 由位置 $C$ 和 $D$ 及其之间的字母组成。您需要回答是否能以某种方式**重新排列单词 $Y$ 中的字母得到单词 $X$**。", "inputFormat": "第一行输入包含单词 $S$（$1\\le\\lvert S\\rvert\\le50000$）。$\\lvert S\\rvert$ 表示单词 $S$ 中的字符数。$S$ 完全由英文小写字母组成。\n\n第二行输入包含正整数 $Q$（$1\\le Q\\le50000$）。\n以下 $Q$ 行中的每一行包含四个整数 $A$、$B$、$C$ 和 $D$（$1\\le A\\le B\\le\\lvert S\\rvert$ 且 $1\\le C\\le D\\le\\lvert S\\rvert$）。", "outputFormat": "对于每次询问，如果可能，输出`DA`（即克罗地亚语的“是”），如果不可能，则输出`NE`（克语的“否”）。", "hint": "对于 $50\\%$ 的测试点，有 $1\\le\\lvert S\\rvert\\le1000$ 且 $1\\le Q\\le1000$。\n\n对于 $100\\%$ 的测试点，有 $1\\le\\lvert S\\rvert\\le50000$，$1\\le Q\\le50000$，$1\\le A\\le B\\le\\lvert S\\rvert$ 且 $1\\le C\\le D\\le\\lvert S\\rvert$。\n\n样例 #3 的解释：在第一次询问中，$X=\\tt vovo$，$Y=\\tt devo$。在第二次询问中，$X=\\tt odev$，$Y=\\tt devo$。", "locale": "zh-CN"}}}
{"pid": "P4441", "type": "P", "difficulty": 5, "samples": [["5 4\n..).\n.)(.\n(.)*\n*(.*\n..M.\n", "4\n(())\n"], ["6 3\n)(.\n*..\n(**\n)()\n().\nM..\n", "4\n()()\n"], ["6 3\n((.\n*..\n(**\n)()\n().\nM..\n", "2\n()"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #3] Retro", "background": "", "description": "Little Mirko got a video game console for Christmas. It wasn’t a Playstation 4 or an Xbox one, but Atari 2600, and it came with one free game. The protagonist of the game is standing on the bottom of the screen, and there are various objects dispersed on the rest of the screen, falling towards the bottom.\n\nMore precisely, the screen can be represented as a grid of RxS pixels arranged in R rows and S columns. The protagonist takes up one pixel of the lowest line and is marked with ‘M’. The rest of the pixels are marked with some of the characters: ‘.’ (empty space), ‘*’ (bomb), ‘(‘ (open bracket) or ‘)’ (closed bracket).\n\nThe protagonist can move one pixel to the left or to the right in a single move, but doesn’t need to, whereas the rest of the objects simultaneously move one pixel down (possibly out of the screen). When the protagonist finds himself at the same position as one of the brackets, we say that he picked up that bracket and added it at the end of his array of acquired brackets. The protagonist’s goal is to acquire the longest possible **valid** bracket\nexpression.\n\nA valid bracket expression is defined inductively in the following way:\n\n- “()” is a valid expression\n- If **a​** is a valid expression, then “(**a**​)” is a valid expression as well\n- If **a​** and **b​** are valid expressions, then “**ab**​” is a valid expression as well\n\nThe game ends when the protagonist finds himself at the same position as the bomb, or when all the objects fall out of the screen.\n", "inputFormat": "The first line of input contains the positive integers R ​and S ​(1 ≤ R, S ≤ 300) that represent the dimensions of the screen.\n\nEach of the following R lines contains S characters ‘M’, ‘.’, ‘*’, ‘(‘ or ‘)’ that represent the initial state of the screen.\n\nTest data will be such that there will always exist at least one valid bracket expression that is possible to acquire. ", "outputFormat": "In the first line, you must output the length of the longest valid bracket expression that Mirko can acquire.\n\nIn the second line, output that expression. If there are multiple longest valid expressions, output the **lexicographically​ ​smallest​** one.", "hint": "In test cases worth 25% of total points, it will hold 1 ≤ R ≤ 15.\n\nIn test cases worth 50% of total points, it will hold 1 ≤ R ≤ 100.\n\nIf you output the correct length, but the wrong expression, you will be awarded 40% of points for that test case. In any case, in order to score points, your output must consist of two non-empty lines. ~~(但我并不会做spj，所以这话屁用没有)~~\n\n**Clarification​ ​of​ ​the​ ​first​ ​test​ ​case**:​ ​The protagonist’s moves are: left, left, right right.\n\n**Clarification​ ​of​ ​the​ ​second​ ​test​ ​case**:​ ​The protagonist’s moves are: stay still, stay still, stay still, right, left.\n\n**Clarification​ ​of​ ​the​ ​third​ ​test​ ​case**:​ ​The protagonist’s moves are: stay still, stay still, right.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #3] Retro", "background": "", "description": "Little Mirko got a video game console for Christmas. It wasn’t a Playstation 4 or an Xbox one, but Atari 2600, and it came with one free game. The protagonist of the game is standing on the bottom of the screen, and there are various objects dispersed on the rest of the screen, falling towards the bottom.\n\nMore precisely, the screen can be represented as a grid of RxS pixels arranged in R rows and S columns. The protagonist takes up one pixel of the lowest line and is marked with ‘M’. The rest of the pixels are marked with some of the characters: ‘.’ (empty space), ‘*’ (bomb), ‘(‘ (open bracket) or ‘)’ (closed bracket).\n\nThe protagonist can move one pixel to the left or to the right in a single move, but doesn’t need to, whereas the rest of the objects simultaneously move one pixel down (possibly out of the screen). When the protagonist finds himself at the same position as one of the brackets, we say that he picked up that bracket and added it at the end of his array of acquired brackets. The protagonist’s goal is to acquire the longest possible **valid** bracket\nexpression.\n\nA valid bracket expression is defined inductively in the following way:\n\n- “()” is a valid expression\n- If **a​** is a valid expression, then “(**a**​)” is a valid expression as well\n- If **a​** and **b​** are valid expressions, then “**ab**​” is a valid expression as well\n\nThe game ends when the protagonist finds himself at the same position as the bomb, or when all the objects fall out of the screen.\n", "inputFormat": "The first line of input contains the positive integers R ​and S ​(1 ≤ R, S ≤ 300) that represent the dimensions of the screen.\n\nEach of the following R lines contains S characters ‘M’, ‘.’, ‘*’, ‘(‘ or ‘)’ that represent the initial state of the screen.\n\nTest data will be such that there will always exist at least one valid bracket expression that is possible to acquire. ", "outputFormat": "In the first line, you must output the length of the longest valid bracket expression that Mirko can acquire.\n\nIn the second line, output that expression. If there are multiple longest valid expressions, output the **lexicographically​ ​smallest​** one.", "hint": "In test cases worth 25% of total points, it will hold 1 ≤ R ≤ 15.\n\nIn test cases worth 50% of total points, it will hold 1 ≤ R ≤ 100.\n\nIf you output the correct length, but the wrong expression, you will be awarded 40% of points for that test case. In any case, in order to score points, your output must consist of two non-empty lines. ~~(但我并不会做spj，所以这话屁用没有)~~\n\n**Clarification​ ​of​ ​the​ ​first​ ​test​ ​case**:​ ​The protagonist’s moves are: left, left, right right.\n\n**Clarification​ ​of​ ​the​ ​second​ ​test​ ​case**:​ ​The protagonist’s moves are: stay still, stay still, stay still, right, left.\n\n**Clarification​ ​of​ ​the​ ​third​ ​test​ ​case**:​ ​The protagonist’s moves are: stay still, stay still, right.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #3] Retro", "background": "", "description": "小 Mirko 在圣诞节得到了一个视频游戏机。它不是 Playstation 4 或 Xbox one，而是 Atari 2600，并且附带了一个免费游戏。游戏的主角站在屏幕的底部，屏幕上其他地方有各种物体向底部掉落。\n\n更确切地说，屏幕可以表示为一个由 R 行 S 列像素组成的网格。主角占据最底行的一个像素，并用 'M' 标记。其余像素用以下字符之一标记：'.'（空格）、'*'（炸弹）、'('（左括号）或 ')'（右括号）。\n\n主角可以在一次移动中向左或向右移动一个像素，但不需要移动，而其他物体同时向下移动一个像素（可能移出屏幕）。当主角与一个括号处于同一位置时，我们说他拾取了该括号并将其添加到他已获得的括号数组的末尾。主角的目标是获得尽可能长的**有效**括号表达式。\n\n有效的括号表达式通过以下方式递归定义：\n\n- \"()\" 是一个有效的表达式。\n- 如果 **a** 是一个有效的表达式，那么 \"(**a**)\" 也是一个有效的表达式。\n- 如果 **a** 和 **b** 是有效的表达式，那么 \"**ab**\" 也是一个有效的表达式。\n\n当主角与炸弹处于同一位置时，或者当所有物体都掉出屏幕时，游戏结束。", "inputFormat": "输入的第一行包含正整数 R 和 S（1 ≤ R, S ≤ 300），表示屏幕的尺寸。\n\n接下来的 R 行中的每一行包含 S 个字符 'M'、'.'、'*'、'(' 或 ')'，表示屏幕的初始状态。\n\n测试数据将保证总是存在至少一个可以获得的有效括号表达式。", "outputFormat": "在第一行，你必须输出 Mirko 可以获得的最长有效括号表达式的长度。\n\n在第二行，输出该表达式。如果存在多个最长的有效表达式，输出**字典序最小**的那个。", "hint": "在价值 25% 总分的测试用例中，将满足 1 ≤ R ≤ 15。\n\n在价值 50% 总分的测试用例中，将满足 1 ≤ R ≤ 100。\n\n如果你输出了正确的长度，但表达式错误，你将获得该测试用例 40% 的分数。无论如何，为了得分，你的输出必须包含两行非空内容。\n\n**第一个测试用例的说明**：主角的移动是：左，左，右，右。\n\n**第二个测试用例的说明**：主角的移动是：保持不动，保持不动，保持不动，右，左。\n\n**第三个测试用例的说明**：主角的移动是：保持不动，保持不动，右。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4442", "type": "P", "difficulty": 5, "samples": [["4 4\n####\n#.F#\n#C.#\n####\n", "2"], ["6 8\n########\n#.##..F#\n#C.##..#\n#..#...#\n#.....##\n########\n", "4"], ["4 5\n#####\n#C#.#\n###F#\n#####\n", "nemoguce\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2017", "最短路", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #3] Portal", "background": "", "description": "The protagonist of this task, Chell, must solve a new puzzle GLaDOS has come up with.\n\nChell is in a room whose layout that can be represented as a matrix of dimensions N rows and M columns. Each field can be one of the following:\n\n- Obstructed field - there is a wall in it (denoted as ‘#’),\n- The field where Chell is initially (denoted as ‘C’),\n- The field where Chell must get to in order to solve the puzzle (denoted as ‘F’), or\n- An empty field (denoted as ‘.’).\n\nChell is carrying a so-called portal gun, a gun with which you can create portals in the walls.\n\nIn each move, she can do one of the following:\n- Move to an adjacent field using one move up, down, left or right (she cannot move to the field with a wall in it). This move lasts one unit of time.\n- Create a portal in the wall by turning towards a wall, not necessarily an adjacent one, in the direction up, down, left or right and shooting. The portal will be created only on the side of the wall it was hit from. In each moment, **at most two portals can be active**​. If a new portal is being created in the moment when two portals are already active, the one that was created earlier will disappear. It is not possible to create a new portal at the position of another existing portal. This move lasts a negligible\namount of time, i.e. zero amounts of time.\n- If she’s at a field that is adjacent to a wall and there’s a portal on her side of the wall, she can step into the portal and exit to a non-obstructed field with another portal. This move is possible if there are two active portals and lasts one unit of time.\n\nChell wants to know the minimal amount of time it takes for her to solve the puzzle, i.e. to reach the field denoted as ‘F’.\n\n**Please note**: The room will always have walls on the sides, and letters ‘C’ and ‘F’ will appear only once in the matrix.\n", "inputFormat": "The first line of input contains the positive integers N and M (4 ≤ N, M ≤ 500), the numbers from the task.\n\nEach of the following N lines contains M characters that describe the layout of the room.\n", "outputFormat": "You must output the minimal amount of time it takes to solve the puzzle, or “nemoguce” (without quotation marks, Croatian for impossible) if it is not possible to solve it.\n", "hint": "In test cases worth 50% of total points, it will hold 4 ≤ N, M ≤ 15.\n\n**Clarification​ ​of​ ​the​ ​second​ ​test​ ​case:**\n\nThe puzzle can be solved in 8 moves, illustrated in the pictures below.\n\nIn the first move, we turn towards the left wall, shoot and create a portal that appears on the wall in the $3^{rd}$ row and $1^{st}$ column (coordinates (3,1)) from the right side.\n\nIn the second move, we create a portal from the upper side of the wall at coordinates (6,2).\n\nIn the third move, we step into the portal at coordinates (3,1) and exit at coordinates (5,2) - a\nnon-obstructed field with the second portal.\n\nIn the fourth move, we turn right and create a portal from the left side of the wall at coordinates (5,7).\nSince there are already two portals, the one at field (3,1) disappears.\n\nIn the fifth move, we step into the portal at coordinates (6,2) and exit at coordinates (5,6) with the\nsecond portal.\n\nIn the sixth move, we create a new portal from the lower side of the wall at coordinates (1,6), making\nthe portal at coordinates (6,2) disappear.\n\nIn the seventh move, we step into the portal at coordinates (5,7) and exit at coordinates (2,6).\nFinally, in the eighth move, we move one place to the right to end the game.\n\nThe portal creation in moves 1, 2, 4 and 6 lasts zero amounts of time, whereas the rest of the move\nlast one unit of time, so the total time needed to solve the puzzle is 4 units of time.\n\n![](https://cdn.luogu.com.cn/upload/pic/17512.png)", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #3] Portal", "background": "", "description": "The protagonist of this task, Chell, must solve a new puzzle GLaDOS has come up with.\n\nChell is in a room whose layout that can be represented as a matrix of dimensions N rows and M columns. Each field can be one of the following:\n\n- Obstructed field - there is a wall in it (denoted as ‘#’),\n- The field where Chell is initially (denoted as ‘C’),\n- The field where Chell must get to in order to solve the puzzle (denoted as ‘F’), or\n- An empty field (denoted as ‘.’).\n\nChell is carrying a so-called portal gun, a gun with which you can create portals in the walls.\n\nIn each move, she can do one of the following:\n- Move to an adjacent field using one move up, down, left or right (she cannot move to the field with a wall in it). This move lasts one unit of time.\n- Create a portal in the wall by turning towards a wall, not necessarily an adjacent one, in the direction up, down, left or right and shooting. The portal will be created only on the side of the wall it was hit from. In each moment, **at most two portals can be active**​. If a new portal is being created in the moment when two portals are already active, the one that was created earlier will disappear. It is not possible to create a new portal at the position of another existing portal. This move lasts a negligible\namount of time, i.e. zero amounts of time.\n- If she’s at a field that is adjacent to a wall and there’s a portal on her side of the wall, she can step into the portal and exit to a non-obstructed field with another portal. This move is possible if there are two active portals and lasts one unit of time.\n\nChell wants to know the minimal amount of time it takes for her to solve the puzzle, i.e. to reach the field denoted as ‘F’.\n\n**Please note**: The room will always have walls on the sides, and letters ‘C’ and ‘F’ will appear only once in the matrix.\n", "inputFormat": "The first line of input contains the positive integers N and M (4 ≤ N, M ≤ 500), the numbers from the task.\n\nEach of the following N lines contains M characters that describe the layout of the room.\n", "outputFormat": "You must output the minimal amount of time it takes to solve the puzzle, or “nemoguce” (without quotation marks, Croatian for impossible) if it is not possible to solve it.\n", "hint": "In test cases worth 50% of total points, it will hold 4 ≤ N, M ≤ 15.\n\n**Clarification​ ​of​ ​the​ ​second​ ​test​ ​case:**\n\nThe puzzle can be solved in 8 moves, illustrated in the pictures below.\n\nIn the first move, we turn towards the left wall, shoot and create a portal that appears on the wall in the $3^{rd}$ row and $1^{st}$ column (coordinates (3,1)) from the right side.\n\nIn the second move, we create a portal from the upper side of the wall at coordinates (6,2).\n\nIn the third move, we step into the portal at coordinates (3,1) and exit at coordinates (5,2) - a\nnon-obstructed field with the second portal.\n\nIn the fourth move, we turn right and create a portal from the left side of the wall at coordinates (5,7).\nSince there are already two portals, the one at field (3,1) disappears.\n\nIn the fifth move, we step into the portal at coordinates (6,2) and exit at coordinates (5,6) with the\nsecond portal.\n\nIn the sixth move, we create a new portal from the lower side of the wall at coordinates (1,6), making\nthe portal at coordinates (6,2) disappear.\n\nIn the seventh move, we step into the portal at coordinates (5,7) and exit at coordinates (2,6).\nFinally, in the eighth move, we move one place to the right to end the game.\n\nThe portal creation in moves 1, 2, 4 and 6 lasts zero amounts of time, whereas the rest of the move\nlast one unit of time, so the total time needed to solve the puzzle is 4 units of time.\n\n![](https://cdn.luogu.com.cn/upload/pic/17512.png)", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #3] Portal", "background": "", "description": "本任务的主角 Chell 必须解决 GLaDOS 提出的新谜题。\n\nChell 处于一个房间中，该房间的布局可以表示为一个 N 行 M 列的矩阵。每个格子可以是以下几种之一：\n\n- 障碍格子 - 其中有一面墙（用 '#' 表示），\n- Chell 的起始位置（用 'C' 表示），\n- Chell 必须到达以解决谜题的格子（用 'F' 表示），或者\n- 空格子（用 '.' 表示）。\n\nChell 携带一个所谓的传送枪，可以用来在墙上创建传送门。\n\n在每次移动中，她可以执行以下操作之一：\n- 向相邻的格子移动，方向可以是上、下、左或右（她不能移动到有墙的格子）。此移动耗时一个单位时间。\n- 通过转向一个方向（不一定是相邻的）朝墙射击来在墙上创建一个传送门。传送门只会在被击中的墙的一侧创建。在任何时刻，**最多只能有两个传送门是激活的**。如果在已有两个激活传送门的情况下创建新的传送门，最早创建的那个将消失。不能在已有传送门的位置创建新的传送门。此操作耗时可忽略不计，即零时间。\n- 如果她在一个与墙相邻的格子并且墙的这一侧有传送门，她可以进入传送门并从另一个传送门出来到一个非障碍格子。此操作在有两个激活传送门时才可能，并且耗时一个单位时间。\n\nChell 想知道解决谜题的最少时间，即到达标记为 'F' 的格子的时间。\n\n**请注意**：房间的四周总是有墙，并且字母 'C' 和 'F' 在矩阵中只出现一次。", "inputFormat": "输入的第一行包含正整数 N 和 M (4 ≤ N, M ≤ 500)，即任务中的数字。\n\n接下来的 N 行中的每一行包含 M 个字符，描述房间的布局。", "outputFormat": "你必须输出解决谜题所需的最少时间，或者如果无法解决则输出“nemoguce”（不带引号，克罗地亚语表示不可能）。", "hint": "在总分的 50% 的测试用例中，将满足 4 ≤ N, M ≤ 15。\n\n**第二个测试用例的说明**：\n\n该谜题可以在 8 步内解决，如下图所示。\n\n在第一步中，我们转向左侧墙壁，射击并创建一个传送门，该传送门出现在第 3 行第 1 列（坐标 (3,1)）的墙的右侧。\n\n在第二步中，我们从墙的上侧在坐标 (6,2) 创建一个传送门。\n\n在第三步中，我们进入坐标 (3,1) 的传送门并在坐标 (5,2) 出口——一个有第二个传送门的非障碍格子。\n\n在第四步中，我们向右转并从墙的左侧在坐标 (5,7) 创建一个传送门。由于已经有两个传送门，位于 (3,1) 的传送门消失。\n\n在第五步中，我们进入坐标 (6,2) 的传送门并在坐标 (5,6) 出口。\n\n在第六步中，我们从墙的下侧在坐标 (1,6) 创建一个新传送门，使得坐标 (6,2) 的传送门消失。\n\n在第七步中，我们进入坐标 (5,7) 的传送门并在坐标 (2,6) 出口。最后，在第八步中，我们向右移动一格以结束游戏。\n\n第 1、2、4 和 6 步中的传送门创建耗时为零，而其余移动耗时一个单位时间，因此解决谜题总共需要 4 个单位时间。\n\n![](https://cdn.luogu.com.cn/upload/pic/17512.png)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4443", "type": "P", "difficulty": 6, "samples": [["2\n0 1 2 3\n", "9"], ["3\n3 7 0 4 6 1 5 2\n", "33"], ["4\n13 0 15 12 4 8 7 3\n11 14 6 10 1 5 9 2\n", "133"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #3] Dojave", "background": "原题每个点4s，但我改不了= =，不过标程1s不到就过了。", "description": "The biggest event of the year ended tragically for Croatian teams. The most influential theoretician of CERC of all time, the founder of the popular page CERC Tips, and in his free time an outstanding bass player, in his most recent performance failed to get his team to the finals.\n\nIn order to get over his existential troubles, our subject is spending time playing games of chance. He is especially interested in the following game:\n\nYou are given a positive integer M. Our protagonist sees in front of him a **permutation** of an array of numbers 0, 1, 2, ..., $2^M$- 1.\n\nThe computer chooses a **nonempty contiguous subsequence** of the given permutation, which it then lights up over a capital city of one of the countries in Southeastern Europe.\n\nOur confidant, after fighting off tears caused by memories of old times, **must** choose two distinct elements of the permutation and **swap their places**​. Our man of the hour wins if and only if the **bitwise XOR** of the numbers in the lit up subsequence after the substitution is **precisely**​ $2^M$- 1.\n\nOur hero wants to know **the number of contiguous subsequences** ​the computer can light up so that he can win.\n\nHelp our hero overcome his (id)entity crisis so our favourite page can be fully active again.\n", "inputFormat": "The first line of input contains the integer M (1 ≤ M ≤ 20),\n\nThe following line contains $2^M$ space-separated numbers that make up a permutation of the array 0, 1, 2, ..., $2^M$- 1.\n", "outputFormat": "You must output the total number of contiguous subsequences that a computer can light up so our hero can win.\n", "hint": "In test cases worth 50% of total points, it will hold 1 ≤ M ≤ 14.\n\n**Clarification​ ​of​ ​the​ ​test​ ​cases:**\n\nIn the first test case, if the computer chooses the subsequence [1 2 3], our hero can replace the numbers 0 and 3. In this case, he can actually win for every chosen contiguous subsequence, except the entire array.\n\nIn the second test case, if the computer chooses the entire array [3 7 0 4 6 1 5 2] as the lit up subsequence, our hero can’t change the XOR of the subsequence (which is 0), no matter which two elements are swapped.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #3] Dojave", "background": "原题每个点4s，但我改不了= =，不过标程1s不到就过了。", "description": "The biggest event of the year ended tragically for Croatian teams. The most influential theoretician of CERC of all time, the founder of the popular page CERC Tips, and in his free time an outstanding bass player, in his most recent performance failed to get his team to the finals.\n\nIn order to get over his existential troubles, our subject is spending time playing games of chance. He is especially interested in the following game:\n\nYou are given a positive integer M. Our protagonist sees in front of him a **permutation** of an array of numbers 0, 1, 2, ..., $2^M$- 1.\n\nThe computer chooses a **nonempty contiguous subsequence** of the given permutation, which it then lights up over a capital city of one of the countries in Southeastern Europe.\n\nOur confidant, after fighting off tears caused by memories of old times, **must** choose two distinct elements of the permutation and **swap their places**​. Our man of the hour wins if and only if the **bitwise XOR** of the numbers in the lit up subsequence after the substitution is **precisely**​ $2^M$- 1.\n\nOur hero wants to know **the number of contiguous subsequences** ​the computer can light up so that he can win.\n\nHelp our hero overcome his (id)entity crisis so our favourite page can be fully active again.\n", "inputFormat": "The first line of input contains the integer M (1 ≤ M ≤ 20),\n\nThe following line contains $2^M$ space-separated numbers that make up a permutation of the array 0, 1, 2, ..., $2^M$- 1.\n", "outputFormat": "You must output the total number of contiguous subsequences that a computer can light up so our hero can win.\n", "hint": "In test cases worth 50% of total points, it will hold 1 ≤ M ≤ 14.\n\n**Clarification​ ​of​ ​the​ ​test​ ​cases:**\n\nIn the first test case, if the computer chooses the subsequence [1 2 3], our hero can replace the numbers 0 and 3. In this case, he can actually win for every chosen contiguous subsequence, except the entire array.\n\nIn the second test case, if the computer chooses the entire array [3 7 0 4 6 1 5 2] as the lit up subsequence, our hero can’t change the XOR of the subsequence (which is 0), no matter which two elements are swapped.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #3] Dojave", "background": null, "description": "这一年最大的事件对于克罗地亚队来说以悲剧告终。CERC 有史以来最具影响力的理论家、热门页面 CERC Tips 的创始人，同时也是一位杰出的贝斯手，在他最近的一次表演中未能将他的团队带入决赛。\n\n为了克服他的存在主义困扰，我们的主角正在通过玩几率游戏来消磨时间。他对以下游戏特别感兴趣：\n\n给定一个正整数 $M$。我们的主角面前有一个数组 $0, 1, 2, \\dots, 2^M-1$ 的**排列**。\n\n计算机选择给定排列中的一个**非空连续子序列**，然后将其点亮在东南欧某国的首都上空。\n\n我们的知己，在摆脱旧时记忆带来的泪水后，**必须**选择排列中的两个不同元素并**交换它们的位置**。只有当替换后的点亮子序列的**按位异或**结果**恰好**为 $2^M-1$ 时，我们的主角才会获胜。\n\n我们的英雄想知道计算机可以点亮的**连续子序列的数量**，以便他能够获胜。\n\n帮助我们的英雄克服他的身份危机，以便我们喜爱的页面能够再次全面活跃。", "inputFormat": "输入的第一行包含整数 $M$。\n\n接下来的行包含 $2^M$ 个以空格分隔的数字，这些数字构成了数组 $0, 1, 2, \\dots, 2^M-1$ 的一个排列。", "outputFormat": "你必须输出计算机可以点亮以使我们的英雄获胜的连续子序列的总数。", "hint": "对于 $50\\%$ 的数据，$1 \\leq M \\leq 14$。\n\n对于 $100\\%$ 的数据，$1 \\leq M \\leq 20$。\n\n**测试用例的说明：**\n\n在第一个测试用例中，如果计算机选择子序列 $[1\\ 2\\ 3]$，我们的英雄可以替换数字 $0$ 和 $3$。在这种情况下，他实际上可以在每个选择的连续子序列中获胜，除了整个数组。\n\n在第二个测试用例中，如果计算机选择整个数组 $[3\\ 7\\ 0\\ 4\\ 6\\ 1\\ 5\\ 2]$ 作为点亮的子序列，我们的英雄无论如何交换两个元素都无法改变子序列的异或结果（结果为 $0$）。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4444", "type": "P", "difficulty": 6, "samples": [["3 1\n2\n", "1"], ["6 2\n2 3\n", "2"], ["123456789 3\n5 6 9\n", "10973937\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #3] Sažetak", "background": "", "description": "An unknown array x consists of N integers. The K-summary of that array is obtained by dividing the array into segments of length K and summing up the elements in each segment.\nIf N is not divisible by K, the last segment of the division will have less than K elements.\n\nIn other words, the K-summary is an array where the elements are, respectively: (x[1] + … + x[K]), (x[K+1] + … + x[2K]), and so on, where the last sum that contains x[N] can have less than K summands. For example, the 5-summary of an array of 13 elements has three elements (sum of elements 1.-5., sum of elements 6.-10., sum of elements 11.-13.).\n\nIt is clear that we cannot reconstruct the elements of the original array from the K-summary, but that might be possible if we knew several K-summaries for different Ks. Write a program that will, given length N and set $K_1$, $K_2$\n, …, $K_M$ , predict how many elements of the original array we would be able to uniquely determine if we knew all the $K_i$ -summaries of the array.\n(It is not difficult to show that the number of reconstructed elements is independent of the content of the summaries.)\n", "inputFormat": "The first line contains the integers N and M (3 <= N <= $10^9$\n, 1 <= M <= 10), the array length and the number of K-summaries.\n\nThe second line contains distinct integers$K_1$, $K_2$ , …, $K_M$\n(2 <= $K_i$ < N) from the task.", "outputFormat": "You must output the required number of reconstructed elements", "hint": "In test cases worth 40% of total points, it will hold N <= 5 000 000.\n\n**Clarification​ ​of​ ​the​ ​first​ ​example**:​ ​We can determine one element: x[3].\n\n**Clarification​ ​of​ ​the​ ​second​ ​example**:​ ​We can determine x[3] and x[4].", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #3] Sažetak", "background": "", "description": "An unknown array x consists of N integers. The K-summary of that array is obtained by dividing the array into segments of length K and summing up the elements in each segment.\nIf N is not divisible by K, the last segment of the division will have less than K elements.\n\nIn other words, the K-summary is an array where the elements are, respectively: (x[1] + … + x[K]), (x[K+1] + … + x[2K]), and so on, where the last sum that contains x[N] can have less than K summands. For example, the 5-summary of an array of 13 elements has three elements (sum of elements 1.-5., sum of elements 6.-10., sum of elements 11.-13.).\n\nIt is clear that we cannot reconstruct the elements of the original array from the K-summary, but that might be possible if we knew several K-summaries for different Ks. Write a program that will, given length N and set $K_1$, $K_2$\n, …, $K_M$ , predict how many elements of the original array we would be able to uniquely determine if we knew all the $K_i$ -summaries of the array.\n(It is not difficult to show that the number of reconstructed elements is independent of the content of the summaries.)\n", "inputFormat": "The first line contains the integers N and M (3 <= N <= $10^9$\n, 1 <= M <= 10), the array length and the number of K-summaries.\n\nThe second line contains distinct integers$K_1$, $K_2$ , …, $K_M$\n(2 <= $K_i$ < N) from the task.", "outputFormat": "You must output the required number of reconstructed elements", "hint": "In test cases worth 40% of total points, it will hold N <= 5 000 000.\n\n**Clarification​ ​of​ ​the​ ​first​ ​example**:​ ​We can determine one element: x[3].\n\n**Clarification​ ​of​ ​the​ ​second​ ​example**:​ ​We can determine x[3] and x[4].", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #3] Sažetak", "background": "", "description": "有一个长度为 $N$ 的未知数组 $x$。这个数组的 $K$-总和定义为将该数组分割为若干长度为 $K$ 的区间，并对每个区间中的元素分别求和的结果。如果 $N$ 不能被 $K$ 整除，则最后一个区间的元素数将少于 $K$。\n\n换言之，$K$-总和指的是一个数组，其中的元素分别为：$(x_1+\\dots+x_K)$，$(x_{K+1}+\\dots+x_{2K})$，以此类推；其中包含了 $x_N$ 的元素，即最后一个元素，可以由少于 $K$ 个部分组成。例如，一个含有十三个元素的数组的 $5$-总和有三个元素（第一到第五项之和，第六到第十项之和，第十一到第十三项之和）\n\n可以发现我们无法通过一个 $K$-总和来重现原数组，但当我们知道几个 $K$ 值不同的 $K$-总和时就有可能做到这一点。给定 $N$ 和 $K_1,K_2,\\dots,K_M$，请您编写一条程序，计算在已知一个长为 $N$ 的数组的 $K_i$-总和的前提下，有多少原数组的元素可以被唯一确定（不难发现唯一确定的元素数与 $K_i$-总和的内容无关）。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$，$N$ 为原数组大小，$M$ 为已知 $K$-总和的数量。\n\n第二行包含 $M$ 个整数，分别为 $K_1,K_2,\\dots,K_M$，如题所述。", "outputFormat": "您需要输出唯一确定的元素数。", "hint": "对于 $40\\%$ 的数据，$N\\le5\\times10^6$。\n\n对于 $100\\%$ 的数据，$3\\le N\\le10^9$，$1\\le M\\le10$，$2\\le K_i<N$。\n\n### 样例解释\n\n对于第一个样例：我们可以确定 $x_3$。\n\n对于第二个样例：我们可以确定 $x_3$ 和 $x_4$。\n\n翻译来自于 @阿丑", "locale": "zh-CN"}}}
{"pid": "P4445", "type": "P", "difficulty": 1, "samples": [["3\n3 1 2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "安徽"], "title": "[AHOI2018初中组] 报名签到", "background": "", "description": "$n$ 位同学（编号从 $1$ 到 $n$）同时来到体育馆报名签到，领取准考证和参赛资料。为了有序报名，这 $n$ 位同学需要按编号次序（编号为 $1$ 的同学站在最前面）从前往后排成一条直线。然而每一位同学都不喜欢拥挤，对于第 $i$ 位同学，如果有另外一位同学距离他/她的距离小于 $a_i$，那么就会发生冲突。小可可想知道如果要不发生任何冲突的情况下，这 $n$ 位同学排队的队列最短长度是多少。", "inputFormat": "第一行一个整数 $n$ ，表示报名签到的同学人数。\n\n第二行有 $n$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 个同学必须与其他同学保持的距离。", "outputFormat": "输出一行，包括一个整数，表示这 $n$ 位同学排队队列的最小长度。\n\n注意： $n$ 位同学要按 $1$ 到 $n$ 的次序从前往后排队。", "hint": "对于 $20\\%$ 的数据满足：$1\\le n\\le 20$。\n\n对于 $70\\%$ 的数据满足：$1\\le n\\le 10^4$。\n\n对于 $100\\%$ 的数据满足：$1\\le n\\le 10^5$，$1\\le a_i\\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2018 Middle School Division] Registration Check-in", "background": "", "description": "$n$ students (numbered from $1$ to $n$) arrive at the gym at the same time to register and check in, and to receive their admission tickets and contest materials. To keep the registration orderly, these $n$ students must line up in a straight line from front to back in increasing order of their numbers (the student with number $1$ stands at the very front). However, each student dislikes crowding: for the $i$-th student, if there is another student whose distance to him/her is less than $a_i$, a conflict occurs. Xiao Keke wants to know, under the condition that no conflicts occur, what is the minimum possible length of the queue formed by these $n$ students.", "inputFormat": "The first line contains an integer $n$, the number of students.\n\nThe second line contains $n$ integers. The $i$-th integer $a_i$ denotes the distance that the $i$-th student must keep from other students.", "outputFormat": "Output one line with a single integer, the minimum possible length of the queue formed by these $n$ students.\n\nNote: The $n$ students must line up from front to back in the order $1$ to $n$.", "hint": "For $20\\%$ of the testdata: $1\\le n\\le 20$.\n\nFor $70\\%$ of the testdata: $1\\le n\\le 10^4$.\n\nFor $100\\%$ of the testdata: $1\\le n\\le 10^5$，$1\\le a_i\\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2018初中组] 报名签到", "background": "", "description": "$n$ 位同学（编号从 $1$ 到 $n$）同时来到体育馆报名签到，领取准考证和参赛资料。为了有序报名，这 $n$ 位同学需要按编号次序（编号为 $1$ 的同学站在最前面）从前往后排成一条直线。然而每一位同学都不喜欢拥挤，对于第 $i$ 位同学，如果有另外一位同学距离他/她的距离小于 $a_i$，那么就会发生冲突。小可可想知道如果要不发生任何冲突的情况下，这 $n$ 位同学排队的队列最短长度是多少。", "inputFormat": "第一行一个整数 $n$ ，表示报名签到的同学人数。\n\n第二行有 $n$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 个同学必须与其他同学保持的距离。", "outputFormat": "输出一行，包括一个整数，表示这 $n$ 位同学排队队列的最小长度。\n\n注意： $n$ 位同学要按 $1$ 到 $n$ 的次序从前往后排队。", "hint": "对于 $20\\%$ 的数据满足：$1\\le n\\le 20$。\n\n对于 $70\\%$ 的数据满足：$1\\le n\\le 10^4$。\n\n对于 $100\\%$ 的数据满足：$1\\le n\\le 10^5$，$1\\le a_i\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4446", "type": "P", "difficulty": 4, "samples": [["3\n125 81 52", "5\n3\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2018", "安徽", "枚举", "素数判断,质数,筛法"], "title": "[AHOI2018初中组] 根式化简", "background": null, "description": "小可可在学习“立方根”的知识时碰到这样的问题：\n\n将下面根式化简为最简根式：\n\n(1) $\\sqrt[3]{125}$ (2) $\\sqrt[3]{81}$ (3) $\\sqrt[3]{52}$\n\n这个问题对于小可可来说太简单了，他很快就算出了答案：\n\n(1) $5$ (2) $3\\sqrt[3]{3}$ (3) $\\sqrt[3]{52}$\n\n小可可知道任意形如 $\\sqrt[3]{x}$ 的根式，化简后一定可以被写成形如 $a\\sqrt[3]{b}$ 的最简根式。他觉得这很有趣，就仿照出了不少题，但没一会儿就被密密麻麻的根式绕晕了，于是他向你求助：\n\n给定 $n$ 个形如 $\\sqrt[3]{x}$ 的根式，请你将它们化简为形如 $a\\sqrt[3]{b}$ 的最简形式，为了方便，你只需要输出其中的 $a$ 即可。\n\n如果你没有学过这部分数学知识，你可以认为题意是：给你 $n$ 个正整数 $x$，对于每一个 $x$，你需要求出整数 $a,b$ 使得 $a^3 \\times b = x$，输出最大的整数 $a$ 即可。", "inputFormat": "输入有两行：\n\n第一行一个整数 $n$，表示有 $n$ 个形如 $\\sqrt[3]{x}$ 的根式；  \n第二行 $n$ 个正整数，依次给出每个$x$。", "outputFormat": "输出 $n$ 行，每行一个正整数，第 $i$ 行正整数表示你对输入中第 $i$ 个 $x$ 给出的答案。", "hint": "对于 $100\\%$ 的数据满足：$1 \\le n \\le 10000$，$1 \\le x \\le 10^{18}$。\n\n本题共 10 个测试点，编号为1 \\~ 10，每个测试点额外保证如下：\n \n1 \\~ 2： $n \\le 10, x \\le 10^6$   \n3 \\~ 4： $n \\le 10, x \\le 10^9$  \n5 \\~ 6： $n \\le 100, x \\le 10^{18}$ 且 $x$ 为完全立方数  \n7 \\~ 8： $n \\le 500, x \\le 10^{18}$  \n9 \\~ 10： $n \\le 10000, x \\le 10^{18}$", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2018 Middle School] Radical Simplification", "background": "", "description": "While learning about cube roots, Keke encountered the following problem:\n\nSimplify the following radicals to their simplest forms:\n\n(1) $\\sqrt[3]{125}$ (2) $\\sqrt[3]{81}$ (3) $\\sqrt[3]{52}$\n\nThis was too easy for Keke, and he quickly got the answers:\n\n(1) $5$ (2) $3\\sqrt[3]{3}$ (3) $\\sqrt[3]{52}$\n\nKeke knows that any radical of the form $\\sqrt[3]{x}$ can be simplified to the simplest form $a\\sqrt[3]{b}$. He found this interesting and created many similar problems, but soon got overwhelmed, so he asked you for help:\n\nGiven $n$ radicals of the form $\\sqrt[3]{x}$, simplify each to the simplest form $a\\sqrt[3]{b}$. For convenience, you only need to output $a$.\n\nIf you have not learned this topic, you can think of it as: given $n$ positive integers $x$, for each $x$, find integers $a, b$ such that $a^3 \\times b = x$, and output the largest integer $a$.", "inputFormat": "The input has two lines:\n\n- The first line contains an integer $n$, the number of radicals of the form $\\sqrt[3]{x}$.\n- The second line contains $n$ positive integers, giving each $x$ in order.", "outputFormat": "Output $n$ lines, each with a positive integer. The $i$-th line contains the answer for the $i$-th $x$ in the input.", "hint": "For $100\\%$ of the testdata: $1 \\le n \\le 10000$, $1 \\le x \\le 10^{18}$.\n\nThere are 10 test points, numbered $1 \\sim 10$, with the following additional guarantees:\n\n1 ~ 2: $n \\le 10$, $x \\le 10^6$.  \n3 ~ 4: $n \\le 10$, $x \\le 10^9$.  \n5 ~ 6: $n \\le 100$, $x \\le 10^{18}$ and $x$ is a perfect cube.  \n7 ~ 8: $n \\le 500$, $x \\le 10^{18}$.  \n9 ~ 10: $n \\le 10000$, $x \\le 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2018初中组] 根式化简", "background": null, "description": "小可可在学习“立方根”的知识时碰到这样的问题：\n\n将下面根式化简为最简根式：\n\n(1) $\\sqrt[3]{125}$ (2) $\\sqrt[3]{81}$ (3) $\\sqrt[3]{52}$\n\n这个问题对于小可可来说太简单了，他很快就算出了答案：\n\n(1) $5$ (2) $3\\sqrt[3]{3}$ (3) $\\sqrt[3]{52}$\n\n小可可知道任意形如 $\\sqrt[3]{x}$ 的根式，化简后一定可以被写成形如 $a\\sqrt[3]{b}$ 的最简根式。他觉得这很有趣，就仿照出了不少题，但没一会儿就被密密麻麻的根式绕晕了，于是他向你求助：\n\n给定 $n$ 个形如 $\\sqrt[3]{x}$ 的根式，请你将它们化简为形如 $a\\sqrt[3]{b}$ 的最简形式，为了方便，你只需要输出其中的 $a$ 即可。\n\n如果你没有学过这部分数学知识，你可以认为题意是：给你 $n$ 个正整数 $x$，对于每一个 $x$，你需要求出整数 $a,b$ 使得 $a^3 \\times b = x$，输出最大的整数 $a$ 即可。", "inputFormat": "输入有两行：\n\n第一行一个整数 $n$，表示有 $n$ 个形如 $\\sqrt[3]{x}$ 的根式；  \n第二行 $n$ 个正整数，依次给出每个$x$。", "outputFormat": "输出 $n$ 行，每行一个正整数，第 $i$ 行正整数表示你对输入中第 $i$ 个 $x$ 给出的答案。", "hint": "对于 $100\\%$ 的数据满足：$1 \\le n \\le 10000$，$1 \\le x \\le 10^{18}$。\n\n本题共 10 个测试点，编号为1 \\~ 10，每个测试点额外保证如下：\n \n1 \\~ 2： $n \\le 10, x \\le 10^6$   \n3 \\~ 4： $n \\le 10, x \\le 10^9$  \n5 \\~ 6： $n \\le 100, x \\le 10^{18}$ 且 $x$ 为完全立方数  \n7 \\~ 8： $n \\le 500, x \\le 10^{18}$  \n9 \\~ 10： $n \\le 10000, x \\le 10^{18}$", "locale": "zh-CN"}}}
{"pid": "P4447", "type": "P", "difficulty": 4, "samples": [["7\n4 5 2 3 -4 -3 -5", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2018", "二分", "安徽", "队列"], "title": "[AHOI2018初中组] 分组", "background": null, "description": "小可可的学校信息组总共有 $n$ 个队员，每个人都有一个实力值 $a_i$。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的 $n$ 个队员分成若干个小组去参加这场比赛。\n\n但是每个队员都不会愿意与实力跟自己过于悬殊的队员组队，于是要求分成的每个小组的队员实力值连续，同时，一个队不需要两个实力相同的选手。举个例子：$[1, 2, 3, 4, 5]$ 是合法的分组方案，因为实力值连续；$[1, 2, 3, 5]$ 不是合法的分组方案，因为实力值不连续；$[0, 1, 1, 2]$ 同样不是合法的分组方案，因为出现了两个实力值为 $1$ 的选手。\n\n如果有小组内人数太少，就会因为时间不够而无法获得高分，于是小可可想让你给出一个合法的分组方案，满足所有人都恰好分到一个小组，使得人数最少的组人数最多，输出人数最少的组人数的最大值。\n\n注意：实力值可能是负数，分组的数量没有限制。", "inputFormat": "输入有两行：\n\n第一行一个正整数 $n$，表示队员数量。  \n\n第二行有 $n$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 个队员的实力。", "outputFormat": "输出一行，包括一个正整数，表示人数最少的组的人数最大值。", "hint": "### 样例解释\n\n分为 $2$ 组，一组的队员实力值是 $[4, 5, 2, 3]$，一组是 $[-4, -3, -5]$，其中最小的组人数为 $3$，可以发现没有比 $3$ 更优的分法了。\n\n### 数据范围\n\n对于 $100\\%$ 的数据满足：$1\\leq n\\leq 10^5$，$|a_i|\\leq10^9$。\n\n本题共 $10$ 个测试点，编号为 $1\\sim10$，每个测试点额外保证如下：\n| 测试点编号 | 数据限制 |\n| :-----------: | :-----------: |\n| $1\\sim2$ | $n\\leq 6, 1\\leq a_i \\leq 100$ |\n| $3\\sim4$ | $n\\leq 1000, 1\\leq a_i\\leq 10^5$ 且 $a_i$ 互不相同 |\n| $5\\sim6$ | $n\\leq 10^5$，$a_i$ 互不相同 |\n| $7\\sim8$ | $n\\leq 10^5, 1\\leq a_i \\leq10^5$ |\n| $9\\sim 10$ | $n\\leq 10^5, -10^9 \\leq a_i \\leq 10^9$ |", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2018 Junior High Division] Grouping", "background": "", "description": "There are $n$ members in Coco's school's informatics team, and each person has a strength value $a_i$. The annual programming contest is coming, and the school has obtained several participation slots. The coach decides to divide the $n$ team members into several groups to participate in the contest.\n\nHowever, no one wants to team up with someone whose strength differs too much from their own, so each group must consist of members whose strength values form a consecutive sequence. Also, no two players in the same group may have the same strength value. For example: $[1, 2, 3, 4, 5]$ is a valid grouping because the strengths are consecutive; $[1, 2, 3, 5]$ is not valid because the strengths are not consecutive; $[0, 1, 1, 2]$ is also not valid because two players have the same strength value $1$.\n\nIf a group is too small, it will not have enough time to score well. Therefore, Coco wants you to give a valid grouping that assigns everyone to exactly one group and maximizes the size of the smallest group. Output the maximum possible size of the smallest group.\n\nNote: Strength values can be negative, and there is no limit on the number of groups.", "inputFormat": "Two lines:\n\nThe first line contains a positive integer $n$, the number of team members.\n\nThe second line contains $n$ integers. The $i$-th integer $a_i$ denotes the strength of the $i$-th player.", "outputFormat": "Output one line containing a single positive integer: the maximum possible size of the smallest group.", "hint": "### Sample Explanation\n\nDivide into $2$ groups: one group has strengths $[4, 5, 2, 3]$, and the other has $[-4, -3, -5]$. The smallest group size is $3$, and there is no better grouping than $3$.\n\n### Constraints\n\nFor $100\\%$ of the testdata: $1 \\leq n \\leq 10^5$, $|a_i| \\leq 10^9$.\n\nThis problem has $10$ test points, numbered $1 \\sim 10$, each with additional guarantees as follows:\n| Test point ID | Constraints |\n| :-----------: | :-----------: |\n| $1 \\sim 2$ | $n \\leq 6$, $1 \\leq a_i \\leq 100$ |\n| $3 \\sim 4$ | $n \\leq 1000$, $1 \\leq a_i \\leq 10^5$ and $a_i$ are all distinct |\n| $5 \\sim 6$ | $n \\leq 10^5$, $a_i$ are all distinct |\n| $7 \\sim 8$ | $n \\leq 10^5$, $1 \\leq a_i \\leq 10^5$ |\n| $9 \\sim 10$ | $n \\leq 10^5$, $-10^9 \\leq a_i \\leq 10^9$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2018初中组] 分组", "background": null, "description": "小可可的学校信息组总共有 $n$ 个队员，每个人都有一个实力值 $a_i$。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的 $n$ 个队员分成若干个小组去参加这场比赛。\n\n但是每个队员都不会愿意与实力跟自己过于悬殊的队员组队，于是要求分成的每个小组的队员实力值连续，同时，一个队不需要两个实力相同的选手。举个例子：$[1, 2, 3, 4, 5]$ 是合法的分组方案，因为实力值连续；$[1, 2, 3, 5]$ 不是合法的分组方案，因为实力值不连续；$[0, 1, 1, 2]$ 同样不是合法的分组方案，因为出现了两个实力值为 $1$ 的选手。\n\n如果有小组内人数太少，就会因为时间不够而无法获得高分，于是小可可想让你给出一个合法的分组方案，满足所有人都恰好分到一个小组，使得人数最少的组人数最多，输出人数最少的组人数的最大值。\n\n注意：实力值可能是负数，分组的数量没有限制。", "inputFormat": "输入有两行：\n\n第一行一个正整数 $n$，表示队员数量。  \n\n第二行有 $n$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 个队员的实力。", "outputFormat": "输出一行，包括一个正整数，表示人数最少的组的人数最大值。", "hint": "### 样例解释\n\n分为 $2$ 组，一组的队员实力值是 $[4, 5, 2, 3]$，一组是 $[-4, -3, -5]$，其中最小的组人数为 $3$，可以发现没有比 $3$ 更优的分法了。\n\n### 数据范围\n\n对于 $100\\%$ 的数据满足：$1\\leq n\\leq 10^5$，$|a_i|\\leq10^9$。\n\n本题共 $10$ 个测试点，编号为 $1\\sim10$，每个测试点额外保证如下：\n| 测试点编号 | 数据限制 |\n| :-----------: | :-----------: |\n| $1\\sim2$ | $n\\leq 6, 1\\leq a_i \\leq 100$ |\n| $3\\sim4$ | $n\\leq 1000, 1\\leq a_i\\leq 10^5$ 且 $a_i$ 互不相同 |\n| $5\\sim6$ | $n\\leq 10^5$，$a_i$ 互不相同 |\n| $7\\sim8$ | $n\\leq 10^5, 1\\leq a_i \\leq10^5$ |\n| $9\\sim 10$ | $n\\leq 10^5, -10^9 \\leq a_i \\leq 10^9$ |", "locale": "zh-CN"}}}
{"pid": "P4448", "type": "P", "difficulty": 6, "samples": [["4\n2 2 3 4", "12\n"], ["9\n2 4 8 9 12 4 3 6 11", "99360"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2018", "安徽", "容斥原理"], "title": "[AHOI2018初中组] 球球的排列", "background": "", "description": "小可可是一个有着特殊爱好的人。他特别喜欢收集各种各样的球球，至今已经收集了$n$ 个球球。\n\n小可可又是一个有着特殊想法的人。他将他的所有球球从 1 到$n$ 编号，并每天都把球球排成一个全新的排列。\n\n小可可又是一个有着特殊情怀的人。他将每个球球的特点用$a[i]$来表示（注意这里不同的球$a[i]$可能相同）。\n\n小可可又是一个爱恨分明的人。他十分讨厌平方数，所以他规定：一个排列$p$，对于所有的$1 ≤ i < n$，$a[p_i]\\times a[p_{i+1}]$ 不是一个平方数，这样的排列$p$ 才是合法的。\n\n小可可一直坚持每天排一个全新的合法的排列。有一天，他心血来潮，想知道所有合法排列的个数。小可可十分强，他当然知道怎么算。不过，他想用这个题来考考身在考场的你。这个数可能太大了，所以你只需要告诉小可可合法排列个数对$10^9+7$ 取模的结果就可以了。\n\n你能正确回答小可可的问题吗？如果能的话，他说不定会送个球球给你呢……", "inputFormat": "输入有两行：\n\n第一行一个正整数$n$，表示小可可拥有的球球个数。  \n第二行有$n$ 个整数，第$i$ 个整数$a[i]$表示编号为$i$ 的球球的特点。", "outputFormat": "输出一行，包括一个正整数，表示合法排列个数对$10^9+7$（即1000000007）取模的结果。", "hint": "【样例1 解释】\n12 种合法的排列分别为：\n```\n1,3,2,4\n2,3,1,4\n3,1,4,2\n3,2,4,1\n1,3,4,2\n2,3,4,1\n1,4,2,3\n2,4,1,3\n4,1,3,2\n4,2,3,1\n1,4,3,2\n2,4,3,1\n```\n\n【数据范围】\n\n对于100%的数据满足：$1≤n≤300$，$1≤a[i]≤10^9$。\n\n本题共10 个测试点，编号为1~10，每个测试点额外保证如下：\n\n测试点编号| n的范围|a[i]的范围\n-|-|-\n1~2|$n≤10$|$a[i]≤10^9$\n3~5|$n≤300$|$1≤a[i]≤2$\n6~8|-|$a[i]≤10^9$且都是质数\n9~10|-|$a[i]≤10^9$", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2018 Junior] Arrangement of Balls", "background": "", "description": "Xiao Keke is a person with special hobbies. He especially likes collecting all kinds of balls, and has collected $n$ balls so far.\n\nXiao Keke also has special ideas. He numbers all his balls from 1 to $n$, and arranges the balls into a brand-new permutation every day.\n\nXiao Keke also has special feelings. He represents the attribute of each ball by $a[i]$ (note that $a[i]$ can be the same for different balls).\n\nXiao Keke is a person of clear likes and dislikes. He hates perfect squares, so he stipulates: for a permutation $p$, for all $1 \\le i < n$, $a[p_i] \\times a[p_{i+1}]$ is not a perfect square; only such a permutation $p$ is valid.\n\nHe keeps arranging a brand-new valid permutation every day. One day, on a whim, he wants to know the number of all valid permutations. Xiao Keke is very strong and certainly knows how to compute it. However, he wants to test you with this problem. This number can be very large, so you only need to tell him the number of valid permutations modulo $10^9+7$.\n\nCan you answer Xiao Keke’s question correctly? If you can, he might even give you a ball.", "inputFormat": "The input has two lines:\n- The first line contains a positive integer $n$, the number of balls that Xiao Keke has.\n- The second line contains $n$ integers; the $i$-th integer $a[i]$ denotes the attribute of the ball with index $i$.", "outputFormat": "Output one line containing a single positive integer, the number of valid permutations modulo $10^9+7$ (i.e., 1000000007).", "hint": "[Sample 1 Explanation]  \nThere are 12 valid permutations:\n```\n1,3,2,4\n2,3,1,4\n3,1,4,2\n3,2,4,1\n1,3,4,2\n2,3,4,1\n1,4,2,3\n2,4,1,3\n4,1,3,2\n4,2,3,1\n1,4,3,2\n2,4,3,1\n```\n\nConstraints\n\nFor 100% of the testdata: $1 \\le n \\le 300$, $1 \\le a[i] \\le 10^9$.\n\nThis problem has 10 test points, numbered 1-10; each test point additionally guarantees the following:\n\nTest point id | Range of n | Range of $a[i]$\n-|-|-\n1-2 | $n \\le 10$ | $a[i] \\le 10^9$\n3-5 | $n \\le 300$ | $1 \\le a[i] \\le 2$\n6-8 | - | $a[i] \\le 10^9$ and all are primes\n9-10 | - | $a[i] \\le 10^9$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2018初中组] 球球的排列", "background": "", "description": "小可可是一个有着特殊爱好的人。他特别喜欢收集各种各样的球球，至今已经收集了$n$ 个球球。\n\n小可可又是一个有着特殊想法的人。他将他的所有球球从 1 到$n$ 编号，并每天都把球球排成一个全新的排列。\n\n小可可又是一个有着特殊情怀的人。他将每个球球的特点用$a[i]$来表示（注意这里不同的球$a[i]$可能相同）。\n\n小可可又是一个爱恨分明的人。他十分讨厌平方数，所以他规定：一个排列$p$，对于所有的$1 ≤ i < n$，$a[p_i]\\times a[p_{i+1}]$ 不是一个平方数，这样的排列$p$ 才是合法的。\n\n小可可一直坚持每天排一个全新的合法的排列。有一天，他心血来潮，想知道所有合法排列的个数。小可可十分强，他当然知道怎么算。不过，他想用这个题来考考身在考场的你。这个数可能太大了，所以你只需要告诉小可可合法排列个数对$10^9+7$ 取模的结果就可以了。\n\n你能正确回答小可可的问题吗？如果能的话，他说不定会送个球球给你呢……", "inputFormat": "输入有两行：\n\n第一行一个正整数$n$，表示小可可拥有的球球个数。  \n第二行有$n$ 个整数，第$i$ 个整数$a[i]$表示编号为$i$ 的球球的特点。", "outputFormat": "输出一行，包括一个正整数，表示合法排列个数对$10^9+7$（即1000000007）取模的结果。", "hint": "【样例1 解释】\n12 种合法的排列分别为：\n```\n1,3,2,4\n2,3,1,4\n3,1,4,2\n3,2,4,1\n1,3,4,2\n2,3,4,1\n1,4,2,3\n2,4,1,3\n4,1,3,2\n4,2,3,1\n1,4,3,2\n2,4,3,1\n```\n\n【数据范围】\n\n对于100%的数据满足：$1≤n≤300$，$1≤a[i]≤10^9$。\n\n本题共10 个测试点，编号为1~10，每个测试点额外保证如下：\n\n测试点编号| n的范围|a[i]的范围\n-|-|-\n1~2|$n≤10$|$a[i]≤10^9$\n3~5|$n≤300$|$1≤a[i]≤2$\n6~8|-|$a[i]≤10^9$且都是质数\n9~10|-|$a[i]≤10^9$", "locale": "zh-CN"}}}
{"pid": "P4449", "type": "P", "difficulty": 6, "samples": [["1 2\n3 3", "20"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [268000, 268000, 268000, 268000, 268000, 268000, 268000, 268000, 268000, 268000]}, "tags": ["数学", "素数判断,质数,筛法", "莫比乌斯反演", "前缀和"], "title": "于神之怒加强版", "background": "", "description": "给定 $n,m,k$，计算\n\n$$\\sum_{i=1}^n \\sum_{j=1}^m \\gcd(i,j)^k$$\n\n对 $10^9 + 7$ 取模的结果。", "inputFormat": "**本题单测试点内有多组测试数据**。\n\n第一行有两个整数，分别表示数据组数 $T$ 和给定的 $k$。\n\n接下来 $T$ 行，每行两个整数，表示一组数据的 $n$ 和 $m$。", "outputFormat": "对于每组数据，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq T \\leq 2 \\times 10^3$，$1 \\leq n, m, k \\leq 5 \\times 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Yu Shen's Fury Enhanced Edition", "background": "", "description": "Given $n, m, k$, compute\n$$\\sum_{i=1}^n \\sum_{j=1}^m \\gcd(i,j)^k$$\nand output the result modulo $10^9 + 7$.", "inputFormat": "**There are multiple test cases in a single test file.**\n\nThe first line contains two integers, the number of test cases $T$ and the given $k$.\n\nThe next $T$ lines each contain two integers, $n$ and $m$, for one test case.", "outputFormat": "For each test case, output one line with a single integer representing the answer.", "hint": "Constraints\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 2 \\times 10^3$, $1 \\leq n, m, k \\leq 5 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "于神之怒加强版", "background": "", "description": "给定 $n,m,k$，计算\n\n$$\\sum_{i=1}^n \\sum_{j=1}^m \\gcd(i,j)^k$$\n\n对 $10^9 + 7$ 取模的结果。", "inputFormat": "**本题单测试点内有多组测试数据**。\n\n第一行有两个整数，分别表示数据组数 $T$ 和给定的 $k$。\n\n接下来 $T$ 行，每行两个整数，表示一组数据的 $n$ 和 $m$。", "outputFormat": "对于每组数据，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq T \\leq 2 \\times 10^3$，$1 \\leq n, m, k \\leq 5 \\times 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4450", "type": "P", "difficulty": 5, "samples": [["5 5 2\n", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["数学", "莫比乌斯反演", "整除分块"], "title": "双亲数", "background": null, "description": "小 D 是一名数学爱好者，他对数字的着迷到了疯狂的程度。\n\n我们以 $d = \\gcd(a, b)$ 表示 $a, b$ 的最大公约数，小 D 执著的认为，这样亲密的关系足可以用双亲来描述，此时，我们称**有序**数对 $(a, b)$ 为 $d$ 的双亲数。\n\n与正常双亲不太相同的是，对于同一个 $d$，他的双亲太多了。\n\n比如，$(4, 6)$，$(6, 4)$，$(2, 100)$ 都是 $2$ 的双亲数。  \n\n于是一个这样的问题摆在眼前，对于 $1 \\leq a \\leq A$，$1 \\leq b \\leq B$，有多少**有序**数对 $(a, b)$ 是 $d$ 的双亲数？", "inputFormat": "输入只有一行三个整数，分别表示 $A, B, d$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 样例 1 解释\n\n共有三对双亲数：$(2, 2)$，$(2, 4)$，$(4, 2)$。\n\n#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1 \\leq A, B \\leq 10^6$，$1 \\leq d \\leq \\min(A, B)$。", "locale": "zh-CN", "translations": {"en": {"title": "Parent Pairs", "background": "", "description": "Xiao D is a math enthusiast, and his obsession with numbers has reached a crazy level.\n\nWe use $d = \\gcd(a, b)$ to denote the greatest common divisor of $a$ and $b$. Xiao D insists that such a close relationship can be described as parents. In this case, we call the **ordered** pair $(a, b)$ a parent pair of $d$.\n\nUnlike normal parents, for the same $d$, it has too many parents.\n\nFor example, $(4, 6)$, $(6, 4)$, $(2, 100)$ are all parent pairs of $2$.  \nThus the following question arises: for $1 \\leq a \\leq A$, $1 \\leq b \\leq B$, how many **ordered** pairs $(a, b)$ are parent pairs of $d$?", "inputFormat": "The input contains a single line with three integers, representing $A$, $B$, and $d$.", "outputFormat": "Output a single integer on one line representing the answer.", "hint": "Sample 1 Explanation\n\nThere are three parent pairs: $(2, 2)$, $(2, 4)$, $(4, 2)$.\n\nConstraints\n\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq A, B \\leq 10^6$, $1 \\leq d \\leq \\min(A, B)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "双亲数", "background": null, "description": "小 D 是一名数学爱好者，他对数字的着迷到了疯狂的程度。\n\n我们以 $d = \\gcd(a, b)$ 表示 $a, b$ 的最大公约数，小 D 执著的认为，这样亲密的关系足可以用双亲来描述，此时，我们称**有序**数对 $(a, b)$ 为 $d$ 的双亲数。\n\n与正常双亲不太相同的是，对于同一个 $d$，他的双亲太多了。\n\n比如，$(4, 6)$，$(6, 4)$，$(2, 100)$ 都是 $2$ 的双亲数。  \n\n于是一个这样的问题摆在眼前，对于 $1 \\leq a \\leq A$，$1 \\leq b \\leq B$，有多少**有序**数对 $(a, b)$ 是 $d$ 的双亲数？", "inputFormat": "输入只有一行三个整数，分别表示 $A, B, d$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 样例 1 解释\n\n共有三对双亲数：$(2, 2)$，$(2, 4)$，$(4, 2)$。\n\n#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1 \\leq A, B \\leq 10^6$，$1 \\leq d \\leq \\min(A, B)$。", "locale": "zh-CN"}}}
{"pid": "P4451", "type": "P", "difficulty": 6, "samples": [["3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2011", "集训队互测", "Fibonacci 数列", "生成函数", "线性递推"], "title": "[国家集训队] 整数的lqp拆分", "background": "来源：2011中国国家集训队命题答辩", "description": "lqp在为出题而烦恼，他完全没有头绪，好烦啊…\n\n他首先想到了整数拆分。整数拆分是个很有趣的问题。给你一个正整数 $N$ ，对于N的一个整数拆分就是满足任意 $m>0$，$a_1 ,a_2 ,a_3…a_m>0$，且 $a_1+a_2+a_3+\\cdots+a_m=n$ 的一个有序集合。通过长时间的研究我们发现了计算对于 $n$ 的整数拆分的总数有一个很简单的递推式，但是因为这个递推式实在太简单了，如果出这样的题目，大家会对比赛毫无兴趣的。  \n\n然后 lqp 又想到了斐波那契数。定义 $F_0=0,F_1=1,F_n=F_{n-1}+F_{n-2}(n>1)$，$F_n$ 就是斐波那契数的第 $n$ 项。但是求出第 $n$ 项斐波那契数似乎也不怎么困难…\n\nlqp 为了增加选手们比赛的欲望，于是绞尽脑汁，想出了一个有趣的整数拆分，我们暂且叫它：整数的 lqp 拆分。\n\n和一般的整数拆分一样，整数的 lqp 拆分是满足任意 $m>0$，$a_1 ,a_2 ,a_3,\\cdots,a_m>0$，且 $a_1+a_2+a_3+\\cdots+a_m=n$ 的一个有序集合。但是整数的 lqp 拆分要求的不是拆分总数，相对更加困难一些。\n\n对于每个拆分，lqp 定义这个拆分的权值 $F_{a_1}F_{a_2}\\cdots F_{a_m}$，他想知道对于所有的拆分，他们的权值之和是多少？\n\n简单来说，就是求  \n$$\n\\sum_{\\substack{m>0\\\\a_1,\\cdots,a_m>0\\\\a_1+\\cdots+a_m=n}}\\prod_{i=1}^mF_{a_i}\n$$\n由于答案可能非常大，所以要对 $10^9 + 7$ 取模。", "inputFormat": "输入的第一行包含一个整数 $n$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $60\\%$ 的数据，$1\\le n \\le 10^9$。  \n对于 $100\\%$ 的数据，$1\\le n \\le 10^{10000}$。\n\n【样例解释】  \n$F_0=0,F_1=1,F_2=1,F_3=2$。\n\n对于 $n=3$，有这样几种 lqp 拆分：\n\n$3=1+1+1$，权值是 $F_1\\times F_1\\times F_1=1\\times1\\times1=1$。\n\n$3=1+2$，权值是 $F_1\\times F_2=1\\times1=1$。\n\n$3=2+1$，权值是 $F_2\\times F_1=1\\times1=1$。\n\n$3=3$，权值是 $F_3=2$。\n\n所以答案是 $1+1+1+2=5$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] lqp Decomposition of Integers", "background": "Source: 2011 China CTT Problem Defense.", "description": "lqp is struggling to write problems and has no clue, which is frustrating.\n\nHe first thought of integer decompositions. Integer decomposition is an interesting problem. Given a positive integer $n$, an integer decomposition of $n$ is an ordered sequence such that for any $m>0$, $a_1,a_2,a_3,\\cdots,a_m>0$, and $a_1+a_2+a_3+\\cdots+a_m=n$. After long study, we found a very simple recurrence to count the total number of integer decompositions of $n$, but because that recurrence is too simple, if he gave such a problem, nobody would be interested.\n\nThen lqp thought of Fibonacci numbers. Define $F_0=0,F_1=1,F_n=F_{n-1}+F_{n-2}(n>1)$; $F_n$ is the $n$-th Fibonacci number. But computing the $n$-th Fibonacci number does not seem very hard either.\n\nTo make the contest more appealing, lqp racked his brain and came up with an interesting integer decomposition; let us call it: the lqp decomposition of an integer.\n\nLike ordinary integer decompositions, an lqp decomposition of an integer is an ordered sequence with $m>0$, $a_1,a_2,a_3,\\cdots,a_m>0$, and $a_1+a_2+a_3+\\cdots+a_m=n$. However, instead of asking for the total number of decompositions, the lqp decomposition asks for something a bit harder.\n\nFor each decomposition, lqp defines its weight as $F_{a_1}F_{a_2}\\cdots F_{a_m}$. He wants to know the sum of the weights over all decompositions.\n\nIn short, compute\n$$\n\\sum_{\\substack{m>0\\\\a_1,\\cdots,a_m>0\\\\a_1+\\cdots+a_m=n}}\\prod_{i=1}^mF_{a_i}\n$$\nSince the answer can be very large, output it modulo $10^9 + 7$.", "inputFormat": "The first line of input contains an integer $n$.", "outputFormat": "Output one line with a single integer representing the answer.", "hint": "Constraints:  \nFor $60\\%$ of the testdata, $1 \\le n \\le 10^9$.  \nFor $100\\%$ of the testdata, $1 \\le n \\le 10^{10000}$.\n\nSample explanation:  \n$F_0=0,F_1=1,F_2=1,F_3=2$.\n\nFor $n=3$, there are the following lqp decompositions:\n\n$3=1+1+1$, the weight is $F_1\\times F_1\\times F_1=1\\times1\\times1=1$.\n\n$3=1+2$, the weight is $F_1\\times F_2=1\\times1=1$.\n\n$3=2+1$, the weight is $F_2\\times F_1=1\\times1=1$.\n\n$3=3$, the weight is $F_3=2$.\n\nTherefore, the answer is $1+1+1+2=5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 整数的lqp拆分", "background": "来源：2011中国国家集训队命题答辩", "description": "lqp在为出题而烦恼，他完全没有头绪，好烦啊…\n\n他首先想到了整数拆分。整数拆分是个很有趣的问题。给你一个正整数 $N$ ，对于N的一个整数拆分就是满足任意 $m>0$，$a_1 ,a_2 ,a_3…a_m>0$，且 $a_1+a_2+a_3+\\cdots+a_m=n$ 的一个有序集合。通过长时间的研究我们发现了计算对于 $n$ 的整数拆分的总数有一个很简单的递推式，但是因为这个递推式实在太简单了，如果出这样的题目，大家会对比赛毫无兴趣的。  \n\n然后 lqp 又想到了斐波那契数。定义 $F_0=0,F_1=1,F_n=F_{n-1}+F_{n-2}(n>1)$，$F_n$ 就是斐波那契数的第 $n$ 项。但是求出第 $n$ 项斐波那契数似乎也不怎么困难…\n\nlqp 为了增加选手们比赛的欲望，于是绞尽脑汁，想出了一个有趣的整数拆分，我们暂且叫它：整数的 lqp 拆分。\n\n和一般的整数拆分一样，整数的 lqp 拆分是满足任意 $m>0$，$a_1 ,a_2 ,a_3,\\cdots,a_m>0$，且 $a_1+a_2+a_3+\\cdots+a_m=n$ 的一个有序集合。但是整数的 lqp 拆分要求的不是拆分总数，相对更加困难一些。\n\n对于每个拆分，lqp 定义这个拆分的权值 $F_{a_1}F_{a_2}\\cdots F_{a_m}$，他想知道对于所有的拆分，他们的权值之和是多少？\n\n简单来说，就是求  \n$$\n\\sum_{\\substack{m>0\\\\a_1,\\cdots,a_m>0\\\\a_1+\\cdots+a_m=n}}\\prod_{i=1}^mF_{a_i}\n$$\n由于答案可能非常大，所以要对 $10^9 + 7$ 取模。", "inputFormat": "输入的第一行包含一个整数 $n$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $60\\%$ 的数据，$1\\le n \\le 10^9$。  \n对于 $100\\%$ 的数据，$1\\le n \\le 10^{10000}$。\n\n【样例解释】  \n$F_0=0,F_1=1,F_2=1,F_3=2$。\n\n对于 $n=3$，有这样几种 lqp 拆分：\n\n$3=1+1+1$，权值是 $F_1\\times F_1\\times F_1=1\\times1\\times1=1$。\n\n$3=1+2$，权值是 $F_1\\times F_2=1\\times1=1$。\n\n$3=2+1$，权值是 $F_2\\times F_1=1\\times1=1$。\n\n$3=3$，权值是 $F_3=2$。\n\n所以答案是 $1+1+1+2=5$。", "locale": "zh-CN"}}}
{"pid": "P4452", "type": "P", "difficulty": 6, "samples": [["2 1 1 10\n0 5\n5 0\n0 5\n5 0\n0 1 0 5 10", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "集训队互测", "网络流", "费用流"], "title": "[国家集训队] 航班安排", "background": "1. wqs 爱好模拟飞行。\n2. clj 开了一家神犇航空，由于 clj 还要玩游戏，所以公司的事务由你来打理。\n\n注意：题目中只是用了这样一个背景，并不与真实 / 模拟飞行相符。", "description": "神犇航空有 $K$ 架飞机，为了简化问题，我们认为每架飞机都是相同的。神犇航空的世界中有 $N$ 个机场，以 $0\\cdots N-1$ 编号，其中 $0$ 号为基地机场，每天 $0$ 时刻起飞机才可以从该机场起飞，并不晚于 $T$ 时刻回到该机场。\n\n一天，神犇航空接到了 $M$ 个包机请求，每个请求为在 $s$ 时刻从 $a$ 机场起飞，在恰好 $t$ 时刻到达 $b$ 机场，可以净获利 $c$。换言之，你只需要在 $s$ 时刻在 $a$ 机场选择提供一架飞机给请求方，那么这架飞机就会在 $t$ 时刻准时出现在 $b$ 机场，并且你将获得 $c$ 的净利润。\n\n设计一种方案，使得总收益最大。", "inputFormat": "第一行，$4$ 个正整数 $N,M,K,T$，如题目描述中所述；\n\n以下 $N$ 行，每行 $N$ 个整数，描述一个 $N\\times N$ 的矩阵 $t$，$t_{i,j}$ 表示从机场 $i$ 空载飞至机场 $j$，需要时间 $t_{i,j}$；\n\n以下 $N$ 行，每行 $N$ 个整数，描述一个 $N\\times N$ 的矩阵 $f$，$f_{i,j}$ 表示从机场 $i$ 空载飞至机场 $j$，需要费用 $f_{i,j}$；\n\n以下 $M$ 行，每行 $5$ 个整数描述一个请求，依次为 $a,b,s,t,c$。", "outputFormat": "　　仅一行，一个整数，表示最大收益。", "hint": "对于 $10\\%$ 的测试数据，$K=1$；\n\n另有 $20\\%$ 的测试数据，$K=2$；\n\n对于全部的测试数据，$1\\le N,M\\le 200$，$1\\le K\\le 10$，$1\\le T\\le 3000$，$1\\le t_{i,j}\\le 200$，$f_{i,j}\\le 2\\times 10^3$，$0\\le a,b<N$，$0\\le s\\le t\\le T$，$0\\le c\\le 10000$，$t_{i,i}=f_{i,i}=0$，$t_{ij}\\le t_{i,k}+t_{k,j}$，$f_{i,j}\\le f_{i,k}+f_{k,j}$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Flight Scheduling", "background": "1. wqs enjoys flight simulation.\n2. clj founded Shenniu Airlines. Because clj still wants to play games, you are in charge of running the company.\n\nNote: This background is only used for the problem and does not correspond to real or simulated flight.", "description": "Shenniu Airlines has $K$ airplanes. To simplify the problem, assume all airplanes are identical. In the world of Shenniu Airlines, there are $N$ airports, numbered $0 \\cdots N-1$, where airport $0$ is the base. All $K$ airplanes are at airport $0$ at time $0$, may take off starting from time $0$, and must return to airport $0$ no later than time $T$.\n\nDuring one day, the company receives $M$ charter requests. Each request is: depart from airport $a$ at time $s$, arrive at airport $b$ exactly at time $t$, and earn a net profit of $c$. In other words, if you assign an airplane at time $s$ at airport $a$ to this request, that airplane will appear at airport $b$ at time $t$, and you will gain a net profit of $c$.\n\nDesign a plan to maximize the total profit.", "inputFormat": "- The first line contains $4$ positive integers $N, M, K, T$, as described above.\n- The next $N$ lines each contain $N$ integers, describing an $N \\times N$ matrix $t$, where $t_{i,j}$ is the time needed to ferry (empty flight) from airport $i$ to airport $j$.\n- The next $N$ lines each contain $N$ integers, describing an $N \\times N$ matrix $f$, where $f_{i,j}$ is the cost to ferry from airport $i$ to airport $j$.\n- The next $M$ lines each describe one request with $5$ integers: $a, b, s, t, c$.", "outputFormat": "Output a single line with one integer: the maximum profit.", "hint": "- For $10\\%$ of the testdata, $K = 1$.\n- For another $20\\%$ of the testdata, $K = 2$.\n- For all the testdata: $1 \\le N, M \\le 200$, $1 \\le K \\le 10$, $1 \\le T \\le 3000$, $1 \\le t_{i,j} \\le 200$, $f_{i,j} \\le 2 \\times 10^3$, $0 \\le a, b < N$, $0 \\le s \\le t \\le T$, $0 \\le c \\le 10000$, $t_{i,i} = f_{i,i} = 0$, $t_{i,j} \\le t_{i,k} + t_{k,j}$, $f_{i,j} \\le f_{i,k} + f_{k,j}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 航班安排", "background": "1. wqs 爱好模拟飞行。\n2. clj 开了一家神犇航空，由于 clj 还要玩游戏，所以公司的事务由你来打理。\n\n注意：题目中只是用了这样一个背景，并不与真实 / 模拟飞行相符。", "description": "神犇航空有 $K$ 架飞机，为了简化问题，我们认为每架飞机都是相同的。神犇航空的世界中有 $N$ 个机场，以 $0\\cdots N-1$ 编号，其中 $0$ 号为基地机场，每天 $0$ 时刻起飞机才可以从该机场起飞，并不晚于 $T$ 时刻回到该机场。\n\n一天，神犇航空接到了 $M$ 个包机请求，每个请求为在 $s$ 时刻从 $a$ 机场起飞，在恰好 $t$ 时刻到达 $b$ 机场，可以净获利 $c$。换言之，你只需要在 $s$ 时刻在 $a$ 机场选择提供一架飞机给请求方，那么这架飞机就会在 $t$ 时刻准时出现在 $b$ 机场，并且你将获得 $c$ 的净利润。\n\n设计一种方案，使得总收益最大。", "inputFormat": "第一行，$4$ 个正整数 $N,M,K,T$，如题目描述中所述；\n\n以下 $N$ 行，每行 $N$ 个整数，描述一个 $N\\times N$ 的矩阵 $t$，$t_{i,j}$ 表示从机场 $i$ 空载飞至机场 $j$，需要时间 $t_{i,j}$；\n\n以下 $N$ 行，每行 $N$ 个整数，描述一个 $N\\times N$ 的矩阵 $f$，$f_{i,j}$ 表示从机场 $i$ 空载飞至机场 $j$，需要费用 $f_{i,j}$；\n\n以下 $M$ 行，每行 $5$ 个整数描述一个请求，依次为 $a,b,s,t,c$。", "outputFormat": "　　仅一行，一个整数，表示最大收益。", "hint": "对于 $10\\%$ 的测试数据，$K=1$；\n\n另有 $20\\%$ 的测试数据，$K=2$；\n\n对于全部的测试数据，$1\\le N,M\\le 200$，$1\\le K\\le 10$，$1\\le T\\le 3000$，$1\\le t_{i,j}\\le 200$，$f_{i,j}\\le 2\\times 10^3$，$0\\le a,b<N$，$0\\le s\\le t\\le T$，$0\\le c\\le 10000$，$t_{i,i}=f_{i,i}=0$，$t_{ij}\\le t_{i,k}+t_{k,j}$，$f_{i,j}\\le f_{i,k}+f_{k,j}$。", "locale": "zh-CN"}}}
{"pid": "P4453", "type": "P", "difficulty": 0, "samples": [["3 2 5\n0 1 10 10\n1 2 20 10", "114"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "集训队互测"], "title": "[国家集训队] 飞行计划", "background": "1. wqs喜欢模拟飞行。\n\n2. clj开了一家神犇航空，由于clj还要玩游戏，所以公司的事务由你来打理。\n\n注意：题目中只是用了这样一个背景，并不与真实/模拟飞行相符", "description": "神犇航空有一架航班从$A$地飞往$B$地，需要规划一条最经济的飞行线路。为了简化问题，我们认为地面是一个平面，高度为$0$，上有$N$个航路点，有$M$条双向航线，每条航线连接两个航路点，有两个参数$H$和$W$，表示以$h$高度通过这条航路，费用为$(H-h)2+W$。在每个航路点可以爬升/下降高度，每爬升一个高度需要费用$C$，而下降不需要费用。航路点$0$为$A$地，$N-1$为$B$地。", "inputFormat": "第一行3个正整数，$N,M$和$C$，含义如题目所述；\n\n以下$M$行，每行4个整数，$u,v,H,W$，表示$u,v$之间有一条航线，$H,W$为描述中的两个参数。", "outputFormat": "仅一行，一个整数，表示$A$地到$B$地的最小费用。", "hint": "对于10%的数据，$N,M<=5$，$H<=200$；\n\n另有20%的数据，$N<=100$，$M<=500$，$H<=100$；\n\n对于全部的测试数据，$N<=2000$，$M<=10000$，$C<=10$，$0<=u,v<N$，$0<=H<=10^5$，$0<=W<=2\\times 10^5$；输入保证答案不超出32位有符号整型。", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Flight Plan", "background": "1. wqs likes flight simulation.\n2. clj started an airline named Shenben Airlines (Shénbén). Since clj also wants to play games, you are in charge of running the company.\n\nNote: This is only a thematic background and does not correspond to real/simulated flight.", "description": "Shenben Airlines has a flight from $A$ to $B$ and needs to plan the most economical route. To simplify, we assume the ground is a plane at height $0$, with $N$ waypoints and $M$ bidirectional airways. Each airway connects two waypoints and has two parameters $H$ and $W$, meaning that traversing this airway at altitude $h$ costs $(H - h)^2 + W$. At each waypoint you may climb or descend; each unit of climb costs $C$, while descending is free. Waypoint $0$ is $A$, and waypoint $N - 1$ is $B$.", "inputFormat": "The first line contains 3 positive integers $N$, $M$, and $C$, as described above.\nThe next $M$ lines each contain 4 integers $u, v, H, W$, indicating there is an airway between $u$ and $v$ with parameters $H$ and $W$.", "outputFormat": "Output a single line with one integer, the minimum cost from $A$ to $B$.", "hint": "Constraints:\n- For 10% of the testdata: $N, M \\le 5$, $H \\le 200$.\n- Additionally, for 20% of the testdata: $N \\le 100$, $M \\le 500$, $H \\le 100$.\n- For all testdata: $N \\le 2000$, $M \\le 10000$, $C \\le 10$, $0 \\le u, v < N$, $0 \\le H \\le 10^5$, $0 \\le W \\le 2 \\times 10^5$. The input guarantees the answer does not exceed a 32-bit signed integer.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 飞行计划", "background": "1. wqs喜欢模拟飞行。\n\n2. clj开了一家神犇航空，由于clj还要玩游戏，所以公司的事务由你来打理。\n\n注意：题目中只是用了这样一个背景，并不与真实/模拟飞行相符", "description": "神犇航空有一架航班从$A$地飞往$B$地，需要规划一条最经济的飞行线路。为了简化问题，我们认为地面是一个平面，高度为$0$，上有$N$个航路点，有$M$条双向航线，每条航线连接两个航路点，有两个参数$H$和$W$，表示以$h$高度通过这条航路，费用为$(H-h)2+W$。在每个航路点可以爬升/下降高度，每爬升一个高度需要费用$C$，而下降不需要费用。航路点$0$为$A$地，$N-1$为$B$地。", "inputFormat": "第一行3个正整数，$N,M$和$C$，含义如题目所述；\n\n以下$M$行，每行4个整数，$u,v,H,W$，表示$u,v$之间有一条航线，$H,W$为描述中的两个参数。", "outputFormat": "仅一行，一个整数，表示$A$地到$B$地的最小费用。", "hint": "对于10%的数据，$N,M<=5$，$H<=200$；\n\n另有20%的数据，$N<=100$，$M<=500$，$H<=100$；\n\n对于全部的测试数据，$N<=2000$，$M<=10000$，$C<=10$，$0<=u,v<N$，$0<=H<=10^5$，$0<=W<=2\\times 10^5$；输入保证答案不超出32位有符号整型。", "locale": "zh-CN"}}}
{"pid": "P4454", "type": "P", "difficulty": 5, "samples": [["3 31\n3\n27 16\n21 3\n9 26", "4\n21\n25"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "重庆", "各省省选", "枚举", "素数判断,质数,筛法", "逆元"], "title": "[CQOI2018] 破解D-H协议", "background": "Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。", "description": "假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\\bmod$ 表示取模运算）：\n\n1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\\boldsymbol P$ 和 $\\boldsymbol g$ 的数值都是公开的，无需保密。**\n\n2. Alice 生成一个随机数 $a$，并计算 $A=g^a\\bmod P$，将 $A$ 通过不安全信道发送给 Bob。\n\n3. Bob 生成一个随机数 $b$，并计算 $B=g^b\\bmod P$，将 $B$ 通过不安全信道发送给 Alice。\n\n4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \\bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\\bmod P$。\n\n5. 双方得到了相同的 $K$，即 $g^{ab} \\bmod P$。$K$ 即之后通讯的加密密钥。\n\n可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。\n\n当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。\n\n$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。\n", "inputFormat": "输入文件第一行包含两个空格分开的正整数 $g$ 和 $P$。\n\n第二行为一个正整数 $n$，表示 Alice 和 Bob 共进行了 $n$ 次连接（即运行了 $n$ 次协议）。\n\n接下来 $n$ 行，每行包含两个空格分开的正整数 $A$ 和 $B$，表示某次连接中，被窃听的 $A,B$ 的数值。", "outputFormat": "输出包含 $n$ 行，每行 $1$ 个正整数 $K$，为每次连接你破解得到的密钥。", "hint": "对于 $30\\%$ 的数据，$2\\le A,B,P\\le 1000$；\n\n对于 $100\\%$ 的数据，$2\\le A,B<P<2^{31}，2\\le g<20，1\\le n\\le 20$。\n\n$\\text{Statement fixed by @Starrykiller.}$", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2018] Cracking the D-H Protocol", "background": "The Diffie-Hellman key exchange protocol is a simple and effective method for key exchange. It allows two parties to agree on a secure key $K$ over an insecure (possibly eavesdropped) channel without a pre-shared key, and then use it to encrypt subsequent communication.", "description": "Assume the two parties are named Alice and Bob. The protocol works as follows (where $\\bmod$ denotes the modulo operation):\n\n1. The protocol specifies a fixed prime $P$ and a primitive root modulo $P$, $g$. The values $\\boldsymbol P$ and $\\boldsymbol g$ are public and do not need to be kept secret.\n\n2. Alice generates a random number $a$, computes $A=g^a \\bmod P$, and sends $A$ to Bob over the insecure channel.\n\n3. Bob generates a random number $b$, computes $B=g^b \\bmod P$, and sends $B$ to Alice over the insecure channel.\n\n4. Bob computes the key $K=A^b \\bmod P$ from the received $A$, and Alice computes $K=B^a \\bmod P$ from the received $B$.\n\n5. Both parties obtain the same $K$, namely $g^{ab} \\bmod P$. $K$ is the encryption key for later communication.\n\nIn this process, only $A$ and $B$ can be eavesdropped, while $a$, $b$, and $K$ remain secret. Given the four numbers $A$, $B$, $P$, and $g$, it is not easy to compute $K$, so $K$ can serve as a secure key.\n\nOf course, security is relative. The security of the protocol depends on the sizes of the values. Typically, $a$, $b$, and $P$ are chosen as large integers with hundreds of bits to prevent compromise. However, if Alice and Bob are lazy in programming and, to avoid implementing big-integer arithmetic, choose values less than $2^{31}$, then cracking their key becomes relatively easy.\n\nGiven $n$ pairs of eavesdropped $A$ and $B$, you need to try to crack the key $K$.", "inputFormat": "The first line contains two space-separated positive integers $g$ and $P$.\n\nThe second line contains a positive integer $n$, indicating that Alice and Bob performed $n$ sessions (i.e., ran the protocol $n$ times).\n\nThen follow $n$ lines. Each line contains two space-separated positive integers $A$ and $B$, representing the eavesdropped values $A$ and $B$ for one session.", "outputFormat": "Output $n$ lines. Each line contains a single positive integer $K$, which is the key you cracked for that session.", "hint": "For $30\\%$ of the testdata, $2\\le A,B,P\\le 1000$.\n\nFor $100\\%$ of the testdata, $2\\le A,B<P<2^{31}$, $2\\le g<20$, $1\\le n\\le 20$.\n\nStatement fixed by @Starrykiller.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2018] 破解D-H协议", "background": "Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。", "description": "假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\\bmod$ 表示取模运算）：\n\n1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\\boldsymbol P$ 和 $\\boldsymbol g$ 的数值都是公开的，无需保密。**\n\n2. Alice 生成一个随机数 $a$，并计算 $A=g^a\\bmod P$，将 $A$ 通过不安全信道发送给 Bob。\n\n3. Bob 生成一个随机数 $b$，并计算 $B=g^b\\bmod P$，将 $B$ 通过不安全信道发送给 Alice。\n\n4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \\bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\\bmod P$。\n\n5. 双方得到了相同的 $K$，即 $g^{ab} \\bmod P$。$K$ 即之后通讯的加密密钥。\n\n可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。\n\n当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。\n\n$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。\n", "inputFormat": "输入文件第一行包含两个空格分开的正整数 $g$ 和 $P$。\n\n第二行为一个正整数 $n$，表示 Alice 和 Bob 共进行了 $n$ 次连接（即运行了 $n$ 次协议）。\n\n接下来 $n$ 行，每行包含两个空格分开的正整数 $A$ 和 $B$，表示某次连接中，被窃听的 $A,B$ 的数值。", "outputFormat": "输出包含 $n$ 行，每行 $1$ 个正整数 $K$，为每次连接你破解得到的密钥。", "hint": "对于 $30\\%$ 的数据，$2\\le A,B,P\\le 1000$；\n\n对于 $100\\%$ 的数据，$2\\le A,B<P<2^{31}，2\\le g<20，1\\le n\\le 20$。\n\n$\\text{Statement fixed by @Starrykiller.}$", "locale": "zh-CN"}}}
{"pid": "P4455", "type": "P", "difficulty": 6, "samples": [["4\n7\n2 1\n3 1\n1 3\n2 3\n3 2\n4 3\n4 2\n", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "重庆", "各省省选", "矩阵树定理", "生成树", "向量", "构造", "行列式"], "title": "[CQOI2018] 社交网络", "background": "当今社会，在社交网络上看朋友的消息已经成为许多人生活的一部分。通常，一个用户在社交网络上发布一条消息后，他的好友们也可以看见这条消息，并可能转发。转发的消息还可以继续被人转发，进而扩散到整个社交网络中。", "description": "在一个实验性的小规模社交网络中我们发现，有时一条热门消息最终会被所有人转发。为了研究这一现象发生的过程，我们希望计算一条消息所有可能的转发途径有多少种。为了编程方便，我们将初始消息发送者编号为 $1$，其他用户编号依次递增。\n\n该社交网络上的所有好友关系是已知的，也就是说对于 $a, b$ 两个用户，我们知道 $a$ 用户可以看到 $b$ 用户发送的消息。注意可能存在单向的好友关系，即 $a$ 能看到 $b$ 的消息，但 $b$ 不能看到 $a$ 的消息。\n\n还有一个假设是，如果某用户看到他的多个好友转发了同一条消息，他只会选择从其中一个转发，最多转发一次消息。从不同好友的转发，被视为不同的情况。\n\n如果用箭头表示好友关系，下图展示了某个社交网络中消息转发的所有可能情况。（初始消息是用户 $1$ 发送的，加粗箭头表示一次消息转发）\n\n![](https://cdn.luogu.com.cn/upload/pic/17549.png)\n![](https://cdn.luogu.com.cn/upload/pic/17550.png)\n![](https://cdn.luogu.com.cn/upload/pic/17551.png)\n![](https://cdn.luogu.com.cn/upload/pic/17552.png)\n![](https://cdn.luogu.com.cn/upload/pic/17553.png)\n![](https://cdn.luogu.com.cn/upload/pic/17554.png)\n\n答案对 $10^4 + 7$ 取模。", "inputFormat": "第一行有一个整数，表示用户的数量 $n$。  \n第二行有一个整数，表示好友关系数目 $m$。  \n接下来 $m$ 行，每行两个整数 $a, b$，表示一组好友关系，即用户 $a$ 可以看到用户 $b$ 发送的信息。", "outputFormat": "输出一行一个整数表示答案对 $10^4 + 7$ 取模的结果。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 10$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 250$，$1 \\leq m \\leq n \\times (n - 1)$，$1 \\leq a, b \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2018] Social Network", "background": "In today's society, checking friends' posts on social networks has become part of many people's lives. Usually, after a user posts a message on a social network, their friends can also see it and may forward it. The forwarded message can continue to be forwarded, spreading through the entire social network.", "description": "In a small experimental social network, we found that sometimes a popular message is eventually forwarded by everyone. To study how this happens, we want to compute how many possible forwarding paths there are for a single message. For convenience, we number the initial sender as user $1$, and number the other users in increasing order.\n\nAll friend relations on this social network are known. That is, for two users $a$ and $b$, we know that user $a$ can see messages sent by user $b$. Note that one-way friend relations may exist; that is, $a$ can see $b$'s messages, but $b$ cannot see $a$'s.\n\nAnother assumption is that if a user sees that multiple friends forwarded the same message, they will choose exactly one of them to forward from, and will forward at most once. Forwarding from different friends is considered different cases.\n\nIf we use arrows to represent friend relations, the figures below show all possible forwarding situations in a certain social network. (The initial message is sent by user $1$, and bold arrows indicate a single forwarding.)\n\n![](https://cdn.luogu.com.cn/upload/pic/17549.png)\n![](https://cdn.luogu.com.cn/upload/pic/17550.png)\n![](https://cdn.luogu.com.cn/upload/pic/17551.png)\n![](https://cdn.luogu.com.cn/upload/pic/17552.png)\n![](https://cdn.luogu.com.cn/upload/pic/17553.png)\n![](https://cdn.luogu.com.cn/upload/pic/17554.png)\n\nOutput the answer modulo $10^4 + 7$.", "inputFormat": "The first line contains an integer $n$, the number of users.  \nThe second line contains an integer $m$, the number of friend relations.  \nEach of the next $m$ lines contains two integers $a, b$, indicating a friend relation, i.e., user $a$ can see messages sent by user $b$.", "outputFormat": "Output a single line with one integer: the answer modulo $10^4 + 7$.", "hint": "Constraints:\n\n- For $30\\%$ of the testdata, $n \\leq 10$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 250$, $1 \\leq m \\leq n \\times (n - 1)$, $1 \\leq a, b \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2018] 社交网络", "background": "当今社会，在社交网络上看朋友的消息已经成为许多人生活的一部分。通常，一个用户在社交网络上发布一条消息后，他的好友们也可以看见这条消息，并可能转发。转发的消息还可以继续被人转发，进而扩散到整个社交网络中。", "description": "在一个实验性的小规模社交网络中我们发现，有时一条热门消息最终会被所有人转发。为了研究这一现象发生的过程，我们希望计算一条消息所有可能的转发途径有多少种。为了编程方便，我们将初始消息发送者编号为 $1$，其他用户编号依次递增。\n\n该社交网络上的所有好友关系是已知的，也就是说对于 $a, b$ 两个用户，我们知道 $a$ 用户可以看到 $b$ 用户发送的消息。注意可能存在单向的好友关系，即 $a$ 能看到 $b$ 的消息，但 $b$ 不能看到 $a$ 的消息。\n\n还有一个假设是，如果某用户看到他的多个好友转发了同一条消息，他只会选择从其中一个转发，最多转发一次消息。从不同好友的转发，被视为不同的情况。\n\n如果用箭头表示好友关系，下图展示了某个社交网络中消息转发的所有可能情况。（初始消息是用户 $1$ 发送的，加粗箭头表示一次消息转发）\n\n![](https://cdn.luogu.com.cn/upload/pic/17549.png)\n![](https://cdn.luogu.com.cn/upload/pic/17550.png)\n![](https://cdn.luogu.com.cn/upload/pic/17551.png)\n![](https://cdn.luogu.com.cn/upload/pic/17552.png)\n![](https://cdn.luogu.com.cn/upload/pic/17553.png)\n![](https://cdn.luogu.com.cn/upload/pic/17554.png)\n\n答案对 $10^4 + 7$ 取模。", "inputFormat": "第一行有一个整数，表示用户的数量 $n$。  \n第二行有一个整数，表示好友关系数目 $m$。  \n接下来 $m$ 行，每行两个整数 $a, b$，表示一组好友关系，即用户 $a$ 可以看到用户 $b$ 发送的信息。", "outputFormat": "输出一行一个整数表示答案对 $10^4 + 7$ 取模的结果。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 10$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 250$，$1 \\leq m \\leq n \\times (n - 1)$，$1 \\leq a, b \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4456", "type": "P", "difficulty": 5, "samples": [["3 1 2 1009", "10"], ["4 3 2 1009", "204"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2018", "重庆", "各省省选", "矩阵加速", "二项式定理", "矩阵乘法"], "title": "[CQOI2018] 交错序列", "background": null, "description": "我们称一个仅由 $0,1$ 构成的序列为“交错序列”，当且仅当序列中没有相邻的 $1$（可以有相邻的 $0$）。例如，`000`、`001`、`101` 都是交错序列，而 `110` 则不是。\n\n对于一个长度为 $n$ 的交错序列，统计其中 $0$ 和 $1$ 出现的次数，分别记为 $x$ 和 $y$。给定参数 $a,b$，定义一个交错序列的特征值为 $x^ay^b$。注意这里规定任何整数的 $0$ 次幂都等于 $1$（包括 $0^0=1$）。\n\n显然长度为 $n$ 的交错序列可能有多个。我们想要知道，所有长度为 $n$ 的交错序列的特征值的和除以 $m$ 的余数（$m$ 是一个给定的质数）。\n\n例如，全部长度为 $3$ 的交错串为：`000`、`001`、`010`、`100`、`101`。当 $a=1,b=2$ 时，可计算：$3^1\\times0^2+2^1\\times1^2+2^1\\times1^2+2^1\\times1^2+1^1\\times2^2=10$。", "inputFormat": "输入文件共一行，包含三个空格分开的整数 $n,a,b,m$。", "outputFormat": "输出文件共一行，为计算结果 $\\bmod{m}$ 的值。", "hint": "对于 $30\\%$ 的数据，$1 \\le n\\le 15$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^7$，$1 \\le a,b \\le 45$，$10^7 \\le m < 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2018] Alternating Sequence", "background": "", "description": "We call a sequence consisting only of $0,1$ an \"alternating sequence\" if and only if there are no adjacent $1$'s (adjacent $0$'s are allowed). For example, `000`, `001`, `101` are alternating sequences, while `110` is not.\n\nFor an alternating sequence of length $n$, let the counts of $0$ and $1$ be $x$ and $y$, respectively. Given parameters $a,b$, define the characteristic value of a sequence as $x^a y^b$. Note that any integer to the $0$-th power equals $1$ (including $0^0 = 1$).\n\nObviously there may be multiple alternating sequences of length $n$. We want to know the remainder modulo $m$ (where $m$ is a given prime) of the sum of characteristic values over all alternating sequences of length $n$.\n\nFor example, all alternating sequences of length $3$ are: `000`, `001`, `010`, `100`, `101`. When $a = 1, b = 2$, we can compute: $3^1 \\times 0^2 + 2^1 \\times 1^2 + 2^1 \\times 1^2 + 2^1 \\times 1^2 + 1^1 \\times 2^2 = 10$.", "inputFormat": "The input contains one line with four space-separated integers $n,a,b,m$.", "outputFormat": "Output one line containing the result $\\bmod m$.", "hint": "For $30\\%$ of the testdata, $1 \\le n \\le 15$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^7$, $1 \\le a,b \\le 45$, $10^7 \\le m < 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2018] 交错序列", "background": null, "description": "我们称一个仅由 $0,1$ 构成的序列为“交错序列”，当且仅当序列中没有相邻的 $1$（可以有相邻的 $0$）。例如，`000`、`001`、`101` 都是交错序列，而 `110` 则不是。\n\n对于一个长度为 $n$ 的交错序列，统计其中 $0$ 和 $1$ 出现的次数，分别记为 $x$ 和 $y$。给定参数 $a,b$，定义一个交错序列的特征值为 $x^ay^b$。注意这里规定任何整数的 $0$ 次幂都等于 $1$（包括 $0^0=1$）。\n\n显然长度为 $n$ 的交错序列可能有多个。我们想要知道，所有长度为 $n$ 的交错序列的特征值的和除以 $m$ 的余数（$m$ 是一个给定的质数）。\n\n例如，全部长度为 $3$ 的交错串为：`000`、`001`、`010`、`100`、`101`。当 $a=1,b=2$ 时，可计算：$3^1\\times0^2+2^1\\times1^2+2^1\\times1^2+2^1\\times1^2+1^1\\times2^2=10$。", "inputFormat": "输入文件共一行，包含三个空格分开的整数 $n,a,b,m$。", "outputFormat": "输出文件共一行，为计算结果 $\\bmod{m}$ 的值。", "hint": "对于 $30\\%$ 的数据，$1 \\le n\\le 15$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^7$，$1 \\le a,b \\le 45$，$10^7 \\le m < 10^8$。", "locale": "zh-CN"}}}
{"pid": "P4457", "type": "P", "difficulty": 7, "samples": [["2\n2 1 1 1\n2 2 1 1", "6\n8"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["递推", "2018", "各省省选", "北京", "O2优化", "期望", "高斯消元"], "title": "[BJOI2018] 治疗之雨", "background": "（没玩过《炉石传说》的人可以跳过这一段）今天我们来探讨下《炉石传说》中“治疗之雨”（恢复 $12$ 点生命值，随机分配到所有友方角色上）和“暗影打击装甲”（每当一个角色获得治疗，便对随机敌人造成 $1$点伤害）这两张卡牌之间的互动效果。假设你场上有 $m$个剩余生命值无限大且生命值上限减去剩余生命值也无限大的随从，而对方的场上有 $k$个暗影打击装甲，你的英雄剩余生命值为 $p$、生命值上限为 $n$，现在你使用了一张可以恢复无限多（而不是 $12$ 点）生命值的治疗之雨，问治疗之雨期望总共恢复了几点生命值以后你的英雄会死亡（生命值降为 $0$；治疗之雨的判定机制使得在此后再也不会为英雄恢复生命值）。\n\n注：题目背景与题目描述有冲突的地方请以题目描述为准\n\n下面让我们再形式化地描述一遍问题。", "description": "**题目更新：鉴于很多人反映看不懂题，但是出于尊重原题面的原则不进行大幅度更改。您可以将最小值和最大值理解为下限和上限，类似于题目背景中的血量。**\n\n\n你现在有 $m+1$ 个数：第一个为 $p$，最小值为 $0$，最大值为 $n$；剩下 $m$个都是无穷，没有最小值或最大值。你可以进行任意多轮操作，每轮操作如下：\n\n在不为最大值的数中等概率随机选择一个（如果没有则不操作），把它加一；\n\n进行 $k$次这个步骤：在不为最小值的数中等概率随机选择一个（如果没有则不操作），把它减一。 \n\n现在问期望进行多少轮操作以后第一个数会变为最小值 $0$。", "inputFormat": "输入包含多组数据。\n输入第一行包含一个正整数 $T$，表示数据组数。\n接下来 $T$行 ，每行 4个非负整数 $n$、$p$、$m$、$k$（含义见题目描述），表示一次询问。", "outputFormat": "输出 $T$行，每行一个整数，表示一次询问的答案。\n\n如果无论进行多少轮操作，第一个数都不会变为最小值 $0$，那么输出```-1```；\n\n否则，可以证明答案一定为有理数，那么请输出答案模 $10^9+7$ 的余数，即设答案为 $\\frac{a}{b}$（$a$、$b$为互质的正整数 ），你输出的整数为 $x$，那么你需要保证 $0 \\leq x < 10^9+7$ 且 $a \\equiv bx (\\mod 10^9+7)$。", "hint": "###数据范围\n\n对于 $10\\%$ 的数据， $n \\leq 3$ ，$m, k \\leq 2$ 。\n\n对于 $20\\%$ 的数据， $n, m, k \\leq 5$ 。\n\n对于 $30\\%$ 的数据， $n, m, k \\leq 30$ 。\n\n对于 $40\\%$ 的数据， $n, m, k \\leq 50$ 。\n\n对于 $50\\%$ 的数据， $n, m, k \\leq 200$ 。\n\n对于 $70\\%$ 的数据， $n \\leq 200$ 。\n\n对于 $80\\%$ 的数据， $n \\leq 500$ 。\n\n对于 $100\\%$ 的数据， $1 \\leq T \\leq 100$，$1 \\leq p \\leq n \\leq 1500$ ，$0 \\leq m, k \\leq 10^9$。\n\n保证不存在 $n=p=k=1$, $m=0$ 的情况（因为出题人判错了）\n\n保证不存在答案的分母是 $10^9+7$ 的倍数的情况（因为出题人没想到）", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2018] Healing Rain", "background": "(Players who have not played Hearthstone can skip this paragraph.) Today we discuss the interaction between “Healing Rain” (restore $12$ Health, randomly distributed among all friendly characters) and “Shadowstrike Armor” (whenever a character is healed, deal $1$ damage to a random enemy). Suppose you have $m$ minions on your side with infinite remaining Health and infinite missing Health (i.e., no upper or lower bounds), and your opponent has $k$ copies of Shadowstrike Armor on the board. Your hero has current Health $p$ and maximum Health $n$. Now you cast a Healing Rain that can restore infinitely many Health (instead of $12$). What is the expected total amount of Health restored by Healing Rain before your hero dies (Health drops to $0$; due to Healing Rain’s targeting rules, the hero will no longer be healed afterward).\n\nNote: If the background conflicts with the problem statement, follow the problem statement.\n\nBelow is the formal description of the problem.", "description": "Problem update: Since many people reported difficulty understanding the statement, but to respect the original wording we will not make large changes. You may interpret “minimum” and “maximum” as lower bound and upper bound, similar to the Health in the background.\n\nYou now have $m+1$ numbers: the first is $p$, with minimum $0$ and maximum $n$; the remaining $m$ are all infinite, with no minimum or maximum. You may perform any number of rounds. In each round, do the following:\n\n- Uniformly at random choose one number among those that are not at their maximum (if none, do nothing), and add $1$ to it.\n- Then perform this step $k$ times: uniformly at random choose one number among those that are not at their minimum (if none, do nothing), and subtract $1$ from it.\n\nWhat is the expected number of rounds until the first number becomes its minimum $0$.", "inputFormat": "The input contains multiple test cases.\nThe first line contains a positive integer $T$, the number of test cases.\nThe next $T$ lines each contain four non-negative integers $n$, $p$, $m$, $k$ (as defined above), representing one query.", "outputFormat": "Output $T$ lines, each with one integer, the answer for that query.\n\nIf the first number never becomes the minimum $0$ no matter how many rounds, output ```-1```.\n\nOtherwise, it can be proved that the answer is a rational number. Output the answer modulo $10^9+7$, i.e., suppose the answer is $\\frac{a}{b}$ (where $a$ and $b$ are coprime positive integers). You must output an integer $x$ such that $0 \\le x < 10^9+7$ and $a \\equiv b x \\pmod{10^9+7}$.", "hint": "### Constraints\n\n- For $10\\%$ of the testdata, $n \\le 3$, $m, k \\le 2$.\n- For $20\\%$ of the testdata, $n, m, k \\le 5$.\n- For $30\\%$ of the testdata, $n, m, k \\le 30$.\n- For $40\\%$ of the testdata, $n, m, k \\le 50$.\n- For $50\\%$ of the testdata, $n, m, k \\le 200$.\n- For $70\\%$ of the testdata, $n \\le 200$.\n- For $80\\%$ of the testdata, $n \\le 500$.\n- For $100\\%$ of the testdata, $1 \\le T \\le 100$, $1 \\le p \\le n \\le 1500$, $0 \\le m, k \\le 10^9$.\n\nIt is guaranteed that the case $n = p = k = 1$, $m = 0$ does not exist (because the author judged it wrong).\n\nIt is guaranteed that the denominator of the answer is not a multiple of $10^9+7$ (because the author did not think of it).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2018] 治疗之雨", "background": "（没玩过《炉石传说》的人可以跳过这一段）今天我们来探讨下《炉石传说》中“治疗之雨”（恢复 $12$ 点生命值，随机分配到所有友方角色上）和“暗影打击装甲”（每当一个角色获得治疗，便对随机敌人造成 $1$点伤害）这两张卡牌之间的互动效果。假设你场上有 $m$个剩余生命值无限大且生命值上限减去剩余生命值也无限大的随从，而对方的场上有 $k$个暗影打击装甲，你的英雄剩余生命值为 $p$、生命值上限为 $n$，现在你使用了一张可以恢复无限多（而不是 $12$ 点）生命值的治疗之雨，问治疗之雨期望总共恢复了几点生命值以后你的英雄会死亡（生命值降为 $0$；治疗之雨的判定机制使得在此后再也不会为英雄恢复生命值）。\n\n注：题目背景与题目描述有冲突的地方请以题目描述为准\n\n下面让我们再形式化地描述一遍问题。", "description": "**题目更新：鉴于很多人反映看不懂题，但是出于尊重原题面的原则不进行大幅度更改。您可以将最小值和最大值理解为下限和上限，类似于题目背景中的血量。**\n\n\n你现在有 $m+1$ 个数：第一个为 $p$，最小值为 $0$，最大值为 $n$；剩下 $m$个都是无穷，没有最小值或最大值。你可以进行任意多轮操作，每轮操作如下：\n\n在不为最大值的数中等概率随机选择一个（如果没有则不操作），把它加一；\n\n进行 $k$次这个步骤：在不为最小值的数中等概率随机选择一个（如果没有则不操作），把它减一。 \n\n现在问期望进行多少轮操作以后第一个数会变为最小值 $0$。", "inputFormat": "输入包含多组数据。\n输入第一行包含一个正整数 $T$，表示数据组数。\n接下来 $T$行 ，每行 4个非负整数 $n$、$p$、$m$、$k$（含义见题目描述），表示一次询问。", "outputFormat": "输出 $T$行，每行一个整数，表示一次询问的答案。\n\n如果无论进行多少轮操作，第一个数都不会变为最小值 $0$，那么输出```-1```；\n\n否则，可以证明答案一定为有理数，那么请输出答案模 $10^9+7$ 的余数，即设答案为 $\\frac{a}{b}$（$a$、$b$为互质的正整数 ），你输出的整数为 $x$，那么你需要保证 $0 \\leq x < 10^9+7$ 且 $a \\equiv bx (\\mod 10^9+7)$。", "hint": "###数据范围\n\n对于 $10\\%$ 的数据， $n \\leq 3$ ，$m, k \\leq 2$ 。\n\n对于 $20\\%$ 的数据， $n, m, k \\leq 5$ 。\n\n对于 $30\\%$ 的数据， $n, m, k \\leq 30$ 。\n\n对于 $40\\%$ 的数据， $n, m, k \\leq 50$ 。\n\n对于 $50\\%$ 的数据， $n, m, k \\leq 200$ 。\n\n对于 $70\\%$ 的数据， $n \\leq 200$ 。\n\n对于 $80\\%$ 的数据， $n \\leq 500$ 。\n\n对于 $100\\%$ 的数据， $1 \\leq T \\leq 100$，$1 \\leq p \\leq n \\leq 1500$ ，$0 \\leq m, k \\leq 10^9$。\n\n保证不存在 $n=p=k=1$, $m=0$ 的情况（因为出题人判错了）\n\n保证不存在答案的分母是 $10^9+7$ 的倍数的情况（因为出题人没想到）", "locale": "zh-CN"}}}
{"pid": "P4458", "type": "P", "difficulty": 6, "samples": [["5 5\n1 1 1 1 1\n2 5 5\n2 1 2\n1 1 2 2\n2 1 1\n1 1 5 3", "5\n13\n9"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "线段树", "各省省选", "北京", "枚举", "前缀和", "差分"], "title": "[BJOI2018] 链上二次求和", "background": "", "description": "有一条长度为 $n$ 的链（ $\\forall 1 \\leq i < n$ ，点 $i$ 与点 $i+1$ 之间有一条边的无向图）， 每个点有一个整数权值，第 $i$ 个点的权值是 $a_i$ 。现在有 $m$ 个操作，每个操作如下：\n\n操作 1（修改）：给定链上两个节点 $u,v$ 和一个整数 $d$，表示将链上 $u$ 到 $v$ 唯一的简单路径上每个点权值都加上 $d$。\n\n操作 2（询问）：给定两个正整数 $l,r$，表示求链上所有节点个数大于等于 $l$ 且小于等于 $r$ 的简单路径节点权值和之和。由于答案很大，只用输出对质数 $1000000007$ 取模的结果即可。\n\n一条节点个数为 $k$ 的简单路径节点权值和为这条上所有 $k$ 个节点（包括端点）的权值之和，而本题中要求是对所有满足要求的简单路径，求这一权值和的和。\n\n由于是无向图，路径也是无向的，即点 $1$ 到点 $2$ 的路径与点 $2$ 到点 $1$ 的路径是同一条，不要重复计算。", "inputFormat": "输入第一行包含两个正整数 $n,m$，分别表示节点个数和操作次数。\n\n第二行包含 $n$ 个整数，其中第 $i$ 个数 $a_i$ 为第 $i$ 个点的初始权值。\n\n接下来 $m$ 行，每行为 ```1 u v d```或 ```2 l r```的形式，分别表示进行一次操作 1（修改）或操作 2（询问）。 ", "outputFormat": "对于每次询问，输出一行一个整数，表示答案对 $1000000007$ 取模的余数。", "hint": "### 样例解释：\n节点个数为 $5$ 的简单路径只有 $1$ 条，权值和为 $5$，故第1次询问输出 $5$。\n\n节点个数为 $1$ 的简单路径有 $5$ 条，每条权值和都是 $1$；节点个数为 $2$ 的简单路径有 $4$ 条，每条权值和都是 $2$，故第2次询问输出 $13 $。\n\n在将点 $1$ 和点 $2$ 的权值加 $2$ 后， $5$ 条节点个数为 $1$ 的简单路径权值和分别为 $3$、$3$、$1$、$1$、$1$，故第 3 次询问输出 $9$。\n\n### 数据范围：\n记操作 1（修改）的次数为 $m^\\prime$。\n\n对于全部数据， 保证 $n \\leq 200000$，$m \\leq 500000$，$ m^\\prime \\leq 100000$，$ 0 \\leq a_i < 1000000007$。\n\n$1 \\leq u \\leq n$，$ 1\\leq v \\leq n$，$ 0 \\leq d < 1000000007$，$l \\leq r \\leq n$。\n\n对于每个数据点的详细规模与约定见下表。\n\n![pic](https://cdn.luogu.com.cn/upload/pic/17580.png)", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2018] Quadratic Sum on a Chain", "background": "", "description": "There is a chain of length $n$ (an undirected graph where $\\forall 1 \\leq i < n$, there is an edge between node $i$ and node $i+1$). Each node has an integer weight; the weight of the $i$-th node is $a_i$. There are $m$ operations, each as follows:\n\nOperation 1 (modify): Given two nodes $u, v$ on the chain and an integer $d$, add $d$ to the weight of every node on the unique simple path from $u$ to $v$ on the chain.\n\nOperation 2 (query): Given two positive integers $l, r$, compute the sum of node-weight sums over all simple paths whose number of nodes is at least $l$ and at most $r$. Since the answer can be very large, output the result modulo the prime $1000000007$.\n\nThe node-weight sum of a simple path with $k$ nodes is the sum of the weights of all $k$ nodes (including endpoints) on that path. In this problem, you need to compute the sum of this value over all simple paths that meet the requirement.\n\nSince the graph is undirected, paths are undirected as well; that is, the path from node $1$ to node $2$ is the same as the path from node $2$ to node $1$, so do not double count.", "inputFormat": "The first line contains two positive integers $n, m$, denoting the number of nodes and the number of operations.\n\nThe second line contains $n$ integers; the $i$-th number $a_i$ is the initial weight of the $i$-th node.\n\nEach of the next $m$ lines is in the form ```1 u v d``` or ```2 l r```, indicating an Operation 1 (modify) or Operation 2 (query), respectively.", "outputFormat": "For each query, output one line with one integer, which is the answer modulo $1000000007$.", "hint": "### Sample Explanation:\nThere is exactly $1$ simple path with $5$ nodes, and its node-weight sum is $5$, so the first query outputs $5$.\n\nThere are $5$ simple paths with $1$ node, each with node-weight sum $1$; there are $4$ simple paths with $2$ nodes, each with node-weight sum $2$, so the second query outputs $13$.\n\nAfter adding $2$ to the weights of nodes $1$ and $2$, the $5$ simple paths with $1$ node have node-weight sums $3$, $3$, $1$, $1$, $1$, so the third query outputs $9$.\n\n### Constraints:\nLet the number of Operation 1 (modify) be $m^\\prime$.\n\nFor all testdata, it is guaranteed that $n \\leq 200000$, $m \\leq 500000$, $m^\\prime \\leq 100000$, $0 \\leq a_i < 1000000007$.\n\n$1 \\leq u \\leq n$, $1 \\leq v \\leq n$, $0 \\leq d < 1000000007$, $l \\leq r \\leq n$.\n\nFor the detailed scale and conventions of each test point, see the table below.\n\n![pic](https://cdn.luogu.com.cn/upload/pic/17580.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2018] 链上二次求和", "background": "", "description": "有一条长度为 $n$ 的链（ $\\forall 1 \\leq i < n$ ，点 $i$ 与点 $i+1$ 之间有一条边的无向图）， 每个点有一个整数权值，第 $i$ 个点的权值是 $a_i$ 。现在有 $m$ 个操作，每个操作如下：\n\n操作 1（修改）：给定链上两个节点 $u,v$ 和一个整数 $d$，表示将链上 $u$ 到 $v$ 唯一的简单路径上每个点权值都加上 $d$。\n\n操作 2（询问）：给定两个正整数 $l,r$，表示求链上所有节点个数大于等于 $l$ 且小于等于 $r$ 的简单路径节点权值和之和。由于答案很大，只用输出对质数 $1000000007$ 取模的结果即可。\n\n一条节点个数为 $k$ 的简单路径节点权值和为这条上所有 $k$ 个节点（包括端点）的权值之和，而本题中要求是对所有满足要求的简单路径，求这一权值和的和。\n\n由于是无向图，路径也是无向的，即点 $1$ 到点 $2$ 的路径与点 $2$ 到点 $1$ 的路径是同一条，不要重复计算。", "inputFormat": "输入第一行包含两个正整数 $n,m$，分别表示节点个数和操作次数。\n\n第二行包含 $n$ 个整数，其中第 $i$ 个数 $a_i$ 为第 $i$ 个点的初始权值。\n\n接下来 $m$ 行，每行为 ```1 u v d```或 ```2 l r```的形式，分别表示进行一次操作 1（修改）或操作 2（询问）。 ", "outputFormat": "对于每次询问，输出一行一个整数，表示答案对 $1000000007$ 取模的余数。", "hint": "### 样例解释：\n节点个数为 $5$ 的简单路径只有 $1$ 条，权值和为 $5$，故第1次询问输出 $5$。\n\n节点个数为 $1$ 的简单路径有 $5$ 条，每条权值和都是 $1$；节点个数为 $2$ 的简单路径有 $4$ 条，每条权值和都是 $2$，故第2次询问输出 $13 $。\n\n在将点 $1$ 和点 $2$ 的权值加 $2$ 后， $5$ 条节点个数为 $1$ 的简单路径权值和分别为 $3$、$3$、$1$、$1$、$1$，故第 3 次询问输出 $9$。\n\n### 数据范围：\n记操作 1（修改）的次数为 $m^\\prime$。\n\n对于全部数据， 保证 $n \\leq 200000$，$m \\leq 500000$，$ m^\\prime \\leq 100000$，$ 0 \\leq a_i < 1000000007$。\n\n$1 \\leq u \\leq n$，$ 1\\leq v \\leq n$，$ 0 \\leq d < 1000000007$，$l \\leq r \\leq n$。\n\n对于每个数据点的详细规模与约定见下表。\n\n![pic](https://cdn.luogu.com.cn/upload/pic/17580.png)", "locale": "zh-CN"}}}
{"pid": "P4459", "type": "P", "difficulty": 7, "samples": [["5 Bob 2\n", "6 10"], ["2 Alice 3", "4 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "各省省选", "北京", "提交答案", "枚举"], "title": "[BJOI2018] 双人猜数游戏", "background": "本题为提交答案题。可在「附件」中下载输入文件。", "description": "Alice 和 Bob 是一对非常聪明的人，他们可以算出各种各样游戏的最优策略。现在有个综艺节目《最强大佬》请他们来玩一个游戏。主持人写了三个正整数 $s,m,n$，然后一起告诉 Alice 和 Bob $s\\le m\\le n$ 以及 $s$ 是多少。（即，$s$ 是接下来要猜的 $m,n$ 的下限。）之后主持人单独告诉 Alice $m\\times n$ 是多少，单独告诉 Bob $m+n$ 是多少。\n\n当然，如果一个人同时知道 $m\\times n$ 以及 $m+n$ 的话就能很容易地算出 $m$ 和 $n$ 分别是多少，但现在 Alice 和 Bob 只分别知道其中一个，而且他们只能回答主持人的问题，不能交流。主持人从他们中的一人开始，轮流询问回答者“知不知道 $m$ 和 $n$ 分别是多少”（回答者只能回答知道/不知道）。\n\n为了节目效果，以及显示出 Alice 和 Bob 的绝顶聪明，主持人希望 Alice 和 Bob 一共说了 $t$ 次“不知道”以后两个人都知道 $m$ 和 $n$ 是多少了。现在主持人找到你，希望让帮他构造一组符合条件的 $m$ 和 $n$。", "inputFormat": "仅一行，形如 `s <name> t`（`<name>` 为 `Alice` 或 `Bob`），其中 $s$ 表示要猜的数的下限，`<name>` 表示主持人第一次问的人，$t$ 表示 Alice 和 Bob 一共说“不知道”的次数。", "outputFormat": "一行两个整数 $m$ 和 $n$（以一个空格隔开），表示一组满足要求的解。若有多组解，输出 $m+n$ 最小的那组解。若仍有多组解，输出 $m+n$ 最小的解中 $m$ 最小的那组解。", "hint": "#### 样例 1 解释\n主持人告诉 Alice 和 Bob $5\\le m\\le n$，单独告诉 Alice $m\\times n=60$，单独告诉 Bob $m+n=16$。询问过程：\n- 主持人问 Bob，Bob 说不知道。\n- 主持人问 Alice，Alice 说不知道。\n- 主持人问 Bob，Bob 说知道。\n- 主持人问 Alice，Alice 说知道。\n\n#### 样例 2 解释\n主持人告诉 Alice 和 Bob $2\\le m\\le n$，单独告诉 Alice $m\\times n=16$，单独告诉 Bob $m+n=8$。询问过程：\n- 主持人问 Alice，Alice 说不知道。\n- 主持人问 Bob，Bob 说不知道。\n- 主持人问 Alice，Alice 说不知道。\n- 主持人问 Bob，Bob 说知道。\n- 主持人问 Alice，Alice 说知道。\n\n#### 数据规模与约定\n对于 $40\\%$ 的数据，$t=2$；\n\n对于 $100\\%$ 的数据，$1\\le s\\le 200$，$2\\le t\\le 15$，保证有解。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2018] Two-Player Number Guessing Game", "background": "This is an answer-submission problem. You can download the input file from \"Attachment\".", "description": "Alice and Bob are very smart; they can figure out optimal strategies for all kinds of games. A variety show \"The Strongest Boss\" invites them to play a game. The host writes three positive integers $s, m, n$, then tells Alice and Bob together that $s \\le m \\le n$ and what $s$ is. (That is, $s$ is the lower bound for the $m, n$ to be guessed.) Then the host privately tells Alice what $m \\times n$ is, and privately tells Bob what $m + n$ is.\n\nOf course, if one person knows both $m \\times n$ and $m + n$, they can easily compute $m$ and $n$, but now Alice and Bob each know only one of them, and they can only answer the host’s questions without communicating. Starting from one of them, the host alternately asks the current respondent, “Do you know what $m$ and $n$ are?” The respondent can only answer “know” or “don’t know.”\n\nFor show effects and to demonstrate Alice and Bob’s brilliance, the host wants that after a total of $t$ “don’t know” answers, both Alice and Bob will know what $m$ and $n$ are. Now the host asks you to construct a pair $m$ and $n$ that satisfies the requirements.", "inputFormat": "A single line in the form `s <name> t` (where `<name>` is `Alice` or `Bob`), where $s$ is the lower bound for the numbers to guess, `<name>` is the person the host asks first, and $t$ is the total number of “don’t know” answers from Alice and Bob.", "outputFormat": "Output two integers $m$ and $n$ (separated by a space), representing one valid solution. If there are multiple solutions, output the one with the smallest $m + n$. If there are still multiple, among those with minimal $m + n$, output the one with the smallest $m$.", "hint": "#### Sample 1 Explanation\nThe host tells Alice and Bob that $5 \\le m \\le n$, privately tells Alice $m \\times n = 60$, and privately tells Bob $m + n = 16$. The questioning process:\n- The host asks Bob; Bob says “don’t know.”\n- The host asks Alice; Alice says “don’t know.”\n- The host asks Bob; Bob says “know.”\n- The host asks Alice; Alice says “know.”\n\n#### Sample 2 Explanation\nThe host tells Alice and Bob that $2 \\le m \\le n$, privately tells Alice $m \\times n = 16$, and privately tells Bob $m + n = 8$. The questioning process:\n- The host asks Alice; Alice says “don’t know.”\n- The host asks Bob; Bob says “don’t know.”\n- The host asks Alice; Alice says “don’t know.”\n- The host asks Bob; Bob says “know.”\n- The host asks Alice; Alice says “know.”\n\n#### Constraints and Conventions\n- For $40\\%$ of the testdata, $t = 2$.\n- For $100\\%$ of the testdata, $1 \\le s \\le 200$, $2 \\le t \\le 15$, and a solution exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2018] 双人猜数游戏", "background": "本题为提交答案题。可在「附件」中下载输入文件。", "description": "Alice 和 Bob 是一对非常聪明的人，他们可以算出各种各样游戏的最优策略。现在有个综艺节目《最强大佬》请他们来玩一个游戏。主持人写了三个正整数 $s,m,n$，然后一起告诉 Alice 和 Bob $s\\le m\\le n$ 以及 $s$ 是多少。（即，$s$ 是接下来要猜的 $m,n$ 的下限。）之后主持人单独告诉 Alice $m\\times n$ 是多少，单独告诉 Bob $m+n$ 是多少。\n\n当然，如果一个人同时知道 $m\\times n$ 以及 $m+n$ 的话就能很容易地算出 $m$ 和 $n$ 分别是多少，但现在 Alice 和 Bob 只分别知道其中一个，而且他们只能回答主持人的问题，不能交流。主持人从他们中的一人开始，轮流询问回答者“知不知道 $m$ 和 $n$ 分别是多少”（回答者只能回答知道/不知道）。\n\n为了节目效果，以及显示出 Alice 和 Bob 的绝顶聪明，主持人希望 Alice 和 Bob 一共说了 $t$ 次“不知道”以后两个人都知道 $m$ 和 $n$ 是多少了。现在主持人找到你，希望让帮他构造一组符合条件的 $m$ 和 $n$。", "inputFormat": "仅一行，形如 `s <name> t`（`<name>` 为 `Alice` 或 `Bob`），其中 $s$ 表示要猜的数的下限，`<name>` 表示主持人第一次问的人，$t$ 表示 Alice 和 Bob 一共说“不知道”的次数。", "outputFormat": "一行两个整数 $m$ 和 $n$（以一个空格隔开），表示一组满足要求的解。若有多组解，输出 $m+n$ 最小的那组解。若仍有多组解，输出 $m+n$ 最小的解中 $m$ 最小的那组解。", "hint": "#### 样例 1 解释\n主持人告诉 Alice 和 Bob $5\\le m\\le n$，单独告诉 Alice $m\\times n=60$，单独告诉 Bob $m+n=16$。询问过程：\n- 主持人问 Bob，Bob 说不知道。\n- 主持人问 Alice，Alice 说不知道。\n- 主持人问 Bob，Bob 说知道。\n- 主持人问 Alice，Alice 说知道。\n\n#### 样例 2 解释\n主持人告诉 Alice 和 Bob $2\\le m\\le n$，单独告诉 Alice $m\\times n=16$，单独告诉 Bob $m+n=8$。询问过程：\n- 主持人问 Alice，Alice 说不知道。\n- 主持人问 Bob，Bob 说不知道。\n- 主持人问 Alice，Alice 说不知道。\n- 主持人问 Bob，Bob 说知道。\n- 主持人问 Alice，Alice 说知道。\n\n#### 数据规模与约定\n对于 $40\\%$ 的数据，$t=2$；\n\n对于 $100\\%$ 的数据，$1\\le s\\le 200$，$2\\le t\\le 15$，保证有解。", "locale": "zh-CN"}}}
{"pid": "P4460", "type": "P", "difficulty": 5, "samples": [["4\n0 0\n1 1\n2 2\n3 3", "8"], ["4\n0 0\n0 1\n0 2\n1 0", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "重庆", "各省省选", "广度优先搜索 BFS", "状压 DP"], "title": "[CQOI2018] 解锁屏幕", "background": "使用过 Android 手机的同学一定对手势解锁屏幕不陌生。 Android 的解锁屏幕由 $3 \\times 3$ 个点组成，手指在屏幕上画一条线，将其中一些点连接起来，即可构成一个解锁图案。如下面三个例子所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/17556.png)\n![](https://cdn.luogu.com.cn/upload/pic/17557.png)\n![](https://cdn.luogu.com.cn/upload/pic/17558.png)", "description": "画线时还需要遵循一些规则：\n1. 连接的点数不能少于 $4$ 个。也就是说只连接两个点或者三个点会提示错误。\n2. 两个点之间的联线不能弯曲。\n3. 每个点只能“使用”一次，不可重复。这里的“使用”是指手指划过一个点，该点变绿。\n4. 两个点之间的连线不能“跨过”另一个点，除非那个点之前已经被“使用”过。\n\n对于最后一条规则，参见下图的解释。左边两幅图违反了该规则；而右边两幅图（分别为 $ 2 \\rightarrow 4 \\rightarrow 1 \\rightarrow 3 \\rightarrow 6$ 和 $ 6 \\rightarrow 5 \\rightarrow 4 \\rightarrow 1 \\rightarrow 9 \\rightarrow 2$ ）则没有违反规则，因为在“跨过”点时，点已经被使用过了。\n\n![](https://cdn.luogu.com.cn/upload/pic/17566.png)\n\n现在工程师希望改进解锁屏幕，增减点的数目，并移动点的位置，不再是一个九宫格形状，但保持上述画线规则不变。\n\n请计算新的解锁屏幕上，一共有多少满足规则的画线方案。", "inputFormat": "输入第一行为一个整数 $n$ ，表示点的数目。\n\n接下来 $n$ 行，每行两个空格分开的整数 $x_i$ 和 $y_i$ ，表示每个点的坐标。", "outputFormat": "输出共一行，为题目所求方案数除以 $10^8+7$ 的余数。", "hint": "#### 样例解释 1\n\n设 $4$ 个点编号为 $1$ 到 $4$ ，方案有 $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4$ ， $2 \\rightarrow 1 \\rightarrow 3 \\rightarrow 4$ ，  $3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 4$ ，  $2 \\rightarrow 3 \\rightarrow 1 \\rightarrow 4$ 以及它们的镜像。\n\n### 数据范围\n\n- 对于 $30\\%$ 的数据，$1 \\le n \\le 10$。\n- 对于 $100\\%$ 的数据，$-1000 \\le x_i ,y_i \\le 1000$，$ 1 \\le n < 20$。各点坐标不相同。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2018] Unlock Screen", "background": "Anyone who has used an Android phone should be familiar with gesture unlocking. Android’s lock screen consists of $3 \\times 3$ points. By drawing a line on the screen to connect some of these points, you can form an unlock pattern. As shown in the three examples below:\n\n![](https://cdn.luogu.com.cn/upload/pic/17556.png)\n![](https://cdn.luogu.com.cn/upload/pic/17557.png)\n![](https://cdn.luogu.com.cn/upload/pic/17558.png)", "description": "When drawing the line, you must also follow some rules:\n1. The number of connected points must be at least $4$. That is, connecting only two or three points will be considered invalid.\n2. The segment between two points must be straight; it cannot bend.\n3. Each point can be “used” at most once and cannot be repeated. Here, “use” means your finger passes over a point and it turns green.\n4. A segment between two points cannot “pass over” another point, unless that point has already been “used” earlier.\n\nFor the last rule, see the explanation in the figure below. The two figures on the left violate the rule; the two on the right (namely $ 2 \\rightarrow 4 \\rightarrow 1 \\rightarrow 3 \\rightarrow 6$ and $ 6 \\rightarrow 5 \\rightarrow 4 \\rightarrow 1 \\rightarrow 9 \\rightarrow 2$) do not violate the rule because, when “passing over” a point, that point has already been used.\n\n![](https://cdn.luogu.com.cn/upload/pic/17566.png)\n\nNow engineers want to improve the unlock screen by increasing or decreasing the number of points and moving their positions, so it is no longer a $3 \\times 3$ grid, while keeping the drawing rules above unchanged.\n\nPlease compute how many line-drawing patterns on the new unlock screen satisfy the rules.", "inputFormat": "The first line contains an integer $n$, the number of points.\n\nThe next $n$ lines each contain two space-separated integers $x_i$ and $y_i$, the coordinates of each point.", "outputFormat": "Output a single line with the answer modulo $10^8+7$.", "hint": "#### Sample Explanation 1\n\nLet the $4$ points be indexed $1$ to $4$. The valid patterns are $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4$, $2 \\rightarrow 1 \\rightarrow 3 \\rightarrow 4$, $3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 4$, $2 \\rightarrow 3 \\rightarrow 1 \\rightarrow 4$, and their mirror images.\n\n### Constraints\n\n- For $30\\%$ of the testdata, $1 \\le n \\le 10$.\n- For $100\\%$ of the testdata, $-1000 \\le x_i, y_i \\le 1000$, $1 \\le n < 20$. All point coordinates are distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2018] 解锁屏幕", "background": "使用过 Android 手机的同学一定对手势解锁屏幕不陌生。 Android 的解锁屏幕由 $3 \\times 3$ 个点组成，手指在屏幕上画一条线，将其中一些点连接起来，即可构成一个解锁图案。如下面三个例子所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/17556.png)\n![](https://cdn.luogu.com.cn/upload/pic/17557.png)\n![](https://cdn.luogu.com.cn/upload/pic/17558.png)", "description": "画线时还需要遵循一些规则：\n1. 连接的点数不能少于 $4$ 个。也就是说只连接两个点或者三个点会提示错误。\n2. 两个点之间的联线不能弯曲。\n3. 每个点只能“使用”一次，不可重复。这里的“使用”是指手指划过一个点，该点变绿。\n4. 两个点之间的连线不能“跨过”另一个点，除非那个点之前已经被“使用”过。\n\n对于最后一条规则，参见下图的解释。左边两幅图违反了该规则；而右边两幅图（分别为 $ 2 \\rightarrow 4 \\rightarrow 1 \\rightarrow 3 \\rightarrow 6$ 和 $ 6 \\rightarrow 5 \\rightarrow 4 \\rightarrow 1 \\rightarrow 9 \\rightarrow 2$ ）则没有违反规则，因为在“跨过”点时，点已经被使用过了。\n\n![](https://cdn.luogu.com.cn/upload/pic/17566.png)\n\n现在工程师希望改进解锁屏幕，增减点的数目，并移动点的位置，不再是一个九宫格形状，但保持上述画线规则不变。\n\n请计算新的解锁屏幕上，一共有多少满足规则的画线方案。", "inputFormat": "输入第一行为一个整数 $n$ ，表示点的数目。\n\n接下来 $n$ 行，每行两个空格分开的整数 $x_i$ 和 $y_i$ ，表示每个点的坐标。", "outputFormat": "输出共一行，为题目所求方案数除以 $10^8+7$ 的余数。", "hint": "#### 样例解释 1\n\n设 $4$ 个点编号为 $1$ 到 $4$ ，方案有 $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4$ ， $2 \\rightarrow 1 \\rightarrow 3 \\rightarrow 4$ ，  $3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 4$ ，  $2 \\rightarrow 3 \\rightarrow 1 \\rightarrow 4$ 以及它们的镜像。\n\n### 数据范围\n\n- 对于 $30\\%$ 的数据，$1 \\le n \\le 10$。\n- 对于 $100\\%$ 的数据，$-1000 \\le x_i ,y_i \\le 1000$，$ 1 \\le n < 20$。各点坐标不相同。", "locale": "zh-CN"}}}
{"pid": "P4461", "type": "P", "difficulty": 6, "samples": [["3\n3\n5\n9", "5\n21\n341"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "2018", "重庆", "各省省选", "快速傅里叶变换 FFT"], "title": "[CQOI2018] 九连环", "background": "九连环是一种源于中国的传统智力游戏。如图所示，九个的圆环套在一把“剑”上，并且互相牵连。游戏的目标是把九个圆环全部从“剑”上卸下。\n\n![](https://cdn.luogu.com.cn/upload/pic/17568.png)", "description": "圆环的装卸需要遵守两个规则:\n\n1. 第一个(最右边) 环任何时候都可以任意装上或卸下。\n\n2. 如果第 $k$ 个环没有被卸下，且第 $k$ 个环右边的所有环都被卸下，则第 $k+1$ 个环(第 $k$ 个环左边相邻的环) 可以任意装上或卸下。\n\n与魔方的千变万化不同，解九连环的最优策略是唯一的。为简单起见，我们以“四连环”为例，演示这一过程。这里用 1 表示环在“剑”上，0 表示环已经卸下。\n\n初始状态为 1111，每步的操作如下:\n\n1. 1101 (根据规则 2,卸下第 2 个环)\n\n2. 1100 (根据规则 1,卸下第 1 个环)\n\n3. 0100 (根据规则 2,卸下第 4 个环)\n\n4. 0101 (根据规则 1,装上第 1 个环)\n\n5. 0111 (根据规则 2,装上第 2 个环)\n\n6. 0110 (根据规则 1,卸下第 1 个环)\n\n7. 0010 (根据规则 2,卸下第 3 个环)\n\n8. 0011 (根据规则 1,装上第 1 个环)\n\n9. 0001 (根据规则 2,卸下第 2 个环)\n\n10. 0000 (根据规则 1,卸下第 1 个环)\n\n由此可见，卸下“四连环”至少需要 $10$ 步。随着环数增加，需要的步数也会随之增多。例如卸下九连环，就至少需要 $341$ 步。\n\n请你计算，有 $n$ 个环的情况下，按照规则，全部卸下至少需要多少步。", "inputFormat": "输入文件第一行，为一个整数 $m$，表示测试点数目。\n\n接下来 $m$ 行，每行一个整数 $n$。", "outputFormat": "输出文件共 $m$ 行，对应每个测试点的计算结果。", "hint": "对于 $10\\%$ 的数据，$1≤n≤10$\n\n对于 $30\\%$ 的数据，$1≤n≤30$\n\n对于 $100\\%$ 的数据，$1≤n≤10^5,1≤m≤10$", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2018] Nine Linked Rings", "background": "The Nine Linked Rings is a traditional Chinese puzzle game. As shown in the figure, nine rings are looped onto a \"sword\" and interlinked. The goal is to remove all nine rings from the \"sword\".\n\n![](https://cdn.luogu.com.cn/upload/pic/17568.png)", "description": "Attaching and removing the rings must follow two rules:\n\n1. The first (rightmost) ring can be attached or removed at any time.\n\n2. If the $k$-th ring is not removed and all rings to the right of the $k$-th ring have been removed, then the $(k+1)$-th ring (the ring immediately to the left of the $k$-th ring) can be attached or removed arbitrarily.\n\nUnlike the Rubik's Cube with its myriad variations, the optimal strategy for the Nine Linked Rings is unique. For simplicity, we take the four-ring case as an example to demonstrate the process. Here, 1 means the ring is on the \"sword\", and 0 means the ring has been removed.\n\nThe initial state is 1111, and the operations at each step are as follows:\n\n1. 1101 (according to rule 2, remove the 2nd ring).\n2. 1100 (according to rule 1, remove the 1st ring).\n3. 0100 (according to rule 2, remove the 4th ring).\n4. 0101 (according to rule 1, attach the 1st ring).\n5. 0111 (according to rule 2, attach the 2nd ring).\n6. 0110 (according to rule 1, remove the 1st ring).\n7. 0010 (according to rule 2, remove the 3rd ring).\n8. 0011 (according to rule 1, attach the 1st ring).\n9. 0001 (according to rule 2, remove the 2nd ring).\n10. 0000 (according to rule 1, remove the 1st ring).\n\nThus, removing the four-ring set requires at least $10$ steps. As the number of rings increases, the required number of steps also increases. For example, removing nine rings requires at least $341$ steps.\n\nPlease compute, for $n$ rings, the minimum number of steps required to remove all rings under the rules.", "inputFormat": "The first line contains an integer $m$, the number of test cases.\n\nThe next $m$ lines each contain an integer $n$.", "outputFormat": "Output $m$ lines, each containing the result for the corresponding test case.", "hint": "For 10% of the testdata, $1 \\le n \\le 10$.\n\nFor 30% of the testdata, $1 \\le n \\le 30$.\n\nFor 100% of the testdata, $1 \\le n \\le 10^5$, $1 \\le m \\le 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2018] 九连环", "background": "九连环是一种源于中国的传统智力游戏。如图所示，九个的圆环套在一把“剑”上，并且互相牵连。游戏的目标是把九个圆环全部从“剑”上卸下。\n\n![](https://cdn.luogu.com.cn/upload/pic/17568.png)", "description": "圆环的装卸需要遵守两个规则:\n\n1. 第一个(最右边) 环任何时候都可以任意装上或卸下。\n\n2. 如果第 $k$ 个环没有被卸下，且第 $k$ 个环右边的所有环都被卸下，则第 $k+1$ 个环(第 $k$ 个环左边相邻的环) 可以任意装上或卸下。\n\n与魔方的千变万化不同，解九连环的最优策略是唯一的。为简单起见，我们以“四连环”为例，演示这一过程。这里用 1 表示环在“剑”上，0 表示环已经卸下。\n\n初始状态为 1111，每步的操作如下:\n\n1. 1101 (根据规则 2,卸下第 2 个环)\n\n2. 1100 (根据规则 1,卸下第 1 个环)\n\n3. 0100 (根据规则 2,卸下第 4 个环)\n\n4. 0101 (根据规则 1,装上第 1 个环)\n\n5. 0111 (根据规则 2,装上第 2 个环)\n\n6. 0110 (根据规则 1,卸下第 1 个环)\n\n7. 0010 (根据规则 2,卸下第 3 个环)\n\n8. 0011 (根据规则 1,装上第 1 个环)\n\n9. 0001 (根据规则 2,卸下第 2 个环)\n\n10. 0000 (根据规则 1,卸下第 1 个环)\n\n由此可见，卸下“四连环”至少需要 $10$ 步。随着环数增加，需要的步数也会随之增多。例如卸下九连环，就至少需要 $341$ 步。\n\n请你计算，有 $n$ 个环的情况下，按照规则，全部卸下至少需要多少步。", "inputFormat": "输入文件第一行，为一个整数 $m$，表示测试点数目。\n\n接下来 $m$ 行，每行一个整数 $n$。", "outputFormat": "输出文件共 $m$ 行，对应每个测试点的计算结果。", "hint": "对于 $10\\%$ 的数据，$1≤n≤10$\n\n对于 $30\\%$ 的数据，$1≤n≤30$\n\n对于 $100\\%$ 的数据，$1≤n≤10^5,1≤m≤10$", "locale": "zh-CN"}}}
{"pid": "P4462", "type": "P", "difficulty": 5, "samples": [["4 5 1\n1 2 3 1\n1 4\n1 3\n2 3\n2 4\n4 4", "4\n2\n1\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "重庆", "莫队", "各省省选", "进制", "前缀和"], "title": "[CQOI2018] 异或序列", "background": "", "description": "已知一个长度为 $n$ 的整数数列 $a_1,a_2,\\dots,a_n$，给定查询参数 $l,r$，问在 $a_l,a_{l+1},\\dots,a_r$ 区间内，有多少子区间满足异或和等于 $k$。也就是说，对于所有的 $x,y (l \\leq x \\leq y \\leq r)$，能够满足 $a_x \\oplus a_{x+1} \\oplus \\dots \\oplus a_y = k$ 的 $x,y$ 有多少组。\n", "inputFormat": "输入文件第一行，为 $3$ 个整数 $n,m,k$。\n\n第二行为空格分开的 $n$ 个整数，即 $a_1,a_2,..a_n$。\n\n接下来 $m$ 行，每行两个整数 $l_j,r_j$，表示一次查询。", "outputFormat": "输出文件共 $m$ 行，对应每个查询的计算结果。", "hint": "对于 $30\\%$ 的数据，$1 \\leq n, m \\leq 1000$。\n\n对于 $100\\%$ 的数据，$1 \\leq n, m \\leq 10^5$，$0 \\leq k, a_i \\leq 10^5$，$1 \\leq l_j \\leq r_j \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2018] XOR Sequence", "background": "", "description": "Given an integer sequence $a_1, a_2, \\dots, a_n$ of length $n$, for a query with parameters $l, r$, ask how many subarrays within $a_l, a_{l+1}, \\dots, a_r$ have xor-sum equal to $k$. That is, among all $x, y$ such that $(l \\leq x \\leq y \\leq r)$, how many pairs $(x, y)$ satisfy $a_x \\oplus a_{x+1} \\oplus \\dots \\oplus a_y = k$.", "inputFormat": "The first line contains three integers $n, m, k$.\n\nThe second line contains $n$ integers separated by spaces, namely $a_1, a_2, \\dots, a_n$.\n\nEach of the next $m$ lines contains two integers $l_j$ and $r_j$, representing one query.", "outputFormat": "Output $m$ lines, each corresponding to the answer for one query.", "hint": "For $30\\%$ of the testdata, $1 \\leq n, m \\leq 1000$.\n\nFor $100\\%$ of the testdata, $1 \\leq n, m \\leq 10^5$, $0 \\leq k, a_i \\leq 10^5$, $1 \\leq l_j \\leq r_j \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2018] 异或序列", "background": "", "description": "已知一个长度为 $n$ 的整数数列 $a_1,a_2,\\dots,a_n$，给定查询参数 $l,r$，问在 $a_l,a_{l+1},\\dots,a_r$ 区间内，有多少子区间满足异或和等于 $k$。也就是说，对于所有的 $x,y (l \\leq x \\leq y \\leq r)$，能够满足 $a_x \\oplus a_{x+1} \\oplus \\dots \\oplus a_y = k$ 的 $x,y$ 有多少组。\n", "inputFormat": "输入文件第一行，为 $3$ 个整数 $n,m,k$。\n\n第二行为空格分开的 $n$ 个整数，即 $a_1,a_2,..a_n$。\n\n接下来 $m$ 行，每行两个整数 $l_j,r_j$，表示一次查询。", "outputFormat": "输出文件共 $m$ 行，对应每个查询的计算结果。", "hint": "对于 $30\\%$ 的数据，$1 \\leq n, m \\leq 1000$。\n\n对于 $100\\%$ 的数据，$1 \\leq n, m \\leq 10^5$，$0 \\leq k, a_i \\leq 10^5$，$1 \\leq l_j \\leq r_j \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4463", "type": "P", "difficulty": 6, "samples": [["9 7 10007", "3611"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "数学", "2012", "集训队互测", "生成函数"], "title": "[集训队互测 2012] calc", "background": "", "description": "一个序列 $a_1,a_2,\\dots,a_n$ 是合法的，当且仅当：\n\n- $a_1,a_2,\\dots,a_n$ 都是 $[1,k]$ 中的整数。\n- $a_1,a_2,\\dots,a_n$ 互不相等。\n\n一个序列的值定义为它里面所有数的乘积，即 $a_1\\times a_2\\times\\dots\\times a_n$。\n\n求所有不同合法序列的值的和对 $p$ 取模后的结果。两个序列不同当且仅当他们任意一位不同。", "inputFormat": "一行三个正整数 $k, n, p$。意义为上面所说的。", "outputFormat": "一行结果。", "hint": "【数据范围】\n\n对于 $5\\%$ 的数据，$k \\le 10$，$n \\le 10$。\n\n对于 $20\\%$ 的数据，$k \\le 1000$，$n \\le 20$。\n\n对于 $50\\%$ 的数据，$k \\le 10^9$，$n \\le 20$。\n\n对于 $100\\%$ 的数据，$k \\le 10 ^ 9$，$n \\le 500$，$p \\le 10 ^ 9$，保证 $p$ 为素数，保证 $n + 1 < k < p$。\n\nby WJMZBMR\n****\n$\\mathsf i \\color{red}\\mathsf{ostream}$ 觉得这题数据太弱了，于是他造了个[加强版](https://www.luogu.com.cn/problem/P5850)", "locale": "zh-CN", "translations": {"en": {"title": "[CTT Mutual Test 2012] calc", "background": "", "description": "A sequence $a_1, a_2, \\dots, a_n$ is valid if and only if:\n- $a_1, a_2, \\dots, a_n$ are all integers in $[1, k]$.\n- $a_1, a_2, \\dots, a_n$ are pairwise distinct.\n\nThe value of a sequence is defined as the product of all its numbers, i.e., $a_1\\times a_2\\times\\dots\\times a_n$.\n\nCompute the sum of the values of all distinct valid sequences, modulo $p$. Two sequences are different if and only if they differ at any position.", "inputFormat": "One line with three positive integers $k, n, p$, as described above.", "outputFormat": "One line with the result.", "hint": "Constraints\n\nFor $5\\%$ of the testdata, $k \\le 10$, $n \\le 10$.\n\nFor $20\\%$ of the testdata, $k \\le 1000$, $n \\le 20$.\n\nFor $50\\%$ of the testdata, $k \\le 10^9$, $n \\le 20$.\n\nFor $100\\%$ of the testdata, $k \\le 10^9$, $n \\le 500$, $p \\le 10^9$, it is guaranteed that $p$ is prime and $n + 1 < k < p$.\n\nby WJMZBMR\n****\n$\\mathsf i \\color{red}\\mathsf{ostream}$ thinks the testdata for this problem is too weak, so he made a [harder version](https://www.luogu.com.cn/problem/P5850).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[集训队互测 2012] calc", "background": "", "description": "一个序列 $a_1,a_2,\\dots,a_n$ 是合法的，当且仅当：\n\n- $a_1,a_2,\\dots,a_n$ 都是 $[1,k]$ 中的整数。\n- $a_1,a_2,\\dots,a_n$ 互不相等。\n\n一个序列的值定义为它里面所有数的乘积，即 $a_1\\times a_2\\times\\dots\\times a_n$。\n\n求所有不同合法序列的值的和对 $p$ 取模后的结果。两个序列不同当且仅当他们任意一位不同。", "inputFormat": "一行三个正整数 $k, n, p$。意义为上面所说的。", "outputFormat": "一行结果。", "hint": "【数据范围】\n\n对于 $5\\%$ 的数据，$k \\le 10$，$n \\le 10$。\n\n对于 $20\\%$ 的数据，$k \\le 1000$，$n \\le 20$。\n\n对于 $50\\%$ 的数据，$k \\le 10^9$，$n \\le 20$。\n\n对于 $100\\%$ 的数据，$k \\le 10 ^ 9$，$n \\le 500$，$p \\le 10 ^ 9$，保证 $p$ 为素数，保证 $n + 1 < k < p$。\n\nby WJMZBMR\n****\n$\\mathsf i \\color{red}\\mathsf{ostream}$ 觉得这题数据太弱了，于是他造了个[加强版](https://www.luogu.com.cn/problem/P5850)", "locale": "zh-CN"}}}
{"pid": "P4464", "type": "P", "difficulty": 7, "samples": [["5\n6 0 0\n6 0 1\n6 1 0\n6 1 1\n1000000000 50 50", "6\n66\n15\n126\n393442025"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "集训队互测"], "title": "[国家集训队] JZPKIL", "background": "", "description": "给定$ n, x, y$，求\n\n$$\\sum_{i=1}^{n}\\mathrm{gcd}(i,n)^x \\mathrm{lcm}(i,n)^y \\bmod (10^9+7)$$\n\n", "inputFormat": "第一行，询问个数 $T$。\n\n下面 $T$ 行，每行三个整数 $n, x, y$。", "outputFormat": "$T$ 行，每行一个整数，表示相应的询问的答案", "hint": "30%的数据，$x=y$\n\n另30%的数据，$n \\le 10^9, x, y \\le 100$\n\n100%的数据，$T \\le 100, 1 \\le n \\le 10^{18}, 0 \\le x, y \\le 3000$\n\n来源：2012集训队互测，by gyz", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] JZPKIL", "background": "", "description": "Given $n, x, y$, compute\n$$\\sum_{i=1}^{n}\\mathrm{gcd}(i,n)^x \\mathrm{lcm}(i,n)^y \\bmod (10^9+7)$$\n.", "inputFormat": "The first line contains the number of queries $T$.\nEach of the next $T$ lines contains three integers $n, x, y$.", "outputFormat": "Output $T$ lines, each containing one integer, the answer to the corresponding query.", "hint": "Constraints:\nFor 30% of the testdata, $x = y$.\nFor another 30% of the testdata, $n \\le 10^9$, $x, y \\le 100$.\nFor 100% of the testdata, $T \\le 100$, $1 \\le n \\le 10^{18}$, $0 \\le x, y \\le 3000$.\n\nSource: 2012 CTT mutual testing, by gyz.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] JZPKIL", "background": "", "description": "给定$ n, x, y$，求\n\n$$\\sum_{i=1}^{n}\\mathrm{gcd}(i,n)^x \\mathrm{lcm}(i,n)^y \\bmod (10^9+7)$$\n\n", "inputFormat": "第一行，询问个数 $T$。\n\n下面 $T$ 行，每行三个整数 $n, x, y$。", "outputFormat": "$T$ 行，每行一个整数，表示相应的询问的答案", "hint": "30%的数据，$x=y$\n\n另30%的数据，$n \\le 10^9, x, y \\le 100$\n\n100%的数据，$T \\le 100, 1 \\le n \\le 10^{18}, 0 \\le x, y \\le 3000$\n\n来源：2012集训队互测，by gyz", "locale": "zh-CN"}}}
{"pid": "P4465", "type": "P", "difficulty": 6, "samples": [["8\n0 0 894894894\n2 0 2 894\n2 0 9 894\n0 2 6\n2 0 9 64\n2 0 9 894\n1 2 6\n2 0 6 894", "0\n3\n1\n1\n2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "2012", "集训队互测", "后缀自动机 SAM", "分块", "bitset"], "title": "[国家集训队] JZPSTR", "background": null, "description": "你要对一个字符串进行三种操作：\n\n0. 在位置 $x_i$ 处插入一个字符串 $y_i$；\n\n1. 删除位置 $[x_i, y_i)$ 的字符串；\n\n2. 查询位置 $[x_i, y_i)$ 的字符串包含多少次给定的子串 $z_i$。", "inputFormat": "第一行，一个整数 $T$，表示操作个数。\n\n下面 $T$ 行，每行第一个数 $p_i$，表示这个操作的类型：\n\n若 $p_i=0$，则接下来有一个整数 $x_i$ 和一个字符串$y_i$，表示进行插入操作；\n\n若 $p_i=1$，则接下来有两个整数 $x_i$ 和 $y_i$，表示进行删除操作；\n\n若 $p_i=2$，则接下来有两个整数 $x_i$ 和 $y_i$，以及一个字符串 $z_i$，表示进行询问。\n\n字符串的下标从 $0$ 开始（即第一个字符的下标为 $0$）。\n\n初始时字符串为空。\n\n对于插入操作，插入后字符串 $y_i$ 的首字符的下标应为 $x_i$；\n\n对于删除操作，删除的区间 $[x_i, y_i)$ 为左闭右开区间；\n\n对于查询操作，询问的区间 $[x_i, y_i)$ 为左闭右开区间。\n\n所有插入的和查询的字符串均不为空，且只包含字符 $\\texttt 0\\sim\\texttt9$。\n\n所有询问的区间和删除的区间均不为空。\n\n保证输入数据合法。\n\n对于“左闭右开区间”不理解的可以去看样例解释。", "outputFormat": "对每个询问操作，输出一行，表示这个询问的答案。", "hint": "样例解释：\n- 第一次操作后，字符串为 $\\texttt{894894894}$；\n\n- 第二次操作，询问的区间为 $\\texttt{89}$，不包含任何 $\\texttt{894}$；\n\n- 第三次操作，询问的区间为 $\\texttt{894894894}$，包含三个 $\\texttt{894}$；\n\n- 第四次操作后，字符串为 $\\texttt{8964894894}$；\n\n- 第五次操作，询问的区间为 $\\texttt{896489489}$，包含一个 $\\texttt{64}$；\n\n- 第六次操作，询问的区间为 $\\texttt{896489489}$，包含一个 $\\texttt{894}$；\n\n- 第七次操作后，字符串为 $\\texttt{894894}$；\n\n- 第八次操作，询问的区间为 $\\texttt{894894}$，包含两个 $\\texttt{894}$。\n\n数据范围：\n- $50\\%$ 的数据中，询问个数 $\\le100$ （不是操作个数）；\n\n- $100\\%$ 的数据中，插入总长度 $\\le 2\\times10^6$，任何时刻字符串长度 $\\le 10^6$，插入次数 $\\le 1001$，删除次数 $\\le  1000$，询问的 $z_i$ 的总长度 $\\le 10^4$。\n\n来源：2012 集训队互测，by gyz", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] JZPSTR", "background": "", "description": "You need to perform three types of operations on a string:\n0. Insert a string $y_i$ at position $x_i$.\n1. Delete the substring in the interval $[x_i, y_i)$.\n2. Query how many times a given substring $z_i$ occurs in the substring of the interval $[x_i, y_i)$.\n\nThe indices of the string start from $0$ (that is, the first character has index $0$).\n\nInitially, the string is empty.\n\nFor the insertion operation, after insertion the first character of $y_i$ should have index $x_i$.\nFor the deletion operation, the interval $[x_i, y_i)$ is a left-closed, right-open interval.\nFor the query operation, the interval $[x_i, y_i)$ is a left-closed, right-open interval.\n\nAll inserted strings and query strings are non-empty and contain only characters $\\texttt{0}\\sim\\texttt{9}$.\n\nAll query intervals and deletion intervals are non-empty.\n\nThe input is guaranteed to be valid.\n\nIf you do not understand the term \"left-closed, right-open interval\", please see the sample explanation.", "inputFormat": "The first line contains an integer $T$, the number of operations.\n\nIn the following $T$ lines, the first number $p_i$ indicates the type of the operation:\n- If $p_i=0$, then an integer $x_i$ and a string $y_i$ follow, indicating an insertion.\n- If $p_i=1$, then two integers $x_i$ and $y_i$ follow, indicating a deletion.\n- If $p_i=2$, then two integers $x_i$ and $y_i$, and a string $z_i$ follow, indicating a query.", "outputFormat": "For each query operation, output one line with the answer to that query.", "hint": "Sample explanation:\n- After the first operation, the string is $\\texttt{894894894}$.\n- In the second operation, the queried interval is $\\texttt{89}$, which contains no $\\texttt{894}$.\n- In the third operation, the queried interval is $\\texttt{894894894}$, which contains three $\\texttt{894}$.\n- After the fourth operation, the string is $\\texttt{8964894894}$.\n- In the fifth operation, the queried interval is $\\texttt{896489489}$, which contains one $\\texttt{64}$.\n- In the sixth operation, the queried interval is $\\texttt{896489489}$, which contains one $\\texttt{894}$.\n- After the seventh operation, the string is $\\texttt{894894}$.\n- In the eighth operation, the queried interval is $\\texttt{894894}$, which contains two $\\texttt{894}$.\n\nConstraints:\n- In $50\\%$ of the testdata, the number of queries $\\le 100$ (not the number of operations).\n- In $100\\%$ of the testdata, the total inserted length $\\le 2\\times 10^6$, the string length at any time $\\le 10^6$, the number of insertions $\\le 1001$, the number of deletions $\\le 1000$, and the total length of all queried $z_i$ $\\le 10^4$.\n\nSource: 2012 CTT internal contest, by gyz.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] JZPSTR", "background": null, "description": "你要对一个字符串进行三种操作：\n\n0. 在位置 $x_i$ 处插入一个字符串 $y_i$；\n\n1. 删除位置 $[x_i, y_i)$ 的字符串；\n\n2. 查询位置 $[x_i, y_i)$ 的字符串包含多少次给定的子串 $z_i$。", "inputFormat": "第一行，一个整数 $T$，表示操作个数。\n\n下面 $T$ 行，每行第一个数 $p_i$，表示这个操作的类型：\n\n若 $p_i=0$，则接下来有一个整数 $x_i$ 和一个字符串$y_i$，表示进行插入操作；\n\n若 $p_i=1$，则接下来有两个整数 $x_i$ 和 $y_i$，表示进行删除操作；\n\n若 $p_i=2$，则接下来有两个整数 $x_i$ 和 $y_i$，以及一个字符串 $z_i$，表示进行询问。\n\n字符串的下标从 $0$ 开始（即第一个字符的下标为 $0$）。\n\n初始时字符串为空。\n\n对于插入操作，插入后字符串 $y_i$ 的首字符的下标应为 $x_i$；\n\n对于删除操作，删除的区间 $[x_i, y_i)$ 为左闭右开区间；\n\n对于查询操作，询问的区间 $[x_i, y_i)$ 为左闭右开区间。\n\n所有插入的和查询的字符串均不为空，且只包含字符 $\\texttt 0\\sim\\texttt9$。\n\n所有询问的区间和删除的区间均不为空。\n\n保证输入数据合法。\n\n对于“左闭右开区间”不理解的可以去看样例解释。", "outputFormat": "对每个询问操作，输出一行，表示这个询问的答案。", "hint": "样例解释：\n- 第一次操作后，字符串为 $\\texttt{894894894}$；\n\n- 第二次操作，询问的区间为 $\\texttt{89}$，不包含任何 $\\texttt{894}$；\n\n- 第三次操作，询问的区间为 $\\texttt{894894894}$，包含三个 $\\texttt{894}$；\n\n- 第四次操作后，字符串为 $\\texttt{8964894894}$；\n\n- 第五次操作，询问的区间为 $\\texttt{896489489}$，包含一个 $\\texttt{64}$；\n\n- 第六次操作，询问的区间为 $\\texttt{896489489}$，包含一个 $\\texttt{894}$；\n\n- 第七次操作后，字符串为 $\\texttt{894894}$；\n\n- 第八次操作，询问的区间为 $\\texttt{894894}$，包含两个 $\\texttt{894}$。\n\n数据范围：\n- $50\\%$ 的数据中，询问个数 $\\le100$ （不是操作个数）；\n\n- $100\\%$ 的数据中，插入总长度 $\\le 2\\times10^6$，任何时刻字符串长度 $\\le 10^6$，插入次数 $\\le 1001$，删除次数 $\\le  1000$，询问的 $z_i$ 的总长度 $\\le 10^4$。\n\n来源：2012 集训队互测，by gyz", "locale": "zh-CN"}}}
{"pid": "P4466", "type": "P", "difficulty": 6, "samples": [["15", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "集训队互测"], "title": "[国家集训队] 和与积", "background": "", "description": "给出 $n$，统计满足下面条件的数对 $(a,b)$ 的个数：\n\n1. $1\\le a<b \\le n$。\n2. $a+b$ 整除 $a\\times b$。", "inputFormat": "一行一个整数数 $n$。", "outputFormat": "一行一个整数表示答案。", "hint": "| Test | $N$ | Test | $N$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 10$ | $11$ | $\\leq 5\\times 10^7$ |\n| $2$ | $\\leq 50$ | $12$ | $\\leq 10^8$ |\n| $3$ | $\\leq 10^3$ | $13$ | $\\leq 2\\times 10^8$ |\n| $4$ | $\\leq 5\\times 10^3$ | $14$ | $\\leq 3\\times 10^8$ |\n| $5$ | $\\leq 2\\times 10^4$ | $15$ | $\\leq 5\\times 10^8$ |\n| $6$ | $\\leq 2\\times 10^5$ | $16$ | $\\leq 10^9$ |\n| $7$ | $\\leq 2\\times 10^6$ | $17$ | $\\leq 10^9$ |\n| $8$ | $\\leq 10^7$ | $18$ | $\\leq 2^{31}-1$ |\n| $9$ | $\\leq 2\\times 10^7$ | $19$ | $\\leq 2^{31}-1$ |\n| $10$ | $\\leq 3\\times 10^7$ | $20$ | $\\leq 2^{31}-1$ |\n\n来源：2012集训队互测，by ayq", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Sum and Product", "background": "", "description": "Given $n$, count the number of pairs $(a, b)$ that satisfy the following conditions:\n1. $1 \\le a < b \\le n$.\n2. $a + b$ divides $a \\times b$.", "inputFormat": "One line containing an integer $n$.", "outputFormat": "One line containing an integer representing the answer.", "hint": "| Test | $N$ | Test | $N$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 10$ | $11$ | $\\leq 5\\times 10^7$ |\n| $2$ | $\\leq 50$ | $12$ | $\\leq 10^8$ |\n| $3$ | $\\leq 10^3$ | $13$ | $\\leq 2\\times 10^8$ |\n| $4$ | $\\leq 5\\times 10^3$ | $14$ | $\\leq 3\\times 10^8$ |\n| $5$ | $\\leq 2\\times 10^4$ | $15$ | $\\leq 5\\times 10^8$ |\n| $6$ | $\\leq 2\\times 10^5$ | $16$ | $\\leq 10^9$ |\n| $7$ | $\\leq 2\\times 10^6$ | $17$ | $\\leq 10^9$ |\n| $8$ | $\\leq 10^7$ | $18$ | $\\leq 2^{31}-1$ |\n| $9$ | $\\leq 2\\times 10^7$ | $19$ | $\\leq 2^{31}-1$ |\n| $10$ | $\\leq 3\\times 10^7$ | $20$ | $\\leq 2^{31}-1$ |\n\nSource: 2012 CTT mutual test, by ayq.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 和与积", "background": "", "description": "给出 $n$，统计满足下面条件的数对 $(a,b)$ 的个数：\n\n1. $1\\le a<b \\le n$。\n2. $a+b$ 整除 $a\\times b$。", "inputFormat": "一行一个整数数 $n$。", "outputFormat": "一行一个整数表示答案。", "hint": "| Test | $N$ | Test | $N$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 10$ | $11$ | $\\leq 5\\times 10^7$ |\n| $2$ | $\\leq 50$ | $12$ | $\\leq 10^8$ |\n| $3$ | $\\leq 10^3$ | $13$ | $\\leq 2\\times 10^8$ |\n| $4$ | $\\leq 5\\times 10^3$ | $14$ | $\\leq 3\\times 10^8$ |\n| $5$ | $\\leq 2\\times 10^4$ | $15$ | $\\leq 5\\times 10^8$ |\n| $6$ | $\\leq 2\\times 10^5$ | $16$ | $\\leq 10^9$ |\n| $7$ | $\\leq 2\\times 10^6$ | $17$ | $\\leq 10^9$ |\n| $8$ | $\\leq 10^7$ | $18$ | $\\leq 2^{31}-1$ |\n| $9$ | $\\leq 2\\times 10^7$ | $19$ | $\\leq 2^{31}-1$ |\n| $10$ | $\\leq 3\\times 10^7$ | $20$ | $\\leq 2^{31}-1$ |\n\n来源：2012集训队互测，by ayq", "locale": "zh-CN"}}}
{"pid": "P4467", "type": "P", "difficulty": 6, "samples": [["5 20 10 1 5\n1 2 1\n1 3 2\n1 4 1\n1 5 3\n2 1 1\n2 3 1\n2 4 2\n2 5 2\n3 1 1\n3 2 2\n3 4 1\n3 5 1\n4 1 1\n4 2 1\n4 3 1\n4 5 2\n5 1 1\n5 2 1\n5 3 1\n5 4 1", "1-2-4-3-5"], ["4 6 1 1 4\n2 4 2\n1 3 2\n1 2 1\n1 4 3\n2 3 1\n3 4 1", "1-2-3-4"], ["3 3 5 1 3\n1 2 1\n2 3 1\n1 3 1", "No"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2007", "四川", "各省省选", "排序", "最短路"], "title": "[SCOI2007] k短路", "background": "", "description": "有 $n$ 个城市和 $m$ 条单向道路，城市编号为 $1$ 到 $n$。每条道路连接两个不同的城市，且任意两条道路要么起点不同要么终点不同，因此 $n$ 和 $m$ 满足$m \\le n(n-1)$。\n\n给定两个城市 $a$ 和 $b$，可以给 $a$ 到 $b$ 的所有简单路（所有城市最多经过一次，包括起点和终点）排序：先按长度从小到大排序，长度相同时按照字典序从小到大排序。你的任务是求出 $a$ 到 $b$ 的第 $k$ 短路。\n", "inputFormat": "输入第一行包含五个正整数 $n,m,k,a,b$。\n\n以下 $m$ 行每行三个整数 $u,v,l$，表示从城市 $u$ 到城市 $v$ 有一条长度为 $l$ 的单向道路。", "outputFormat": "如果 $a$ 到 $b$ 的简单路不足 $k$ 条，输出 `No`，否则输出第 $k$ 短路：从城市 $a$ 开始依次输出每个到达的城市，直到城市 $b$，中间用减号 `-` 分割。", "hint": "第一个例子有 $5$ 个城市，所有可能出现的道路均存在。从城市 $1$ 到城市 $5$ 一共有 $5$ 条简单路，排序如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/17706.png)\n\n- $20\\%$ 的数据满足：$n\\leq 5$；\n- $40\\%$ 的数据满足：$n\\leq 30$；\n- $100\\%$ 的数据满足：$2\\leq n\\leq 50$，$1\\leq k\\leq 200$，$1\\le l\\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2007] k-th Shortest Path", "background": "", "description": "There are $n$ cities and $m$ directed roads, with cities numbered from $1$ to $n$. Each road connects two different cities, and for any two roads, either their starting cities differ or their ending cities differ. Therefore, $n$ and $m$ satisfy $m \\le n(n-1)$.\n\nGiven two cities $a$ and $b$, you can sort all simple paths (each city appears at most once, including the start and end) from $a$ to $b$: first by total length in ascending order, and if lengths are equal, by lexicographical order in ascending order. Your task is to find the $k$-th shortest path from $a$ to $b$.", "inputFormat": "The first line contains five positive integers $n, m, k, a, b$.\n\nEach of the following $m$ lines contains three integers $u, v, l$, indicating there is a directed road from city $u$ to city $v$ with length $l$.", "outputFormat": "If there are fewer than $k$ simple paths from $a$ to $b$, output `No`. Otherwise, output the $k$-th shortest path: starting from city $a$, output each visited city in order until city $b$, separated by hyphens `-`.", "hint": "In the first example, there are $5$ cities and all possible roads exist. There are $5$ simple paths from city $1$ to city $5$, sorted as follows:\n\n![](https://cdn.luogu.com.cn/upload/pic/17706.png)\n\n- 20% of the testdata: $n \\le 5$.\n- 40% of the testdata: $n \\le 30$.\n- 100% of the testdata: $2 \\le n \\le 50$, $1 \\le k \\le 200$, $1 \\le l \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2007] k短路", "background": "", "description": "有 $n$ 个城市和 $m$ 条单向道路，城市编号为 $1$ 到 $n$。每条道路连接两个不同的城市，且任意两条道路要么起点不同要么终点不同，因此 $n$ 和 $m$ 满足$m \\le n(n-1)$。\n\n给定两个城市 $a$ 和 $b$，可以给 $a$ 到 $b$ 的所有简单路（所有城市最多经过一次，包括起点和终点）排序：先按长度从小到大排序，长度相同时按照字典序从小到大排序。你的任务是求出 $a$ 到 $b$ 的第 $k$ 短路。\n", "inputFormat": "输入第一行包含五个正整数 $n,m,k,a,b$。\n\n以下 $m$ 行每行三个整数 $u,v,l$，表示从城市 $u$ 到城市 $v$ 有一条长度为 $l$ 的单向道路。", "outputFormat": "如果 $a$ 到 $b$ 的简单路不足 $k$ 条，输出 `No`，否则输出第 $k$ 短路：从城市 $a$ 开始依次输出每个到达的城市，直到城市 $b$，中间用减号 `-` 分割。", "hint": "第一个例子有 $5$ 个城市，所有可能出现的道路均存在。从城市 $1$ 到城市 $5$ 一共有 $5$ 条简单路，排序如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/17706.png)\n\n- $20\\%$ 的数据满足：$n\\leq 5$；\n- $40\\%$ 的数据满足：$n\\leq 30$；\n- $100\\%$ 的数据满足：$2\\leq n\\leq 50$，$1\\leq k\\leq 200$，$1\\le l\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P4468", "type": "P", "difficulty": 7, "samples": [["2\n-0.5 -0.5 1 1\n1 75 0 75\n6\n10 60\n80 60\n30 40\n10 10\n50 50\n20 50", "4\n2\n2\n0\n0\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "四川", "各省省选"], "title": "[SCOI2007] 折纸", "background": "", "description": "桌上有一张边界平行于坐标轴的正方形纸片，左下角的坐标为(0,0)，右上角的坐标为(100,100)。接下来执行n条折纸命令。每条命令用两个不同点P1(x1,y1)和P2(x2,y2)来表示，执行时把当前的折纸作品沿着P1P2所在直线折叠，并把有向线段P1P2的右边折向左边（左边的部分保持不变）。\n\n折叠结束后，需要在作品上打一个孔，然后用绳子穿起来挂在墙上。孔的位置是相当重要的：若需要穿过太多层的纸，打孔本身比较困难；若穿过的层数太少，悬挂起来以后作品可能会被撕破。为了选择一个比较合适的打孔位置，你需要计算在每个候选位置打孔时穿过的层数。如果恰好穿过某一层的边界（误差0.000001内），则该层不统计在结果中。\n\n本题考虑一个简化的模型：纸的厚度不计，因此折纸操作总能完美执行。\n", "inputFormat": "输入第一行为一个整数n，即折纸的次数。以下n行每行四个实数x1,y1,x2,y2，表示每次折纸时对应的有向线段。\n\n下一行包含一个正整数m，即候选位置的个数，以下每行包含两个实数x,y，表示一个候选位置。", "outputFormat": "每个候选位置输出一行，包含一个整数，即该位置打孔时穿过的层数。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17707.png )\n\n20%的数据满足：n<=1\n\n100%的数据满足：0<=n<=8, 1<=m<=50\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2007] Folding Paper", "background": "", "description": "There is a square sheet of paper on the table with edges parallel to the coordinate axes. The lower-left corner is at $ (0, 0) $, and the upper-right corner is at $ (100, 100) $. Next, you will execute $n$ folding commands. Each command is specified by two distinct points $P_1(x_1, y_1)$ and $P_2(x_2, y_2)$. When executing a command, fold the current work along the line through $P_1P_2$, and fold the right side of the directed segment $ \\overrightarrow{P_1P_2} $ toward the left side (the left side remains unchanged).\n\nAfter all folds, you need to punch a hole in the work and thread a string through it to hang it on the wall. The hole’s position is crucial: if it goes through too many layers of paper, punching the hole is difficult; if it goes through too few layers, the work may tear when hung. To choose a suitable hole position, you need to compute, for each candidate position, the number of layers the hole passes through. If the hole lies exactly on the boundary of a layer (within $0.000001$), that layer is not counted.\n\nThis problem uses a simplified model: the paper has zero thickness, so each folding operation can be performed perfectly.", "inputFormat": "The first line contains an integer $n$, the number of folds. Each of the next $n$ lines contains four real numbers $x_1, y_1, x_2, y_2$, representing the directed segment used for that fold.\n\nThe next line contains a positive integer $m$, the number of candidate positions. Each of the following $m$ lines contains two real numbers $x, y$, representing a candidate position.", "outputFormat": "For each candidate position, output one line containing an integer, which is the number of layers the hole passes through at that position.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17707.png )\n\nConstraints:\n- $20\\%$ of the testdata satisfy $n \\le 1$.\n- $100\\%$ of the testdata satisfy $0 \\le n \\le 8$, $1 \\le m \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2007] 折纸", "background": "", "description": "桌上有一张边界平行于坐标轴的正方形纸片，左下角的坐标为(0,0)，右上角的坐标为(100,100)。接下来执行n条折纸命令。每条命令用两个不同点P1(x1,y1)和P2(x2,y2)来表示，执行时把当前的折纸作品沿着P1P2所在直线折叠，并把有向线段P1P2的右边折向左边（左边的部分保持不变）。\n\n折叠结束后，需要在作品上打一个孔，然后用绳子穿起来挂在墙上。孔的位置是相当重要的：若需要穿过太多层的纸，打孔本身比较困难；若穿过的层数太少，悬挂起来以后作品可能会被撕破。为了选择一个比较合适的打孔位置，你需要计算在每个候选位置打孔时穿过的层数。如果恰好穿过某一层的边界（误差0.000001内），则该层不统计在结果中。\n\n本题考虑一个简化的模型：纸的厚度不计，因此折纸操作总能完美执行。\n", "inputFormat": "输入第一行为一个整数n，即折纸的次数。以下n行每行四个实数x1,y1,x2,y2，表示每次折纸时对应的有向线段。\n\n下一行包含一个正整数m，即候选位置的个数，以下每行包含两个实数x,y，表示一个候选位置。", "outputFormat": "每个候选位置输出一行，包含一个整数，即该位置打孔时穿过的层数。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17707.png )\n\n20%的数据满足：n<=1\n\n100%的数据满足：0<=n<=8, 1<=m<=50\n", "locale": "zh-CN"}}}
{"pid": "P4469", "type": "P", "difficulty": 7, "samples": [["6 20\n30 40 50 50 50 50\n50 50 50 50 50 40\n1 1 6 6 300 320", "300 6.25\n318 5.60"], ["8 2\n10 20 20 30 10 20 10 10\n10 20 20 30 10 20 10 20\n6 8 2 4 10 39", "No"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "四川", "各省省选"], "title": "[SCOI2007] 最优驾车", "background": "", "description": "有n条南北方向的双向街道和n条东西方向的双向街道纵横交错。相邻街道（不管是哪个走向）的距离均为L英里。西南角交叉口的坐标为$(1,1)$，东北角为$(n,n)$。在所有交叉口均可任意改变行驶方向。每条街道有它自己的最高速度限制，该限制对整条街道有效（不管行驶方向如何）。\n\n你的任务是从交叉口$(x_s,y_s)$开车行驶到$(x_t,y_t)$，要求只能在交叉口处改变速度，行驶过程中不得违反所在街道的速度限制，只能沿着路程最短的线路行驶，并且行驶时间在给定的闭区间$[t_1,t_2]$内。车速以“每小时英里数”为单位，它必须是$5$的正整数倍。若车速为$v$，则每加仑汽油能行驶的英里数为$80-0.03v^2$。", "inputFormat": "输入第一行为两个整数$n, L$。  \n第二行包含$n$个正整数，从南到北描述$n$条东西走向的街道的速度限制。  \n第三行包含$n$个正整数，从西到东描述$n$条南北走向的街道的速度限制。  \n第四行包含六个正整数$x_s, y_s, x_t, y_t, t_1, t_2$。", "outputFormat": "如果无解，输出No。\n\n否则输出两行，分别描述最早到达的方案（若有多种方案，选择其中最省油的）和最省油的方案（如果有多种方案，选择其中最早到达的）。每种方案用两个数表示，第一个数表示到达时刻（单位：分钟，向上取整）；第二个数表示耗油量（单位：加仑，四舍五入保留两位小数）。", "hint": "样例1的最快路线为以40英里/小时为速度匀速前进，路程为200英里，因此时间为5小时，每加仑汽油可以行驶80-0.03*40*40=32英里，因此耗油量为200/32=6.25加仑。\n\n最省油路线是先以40英里/小时行驶120英里，然后以35英里/小时行驶80英里，耗油量为120/32+80/(80-0.03*35*35)=5.60加仑。下图的路线可以同时满足两种方案（其中第二种方案需要在(6,2)处改变速度）。\n\n![](https://cdn.luogu.com.cn/upload/pic/17708.png )\n\n20%的数据满足：n<=4\n\n50%的数据满足：n<=8\n\n100%的数据满足：1<=n<=10, 1<=l<=20, 0<=t1<=t2<=1000. 速度限制不超过50\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2007] Optimal Driving", "background": "", "description": "There are $n$ north–south two-way streets and $n$ east–west two-way streets forming a grid. The distance between any two adjacent streets (regardless of orientation) is $L$ miles. The southwest corner intersection has coordinates $(1, 1)$, and the northeast corner is $(n, n)$. At any intersection, you may change direction arbitrarily. Each street has its own speed limit, which applies to the entire street regardless of travel direction.\n\nYour task is to drive from intersection $(x_s, y_s)$ to $(x_t, y_t)$. You may change speed only at intersections; you must not violate the speed limit of the street you are currently on; you may only travel along paths of minimal length; and the total travel time must lie within the closed interval $[t_1, t_2]$. Speed is measured in miles per hour and must be a positive multiple of $5$. If the speed is $v$, then the miles per gallon is $80 - 0.03 v^2$.", "inputFormat": "- The first line contains two integers $n, L$.\n- The second line contains $n$ positive integers, giving the speed limits of the $n$ east–west streets from south to north.\n- The third line contains $n$ positive integers, giving the speed limits of the $n$ north–south streets from west to east.\n- The fourth line contains six integers $x_s, y_s, x_t, y_t, t_1, t_2$.", "outputFormat": "If there is no solution, output No.\n\nOtherwise, output two lines describing, respectively, the earliest-arrival plan (if multiple, choose the most fuel-efficient among them) and the most fuel-efficient plan (if multiple, choose the earliest-arrival among them). Each plan is represented by two numbers: the arrival time in minutes (ceiling to the next integer), and the fuel consumption in gallons (rounded to two decimal places).", "hint": "In Sample 1, the fastest route travels at a constant speed of $40$ miles per hour, with a total distance of $200$ miles, so the time is $5$ hours. The miles per gallon is $80 - 0.03 \\times 40 \\times 40 = 32$, so the fuel consumption is $200 / 32 = 6.25$ gallons.\n\nThe most fuel-efficient route first travels $120$ miles at $40$ miles per hour, then $80$ miles at $35$ miles per hour, for a fuel consumption of $120 / 32 + 80 / \\bigl(80 - 0.03 \\times 35 \\times 35\\bigr) = 5.60$ gallons. The route in the figure satisfies both plans (the second plan changes speed at $(6, 2)$).\n\n![](https://cdn.luogu.com.cn/upload/pic/17708.png)\n\nConstraints:\n- 20% of the testdata satisfy: $n \\le 4$.\n- 50% of the testdata satisfy: $n \\le 8$.\n- 100% of the testdata satisfy: $1 \\le n \\le 10$, $1 \\le L \\le 20$, $0 \\le t_1 \\le t_2 \\le 1000$. Speed limits do not exceed $50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2007] 最优驾车", "background": "", "description": "有n条南北方向的双向街道和n条东西方向的双向街道纵横交错。相邻街道（不管是哪个走向）的距离均为L英里。西南角交叉口的坐标为$(1,1)$，东北角为$(n,n)$。在所有交叉口均可任意改变行驶方向。每条街道有它自己的最高速度限制，该限制对整条街道有效（不管行驶方向如何）。\n\n你的任务是从交叉口$(x_s,y_s)$开车行驶到$(x_t,y_t)$，要求只能在交叉口处改变速度，行驶过程中不得违反所在街道的速度限制，只能沿着路程最短的线路行驶，并且行驶时间在给定的闭区间$[t_1,t_2]$内。车速以“每小时英里数”为单位，它必须是$5$的正整数倍。若车速为$v$，则每加仑汽油能行驶的英里数为$80-0.03v^2$。", "inputFormat": "输入第一行为两个整数$n, L$。  \n第二行包含$n$个正整数，从南到北描述$n$条东西走向的街道的速度限制。  \n第三行包含$n$个正整数，从西到东描述$n$条南北走向的街道的速度限制。  \n第四行包含六个正整数$x_s, y_s, x_t, y_t, t_1, t_2$。", "outputFormat": "如果无解，输出No。\n\n否则输出两行，分别描述最早到达的方案（若有多种方案，选择其中最省油的）和最省油的方案（如果有多种方案，选择其中最早到达的）。每种方案用两个数表示，第一个数表示到达时刻（单位：分钟，向上取整）；第二个数表示耗油量（单位：加仑，四舍五入保留两位小数）。", "hint": "样例1的最快路线为以40英里/小时为速度匀速前进，路程为200英里，因此时间为5小时，每加仑汽油可以行驶80-0.03*40*40=32英里，因此耗油量为200/32=6.25加仑。\n\n最省油路线是先以40英里/小时行驶120英里，然后以35英里/小时行驶80英里，耗油量为120/32+80/(80-0.03*35*35)=5.60加仑。下图的路线可以同时满足两种方案（其中第二种方案需要在(6,2)处改变速度）。\n\n![](https://cdn.luogu.com.cn/upload/pic/17708.png )\n\n20%的数据满足：n<=4\n\n50%的数据满足：n<=8\n\n100%的数据满足：1<=n<=10, 1<=l<=20, 0<=t1<=t2<=1000. 速度限制不超过50\n", "locale": "zh-CN"}}}
{"pid": "P4470", "type": "P", "difficulty": 2, "samples": [["4\nZAGREB\nSISAK\nZADAR\nZABOK\nZA", "****B*D*\n*G******\n********\n********"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["模拟", "字符串", "2018", "北京", "枚举"], "title": "[BJWC2018] 售票", "background": "", "description": "C 市火车站最近出现了一种新式自动售票机。买票时，乘客要先在售票机上输入终点名称。一共有 $N$ 处目的地，随着乘客按顺序输入终点名称的每个字母，候选终点站数目会逐渐减少。\n\n在自动售票机屏幕上，有一个 $4$ 行 $8$ 列的键盘，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/17861.png)\n\n在乘客每输入一个字母后，键盘上只有有效字符是可选的（取决于还有哪些候选终点站），其余的字母会被字符 `*` 取代。\n\n告诉你 $N$ 处目的地的名称，以及乘客已经输入的若干字符，请你输出键盘目前的状态。", "inputFormat": "第一行为一个整数 $N (1\\leq N \\leq 50)$。接下来 $N$ 行，每行一个由大写英文字母组成的长度不超过 $100$ 的字符串，表示一处目的地。最后一行，一个长度不超过 $100$ 的字符串，表示按顺序输入的若干字符。\n", "outputFormat": "输出 $4$ 行，每行一个长度为 $8$ 的字符串，表示键盘状态。", "hint": "**【样例解释】**\n\n输入 `ZA` 以后，下一个字符可能是 `G`（终点站有可能是 `ZAGREB`），或 `D`（终点站有可能是 `ZADAR`），或 `B`（终点站有可能是 `ZABOK`）。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Ticket Vending", "background": "", "description": "A new type of automatic ticket machine has appeared at the train station in city C. When buying a ticket, the passenger first enters the destination name on the machine. There are $N$ destinations in total. As the passenger types each letter in order, the number of candidate destinations gradually decreases.\n\nOn the machine screen, there is a keyboard with $4$ rows and $8$ columns, as shown in the figure below.\n\n![](https://cdn.luogu.com.cn/upload/pic/17861.png)\n\nAfter each letter is entered, only the valid characters on the keyboard are selectable (depending on the remaining candidate destinations), and the other letters are replaced by the character `*`.\n\nGiven the names of $N$ destinations and the characters already typed by the passenger, output the current state of the keyboard.", "inputFormat": "The first line contains an integer $N$ ($1 \\leq N \\leq 50$). The next $N$ lines each contain a string of uppercase English letters with length at most $100$, representing a destination. The last line contains a string with length at most $100$, representing the characters typed in order.", "outputFormat": "Output $4$ lines, each being a string of length $8$, representing the keyboard state.", "hint": "Sample explanation:\n\nAfter typing `ZA`, the next character could be `G` (the destination could be `ZAGREB`), or `D` (the destination could be `ZADAR`), or `B` (the destination could be `ZABOK`).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 售票", "background": "", "description": "C 市火车站最近出现了一种新式自动售票机。买票时，乘客要先在售票机上输入终点名称。一共有 $N$ 处目的地，随着乘客按顺序输入终点名称的每个字母，候选终点站数目会逐渐减少。\n\n在自动售票机屏幕上，有一个 $4$ 行 $8$ 列的键盘，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/17861.png)\n\n在乘客每输入一个字母后，键盘上只有有效字符是可选的（取决于还有哪些候选终点站），其余的字母会被字符 `*` 取代。\n\n告诉你 $N$ 处目的地的名称，以及乘客已经输入的若干字符，请你输出键盘目前的状态。", "inputFormat": "第一行为一个整数 $N (1\\leq N \\leq 50)$。接下来 $N$ 行，每行一个由大写英文字母组成的长度不超过 $100$ 的字符串，表示一处目的地。最后一行，一个长度不超过 $100$ 的字符串，表示按顺序输入的若干字符。\n", "outputFormat": "输出 $4$ 行，每行一个长度为 $8$ 的字符串，表示键盘状态。", "hint": "**【样例解释】**\n\n输入 `ZA` 以后，下一个字符可能是 `G`（终点站有可能是 `ZAGREB`），或 `D`（终点站有可能是 `ZADAR`），或 `B`（终点站有可能是 `ZABOK`）。", "locale": "zh-CN"}}}
{"pid": "P4471", "type": "P", "difficulty": 5, "samples": [["5\nask\npsk\nk\nkrafna\nsk", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "北京", "树形 DP", "字典树 Trie"], "title": "[BJWC2018] 词韵", "background": null, "description": "Adrian 很喜欢诗歌中的韵。他认为，两个单词押韵当且仅当它们的最长公共后缀的长度至少是其中较长单词的长度减一。也就是说，单词A 与单词B 押韵当且仅当 $\\operatorname{LCS}(A,B) \\ge \\max(|A|,|B|)- 1$。（其中 $\\operatorname{LCS}$ 是最长公共后缀 longest common suffix 的缩写）\n\n现在，Adrian 得到了 $N$ 个单词。他想从中选出尽可能多的单词，要求它们能组成一个单词序列，使得单词序列中任何两个相邻单词是押韵的。", "inputFormat": "第一行是一个整数 $N$。\n\n接下来 $N$ 行，每行一个由小写英文字母组成的字符串，表示每个单词。所有单词互不相同。", "outputFormat": "输出一行，为一个整数，表示最长单词序列的长度。", "hint": "**【样例解释】**\n\n一种最长单词序列是 `ask-psk-sk-k`。\n\n**【数据规模和约定】**\n\n$30\\%$ 的测试数据：$1 \\le N \\le 20$，所有单词长度之和不超过 $3000$。\n\n$100\\%$ 的测试数据：$1 \\le N \\le 5 \\times 10^5$，所有单词长度之和不超过 $3 \\times 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Rhyme", "background": "", "description": "Adrian likes rhyme in poetry. He thinks two words rhyme if and only if the length of their longest common suffix is at least the length of the longer word minus one. That is, words A and B rhyme if and only if $\\operatorname{LCS}(A,B) \\ge \\max(|A|,|B|)- 1$. (Here, $\\operatorname{LCS}$ is the abbreviation for the longest common suffix.)\n\nNow Adrian has $N$ words. He wants to select as many words as possible to form a sequence such that any two adjacent words in the sequence rhyme.", "inputFormat": "The first line contains an integer $N$.\n\nEach of the next $N$ lines contains a string consisting of lowercase English letters, representing a word. All words are distinct.", "outputFormat": "Output a single line with one integer, the length of the longest word sequence.", "hint": "**[Sample Explanation]**\n\nOne longest word sequence is `ask-psk-sk-k`.\n\n**[Constraints]**\n\n30% of the testdata: $1 \\le N \\le 20$, and the sum of word lengths does not exceed $3000$.\n\n100% of the testdata: $1 \\le N \\le 5 \\times 10^5$, and the sum of word lengths does not exceed $3 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 词韵", "background": null, "description": "Adrian 很喜欢诗歌中的韵。他认为，两个单词押韵当且仅当它们的最长公共后缀的长度至少是其中较长单词的长度减一。也就是说，单词A 与单词B 押韵当且仅当 $\\operatorname{LCS}(A,B) \\ge \\max(|A|,|B|)- 1$。（其中 $\\operatorname{LCS}$ 是最长公共后缀 longest common suffix 的缩写）\n\n现在，Adrian 得到了 $N$ 个单词。他想从中选出尽可能多的单词，要求它们能组成一个单词序列，使得单词序列中任何两个相邻单词是押韵的。", "inputFormat": "第一行是一个整数 $N$。\n\n接下来 $N$ 行，每行一个由小写英文字母组成的字符串，表示每个单词。所有单词互不相同。", "outputFormat": "输出一行，为一个整数，表示最长单词序列的长度。", "hint": "**【样例解释】**\n\n一种最长单词序列是 `ask-psk-sk-k`。\n\n**【数据规模和约定】**\n\n$30\\%$ 的测试数据：$1 \\le N \\le 20$，所有单词长度之和不超过 $3000$。\n\n$100\\%$ 的测试数据：$1 \\le N \\le 5 \\times 10^5$，所有单词长度之和不超过 $3 \\times 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4472", "type": "P", "difficulty": 5, "samples": [["1 2 2\nab", "5/16"], ["3 3 10\nban\nana\nnab", "2/27"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "北京"], "title": "[BJWC2018] 八维", "background": "", "description": "我们将一个 $M$ 行 $N$ 列的字符矩阵无限复制，可以得到一个无限字符矩阵。例如，对于以下矩阵:\n\n$$\\begin{aligned}\n& \\verb!honi! \\\\\n& \\verb!hsin! \\\\\n\\end{aligned}$$\n\n可以无限复制出矩阵\n\n$$\\begin{aligned}\n& \\verb!...honihonihonihoni...! \\\\\n& \\verb!...hsinhsinhsinhsin...! \\\\\n& \\verb!...honihonihonihoni...! \\\\\n& \\verb!...hsinhsinhsinhsin...! \\\\\n\\end{aligned}$$\n\n我们认为矩阵是八连通的。八连通，  指矩阵中的每个位置与上下左右和四个斜向（左上、右上、左下、右下）的位置相邻。因此，从矩阵任意位置出发沿八个方向中的任意一个都可以无限延长。\n\n如果我们随机选择一个位置和一个方向，则可以从此位置开始沿此方向连续选取 $K$ 个字符组成一个字符串。问，两次这样操作得到两个相同字符串的概率是多少。(假设随机选择时任意位置是等可能的，任意方向也是等可能的)", "inputFormat": "第一行是三个整数 $M,  N,  K$。\n\n接下来 $M$ 行，  每行一个由小写英文字母组成的长度为 $N$ 的字符串，即 $M\\times N$ 的字符矩阵。保证矩阵中至少出现两种不同字符。", "outputFormat": "输出一行，为一个化简后的分数，表示概率。", "hint": "**【样例解释】**\n\n样例一中，一次操作共有 $16$ 种可能，其中得到 $\\verb!aa!$ 的概率是 $1/8$，得到 $\\verb!ab!$ 的概率是 $3/8$,得到bb 的概率是 $1/8$，得到 $\\verb!ba!$ 的概率是 $\\verb!3/8!$。两次操作结果相同的\n概率是 $5/16$。\n\n**【数据规模和约定】**\n\n- 对于 $30\\%$ 的测试数据：$M, N ≤ 10$，$K ≤ 100$。\n- 对于 $50\\%$ 的测试数据：$M = N$。\n- 对于 $100\\%$ 的测试数据 ：$1 ≤ M,N ≤ 500$，$2 ≤ K ≤ 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Eight Dimensions", "background": "", "description": "We infinitely tile a character matrix with $M$ rows and $N$ columns to obtain an infinite character matrix. For example, for the following matrix:\n\n$$\\begin{aligned}\n& \\verb!honi! \\\\\n& \\verb!hsin! \\\\\n\\end{aligned}$$\n\nwe can tile it infinitely to get\n\n$$\\begin{aligned}\n& \\verb!...honihonihonihoni...! \\\\\n& \\verb!...hsinhsinhsinhsin...! \\\\\n& \\verb!...honihonihonihoni...! \\\\\n& \\verb!...hsinhsinhsinhsin...! \\\\\n\\end{aligned}$$\n\nWe consider the matrix to be 8-connected. 8-connected means each position in the matrix is adjacent to the positions above, below, left, right, and the four diagonals (upper-left, upper-right, lower-left, lower-right). Therefore, starting from any position in the matrix, you can extend infinitely along any one of the eight directions.\n\nIf we uniformly at random choose one position and one direction, then starting from this position and going along this direction, we take $K$ consecutive characters to form a string. What is the probability that two such operations produce identical strings? (Assume any position is equally likely and any direction is equally likely.)", "inputFormat": "The first line contains three integers $M, N, K$.\n\nThe next $M$ lines each contain a string of length $N$ consisting of lowercase English letters, forming the $M \\times N$ character matrix. It is guaranteed that at least two different characters appear in the matrix.", "outputFormat": "Output one line containing a reduced fraction representing the probability.", "hint": "【Sample Explanation】\n\nIn Sample 1, there are $16$ possibilities for one operation in total. The probability of obtaining \\verb!aa! is $1/8$, the probability of obtaining \\verb!ab! is $3/8$, the probability of obtaining \\verb!bb! is $1/8$, and the probability of obtaining \\verb!ba! is $3/8$. The probability that the results of two operations are the same is $5/16$.\n\n【Constraints】\n\n- For $30\\%$ of the testdata: $M, N \\le 10$, $K \\le 100$.\n- For $50\\%$ of the testdata: $M = N$.\n- For $100\\%$ of the testdata: $1 \\le M, N \\le 500$, $2 \\le K \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 八维", "background": "", "description": "我们将一个 $M$ 行 $N$ 列的字符矩阵无限复制，可以得到一个无限字符矩阵。例如，对于以下矩阵:\n\n$$\\begin{aligned}\n& \\verb!honi! \\\\\n& \\verb!hsin! \\\\\n\\end{aligned}$$\n\n可以无限复制出矩阵\n\n$$\\begin{aligned}\n& \\verb!...honihonihonihoni...! \\\\\n& \\verb!...hsinhsinhsinhsin...! \\\\\n& \\verb!...honihonihonihoni...! \\\\\n& \\verb!...hsinhsinhsinhsin...! \\\\\n\\end{aligned}$$\n\n我们认为矩阵是八连通的。八连通，  指矩阵中的每个位置与上下左右和四个斜向（左上、右上、左下、右下）的位置相邻。因此，从矩阵任意位置出发沿八个方向中的任意一个都可以无限延长。\n\n如果我们随机选择一个位置和一个方向，则可以从此位置开始沿此方向连续选取 $K$ 个字符组成一个字符串。问，两次这样操作得到两个相同字符串的概率是多少。(假设随机选择时任意位置是等可能的，任意方向也是等可能的)", "inputFormat": "第一行是三个整数 $M,  N,  K$。\n\n接下来 $M$ 行，  每行一个由小写英文字母组成的长度为 $N$ 的字符串，即 $M\\times N$ 的字符矩阵。保证矩阵中至少出现两种不同字符。", "outputFormat": "输出一行，为一个化简后的分数，表示概率。", "hint": "**【样例解释】**\n\n样例一中，一次操作共有 $16$ 种可能，其中得到 $\\verb!aa!$ 的概率是 $1/8$，得到 $\\verb!ab!$ 的概率是 $3/8$,得到bb 的概率是 $1/8$，得到 $\\verb!ba!$ 的概率是 $\\verb!3/8!$。两次操作结果相同的\n概率是 $5/16$。\n\n**【数据规模和约定】**\n\n- 对于 $30\\%$ 的测试数据：$M, N ≤ 10$，$K ≤ 100$。\n- 对于 $50\\%$ 的测试数据：$M = N$。\n- 对于 $100\\%$ 的测试数据 ：$1 ≤ M,N ≤ 500$，$2 ≤ K ≤ 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4473", "type": "P", "difficulty": 6, "samples": [["4 4\n0 0 0 0\n1 2 2 0\n0 2 2 1\n0 0 0 0\n5 5 5 5\n5 5 5 5\n5 5 5 5\n5 5 5 5\n2 1 3 4 2 2", "Z\n15"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2011", "线段树", "并查集", "集训队互测", "O2优化", "最短路"], "title": "[国家集训队] 飞飞侠", "background": "来源：国家集训队 2011 何朴藩", "description": "飞飞国是一个传说中的国度，国家的居民叫做飞飞侠。飞飞国是一个 $N\\times M$ 的矩形方阵，每个格子代表一个街区。\n\n然而飞飞国是没有交通工具的。飞飞侠完全靠地面的弹射装置来移动。  \n\n每个街区都装有弹射装置。使用弹射装置是需要支付一定费用的。而且每个弹射装置都有自己的弹射能力。  \n\n我们设第 $i$ 行第 $j$ 列的弹射装置有 $A_{i,j}$ 的费用和 $B_{i,j}$ 的弹射能力。并规定有相邻边的格子间距离是 $1$。那么，任何飞飞侠都只需要在 $(i,j)$ 支付 $A_{i,j}$ 的费用就可以任意选择弹到距离不超过 $B_{i,j}$ 的位置了。如下图  \n![https://cdn.luogu.com.cn/upload/pic/17919.png](https://cdn.luogu.com.cn/upload/pic/17919.png)  \n（从红色街区交费以后可以跳到周围的任意蓝色街区。）  \n\n现在的问题很简单。有三个飞飞侠，分别叫做 $X, Y, Z$。现在它们决定聚在一起玩，于是想往其中一人的位置集合。告诉你 $3$ 个飞飞侠的坐标，求往哪里集合大家需要花的费用总和最低。（费用相同时优先 $X$，次优先 $Y$）", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$，分别表示行数和列数。\n\n接下来是 $2$ 个 $N\\times M$ 的自然数矩阵，为 $B_{i,j}$ 和 $A_{i,j}$。\n\n最后一行六个数，分别代表 $X, Y, Z$ 所在地的行号和列号。", "outputFormat": "第一行输出一个字符 $X, Y$ 或者 $Z$。表示最优集合地点。\n\n第二行输出一个整数，表示最小费用。\n\n如果无法集合，只输出一行 `NO`。  ", "hint": "对于 $20\\%$ 的数据，$N, M\\leq 10$，$B_{i,j}\\leq 20$。 \n\n对于 $40\\%$ 的数据，$N, M \\leq 100$，$B_{i,j}\\leq 20$。\n\n对于 $100\\%$ 的数据，$1\\leq N, M\\leq 150$，$0\\leq B_{i, j}\\leq 10^9$，$0\\leq A_{i, j}\\leq 1000$。  ", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Fei Fei Xia", "background": "Source: CTT 2011 He Pufan.", "description": "Fei Fei Country is a legendary land, and its residents are called \"Fei Fei Xia\" (pinyin).\n\nFei Fei Country is an $N\\times M$ rectangular grid, where each cell represents a block.\n\nHowever, there is no transportation in Fei Fei Country. Fei Fei Xia move entirely using ground-based launch devices.\n\nEvery block is equipped with a launch device. Using a launch device requires paying a certain fee, and each device has its own launching capability.\n\nLet the launch device at row $i$, column $j$ have a fee $A_{i,j}$ and a launching capability $B_{i,j}$. We define the distance between two cells sharing an edge to be $1$. Then, any Fei Fei Xia only needs to pay $A_{i,j}$ at $(i, j)$ to jump to any position whose distance from $(i, j)$ is no more than $B_{i,j}$. See the figure below.\n![https://cdn.luogu.com.cn/upload/pic/17919.png](https://cdn.luogu.com.cn/upload/pic/17919.png)\n(After paying at the red block, one can jump to any blue block around it.)\n\nThe problem is simple. There are three Fei Fei Xia, named $X, Y, Z$. They decide to gather to play and want to meet at one of their positions. Given the coordinates of the $3$ Fei Fei Xia, find at which person’s position they should gather to minimize the total cost for all of them. If the minimal costs are the same, prefer $X$ first, then $Y$.\n\n# Description", "inputFormat": "The first line contains two integers $N$ and $M$, representing the number of rows and columns.\n\nNext are two $N\\times M$ matrices of natural numbers, giving $B_{i,j}$ and $A_{i,j}$.\n\nThe last line contains six numbers, representing the row and column indices of the locations of $X, Y, Z$.", "outputFormat": "On the first line, output a single character $X$, $Y$ or $Z$, indicating the optimal meeting person.\n\nOn the second line, output an integer, the minimal total cost.\n\nIf gathering is impossible, output only one line `NO`.", "hint": "Constraints:\n- For $20\\%$ of the testdata, $N, M \\leq 10$, $B_{i,j} \\leq 20$.\n- For $40\\%$ of the testdata, $N, M \\leq 100$, $B_{i,j} \\leq 20$.\n- For $100\\%$ of the testdata, $1 \\leq N, M \\leq 150$, $0 \\leq B_{i, j} \\leq 10^9$, $0 \\leq A_{i, j} \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 飞飞侠", "background": "来源：国家集训队 2011 何朴藩", "description": "飞飞国是一个传说中的国度，国家的居民叫做飞飞侠。飞飞国是一个 $N\\times M$ 的矩形方阵，每个格子代表一个街区。\n\n然而飞飞国是没有交通工具的。飞飞侠完全靠地面的弹射装置来移动。  \n\n每个街区都装有弹射装置。使用弹射装置是需要支付一定费用的。而且每个弹射装置都有自己的弹射能力。  \n\n我们设第 $i$ 行第 $j$ 列的弹射装置有 $A_{i,j}$ 的费用和 $B_{i,j}$ 的弹射能力。并规定有相邻边的格子间距离是 $1$。那么，任何飞飞侠都只需要在 $(i,j)$ 支付 $A_{i,j}$ 的费用就可以任意选择弹到距离不超过 $B_{i,j}$ 的位置了。如下图  \n![https://cdn.luogu.com.cn/upload/pic/17919.png](https://cdn.luogu.com.cn/upload/pic/17919.png)  \n（从红色街区交费以后可以跳到周围的任意蓝色街区。）  \n\n现在的问题很简单。有三个飞飞侠，分别叫做 $X, Y, Z$。现在它们决定聚在一起玩，于是想往其中一人的位置集合。告诉你 $3$ 个飞飞侠的坐标，求往哪里集合大家需要花的费用总和最低。（费用相同时优先 $X$，次优先 $Y$）", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$，分别表示行数和列数。\n\n接下来是 $2$ 个 $N\\times M$ 的自然数矩阵，为 $B_{i,j}$ 和 $A_{i,j}$。\n\n最后一行六个数，分别代表 $X, Y, Z$ 所在地的行号和列号。", "outputFormat": "第一行输出一个字符 $X, Y$ 或者 $Z$。表示最优集合地点。\n\n第二行输出一个整数，表示最小费用。\n\n如果无法集合，只输出一行 `NO`。  ", "hint": "对于 $20\\%$ 的数据，$N, M\\leq 10$，$B_{i,j}\\leq 20$。 \n\n对于 $40\\%$ 的数据，$N, M \\leq 100$，$B_{i,j}\\leq 20$。\n\n对于 $100\\%$ 的数据，$1\\leq N, M\\leq 150$，$0\\leq B_{i, j}\\leq 10^9$，$0\\leq A_{i, j}\\leq 1000$。  ", "locale": "zh-CN"}}}
{"pid": "P4474", "type": "P", "difficulty": 6, "samples": [["2 2\n1 2\n2 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["网络流", "二分图", "最小割"], "title": "王者之剑", "background": "", "description": "![https://cdn.luogu.com.cn/upload/pic/17920.png](https://cdn.luogu.com.cn/upload/pic/17920.png)  \n\n这是在阿尔托利亚·潘德拉贡成为英灵前的事情，她正要去拔出石中剑成为亚瑟王，在这之前她要去收集一些宝石。\n\n宝石排列在一个 $n \\times m$ 的网格中，每个网格中有一块价值为 $v_{i,j}$ 的宝石，阿尔托利亚·潘德拉贡可以选择自己的起点。\n\n开始时刻为 $0$ 秒。以下操作，每秒按顺序执行。\n\n1. 在第 $i$ 秒开始的时候，阿尔托利亚·潘德拉贡在方格 $(x,y)$ 上，她可以拿走 $(x, y)$ 中的宝石。\n2. 在偶数秒，阿尔托利亚·潘德拉贡周围四格的宝石会消失。\n3. 若阿尔托利亚·潘德拉贡第 $i$ 秒开始时在方格 $(x,y)$ 上，则在第 $i+1$ 秒可以立即移动到 $(x+1,y),(x,y+1),(x-1,y)$ 或 $(x, y- 1)$ 上，也可以停留在（$x,y)$ 上。\n\n\n求阿尔托利亚·潘德拉贡最多可以获得多少价值的宝石", "inputFormat": "第一行给出数字 $N,M$ 代表行列数 $N,M$ 均小于等于 $100$，宝石的价值不会超过 $10000$。下面 $N$ 行 $M$ 列用于描述数字矩阵。", "outputFormat": "输出最多可以拿到多少价值宝石。", "hint": "姚金宇的原创题。", "locale": "zh-CN", "translations": {"en": {"title": "The King’s Sword", "background": "", "description": "![https://cdn.luogu.com.cn/upload/pic/17920.png](https://cdn.luogu.com.cn/upload/pic/17920.png)\n\nThis is before Artoria Pendragon became a Heroic Spirit. She is about to pull the sword from the stone to become King Arthur, and before that she needs to collect some gems.\n\nThe gems are arranged in an $n \\times m$ grid. Each cell contains a gem worth $v_{i,j}$. Artoria Pendragon may choose her own starting cell.\n\nThe initial time is $0$ seconds. The following operations are executed every second, in order.\n\n1. At the beginning of second $i$, if Artoria Pendragon is on cell $(x, y)$, she can take the gem in $(x, y)$.\n2. At even-numbered seconds, the gems in the four orthogonally adjacent cells around Artoria Pendragon disappear.\n3. If Artoria Pendragon is on cell $(x, y)$ at the beginning of second $i$, then at second $i+1$ she may immediately move to $(x+1, y)$, $(x, y+1)$, $(x-1, y)$, or $(x, y-1)$, or stay at $(x, y)$.\n\nFind the maximum total value of gems that Artoria Pendragon can obtain.", "inputFormat": "The first line gives the numbers $N, M$, representing the number of rows and columns. $N, M \\le 100$. The value of each gem does not exceed $10000$. The next $N$ lines and $M$ columns describe the value matrix.", "outputFormat": "Output the maximum total value of gems that can be taken.", "hint": "An original problem by Yao Jinyu.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "王者之剑", "background": "", "description": "![https://cdn.luogu.com.cn/upload/pic/17920.png](https://cdn.luogu.com.cn/upload/pic/17920.png)  \n\n这是在阿尔托利亚·潘德拉贡成为英灵前的事情，她正要去拔出石中剑成为亚瑟王，在这之前她要去收集一些宝石。\n\n宝石排列在一个 $n \\times m$ 的网格中，每个网格中有一块价值为 $v_{i,j}$ 的宝石，阿尔托利亚·潘德拉贡可以选择自己的起点。\n\n开始时刻为 $0$ 秒。以下操作，每秒按顺序执行。\n\n1. 在第 $i$ 秒开始的时候，阿尔托利亚·潘德拉贡在方格 $(x,y)$ 上，她可以拿走 $(x, y)$ 中的宝石。\n2. 在偶数秒，阿尔托利亚·潘德拉贡周围四格的宝石会消失。\n3. 若阿尔托利亚·潘德拉贡第 $i$ 秒开始时在方格 $(x,y)$ 上，则在第 $i+1$ 秒可以立即移动到 $(x+1,y),(x,y+1),(x-1,y)$ 或 $(x, y- 1)$ 上，也可以停留在（$x,y)$ 上。\n\n\n求阿尔托利亚·潘德拉贡最多可以获得多少价值的宝石", "inputFormat": "第一行给出数字 $N,M$ 代表行列数 $N,M$ 均小于等于 $100$，宝石的价值不会超过 $10000$。下面 $N$ 行 $M$ 列用于描述数字矩阵。", "outputFormat": "输出最多可以拿到多少价值宝石。", "hint": "姚金宇的原创题。", "locale": "zh-CN"}}}
{"pid": "P4475", "type": "P", "difficulty": 6, "samples": [["3 3\n1 2 5\n3 1 4\n2 2 1\n2 1 6\n1 3 5\n1 3 7", "5\n0\n4"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": [], "title": "巧克力王国", "background": "", "description": "巧克力王国里的巧克力都是由牛奶和可可做成的。但是并不是每一块巧克力都受王国人民的欢迎，因为大家都不喜欢过于甜的巧克力。\n\n对于每一块巧克力，我们设 $x$ 和 $y$ 为其牛奶和可可的含量。由于每个人对于甜的程度都有自己的评判标准，所以每个人都有两个参数 $a$ 和 $b$ ，分别为他自己为牛奶和可可定义的权重， 因此牛奶和可可含量分别为 $x$ 和 $y$ 的巧克力对于他的甜味程度即为 $ax+by$。而每个人又有一个甜味限度 $c$ ，所有甜味程度大于等于 $c$ 的巧克力他都无法接受。每块巧克力都有一个美味值 $h$ 。\n\n现在我们想知道对于每个人，他所能接受的巧克力的美味值之和为多少。", "inputFormat": "第一行两个正整数 $n$ 和 $m$ ，分别表示巧克力个数和询问个数。  \n接下来$n$行，每行三个整数 $x , y , h$ ，含义如题目所示。  \n再接下来 $m$ 行，每行三个整数 $a , b , c$ ，含义如题目所示。", "outputFormat": "输出$m$行，其中第$i$行表示第$i$个人所能接受的巧克力的美味值之和。", "hint": "对于100%的数据，$1<=n,m<=50000$,$-10^9<=a_i,b_i,x_i,y_i<=10^9$。\n\n保证数据用某种方式随机生成。", "locale": "zh-CN", "translations": {"en": {"title": "Chocolate Kingdom", "background": "", "description": "In the Chocolate Kingdom, chocolates are made from milk and cocoa. However, not every piece of chocolate is favored by the people, because no one likes overly sweet chocolate.\n\nFor each piece of chocolate, let $x$ and $y$ be its milk and cocoa content. Since everyone has their own standard for sweetness, each person has two parameters $a$ and $b$, which are their weights for milk and cocoa, respectively. Therefore, for a chocolate with milk and cocoa content $x$ and $y$, its sweetness for that person is $ax+by$. Each person also has a sweetness threshold $c$: all chocolates with sweetness greater than or equal to $c$ are unacceptable to them. Each piece of chocolate has a deliciousness value $h$.\n\nNow we want to know, for each person, the sum of the deliciousness values of the chocolates they can accept.", "inputFormat": "The first line contains two positive integers $n$ and $m$, denoting the number of chocolates and the number of queries.  \nThe next $n$ lines each contain three integers $x , y , h$, as described above.  \nThen the next $m$ lines each contain three integers $a , b , c$, as described above.", "outputFormat": "Output $m$ lines, where the $i$-th line is the sum of the deliciousness values of the chocolates acceptable to the $i$-th person.", "hint": "Constraints: For 100% of the testdata, $1<=n,m<=50000$,$-10^9<=a_i,b_i,x_i,y_i<=10^9$.\n\nThe testdata is guaranteed to be randomly generated in some manner.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "巧克力王国", "background": "", "description": "巧克力王国里的巧克力都是由牛奶和可可做成的。但是并不是每一块巧克力都受王国人民的欢迎，因为大家都不喜欢过于甜的巧克力。\n\n对于每一块巧克力，我们设 $x$ 和 $y$ 为其牛奶和可可的含量。由于每个人对于甜的程度都有自己的评判标准，所以每个人都有两个参数 $a$ 和 $b$ ，分别为他自己为牛奶和可可定义的权重， 因此牛奶和可可含量分别为 $x$ 和 $y$ 的巧克力对于他的甜味程度即为 $ax+by$。而每个人又有一个甜味限度 $c$ ，所有甜味程度大于等于 $c$ 的巧克力他都无法接受。每块巧克力都有一个美味值 $h$ 。\n\n现在我们想知道对于每个人，他所能接受的巧克力的美味值之和为多少。", "inputFormat": "第一行两个正整数 $n$ 和 $m$ ，分别表示巧克力个数和询问个数。  \n接下来$n$行，每行三个整数 $x , y , h$ ，含义如题目所示。  \n再接下来 $m$ 行，每行三个整数 $a , b , c$ ，含义如题目所示。", "outputFormat": "输出$m$行，其中第$i$行表示第$i$个人所能接受的巧克力的美味值之和。", "hint": "对于100%的数据，$1<=n,m<=50000$,$-10^9<=a_i,b_i,x_i,y_i<=10^9$。\n\n保证数据用某种方式随机生成。", "locale": "zh-CN"}}}
{"pid": "P4476", "type": "P", "difficulty": 6, "samples": [["1\n3 1\n001 101", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "北京"], "title": "[BJWC2018] 数字统计", "background": "", "description": "小A 正在研究一些数字统计问题。有一天他突然看到了一个这样的问题：\n\n将[L..R]中的所有整数用M 位二进制数表示（允许出现前导0）。现在将这些数中的每一个作如下变换：\n\n从这个数的最低两位开始，如果这两位都是0，那么X=1，否则X=0。现在将这两位删去，然后将X 放在原来最低位的位置上。重复这个变换直到这个数只剩下一位为止。\n\n例如01001 的变换过程如下：\n\n01001-->0100-->011-->00-->1。\n\n现在的问题是变换后的所有数中，值为Y（Y 为0 或1）的有多少个？\n\n小A 不会了，他想让你帮助他完成这个问题。", "inputFormat": "输入文件包含多组测试数据。\n\n第一行，一个整数T，表示测试数据的组数。\n\n接下来的T 节，每节对应一组测试数据，格式如下：\n\n第一行，两个整数M、Y。\n\n第二行，两个M 位二进制数L、R。", "outputFormat": "对于每组测试数据，输出一行，一个二进制数，表示该组测试数据中[L..R]中的所有整数变换后的值为Y 的个数。这里的二进制数不允许出现前导0。", "hint": "对于20%的数据：1 ≤ M ≤ 16。\n\n对于40%的数据：1 ≤ M ≤ 32。\n\n对于100%的数据：1 ≤ M ≤ 200，1 ≤ T ≤ 50。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Digit Statistics", "background": "", "description": "Little A is studying some problems about digit statistics. One day he came across the following problem:\n\nRepresent every integer in [L..R] as an M-bit binary number (leading zeros are allowed). Now apply the following transformation to each number:\n\nStarting from the two least significant bits, if both bits are 0, then set X = 1; otherwise set X = 0. Delete these two bits, then place X in the least significant position. Repeat this transformation until the number has only one bit left.\n\nFor example, the transformation process of 01001 is:\n01001-->0100-->011-->00-->1.\n\nNow the question is: among all transformed numbers, how many are equal to Y (Y is 0 or 1)?\n\nLittle A does not know how to solve it and asks you for help.", "inputFormat": "The input contains multiple test cases.\n\nThe first line contains an integer T, the number of test cases.\n\nEach of the next T sections corresponds to one test case, in the following format:\n\n- The first line contains two integers M and Y.\n- The second line contains two M-bit binary numbers L and R.", "outputFormat": "For each test case, output one line containing a binary number, which is the count of integers in [L..R] whose transformed value equals Y. This binary number must not contain leading zeros.", "hint": "- For 20% of the testdata: 1 ≤ M ≤ 16.\n- For 40% of the testdata: 1 ≤ M ≤ 32.\n- For 100% of the testdata: 1 ≤ M ≤ 200, 1 ≤ T ≤ 50.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 数字统计", "background": "", "description": "小A 正在研究一些数字统计问题。有一天他突然看到了一个这样的问题：\n\n将[L..R]中的所有整数用M 位二进制数表示（允许出现前导0）。现在将这些数中的每一个作如下变换：\n\n从这个数的最低两位开始，如果这两位都是0，那么X=1，否则X=0。现在将这两位删去，然后将X 放在原来最低位的位置上。重复这个变换直到这个数只剩下一位为止。\n\n例如01001 的变换过程如下：\n\n01001-->0100-->011-->00-->1。\n\n现在的问题是变换后的所有数中，值为Y（Y 为0 或1）的有多少个？\n\n小A 不会了，他想让你帮助他完成这个问题。", "inputFormat": "输入文件包含多组测试数据。\n\n第一行，一个整数T，表示测试数据的组数。\n\n接下来的T 节，每节对应一组测试数据，格式如下：\n\n第一行，两个整数M、Y。\n\n第二行，两个M 位二进制数L、R。", "outputFormat": "对于每组测试数据，输出一行，一个二进制数，表示该组测试数据中[L..R]中的所有整数变换后的值为Y 的个数。这里的二进制数不允许出现前导0。", "hint": "对于20%的数据：1 ≤ M ≤ 16。\n\n对于40%的数据：1 ≤ M ≤ 32。\n\n对于100%的数据：1 ≤ M ≤ 200，1 ≤ T ≤ 50。", "locale": "zh-CN"}}}
{"pid": "P4477", "type": "P", "difficulty": 6, "samples": [["4 10 8\n1 2 4 6\n6 3 6 2 8 4 9 10 6 8\n4\n1 4\n2 5\n5 6\n1 6", "4\n3\n1\n4"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "莫队", "北京", "枚举"], "title": "[BJWC2018] 基础匹配算法练习题", "background": null, "description": "小 S 最近学会了二分图匈牙利匹配算法。\n\n现在二分图的 X 部有 $N$ 个数字 $A_i$，Y 部有 $K$ 个数字 $C_i$。\n\n已知如果 $A_i + C_j \\le  Z$，那么 $A_i$ 和 $C_j$ 之间就有一条边，求二分图（X，E，Y）的最大匹配数。\n\n小 S 是初学者，所以她想做多做一些练习来巩固知识。于是她找到了一个长度为 $M$ 的正整数数组 $B$，每次她会在 $B$ 数组中抽取一段连续的区间 $[L_i,R_i]$，把区间 $[L_i,R_i]$ 的所有数字作为二分图 Y 部的 $K$ 个数字 $C_i$，然后重新求一次二分图最大匹配数。\n\n小 S 打算一共做 $Q$ 次练习，但是她不知道每次计算出的答案对不对，你能帮帮她吗？", "inputFormat": "第一行为三个正整数 $N,M,Z$。\n\n第二行为 $N$ 个正整数，第 $i$ 个正整数表示 $A_i$。\n\n第三行为 $M$ 个正整数，第 $i$ 个正整数表示 $B_i$。\n\n第四行为一个整数 $Q$ 表示询问个数。\n\n接下来 $Q$ 行每行两个正整数，第 $i$ 行的两个正整数分别表示 $L_i,R_i$。", "outputFormat": "对于每次练习，输出该次练习的答案。", "hint": "测试数据编号|$N$|$M$|$Q$\n:-:|:-:|:-:|:-:\n$1 \\sim 4$|$\\le 50$|$\\le 50$|$\\le 50$\n$5 \\sim 10$|$\\le 2501$|$\\le 2501$|$\\le 2501$\n$11\\sim 14$|$\\le 152501$|$\\le 45678$|$\\le 45678$\n$15 ,16$|$\\le 152501$|$\\le 50$|$\\le 52501$\n$17 \\sim 20$|$\\le 152501$|$\\le 52501$|$\\le 52501$\n\n对于 $100\\%$ 的数据，$1 \\le A_i,B_i,Z \\le 10^9$，$1 \\le L_i \\le R_i \\le M$。\n\n保证数据有一定梯度。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Basic Matching Algorithm Practice", "background": "", "description": "Xiao S recently learned the Hungarian algorithm for bipartite matching.\n\nNow the X part of a bipartite graph has $N$ numbers $A_i$, and the Y part has $K$ numbers $C_i$.\n\nIf $A_i + C_j \\le Z$, then there is an edge between $A_i$ and $C_j$. Find the maximum matching size of the bipartite graph $(X, E, Y)$.\n\nXiao S is a beginner, so she wants to do more practice to consolidate her knowledge. She found a positive integer array $B$ of length $M$. Each time, she picks a continuous subarray $[L_i, R_i]$ from $B$, takes all numbers in $[L_i, R_i]$ as the $K$ numbers $C_i$ on the Y part of the bipartite graph, and then recomputes the maximum matching size.\n\nXiao S plans to do $Q$ practice sessions, but she is not sure whether each computed answer is correct. Can you help her?", "inputFormat": "The first line contains three positive integers $N, M, Z$.\n\nThe second line contains $N$ positive integers, where the $i$-th integer is $A_i$.\n\nThe third line contains $M$ positive integers, where the $i$-th integer is $B_i$.\n\nThe fourth line contains an integer $Q$ denoting the number of queries.\n\nEach of the next $Q$ lines contains two positive integers; on the $i$-th line, the two integers are $L_i, R_i$.", "outputFormat": "For each practice session, output the answer for that session.", "hint": "Testdata ID|$N$|$M$|$Q$\n:-:|:-:|:-:|:-:\n$1 \\sim 4$|$\\le 50$|$\\le 50$|$\\le 50$\n$5 \\sim 10$|$\\le 2501$|$\\le 2501$|$\\le 2501$\n$11 \\sim 14$|$\\le 152501$|$\\le 45678$|$\\le 45678$\n$15 ,16$|$\\le 152501$|$\\le 50$|$\\le 52501$\n$17 \\sim 20$|$\\le 152501$|$\\le 52501$|$\\le 52501$\n\nFor $100\\%$ of the testdata, $1 \\le A_i, B_i, Z \\le 10^9$, $1 \\le L_i \\le R_i \\le M$.\n\nThe testdata is graded.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 基础匹配算法练习题", "background": null, "description": "小 S 最近学会了二分图匈牙利匹配算法。\n\n现在二分图的 X 部有 $N$ 个数字 $A_i$，Y 部有 $K$ 个数字 $C_i$。\n\n已知如果 $A_i + C_j \\le  Z$，那么 $A_i$ 和 $C_j$ 之间就有一条边，求二分图（X，E，Y）的最大匹配数。\n\n小 S 是初学者，所以她想做多做一些练习来巩固知识。于是她找到了一个长度为 $M$ 的正整数数组 $B$，每次她会在 $B$ 数组中抽取一段连续的区间 $[L_i,R_i]$，把区间 $[L_i,R_i]$ 的所有数字作为二分图 Y 部的 $K$ 个数字 $C_i$，然后重新求一次二分图最大匹配数。\n\n小 S 打算一共做 $Q$ 次练习，但是她不知道每次计算出的答案对不对，你能帮帮她吗？", "inputFormat": "第一行为三个正整数 $N,M,Z$。\n\n第二行为 $N$ 个正整数，第 $i$ 个正整数表示 $A_i$。\n\n第三行为 $M$ 个正整数，第 $i$ 个正整数表示 $B_i$。\n\n第四行为一个整数 $Q$ 表示询问个数。\n\n接下来 $Q$ 行每行两个正整数，第 $i$ 行的两个正整数分别表示 $L_i,R_i$。", "outputFormat": "对于每次练习，输出该次练习的答案。", "hint": "测试数据编号|$N$|$M$|$Q$\n:-:|:-:|:-:|:-:\n$1 \\sim 4$|$\\le 50$|$\\le 50$|$\\le 50$\n$5 \\sim 10$|$\\le 2501$|$\\le 2501$|$\\le 2501$\n$11\\sim 14$|$\\le 152501$|$\\le 45678$|$\\le 45678$\n$15 ,16$|$\\le 152501$|$\\le 50$|$\\le 52501$\n$17 \\sim 20$|$\\le 152501$|$\\le 52501$|$\\le 52501$\n\n对于 $100\\%$ 的数据，$1 \\le A_i,B_i,Z \\le 10^9$，$1 \\le L_i \\le R_i \\le M$。\n\n保证数据有一定梯度。", "locale": "zh-CN"}}}
{"pid": "P4478", "type": "P", "difficulty": 6, "samples": [["3 4 3 1019663265\n3 0\n1 1\n2 2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2018", "北京"], "title": "[BJWC2018] 上学路线", "background": "", "description": "小 B 所在的城市的道路构成了一个方形网格，它的西南角为 $(0,0)$，东北角为 $(N,M)$。\n\n小 B 家住在西南角，学校在东北角。现在有 $T$ 个路口进行施工，小 B 不能通过这些路口。小 B 喜欢走最短的路径到达目的地，因此他每天上学时都只会向东或北行走；而小 B 又喜欢走不同的路径，因此他问你按照他走最短路径的规则，他可以选择的不同的上学路线有多少条。由于答案可能很大，所以小 B 只需要让你求出路径数 mod $P$ 的值。", "inputFormat": "第一行为四个整数 $N$ 、 $M$ 、 $T$ 、 $P$。\n\n接下来的 $T$ 行，每行两个整数，表示施工的路口的坐标。", "outputFormat": "一行一个整数，表示路径数 mod $P$ 的值。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17943.png)", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Route to School", "background": "", "description": "The roads of Xiao B’s city form a square grid, whose southwest corner is $(0,0)$ and northeast corner is $(N,M)$.\n\nXiao B lives at the southwest corner, and the school is at the northeast corner. There are $T$ intersections under construction, and Xiao B cannot pass through these intersections. Xiao B prefers to take the shortest route to his destination, so each day he only moves east or north; since he also likes different routes, he asks you, under the rule of taking shortest routes, how many different routes to school he can choose. Because the answer may be large, compute the number of routes mod $P$.", "inputFormat": "The first line contains four integers $N$, $M$, $T$, $P$.\nThe next $T$ lines each contain two integers, denoting the coordinates of an intersection under construction.", "outputFormat": "Output a single integer, the number of routes mod $P$.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17943.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 上学路线", "background": "", "description": "小 B 所在的城市的道路构成了一个方形网格，它的西南角为 $(0,0)$，东北角为 $(N,M)$。\n\n小 B 家住在西南角，学校在东北角。现在有 $T$ 个路口进行施工，小 B 不能通过这些路口。小 B 喜欢走最短的路径到达目的地，因此他每天上学时都只会向东或北行走；而小 B 又喜欢走不同的路径，因此他问你按照他走最短路径的规则，他可以选择的不同的上学路线有多少条。由于答案可能很大，所以小 B 只需要让你求出路径数 mod $P$ 的值。", "inputFormat": "第一行为四个整数 $N$ 、 $M$ 、 $T$ 、 $P$。\n\n接下来的 $T$ 行，每行两个整数，表示施工的路口的坐标。", "outputFormat": "一行一个整数，表示路径数 mod $P$ 的值。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/17943.png)", "locale": "zh-CN"}}}
{"pid": "P4479", "type": "P", "difficulty": 6, "samples": [["4 1\n-1 -1\n2 1\n3 3\n1 4", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "二分", "树状数组", "离散化", "北京"], "title": "[BJWC2018] 第k大斜率", "background": "", "description": "在平面直角坐标系上，有 $n$ 个不同的点。任意两个不同的点确定了一条直线。请求出所有斜率存在的直线按斜率从大到小排序后，第 $k$ 条直线的斜率为多少。\n\n为了避免精度误差，请输出斜率向下取整后的结果。（例如：$\\lfloor 1.5 \\rfloor = 1$，$\\lfloor -1.5 \\rfloor = -2$）。", "inputFormat": "第一行，包含两个正整数 $n$ 和 $k$。  \n接下来 $n$ 行，每行包含两个整数 $x_i, y_i$，表示每个点的横纵坐标。", "outputFormat": "输出一行，包含一个整数，表示第 $k$ 大的斜率向下取整的结果。", "hint": "**【样例说明】**\n\n符合要求的直线的斜率分别为 $-3, -\\frac{1}{2}, \\frac{2}{3}, 1, 2, \\frac{5}{2}$ 。\n\n**【数据规模和约定】**\n\n令 $M$ 为所有斜率存在的直线的数量 。\n\n对于 $10 \\%$ 的数据，$1 \\le n \\le 10$。  \n对于 $20 \\%$ 的数据，$1 \\le n \\le 100$，$|x_i|, |y_i| \\le {10}^3$。  \n对于 $30 \\%$ 的数据，$1 \\le n \\le 1000$。  \n对于 $40 \\%$ 的数据，$1 ≤ n ≤ 5000$。  \n对于另 $20 \\%$ 的数据，满足 $k = 1$ 。  \n对于另 $20 \\%$ 的数据，满足 $1 \\le x_i, y_i \\le {10}^3$。  \n对于 $100 \\%$ 的数据，$1 \\le n \\le 100000$，$1 \\le k \\le M$，$|x_i|, |y_i| \\le {10}^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] The k-th Largest Slope", "background": "", "description": "On the 2D Cartesian plane, there are $n$ distinct points. Any two distinct points determine a line. Among all lines whose slopes are defined, sort them by slope in descending order and find the slope of the $k$-th line.\n\nTo avoid precision errors, please output the floor of the slope. (For example: $\\lfloor 1.5 \\rfloor = 1$, $\\lfloor -1.5 \\rfloor = -2$.)", "inputFormat": "The first line contains two positive integers $n$ and $k$.  \nEach of the next $n$ lines contains two integers $x_i, y_i$, the coordinates of a point.", "outputFormat": "Output one line containing an integer: the floor of the $k$-th largest slope.", "hint": "[Sample Explanation]\n\nThe slopes of the lines that meet the requirement are $-3, -\\frac{1}{2}, \\frac{2}{3}, 1, 2, \\frac{5}{2}$.\n\n[Constraints]\n\nLet $M$ be the number of lines whose slopes are defined.\n\n- For $10\\%$ of the testdata, $1 \\le n \\le 10$.\n- For $20\\%$ of the testdata, $1 \\le n \\le 100$, $|x_i|, |y_i| \\le 10^3$.\n- For $30\\%$ of the testdata, $1 \\le n \\le 1000$.\n- For $40\\%$ of the testdata, $1 \\le n \\le 5000$.\n- For another $20\\%$ of the testdata, $k = 1$.\n- For another $20\\%$ of the testdata, $1 \\le x_i, y_i \\le 10^3$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 100000$, $1 \\le k \\le M$, $|x_i|, |y_i| \\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 第k大斜率", "background": "", "description": "在平面直角坐标系上，有 $n$ 个不同的点。任意两个不同的点确定了一条直线。请求出所有斜率存在的直线按斜率从大到小排序后，第 $k$ 条直线的斜率为多少。\n\n为了避免精度误差，请输出斜率向下取整后的结果。（例如：$\\lfloor 1.5 \\rfloor = 1$，$\\lfloor -1.5 \\rfloor = -2$）。", "inputFormat": "第一行，包含两个正整数 $n$ 和 $k$。  \n接下来 $n$ 行，每行包含两个整数 $x_i, y_i$，表示每个点的横纵坐标。", "outputFormat": "输出一行，包含一个整数，表示第 $k$ 大的斜率向下取整的结果。", "hint": "**【样例说明】**\n\n符合要求的直线的斜率分别为 $-3, -\\frac{1}{2}, \\frac{2}{3}, 1, 2, \\frac{5}{2}$ 。\n\n**【数据规模和约定】**\n\n令 $M$ 为所有斜率存在的直线的数量 。\n\n对于 $10 \\%$ 的数据，$1 \\le n \\le 10$。  \n对于 $20 \\%$ 的数据，$1 \\le n \\le 100$，$|x_i|, |y_i| \\le {10}^3$。  \n对于 $30 \\%$ 的数据，$1 \\le n \\le 1000$。  \n对于 $40 \\%$ 的数据，$1 ≤ n ≤ 5000$。  \n对于另 $20 \\%$ 的数据，满足 $k = 1$ 。  \n对于另 $20 \\%$ 的数据，满足 $1 \\le x_i, y_i \\le {10}^3$。  \n对于 $100 \\%$ 的数据，$1 \\le n \\le 100000$，$1 \\le k \\le M$，$|x_i|, |y_i| \\le {10}^8$。", "locale": "zh-CN"}}}
{"pid": "P4480", "type": "P", "difficulty": 7, "samples": [["4 1 2 2 1 3\n8\n2\n1\n6", "35"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "网络流", "北京", "最短路", "队列"], "title": "[BJWC2018] 餐巾计划问题", "background": "**本题和网络流24题中的餐巾计划不为重题**", "description": "一个餐厅在相继的 $n$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天 $(i=1, 2, ..., n)$ 需要 $r_i$ 块餐巾。餐厅可以在任意时刻购买新的餐巾，每块餐巾的费用为 $p$ 。使用过的旧餐巾，则需要经过清洗才能重新使用。把一块旧餐巾送到清洗店A，需要等待 $m_1$ 天后才能拿到新餐巾，其费用为 $c_1$ ；把一块旧餐巾送到清洗店B，需要等待 $m_2$ 天后才能拿到新餐巾，其费用为 $c_2$ 。例如，将一块第 $k$ 天使用过的餐巾送到清洗店A清洗，则可以在第 $k+m_1$ 天使用。\n\n请为餐厅合理地安排好 $n$ 天中餐巾使用计划，使总的花费最小。", "inputFormat": "第一行，包含六个个正整数  $n, m_1, m_2, c_1, c_2, p$ 。\n\n接下来输入 $n$ 行，每行包含一个正整数 $r_i$ 。", "outputFormat": "输出一行，包含一个正整数，表示最小的总花费。", "hint": "**【样例说明】**\n\n第 1 天：买8块餐巾，花费24。送2块餐巾去清洗店A，6块餐巾去清洗店B。\n\n第 2 天：取回2块清洗店A的餐巾，花费4。送1块餐巾去清洗店B。\n\n第 3 天：取回6块清洗店B的餐巾，花费6。\n\n第 4 天：取回1块清洗店B的餐巾，花费1。这样就用了最少的钱。\n\n\n**【数据规模和约定】**\n\n对于30%的数据，$1 \\leq n \\leq 5$ ，$1 \\leq c_1, c_2, p \\leq 5$ ， $1 \\leq r_i \\leq 5$ 。\n\n对于50%的数据，$1 \\leq n \\leq 100$ ，$1 \\leq r_i \\leq 50$ 。\n\n对于70%的数据，$1 \\leq n \\leq 5000$ 。\n\n对于100%的数据，$1 \\leq n \\leq 200000$ ， $1 \\leq m_1, m_2 \\leq n$ ， $1 \\leq c_1, c_2, p \\leq 100$ ， $1 \\leq r_i \\leq 100$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Napkin Planning Problem", "background": "This problem is not the same as the Napkin Plan in the 24 Network Flow Problems.", "description": "A restaurant requires a varying number of napkins over $n$ consecutive days. Suppose on day $i$ ($i = 1, 2, \\ldots, n$) it needs $r_i$ napkins. The restaurant can purchase new napkins at any time, at a cost of $p$ per napkin. Used napkins must be washed before reuse. Sending one used napkin to laundry A returns it after $m_1$ days at a cost of $c_1$; sending one used napkin to laundry B returns it after $m_2$ days at a cost of $c_2$. For example, a napkin used on day $k$ and sent to laundry A can be used on day $k+m_1$.\n\nArrange the napkin usage plan over $n$ days to minimize the total cost.", "inputFormat": "The first line contains six positive integers $n, m_1, m_2, c_1, c_2, p$.\n\nThe next $n$ lines each contain a positive integer $r_i$.", "outputFormat": "Output one line containing a single positive integer, the minimum total cost.", "hint": "【Sample Explanation】\n\nDay 1: Buy 8 napkins, costing 24. Send 2 napkins to laundry A and 6 napkins to laundry B.\n\nDay 2: Take back 2 napkins from laundry A, costing 4. Send 1 napkin to laundry B.\n\nDay 3: Take back 6 napkins from laundry B, costing 6.\n\nDay 4: Take back 1 napkin from laundry B, costing 1. This achieves the minimum cost.\n\n【Constraints】\n\nFor 30% of the testdata, $1 \\leq n \\leq 5$, $1 \\leq c_1, c_2, p \\leq 5$, $1 \\leq r_i \\leq 5$.\n\nFor 50% of the testdata, $1 \\leq n \\leq 100$, $1 \\leq r_i \\leq 50$.\n\nFor 70% of the testdata, $1 \\leq n \\leq 5000$.\n\nFor 100% of the testdata, $1 \\leq n \\leq 200000$, $1 \\leq m_1, m_2 \\leq n$, $1 \\leq c_1, c_2, p \\leq 100$, $1 \\leq r_i \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 餐巾计划问题", "background": "**本题和网络流24题中的餐巾计划不为重题**", "description": "一个餐厅在相继的 $n$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天 $(i=1, 2, ..., n)$ 需要 $r_i$ 块餐巾。餐厅可以在任意时刻购买新的餐巾，每块餐巾的费用为 $p$ 。使用过的旧餐巾，则需要经过清洗才能重新使用。把一块旧餐巾送到清洗店A，需要等待 $m_1$ 天后才能拿到新餐巾，其费用为 $c_1$ ；把一块旧餐巾送到清洗店B，需要等待 $m_2$ 天后才能拿到新餐巾，其费用为 $c_2$ 。例如，将一块第 $k$ 天使用过的餐巾送到清洗店A清洗，则可以在第 $k+m_1$ 天使用。\n\n请为餐厅合理地安排好 $n$ 天中餐巾使用计划，使总的花费最小。", "inputFormat": "第一行，包含六个个正整数  $n, m_1, m_2, c_1, c_2, p$ 。\n\n接下来输入 $n$ 行，每行包含一个正整数 $r_i$ 。", "outputFormat": "输出一行，包含一个正整数，表示最小的总花费。", "hint": "**【样例说明】**\n\n第 1 天：买8块餐巾，花费24。送2块餐巾去清洗店A，6块餐巾去清洗店B。\n\n第 2 天：取回2块清洗店A的餐巾，花费4。送1块餐巾去清洗店B。\n\n第 3 天：取回6块清洗店B的餐巾，花费6。\n\n第 4 天：取回1块清洗店B的餐巾，花费1。这样就用了最少的钱。\n\n\n**【数据规模和约定】**\n\n对于30%的数据，$1 \\leq n \\leq 5$ ，$1 \\leq c_1, c_2, p \\leq 5$ ， $1 \\leq r_i \\leq 5$ 。\n\n对于50%的数据，$1 \\leq n \\leq 100$ ，$1 \\leq r_i \\leq 50$ 。\n\n对于70%的数据，$1 \\leq n \\leq 5000$ 。\n\n对于100%的数据，$1 \\leq n \\leq 200000$ ， $1 \\leq m_1, m_2 \\leq n$ ， $1 \\leq c_1, c_2, p \\leq 100$ ， $1 \\leq r_i \\leq 100$ 。", "locale": "zh-CN"}}}
{"pid": "P4481", "type": "P", "difficulty": 5, "samples": [["3\n3 2 2\n1 2 3\n3 2 3\n1 2 3\n4 3 3\n1 2 3 4", "9\n6\n0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2018", "北京", "区间 DP"], "title": "[BJWC2018] 序列合并", "background": "绿意盎然的一天，Scape 去 XX 赛区加冕为王。", "description": "Scape 倒开题目，看到了这样一道题：\n\n有一个序列 $A$ 和 $L,R$，每次可以合并相邻的 $K$ 个元素（要求 $L\\leq K\\leq R$），代价为这 $K$ 个元素的和并合并产生一个新元素，权值为这 $K$ 个元素的和。\n\n求把整个序列合并为一个元素的最小代价。\n\nScape 想都不想就写了一个 $\\mathcal{O}(n^4)$ 暴力，结果居然 T 了，作为 XX 之王的 Scape 自然不会管这种辣鸡题，请你写出这道题。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n每组数据第一行三个整数 $n,L,R$ 表示序列 $A$ 的长度，和 $K$ 的上下界限制。\n\n第二行 $n$ 个整数表示序列 $A$。", "outputFormat": "每行一个整数表示结果，无解输出 $0$。", "hint": "对于 $20\\%$ 的数据， $n\\le 20$。\n\n对于 $60\\%$ 的数据， $n\\le 50$。\n\n对于 $100\\%$ 的数据， $1\\le T\\le 10,n\\le 300,A_i\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Sequence Merging", "background": "On a verdant day, Scape went to the XX division to be crowned king.", "description": "Scape flipped open the problemset and saw this problem:\n\nThere is a sequence $A$ and $L, R$. At each step, you may merge $K$ adjacent elements (with $L \\le K \\le R$). The cost is the sum of those $K$ elements, and the merge produces a new element whose value is that same sum.\n\nFind the minimum cost to merge the entire sequence into one element.\n\nWithout thinking, Scape wrote an $\\mathcal{O}(n^4)$ brute force, which actually timed out (TLE). As the king of XX, Scape naturally will not bother with such a “trash” problem; please solve it.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains three integers $n, L, R$, denoting the length of sequence $A$ and the bounds on $K$.\n\nThe second line contains $n$ integers, the sequence $A$.", "outputFormat": "For each test case, output one integer — the answer. If it is impossible, output $0$.", "hint": "Constraints:\n- For $20\\%$ of the testdata, $n \\le 20$.\n- For $60\\%$ of the testdata, $n \\le 50$.\n- For $100\\%$ of the testdata, $1 \\le T \\le 10$, $n \\le 300$, $A_i \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 序列合并", "background": "绿意盎然的一天，Scape 去 XX 赛区加冕为王。", "description": "Scape 倒开题目，看到了这样一道题：\n\n有一个序列 $A$ 和 $L,R$，每次可以合并相邻的 $K$ 个元素（要求 $L\\leq K\\leq R$），代价为这 $K$ 个元素的和并合并产生一个新元素，权值为这 $K$ 个元素的和。\n\n求把整个序列合并为一个元素的最小代价。\n\nScape 想都不想就写了一个 $\\mathcal{O}(n^4)$ 暴力，结果居然 T 了，作为 XX 之王的 Scape 自然不会管这种辣鸡题，请你写出这道题。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n每组数据第一行三个整数 $n,L,R$ 表示序列 $A$ 的长度，和 $K$ 的上下界限制。\n\n第二行 $n$ 个整数表示序列 $A$。", "outputFormat": "每行一个整数表示结果，无解输出 $0$。", "hint": "对于 $20\\%$ 的数据， $n\\le 20$。\n\n对于 $60\\%$ 的数据， $n\\le 50$。\n\n对于 $100\\%$ 的数据， $1\\le T\\le 10,n\\le 300,A_i\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P4482", "type": "P", "difficulty": 7, "samples": [["abbabbaa\n3\n1 8\n1 7\n2 7", "1\n4\n3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "北京", "O2优化"], "title": "[BJWC2018] Border 的四种求法", "background": "Scape 一到机房，所有做题的人便都看着他笑，有的叫道，“Scape，你一定又被标准分倍杀了！”他不回答，对柜里说，“测两个程序，看一眼成绩单。”便拷出两个程序。他们又故意的高声嚷道，“你怎么欧拉回路和逆序对都WA了！”……", "description": "Scape 知道，以上的故事只是 OI 生涯里的一个意外，为了证明自己，他决定教你 $\\text{Border}$ 的四种求法。\n\n给一个小写字母字符串 $S$，$q$ 次询问每次给出 $l,r$ ，求 $s_{l\\ldots r}$ 的 $\\text{Border}$。\n\n$\\text{Border}$：对于给定的串 $s$，最大的 $i$ 使得 $s_{1\\ldots i} = s_{|s|-i+1\\ldots |s|}$。$|s|$ 为 $s$ 的长度。", "inputFormat": "第一行一个字符串 $S$。\n\n第二行一个整数 $q$ 表示询问个数。\n\n接下来的 $q$ 行每行两个整数 $l,r$ 表示一个询问。", "outputFormat": "对于每组询问输出答案。", "hint": "对于 $30%$ 的数据， $n,q\\leq 1000$ 。\n\n对于 $50%$ 的数据， $n,q\\leq 2\\times 10^4$ 。\n\n对于另外 $30\\%$ 的数据，答案至少为 $r-l+1$ 的一半。\n\n对于 $100\\%$ 的数据， $n,q\\leq 2\\times 10^5$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Four Methods to Compute Border", "background": "As soon as Scape walked into the computer lab, everyone solving problems looked at him and laughed. Someone shouted, \"Scape, you must have been crushed by the standard score again!\" He did not answer; he said, \"Run two programs, check the score sheet,\" and then he copied out two programs. They deliberately shouted again, \"How did you get WA on both the Euler circuit and inversions?\" ...", "description": "Scape knows that the story above is just an accident in his OI career. To prove himself, he decides to teach you four methods to compute $\\text{Border}$.\n\nGiven a lowercase-letter string $S$, there are $q$ queries. Each query gives $l, r$, and asks for the $\\text{Border}$ of $s_{l\\ldots r}$.\n\n$\\text{Border}$: For a given string $s$, the largest $i$ such that $s_{1\\ldots i} = s_{|s|-i+1\\ldots |s|}$. Here $|s|$ is the length of $s$.", "inputFormat": "The first line contains a string $S$.\n\nThe second line contains an integer $q$ denoting the number of queries.\n\nEach of the next $q$ lines contains two integers $l, r$ denoting a query.", "outputFormat": "For each query, output the answer.", "hint": "- For $30\\%$ of the testdata, $n, q \\le 1000$.\n- For $50\\%$ of the testdata, $n, q \\le 2\\times 10^4$.\n- For another $30\\%$ of the testdata, the answer is at least half of $r - l + 1$.\n- For $100\\%$ of the testdata, $n, q \\le 2\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] Border 的四种求法", "background": "Scape 一到机房，所有做题的人便都看着他笑，有的叫道，“Scape，你一定又被标准分倍杀了！”他不回答，对柜里说，“测两个程序，看一眼成绩单。”便拷出两个程序。他们又故意的高声嚷道，“你怎么欧拉回路和逆序对都WA了！”……", "description": "Scape 知道，以上的故事只是 OI 生涯里的一个意外，为了证明自己，他决定教你 $\\text{Border}$ 的四种求法。\n\n给一个小写字母字符串 $S$，$q$ 次询问每次给出 $l,r$ ，求 $s_{l\\ldots r}$ 的 $\\text{Border}$。\n\n$\\text{Border}$：对于给定的串 $s$，最大的 $i$ 使得 $s_{1\\ldots i} = s_{|s|-i+1\\ldots |s|}$。$|s|$ 为 $s$ 的长度。", "inputFormat": "第一行一个字符串 $S$。\n\n第二行一个整数 $q$ 表示询问个数。\n\n接下来的 $q$ 行每行两个整数 $l,r$ 表示一个询问。", "outputFormat": "对于每组询问输出答案。", "hint": "对于 $30%$ 的数据， $n,q\\leq 1000$ 。\n\n对于 $50%$ 的数据， $n,q\\leq 2\\times 10^4$ 。\n\n对于另外 $30\\%$ 的数据，答案至少为 $r-l+1$ 的一半。\n\n对于 $100\\%$ 的数据， $n,q\\leq 2\\times 10^5$ 。", "locale": "zh-CN"}}}
{"pid": "P4483", "type": "P", "difficulty": 6, "samples": [["65432", "01:08 03:40 13:52"], ["1", "00:01 00:01 00:01"], ["58", "00:01 00:02 00:01"], ["2000000000", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "北京"], "title": "[BJWC2018] 神奇的钟点", "background": "", "description": "一天，小 L 看到了 3 块钟表，分别显示着 $\\texttt{01:08}$、$\\texttt{03:40}$、$\\texttt{13:52}$。小 L 发现，每块表上的时间都是 $\\texttt{hh:mm}$ 的形式，其中 $\\texttt{hh}$ 表示小时，$\\texttt{mm}$ 表示分钟，而且都不是整点（即 $0\\leqslant\\texttt{hh}<24$，$1\\leqslant\\texttt{mm}<60$）。\n\n回想起小学数学老师刚刚讲的关于比例的知识，$\\texttt{hh:mm}$ 也表示一个比，它的值等于 $\\frac{\\texttt{hh}}{\\texttt{mm}}$。这时小 L 发现了一件神奇的事情：把这三个钟点加起来会得到 $\\texttt{18:40}$，这也是一个不是整点的合法时间（注意小时数要小于 $24$），它对应的比值 $\\frac{9}{20}$，与这三个钟点对应的比值 $\\frac{1}{8}$、$\\frac{3}{40}$、$\\frac{1}{4}$ 之和竟然相等！\n\n现在小 L 想知道，把所有的满足这个神奇的性质的 3 个钟点组成的钟点组按照字典序排序后，第 $k$ 小的是什么。", "inputFormat": "输入仅包含一个正整数 $k$。", "outputFormat": "输出字典序第 $k$ 小的满足题目所述神奇性质的钟点组，以一个空格隔开，详见样例输出。如果答案不存在，输出 `-1`。", "hint": "**【样例说明】**\n\n注意钟点可以相同。\n\n**【数据规模和约定】**\n\n对于 $30\\%$ 的数据，$k\\leqslant 1000$。  \n对于 $60\\%$ 的数据，$k\\leqslant 20000$。  \n对于 $100\\%$ 的数据，$1\\leqslant k\\leqslant 2\\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Magical Clock Times", "background": "", "description": "One day, Xiao L saw three clocks showing $\\texttt{01:08}$, $\\texttt{03:40}$, and $\\texttt{13:52}$. Xiao L noticed that each time is in the form $\\texttt{hh:mm}$, where $\\texttt{hh}$ is the hour and $\\texttt{mm}$ is the minute, and none of them is on the hour (i.e., $0\\leqslant\\texttt{hh}<24$, $1\\leqslant\\texttt{mm}<60$).\n\nRecalling a lesson about ratios, $\\texttt{hh:mm}$ also represents a ratio with value $\\frac{\\texttt{hh}}{\\texttt{mm}}$. Then Xiao L discovered something magical: adding these three times yields $\\texttt{18:40}$, which is also a valid time that is not on the hour (note the hour must be less than $24$). Its corresponding ratio $\\frac{9}{20}$ is exactly equal to the sum of the ratios $\\frac{1}{8}$, $\\frac{3}{40}$, and $\\frac{1}{4}$ of the three times!\n\nNow Xiao L wants to know: among all triplets of times that satisfy this magical property, sorted in lexicographic order, what is the $k$-th smallest?", "inputFormat": "The input contains only a single positive integer $k$.", "outputFormat": "Output the $k$-th smallest triplet that satisfies the magical property described in the statement, with the three times separated by a space; see the sample output. If the answer does not exist, output `-1`.", "hint": "【Sample Explanation】\n\nNote that the times may be identical.\n\n【Constraints】\n\nFor $30\\%$ of the testdata, $k\\leqslant 1000$.  \nFor $60\\%$ of the testdata, $k\\leqslant 20000$.  \nFor $100\\%$ of the testdata, $1\\leqslant k\\leqslant 2\\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 神奇的钟点", "background": "", "description": "一天，小 L 看到了 3 块钟表，分别显示着 $\\texttt{01:08}$、$\\texttt{03:40}$、$\\texttt{13:52}$。小 L 发现，每块表上的时间都是 $\\texttt{hh:mm}$ 的形式，其中 $\\texttt{hh}$ 表示小时，$\\texttt{mm}$ 表示分钟，而且都不是整点（即 $0\\leqslant\\texttt{hh}<24$，$1\\leqslant\\texttt{mm}<60$）。\n\n回想起小学数学老师刚刚讲的关于比例的知识，$\\texttt{hh:mm}$ 也表示一个比，它的值等于 $\\frac{\\texttt{hh}}{\\texttt{mm}}$。这时小 L 发现了一件神奇的事情：把这三个钟点加起来会得到 $\\texttt{18:40}$，这也是一个不是整点的合法时间（注意小时数要小于 $24$），它对应的比值 $\\frac{9}{20}$，与这三个钟点对应的比值 $\\frac{1}{8}$、$\\frac{3}{40}$、$\\frac{1}{4}$ 之和竟然相等！\n\n现在小 L 想知道，把所有的满足这个神奇的性质的 3 个钟点组成的钟点组按照字典序排序后，第 $k$ 小的是什么。", "inputFormat": "输入仅包含一个正整数 $k$。", "outputFormat": "输出字典序第 $k$ 小的满足题目所述神奇性质的钟点组，以一个空格隔开，详见样例输出。如果答案不存在，输出 `-1`。", "hint": "**【样例说明】**\n\n注意钟点可以相同。\n\n**【数据规模和约定】**\n\n对于 $30\\%$ 的数据，$k\\leqslant 1000$。  \n对于 $60\\%$ 的数据，$k\\leqslant 20000$。  \n对于 $100\\%$ 的数据，$1\\leqslant k\\leqslant 2\\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4484", "type": "P", "difficulty": 6, "samples": [["1\n", "1\n"], ["2\n", "499122178\n"], ["3\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "北京", "差分", "杨表", "状压 DP"], "title": "[BJWC2018] 最长上升子序列", "background": "", "description": "现在有一个长度为 $n$ 的随机排列，求它的最长上升子序列长度的期望。\n\n为了避免精度误差，你只需要输出答案模 $998244353$ 的余数。", "inputFormat": "输入只包含一个正整数 $n$。", "outputFormat": "输出只包含一个非负整数，表示答案模 $998244353$ 的余数。\n\n可以证明，答案一定为有理数，设其为 $a/b$（$a, b$ 为互质的整数），你输出的整数为 $x$，则你需要保证 $0 \\le x < 998244353$ 且 $a$ 与 $b x$ 模 $998244353$ 同余。", "hint": "**【样例 \\#2 说明】**\n\n这是 $3/2$。\n\n**【数据规模和约定】**\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 28$。\n\n共有 25 组数据，对于第 $i$ 组数据（$1 \\le i \\le 25$），$n = i + 3$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Longest Increasing Subsequence", "background": "", "description": "Given a uniformly random permutation of length $n$, compute the expected length of its longest increasing subsequence.\n\nTo avoid precision errors, you only need to output the answer modulo $998244353$.", "inputFormat": "The input contains a single positive integer $n$.", "outputFormat": "Output a single non-negative integer, the remainder of the answer modulo $998244353$.\n\nIt can be proved that the answer is a rational number; let it be $a/b$ ($a, b$ are coprime integers). Let the integer you output be $x$. You must ensure $0 \\le x < 998244353$ and $a \\equiv b x \\pmod{998244353}$.", "hint": "Sample #2 Explanation:\n\nThis is $3/2$.\n\nConstraints:\n\n- For $100\\%$ of the data, $1 \\le n \\le 28$.\n- There are 25 testcases. For the $i$-th testcase ($1 \\le i \\le 25$), $n = i + 3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 最长上升子序列", "background": "", "description": "现在有一个长度为 $n$ 的随机排列，求它的最长上升子序列长度的期望。\n\n为了避免精度误差，你只需要输出答案模 $998244353$ 的余数。", "inputFormat": "输入只包含一个正整数 $n$。", "outputFormat": "输出只包含一个非负整数，表示答案模 $998244353$ 的余数。\n\n可以证明，答案一定为有理数，设其为 $a/b$（$a, b$ 为互质的整数），你输出的整数为 $x$，则你需要保证 $0 \\le x < 998244353$ 且 $a$ 与 $b x$ 模 $998244353$ 同余。", "hint": "**【样例 \\#2 说明】**\n\n这是 $3/2$。\n\n**【数据规模和约定】**\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 28$。\n\n共有 25 组数据，对于第 $i$ 组数据（$1 \\le i \\le 25$），$n = i + 3$。", "locale": "zh-CN"}}}
{"pid": "P4485", "type": "P", "difficulty": 0, "samples": [["4 4 4\n1 2 3 4", "1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "北京"], "title": "[BJWC2018] 拓扑序列", "background": "", "description": "小 C 最近学习了拓扑排序的相关知识。对一个有向无环图 $G$ 进行拓扑排序，是将 $G$ 中所有顶点排成一个线性序列，使得对图 $G$ 中任意一条有向边 $(u,v)$，$u$ 在线性序列中出现在 $v$ 之前。例如，如果图 $G$ 的点集为 $\\{1,2,3,4\\}$，边集为 $\\{(1,2)\n,(1,3),(2,4),(3,4)\\}$，那么 $(1,2,3,4)$ 和 $(1,3,2,4)$ 都是图 $G$ 的拓扑序列。\n\n现在小 C 对一个简单（无重边）有向无环图进行了拓扑排序，但不小心把原图弄丢了。除了拓扑序列，小 C 只记得原图的边数为 $k$，而且图中存在一个顶点 $u$ 可以到达其他所有顶点。他想知道有多少个满足上述要求的简单有向无环图。由于答案可能很大，你只需要输出答案模 $m$ 的余数。", "inputFormat": "输入第一行包含三个整数 $n,k,m$。\n\n第二行是空格隔开的 $n$ 个正整数 $a_1,a_2,…,a_n$，表示原图的一个拓扑序列，保证是 $1$ 到 $n$ 的一个排列。\t", "outputFormat": "仅输出一个整数， 表示满足要求的简单有向无环图个数模 $m$ 的余数。", "hint": "**【样例说明】**\n\n共有 $9$ 个满足要求的简单有向无环图，边集分别为：\n\n$\\{(1, 2), (1, 3), (1, 4), (2, 3)\\}$\n\n$\\{(1, 2), (1, 3), (1, 4), (2, 4)\\}$\n\n$\\{(1, 2), (1, 3), (1, 4), (3, 4)\\}$\n\n$\\{(1, 2), (1, 3), (2, 3), (2, 4)\\}$\n\n$\\{(1, 2), (1, 3), (2, 3), (3, 4)\\}$\n\n$\\{(1, 2), (1, 3), (2, 4), (3, 4)\\}$\n\n$\\{(1, 2), (1, 4), (2, 3), (2, 4)\\}$\n\n$\\{(1, 2), (1, 4), (2, 3), (3, 4)\\}$\n\n$\\{(1, 2), (2, 3), (2, 4), (3, 4)\\}$\n\n**【数据规模和约定】**\n\n对于 $100\\%$ 的数据 ，$0 \\le k \\le n \\le 2\\times 10^5$，$1 \\leq m \\leq 10^{200000}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/17945.png)", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Topological Sequence", "background": "", "description": "Xiao C recently learned about topological sorting. Performing a topological sort on a directed acyclic graph $G$ means arranging all vertices of $G$ into a linear order such that for any directed edge $(u, v)$ in $G$, $u$ appears before $v$ in the linear order. For example, if the vertex set of $G$ is $\\{1,2,3,4\\}$ and the edge set is $\\{(1,2)\n,(1,3),(2,4),(3,4)\\}$, then $(1,2,3,4)$ and $(1,3,2,4)$ are both topological sequences of $G$.\n\nNow Xiao C performed a topological sort on a simple (no multiple edges) directed acyclic graph, but accidentally lost the original graph. Besides the topological sequence, he only remembers that the original graph has $k$ edges, and that there exists a vertex $u$ that can reach all other vertices in the graph. He wants to know how many simple directed acyclic graphs satisfy the above requirements. Since the answer may be large, you only need to output the answer modulo $m$.", "inputFormat": "The first line contains three integers $n, k, m$.\n\nThe second line contains $n$ space-separated positive integers $a_1, a_2, \\dots, a_n$, representing a topological sequence of the original graph, guaranteed to be a permutation of $1$ to $n$.", "outputFormat": "Output a single integer, the remainder modulo $m$ of the number of simple directed acyclic graphs that satisfy the requirements.", "hint": "【Sample Explanation】\n\nThere are $9$ simple directed acyclic graphs that satisfy the requirements. Their edge sets are:\n\n$\\{(1, 2), (1, 3), (1, 4), (2, 3)\\}$\n\n$\\{(1, 2), (1, 3), (1, 4), (2, 4)\\}$\n\n$\\{(1, 2), (1, 3), (1, 4), (3, 4)\\}$\n\n$\\{(1, 2), (1, 3), (2, 3), (2, 4)\\}$\n\n$\\{(1, 2), (1, 3), (2, 3), (3, 4)\\}$\n\n$\\{(1, 2), (1, 3), (2, 4), (3, 4)\\}$\n\n$\\{(1, 2), (1, 4), (2, 3), (2, 4)\\}$\n\n$\\{(1, 2), (1, 4), (2, 3), (3, 4)\\}$\n\n$\\{(1, 2), (2, 3), (2, 4), (3, 4)\\}$\n\nConstraints\n\nFor $100\\%$ of the testdata, $0 \\le k \\le n \\le 2 \\times 10^5$, $1 \\le m \\le 10^{200000}$.\n\n![](https://cdn.luogu.com.cn/upload/pic/17945.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] 拓扑序列", "background": "", "description": "小 C 最近学习了拓扑排序的相关知识。对一个有向无环图 $G$ 进行拓扑排序，是将 $G$ 中所有顶点排成一个线性序列，使得对图 $G$ 中任意一条有向边 $(u,v)$，$u$ 在线性序列中出现在 $v$ 之前。例如，如果图 $G$ 的点集为 $\\{1,2,3,4\\}$，边集为 $\\{(1,2)\n,(1,3),(2,4),(3,4)\\}$，那么 $(1,2,3,4)$ 和 $(1,3,2,4)$ 都是图 $G$ 的拓扑序列。\n\n现在小 C 对一个简单（无重边）有向无环图进行了拓扑排序，但不小心把原图弄丢了。除了拓扑序列，小 C 只记得原图的边数为 $k$，而且图中存在一个顶点 $u$ 可以到达其他所有顶点。他想知道有多少个满足上述要求的简单有向无环图。由于答案可能很大，你只需要输出答案模 $m$ 的余数。", "inputFormat": "输入第一行包含三个整数 $n,k,m$。\n\n第二行是空格隔开的 $n$ 个正整数 $a_1,a_2,…,a_n$，表示原图的一个拓扑序列，保证是 $1$ 到 $n$ 的一个排列。\t", "outputFormat": "仅输出一个整数， 表示满足要求的简单有向无环图个数模 $m$ 的余数。", "hint": "**【样例说明】**\n\n共有 $9$ 个满足要求的简单有向无环图，边集分别为：\n\n$\\{(1, 2), (1, 3), (1, 4), (2, 3)\\}$\n\n$\\{(1, 2), (1, 3), (1, 4), (2, 4)\\}$\n\n$\\{(1, 2), (1, 3), (1, 4), (3, 4)\\}$\n\n$\\{(1, 2), (1, 3), (2, 3), (2, 4)\\}$\n\n$\\{(1, 2), (1, 3), (2, 3), (3, 4)\\}$\n\n$\\{(1, 2), (1, 3), (2, 4), (3, 4)\\}$\n\n$\\{(1, 2), (1, 4), (2, 3), (2, 4)\\}$\n\n$\\{(1, 2), (1, 4), (2, 3), (3, 4)\\}$\n\n$\\{(1, 2), (2, 3), (2, 4), (3, 4)\\}$\n\n**【数据规模和约定】**\n\n对于 $100\\%$ 的数据 ，$0 \\le k \\le n \\le 2\\times 10^5$，$1 \\leq m \\leq 10^{200000}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/17945.png)", "locale": "zh-CN"}}}
{"pid": "P4486", "type": "P", "difficulty": 7, "samples": [["8 8\n0 1 1 0 0 1 1 1\n2 4 4 0 3 4 4 4\n2 4 4 3 4 4 4 4\n2 4 4 4 4 4 1 0\n0 2 4 4 3 4 4 1\n0 1 3 4 4 4 4 4\n2 4 4 4 4 2 4 4\n2 4 4 4 0 2 4 4\n23 30 27 12 16\n16 9 7 17 24 8 7 9\n17 8 9 15 29 8 9 5 7\n35 6 8 5 9 7 12\n7 6 1 7 8 2 6 7\n11 10 16 4 6 1 3 2\n21 8 9 3 1 5 1 4\n6 3 1 2 3 2 1\n-1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1", "0"], ["5 5\n0 1 1 1 1\n2 4 4 4 4\n2 4 4 3 4\n2 4 4 4 4\n2 4 4 4 4\n16 8 6 8\n4 4 9 5 4\n12 8 4 19 10 4\n14 2 3 3 6\n1 7 9 4 5\n17 5 10 13\n11 15 16 4 14\n20 20 15 5 16 3\n4 3 19 2 4\n19 19 13 15 20", "822"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "网络流", "北京", "上下界网络流"], "title": "[BJWC2018] Kakuro", "background": "首先介绍一下Kakuro(カックロ) 这个游戏。\n\n游戏规则为：\n\n• 方形空格中填入1 ~ 9 的整数。\n\n• 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。\n\n• 无论是横向还是纵向，连续方格中的数字不能重复。\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n![](https://cdn.luogu.com.cn/upload/pic/17947.png)\n\n左边为一个Kakuro 游戏，右边为这个游戏的唯一解。\n\n我们称一开始给出的数字为线索，称需要填入数字的地方为空格。如果一个格子包含线索那么就不需要填入数字。我们约定所有的谜题都非空，即至少有一个空格需要被填入。\n\n**注意：在以下题目中的游戏规则可能会有所不同，请认真阅读在每个\n题目下的规则。**", "description": "游戏规则：\n\n• 空格中填入正整数。\n\n• 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。\n\nApia 给了Rimbaud 一个Kakuro 谜题。心不灵手不巧的Rimbaud 根本不会做Kakuro，所以只在空格里面填上了一些随机的数字，称这个为一个局面，即包含了谜题一开始给出的线索和后面填入的数字。\n\n现在Rimbaud 希望能修改这个局面使得她的答案是一个合法解。这个局面中有些数字(**包括一开始的给出线索和后面填入的数字**) 是可以修改的。每个数字都有个特定的代价，将这个数字加1 或者减1 都得付出这个数字对应的代价。注意对于一组合法解，必须满足游戏规则，也就是**空格中填的数字必须是正整数并且满足和的条件，但是不要求不重复**。\n\nRimbaud 希望用最少的代价让这个局面变得合法，如果不可能那么输出-1。", "inputFormat": "第一行，两个正整数表示n,m 表示这个游戏的行和列。\n\n接下来n 行，每行包含m 个0 到4 的数字，第i 行第j 列表示第i 行第j 列格子的种类。\n\n• 0 表示这个格子既不是空格也不是线索。\n\n• 1 表示这个格子左下角包含线索，右上角没有线索。\n\n• 2 表示这个格子右上角包含线索，左下角没有线索。\n\n• 3 表示这个格子左下角右上角都包含线索。\n\n• 4 表示这个格子为空格。\n\n输入保证这个从格式上来说一定是个合法的Kakuro 谜题，即每一段连续的空格的左边或者上面的格子包含线索。\n\n接下来n 行，每行包含若干个正整数，按从左往右的顺序给出初始局面中的每个数字。特别地如果这个格子的种类为3，那么先给出左下角的线索，再给出右上角的线索。\n\n接下来n 行，每行包含若干个整数，按从左往右的顺序给出初始局面中的每个数字对应的代价。如果代价为-1 表示这个格子不能修改，否则代价为非负整数。注意3 号格子的两个线索有着两个不同的代价。\n\n**样例1 给出了上面的谜题的输入，请在做题前阅读样例1 确保你理解了输入格式。**", "outputFormat": "一个整数表示最小的代价，如果不可能输出-1。", "hint": "对于5% 的数据，保证所有的代价都为-1。\n\n对于20% 的数据，保证所有空格中的数字代价都为-1。\n\n对于另外30% 的数据，保证所有代表线索的数字的代价都为-1。\n\n对于另外20% 的数据，保证只有第一行第一列包含线索，剩下的地方全都是空格。\n\n对于100% 的数据，保证3 ≤ n,m ≤ 30，保证初始局面中的每个数字不超过$10^6$，保证每个数字的代价不超过$10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Kakuro", "background": "First, an introduction to the game Kakuro (カックロ).\n\nRules of the game:\n• Fill each blank square with an integer from 1 to 9.\n• In a square divided by a diagonal, the number in the upper-right corner equals the sum of the numbers in the contiguous squares to its right, and the number in the lower-left corner equals the sum of the numbers in the contiguous squares below it.\n• In any contiguous run of squares, whether horizontal or vertical, the numbers cannot repeat.\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n![](https://cdn.luogu.com.cn/upload/pic/17947.png)\n\nThe left figure shows a Kakuro puzzle, and the right figure shows its unique solution.\n\nWe call the initially given numbers clues, and the places where numbers are to be filled blanks. If a cell contains a clue, then no number needs to be filled there. We assume all puzzles are nonempty, i.e., at least one blank must be filled.\n\nNote: The rules in the following problems may differ from the above. Please read the rules under each problem carefully.", "description": "Rules of this problem:\n• Fill each blank with a positive integer.\n• In a square divided by a diagonal, the number in the upper-right corner equals the sum of the numbers in the contiguous squares to its right, and the number in the lower-left corner equals the sum of the numbers in the contiguous squares below it.\n\nApia gave Rimbaud a Kakuro puzzle. Clumsy as she is, Rimbaud did not know how to solve Kakuro, so she filled some random numbers into the blanks. We call this a position: it includes both the initially given clues and the numbers filled later.\n\nNow Rimbaud wants to modify this position so that her answer becomes a valid solution. Some numbers in this position (including both the initially given clues and the numbers filled later) can be modified. Each number has a specific cost: increasing or decreasing this number by 1 costs its associated cost per unit. Note that any valid solution must satisfy the game rules: the numbers filled in blanks must be positive integers and must satisfy the sum conditions, but distinctness is not required.\n\nRimbaud wants to make the position valid with the minimum total cost; if impossible, output -1.", "inputFormat": "The first line contains two positive integers n, m, the numbers of rows and columns.\n\nThen follow n lines, each containing m integers from 0 to 4; the integer in row i and column j denotes the type of the cell at (i, j):\n• 0 means the cell is neither a blank nor a clue.\n• 1 means the cell has a clue in the lower-left corner, and no clue in the upper-right corner.\n• 2 means the cell has a clue in the upper-right corner, and no clue in the lower-left corner.\n• 3 means the cell has clues in both the lower-left and upper-right corners.\n• 4 means the cell is a blank.\n\nThe input is guaranteed to be a syntactically valid Kakuro puzzle: for every contiguous run of blanks, the cell immediately to its left or immediately above contains a clue.\n\nThen follow n lines, each containing a sequence of positive integers, giving, from left to right, every number present in the initial position. In particular, if a cell is of type 3, then the lower-left clue is given first, followed by the upper-right clue.\n\nThen follow n lines, each containing a sequence of integers, giving, from left to right, the modification cost corresponding to each number in the initial position. A cost of -1 means the number in that cell cannot be modified; otherwise the cost is a nonnegative integer. Note that the two clues in a type 3 cell have two different costs.\n\nSample 1 gives the input for the puzzle above. Please read Sample 1 before solving to ensure you understand the input format.", "outputFormat": "Output a single integer, the minimum total cost. If it is impossible, output -1.", "hint": "• For 5% of the testdata, all costs are -1.\n• For 20% of the testdata, the costs of all numbers in blanks are -1.\n• For another 30% of the testdata, the costs of all clue numbers are -1.\n• For another 20% of the testdata, only the cell at row 1, column 1 contains clues, and all remaining cells are blanks.\n• For 100% of the testdata, 3 ≤ n, m ≤ 30, every number in the initial position is at most $10^6$, and every cost is at most $10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] Kakuro", "background": "首先介绍一下Kakuro(カックロ) 这个游戏。\n\n游戏规则为：\n\n• 方形空格中填入1 ~ 9 的整数。\n\n• 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。\n\n• 无论是横向还是纵向，连续方格中的数字不能重复。\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n![](https://cdn.luogu.com.cn/upload/pic/17947.png)\n\n左边为一个Kakuro 游戏，右边为这个游戏的唯一解。\n\n我们称一开始给出的数字为线索，称需要填入数字的地方为空格。如果一个格子包含线索那么就不需要填入数字。我们约定所有的谜题都非空，即至少有一个空格需要被填入。\n\n**注意：在以下题目中的游戏规则可能会有所不同，请认真阅读在每个\n题目下的规则。**", "description": "游戏规则：\n\n• 空格中填入正整数。\n\n• 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。\n\nApia 给了Rimbaud 一个Kakuro 谜题。心不灵手不巧的Rimbaud 根本不会做Kakuro，所以只在空格里面填上了一些随机的数字，称这个为一个局面，即包含了谜题一开始给出的线索和后面填入的数字。\n\n现在Rimbaud 希望能修改这个局面使得她的答案是一个合法解。这个局面中有些数字(**包括一开始的给出线索和后面填入的数字**) 是可以修改的。每个数字都有个特定的代价，将这个数字加1 或者减1 都得付出这个数字对应的代价。注意对于一组合法解，必须满足游戏规则，也就是**空格中填的数字必须是正整数并且满足和的条件，但是不要求不重复**。\n\nRimbaud 希望用最少的代价让这个局面变得合法，如果不可能那么输出-1。", "inputFormat": "第一行，两个正整数表示n,m 表示这个游戏的行和列。\n\n接下来n 行，每行包含m 个0 到4 的数字，第i 行第j 列表示第i 行第j 列格子的种类。\n\n• 0 表示这个格子既不是空格也不是线索。\n\n• 1 表示这个格子左下角包含线索，右上角没有线索。\n\n• 2 表示这个格子右上角包含线索，左下角没有线索。\n\n• 3 表示这个格子左下角右上角都包含线索。\n\n• 4 表示这个格子为空格。\n\n输入保证这个从格式上来说一定是个合法的Kakuro 谜题，即每一段连续的空格的左边或者上面的格子包含线索。\n\n接下来n 行，每行包含若干个正整数，按从左往右的顺序给出初始局面中的每个数字。特别地如果这个格子的种类为3，那么先给出左下角的线索，再给出右上角的线索。\n\n接下来n 行，每行包含若干个整数，按从左往右的顺序给出初始局面中的每个数字对应的代价。如果代价为-1 表示这个格子不能修改，否则代价为非负整数。注意3 号格子的两个线索有着两个不同的代价。\n\n**样例1 给出了上面的谜题的输入，请在做题前阅读样例1 确保你理解了输入格式。**", "outputFormat": "一个整数表示最小的代价，如果不可能输出-1。", "hint": "对于5% 的数据，保证所有的代价都为-1。\n\n对于20% 的数据，保证所有空格中的数字代价都为-1。\n\n对于另外30% 的数据，保证所有代表线索的数字的代价都为-1。\n\n对于另外20% 的数据，保证只有第一行第一列包含线索，剩下的地方全都是空格。\n\n对于100% 的数据，保证3 ≤ n,m ≤ 30，保证初始局面中的每个数字不超过$10^6$，保证每个数字的代价不超过$10^6$。", "locale": "zh-CN"}}}
{"pid": "P4487", "type": "P", "difficulty": 7, "samples": [["3\n3 3\n0 1 1\n2 4 4\n2 4 4\n3 7\n2\n6\n3 3\n0 1 1\n2 4 4\n2 4 4\n1 1\n1\n1\n2 2\n0 1\n2 4\n0\n0", "\n1 3\n2 4\n-1\n-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "北京", "Special Judge"], "title": "[BJWC2018] Cross sum", "background": "首先介绍一下Kakuro(カックロ) 这个游戏。\n\n游戏规则为：\n\n- 方形空格中填入 $1\\sim 9$ 的整数。\n- 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。\n- 无论是横向还是纵向，连续方格中的数字不能重复。\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n![](https://cdn.luogu.com.cn/upload/pic/17947.png)\n\n左边为一个Kakuro 游戏，右边为这个游戏的唯一解。\n\n我们称一开始给出的数字为线索，称需要填入数字的地方为空格。如果一个格子包含线索那么就不需要填入数字。我们约定所有的谜题都非空，即至少有一个空格需要被填入。\n\n**注意：在以下题目中的游戏规则可能会有所不同，请认真阅读在每个\n题目下的规则。**", "description": "游戏规则：\n\n- 空格中填入正整数。\n- 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之异或和，左下角的数字等于其下方邻接之连续方格中数字之异或和。\n- 所有空格中填入的整数都不能重复。\n\nApia 给了 Rimbaud 一个 Kakuro 谜题。心不灵手不巧的 Rimbaud 根本不会做 Kakuro，所以她请求你帮她解决。由于 Rimbaud 很年幼，只会对不超过 $2^{60}-1$ 的数字进行运算。所以希望谜题的解中每个数字都不超过\n $2^{60}-1$。", "inputFormat": "每组数据包含多组测试数据。第一行包含一个整数 $T$ 表示测试数据组数。\n\n对于每组测试数据，第一行，两个正整数 $n,m$ 表示这个游戏的行和列。\n\n接下来 $n$ 行，每行包含 $m$ 个 $0$ 到 $4$ 的数字，第 $i$ 行第 $j$ 列表示第 $i$ 行第 $j$ 列格子的种类。\n\n- $0$ 表示这个格子既不是空格也不是线索。\n- $1$ 表示这个格子左下角包含线索，右上角没有线索。\n- $2$ 表示这个格子右上角包含线索，左下角没有线索。\n- $3$ 表示这个格子左下角右上角都包含线索。\n- $4$ 表示这个格子为空格。\n\n输入保证这个从格式上来说一定是个合法的 Kakuro 谜题，即每一段连续的空格的左边或者上面的格子包含线索。\n\n接下来 $n$ 行，每行包含若干个**非负整数**，按从左往右的顺序给出谜题中的每个线索。特别地如果这个格子的种类为 $3$，那么先给出左下角的线索，再给出右上角的线索。", "outputFormat": "对于每组测试数据，如果有解，那么输出 $n$ 行，每行按从左往右的顺序输出往空格中填入的数，要求空格内填入的数字在 $1$ 到 $2^{60}-1$ 之间。否则输出一个 $-1$。", "hint": "对于 $10\\%$ 的数据，保证 $n,m \\leq 3$。\n\n对于 $30\\%$ 的数据，保证$n,m \\leq 15$。\n\n对于 $50\\%$ 的数据，保证$n,m \\leq 40$。\n\n对于另外 $20\\%$ 的数据，保证只有第一行第一列包含线索，剩下的地方全都是空格。\n\n对于 $100\\%$ 的数据，保证$3 \\leq n,m \\leq 200$，$1\\leq T \\leq 5$，保证初始局面中的每个数字不超过 $2^{60}-1$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Cross sum", "background": "First, let us introduce the game Kakuro (カックロ).\n\nThe rules are:\n\n- Fill each empty cell with an integer from $1\\sim 9$.\n- In a cell split by a diagonal line, the number in the upper-right corner equals the sum of the numbers in the consecutive adjacent cells to its right, and the number in the lower-left corner equals the sum of the numbers in the consecutive adjacent cells below it.\n- Whether horizontally or vertically, numbers in consecutive cells must not repeat.\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n![](https://cdn.luogu.com.cn/upload/pic/17947.png)\n\nThe left picture shows a Kakuro puzzle, and the right picture shows its unique solution.\n\nWe call the numbers given at the beginning clues, and the places that need to be filled are called empty cells. If a cell contains a clue, then it does not need to be filled. We guarantee that all puzzles are non-empty, meaning there is at least one empty cell that needs to be filled.\n\n**Note: The game rules in the following problems may be different. Please read the rules under each problem carefully.**", "description": "Game rules:\n\n- Fill each empty cell with a positive integer.\n- In a cell split by a diagonal line, the number in the upper-right corner equals the XOR sum of the numbers in the consecutive adjacent cells to its right, and the number in the lower-left corner equals the XOR sum of the numbers in the consecutive adjacent cells below it.\n- All integers filled in empty cells must be pairwise distinct (no duplicates).\n\nApia gave Rimbaud a Kakuro puzzle. Rimbaud is not good at such puzzles at all, so she asks you to help solve it. Since Rimbaud is very young, she can only operate on numbers not exceeding $2^{60}-1$. Therefore, it is required that in the solution of the puzzle, every number does not exceed $2^{60}-1$.", "inputFormat": "Each input contains multiple test cases. The first line contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains two positive integers $n, m$, representing the number of rows and columns of the board.\n\nIn the next $n$ lines, each line contains $m$ digits from $0$ to $4$. The digit in row $i$, column $j$ indicates the type of the cell at $(i, j)$:\n\n- $0$ means this cell is neither an empty cell nor a clue cell.\n- $1$ means this cell contains a clue in the lower-left corner, and no clue in the upper-right corner.\n- $2$ means this cell contains a clue in the upper-right corner, and no clue in the lower-left corner.\n- $3$ means this cell contains clues in both the lower-left and upper-right corners.\n- $4$ means this cell is an empty cell.\n\nThe input guarantees that, in terms of format, this is a valid Kakuro puzzle: for every consecutive segment of empty cells, the cell to its left or the cell above it contains a clue.\n\nThen there are $n$ more lines. Each line contains several **non-negative integers**, giving all clues in the puzzle in left-to-right order. In particular, if a cell type is $3$, then the lower-left clue is given first, followed by the upper-right clue.", "outputFormat": "For each test case, if there is a solution, output $n$ lines. Each line should output, from left to right, the numbers filled into the empty cells in that row. The filled numbers must be between $1$ and $2^{60}-1$ (inclusive). Otherwise, output $-1$.", "hint": "For $10\\%$ of the testdata, it is guaranteed that $n, m \\leq 3$.\n\nFor $30\\%$ of the testdata, it is guaranteed that $n, m \\leq 15$.\n\nFor $50\\%$ of the testdata, it is guaranteed that $n, m \\leq 40$.\n\nFor another $20\\%$ of the testdata, it is guaranteed that only the cell at the first row and first column contains clues, and all remaining cells are empty cells.\n\nFor $100\\%$ of the testdata, it is guaranteed that $3 \\leq n, m \\leq 200$, $1 \\leq T \\leq 5$, and every initial clue number does not exceed $2^{60}-1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] Cross sum", "background": "首先介绍一下Kakuro(カックロ) 这个游戏。\n\n游戏规则为：\n\n- 方形空格中填入 $1\\sim 9$ 的整数。\n- 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。\n- 无论是横向还是纵向，连续方格中的数字不能重复。\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n![](https://cdn.luogu.com.cn/upload/pic/17947.png)\n\n左边为一个Kakuro 游戏，右边为这个游戏的唯一解。\n\n我们称一开始给出的数字为线索，称需要填入数字的地方为空格。如果一个格子包含线索那么就不需要填入数字。我们约定所有的谜题都非空，即至少有一个空格需要被填入。\n\n**注意：在以下题目中的游戏规则可能会有所不同，请认真阅读在每个\n题目下的规则。**", "description": "游戏规则：\n\n- 空格中填入正整数。\n- 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之异或和，左下角的数字等于其下方邻接之连续方格中数字之异或和。\n- 所有空格中填入的整数都不能重复。\n\nApia 给了 Rimbaud 一个 Kakuro 谜题。心不灵手不巧的 Rimbaud 根本不会做 Kakuro，所以她请求你帮她解决。由于 Rimbaud 很年幼，只会对不超过 $2^{60}-1$ 的数字进行运算。所以希望谜题的解中每个数字都不超过\n $2^{60}-1$。", "inputFormat": "每组数据包含多组测试数据。第一行包含一个整数 $T$ 表示测试数据组数。\n\n对于每组测试数据，第一行，两个正整数 $n,m$ 表示这个游戏的行和列。\n\n接下来 $n$ 行，每行包含 $m$ 个 $0$ 到 $4$ 的数字，第 $i$ 行第 $j$ 列表示第 $i$ 行第 $j$ 列格子的种类。\n\n- $0$ 表示这个格子既不是空格也不是线索。\n- $1$ 表示这个格子左下角包含线索，右上角没有线索。\n- $2$ 表示这个格子右上角包含线索，左下角没有线索。\n- $3$ 表示这个格子左下角右上角都包含线索。\n- $4$ 表示这个格子为空格。\n\n输入保证这个从格式上来说一定是个合法的 Kakuro 谜题，即每一段连续的空格的左边或者上面的格子包含线索。\n\n接下来 $n$ 行，每行包含若干个**非负整数**，按从左往右的顺序给出谜题中的每个线索。特别地如果这个格子的种类为 $3$，那么先给出左下角的线索，再给出右上角的线索。", "outputFormat": "对于每组测试数据，如果有解，那么输出 $n$ 行，每行按从左往右的顺序输出往空格中填入的数，要求空格内填入的数字在 $1$ 到 $2^{60}-1$ 之间。否则输出一个 $-1$。", "hint": "对于 $10\\%$ 的数据，保证 $n,m \\leq 3$。\n\n对于 $30\\%$ 的数据，保证$n,m \\leq 15$。\n\n对于 $50\\%$ 的数据，保证$n,m \\leq 40$。\n\n对于另外 $20\\%$ 的数据，保证只有第一行第一列包含线索，剩下的地方全都是空格。\n\n对于 $100\\%$ 的数据，保证$3 \\leq n,m \\leq 200$，$1\\leq T \\leq 5$，保证初始局面中的每个数字不超过 $2^{60}-1$。", "locale": "zh-CN"}}}
{"pid": "P4488", "type": "P", "difficulty": 6, "samples": [["8 8 9 24\n0 2 2 3 16\n0 2 6 8 24\n0 3 2 3 17\n0 3 5 8 29\n0 4 2 6 35\n0 5 3 4 7\n0 5 6 7 8\n0 6 4 8 16\n0 7 2 5 21\n0 7 7 8 5\n0 8 2 4 6\n0 8 7 8 3\n1 2 2 4 23\n1 2 7 8 11\n1 3 2 5 30\n1 3 7 8 10\n1 4 4 8 15\n1 5 3 4 17\n1 5 6 7 7\n1 6 2 6 27\n1 7 2 3 12\n1 7 5 8 12\n1 8 2 3 16\n1 8 6 8 7", "127"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2018", "北京", "cdq 分治", "扫描线"], "title": "[BJWC2018] Kreuzsummen", "background": "首先介绍一下Kakuro(カックロ) 这个游戏。\n\n游戏规则为：\n\n• 方形空格中填入1 ~ 9 的整数。\n\n• 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。\n\n• 无论是横向还是纵向，连续方格中的数字不能重复。\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n![](https://cdn.luogu.com.cn/upload/pic/17947.png)\n\n左边为一个Kakuro 游戏，右边为这个游戏的唯一解。\n\n我们称一开始给出的数字为线索，称需要填入数字的地方为空格。如果一个格子包含线索那么就不需要填入数字。我们约定所有的谜题都非空，即至少有一个空格需要被填入。\n\n**注意：在以下题目中的游戏规则可能会有所不同，请认真阅读在每个\n题目下的规则。**", "description": "游戏规则：\n\n• 方形空格中填入1 ~ k 的整数。\n\n• 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。\n\n• 无论是横向还是纵向，连续方格中的数字不能重复。\n\nApia 给了Rimbaud 一个Kakuro 谜题。心不灵手不巧的Rimbaud 发现自己总是做不出Kakuro。她怀疑原因是Apia 给的题目难度太高而不是自己太菜。所以她想评价一下这个题目的难度。\n\nRimbaud 认为一个Kakuro 谜题的难度为每个空格的候选数个数的和。我们来定义一下对于每个空格的候选数，这里的候选数为只考虑这个格子在初始谜题下对应的行和列线索和数字不能重复的条件下可以填的数字集合。\n\n如果某连续4 个空格对应的线索为10，那么这四个数只可能是1 + 2 + 3 + 4，也就是这几个空格在这个线索的限制下候选数集合为{1, 2, 3, 4}。\n\n更一般的，如果某连续c 个空格对应的线索为s，那么考虑所有数值1 ~ k 之间，不重复并且和为s 的c 元组，这几个空格在这个线索限制下的候选数集合为出现在这些c 元组中的所有数字。对于每个空格，它的候选数集合为行限制下的候选数和列限制下的候选数的交。\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n\n在这个谜题中，我们考虑第2 行第2 列的空格。这个空格的行线索为16，对应的候选数集合为{7, 9}。这个空格的列线索为23，对应的候选数{6, 8, 9}，所以这个空格的候选数集合为{9}。第2 行第3 列的空格的行线索对应的候选数集合为{7, 9}，列线索的I 应的候选数集合为{6, 7, 8, 9}，所以这个空格的候选数集合为{7, 9}。注意虽然我们可以通过先确定第2 行第2 列的数字，然后根据行线索推算出第2 行第3 列的数字，但是Rimbaud **只会考虑初始的线索**。\n\n请帮助Rimbaud 求出这个谜题的难度即所有的空格的候选数个数的和。", "inputFormat": "第一行，四个正整数表示n, m, k, T 表示这个游戏的行，列，数值范围和总线索个数。\n接下来T 行，每行五个正整数，$t, x, y_1, y_2, s(t \\in \\{0, 1\\}, y_1 ≤ y_2)$。其中t 表示这个线索的种类，如果t = 0，那么表示这个线索为行线索，第x 行第y1 列到y2 列之间的数字和为s。如果t = 1，那么表示这个线索为行线索，\n第x 列第y1 行到y2 行之间的数字和为s。数据中的行和列都从1 开始标号。\n\n这个谜题的空格为所有线索对应的空格的并集。输入保证这个从格式上来说一定是个合法的Kakuro 谜题，即每一段连续的空格的左边或者上面的格子包含线索，并且每个空格出现了恰好两次。\n\n**数据中可能出现某些位置的候选数集合为空或者无解的情况**。对于这种情况还是只需要按定义求出这个谜题的难度即可。", "outputFormat": "输出一个整数表示答案。", "hint": "// 下面为这个样例的解释。\n\n-1 -1 -1 -1 -1 -1 -1 -1\n\n-1 1 2 -1 -1 3 3 2\n\n-1 2 2 -1 2 4 4 2\n\n-1 3 4 1 2 5 -1 -1\n\n-1 -1 1 5 -1 6 5 -1\n\n-1 -1 -1 4 5 5 5 3\n\n-1 8 8 5 6 -1 4 3\n\n-1 2 3 3 -1 -1 2 2\n\n对于10% 的数据，保证$n,m ≤ 3$。\n\n对于30% 的数据，保证$n,m ≤ 50$。\n\n对于50% 的数据，保证$n,m ≤ 500$。\n\n对于另外20% 的数据，保证只有第一行第一列包含线索，剩下的地方全都是空格。\n\n对于100% 的数据，保证$3 ≤ n, m, T ≤ 10^5, 1 ≤ k ≤ 10^5, s ≤ 10^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2018] Kreuzsummen", "background": "First, let’s introduce the game Kakuro (カックロ).\n\nRules:\n- Fill each square cell with an integer from $1$ to $9$.\n- In a cell split by a diagonal slash, the number at the top-right equals the sum of the consecutive cells to its right, and the number at the bottom-left equals the sum of the consecutive cells below it.\n- In any horizontal or vertical run, digits may not repeat.\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n![](https://cdn.luogu.com.cn/upload/pic/17947.png)\n\nThe left is a Kakuro puzzle, and the right is its unique solution.\n\nWe call the numbers given at the start clues, and the places where numbers need to be filled empty cells. If a cell contains a clue, then no number needs to be filled there. We assume every puzzle is non-empty, i.e., at least one empty cell needs to be filled.\n\nNote: The game rules in the following problems may differ. Please read the rules under each problem carefully.", "description": "Rules:\n- Fill each square cell with an integer from $1$ to $k$.\n- In a cell split by a diagonal slash, the number at the top-right equals the sum of the consecutive cells to its right, and the number at the bottom-left equals the sum of the consecutive cells below it.\n- In any horizontal or vertical run, digits may not repeat.\n\nApia gave Rimbaud a Kakuro puzzle. Clumsy as she is, Rimbaud keeps failing to solve Kakuro. She suspects the reason is that Apia’s puzzle is too hard rather than her own skill. So she wants to evaluate the difficulty of this puzzle.\n\nRimbaud defines the difficulty of a Kakuro puzzle as the sum, over all empty cells, of the sizes of their candidate sets. For each empty cell, its candidate set is defined using only the initial puzzle’s row and column clues and the “no repetition” rule, considering the cell in its row and column runs independently.\n\nFor example, if a run of $4$ consecutive cells has a clue sum $10$, then the four digits must be $1 + 2 + 3 + 4$. That is, under this clue, the candidate set for these cells is $\\{1, 2, 3, 4\\}$.\n\nMore generally, if a run of $c$ consecutive cells has a clue sum $s$, consider all $c$-tuples of distinct numbers from $1$ to $k$ that sum to $s$. Under this clue, the candidate set for these cells is the set of all digits that appear in any of those $c$-tuples. For any given empty cell, its candidate set is the intersection of the candidate set from its row run and that from its column run.\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n\nIn this puzzle, consider the empty cell at row $2$, column $2$. The row clue is $16$, giving a candidate set $\\{7, 9\\}$. The column clue is $23$, giving a candidate set $\\{6, 8, 9\\}$, so the cell’s candidate set is $\\{9\\}$. For the cell at row $2$, column $3$, the row clue gives $\\{7, 9\\}$ and the column clue gives $\\{6, 7, 8, 9\\}$, so the candidate set is $\\{7, 9\\}$. Note that although one could deduce more by first fixing row $2$, column $2$ and then using the row clue to determine row $2$, column $3$, Rimbaud only considers the initial clues.\n\nPlease help Rimbaud compute the difficulty of this puzzle, i.e., the sum of the sizes of the candidate sets over all empty cells.", "inputFormat": "The first line contains four positive integers $n, m, k, T$, denoting the number of rows, columns, the value range, and the total number of clues.\n\nThe next $T$ lines each contain five positive integers\n$t, x, y_1, y_2, s \\ (t \\in \\{0, 1\\},\\ y_1 \\le y_2)$.\nHere $t$ indicates the type of clue:\n- If $t = 0$, this is a row clue: in row $x$, columns $y_1$ to $y_2$ sum to $s$.\n- If $t = 1$, this is a column clue: in column $x$, rows $y_1$ to $y_2$ sum to $s$.\nRows and columns are $1$-indexed.\n\nThe empty cells of the puzzle are the union of all cells covered by the clues. The input is guaranteed to be a syntactically valid Kakuro puzzle: for every run of consecutive empty cells, the cell immediately to its left or above contains the corresponding clue, and each empty cell is covered by exactly two clues (one row clue and one column clue).\n\nThe testdata may contain positions where the candidate set is empty or the puzzle is unsatisfiable. In such cases, still compute the difficulty strictly by the definition above.", "outputFormat": "Output a single integer, the answer.", "hint": "// The following explains this sample.\n\n```\n-1 -1 -1 -1 -1 -1 -1 -1\n-1 1 2 -1 -1 3 3 2\n-1 2 2 -1 2 4 4 2\n-1 3 4 1 2 5 -1 -1\n-1 -1 1 5 -1 6 5 -1\n-1 -1 -1 4 5 5 5 3\n-1 8 8 5 6 -1 4 3\n-1 2 3 3 -1 -1 2 2\n```\n\nFor $10\\%$ of the testdata, it is guaranteed that $n, m \\le 3$.\n\nFor $30\\%$ of the testdata, it is guaranteed that $n, m \\le 50$.\n\nFor $50\\%$ of the testdata, it is guaranteed that $n, m \\le 500$.\n\nFor another $20\\%$ of the testdata, only the cell at row $1$, column $1$ contains a clue, and all other cells are empty.\n\nFor $100\\%$ of the testdata, it is guaranteed that $3 \\le n, m, T \\le 10^5$, $1 \\le k \\le 10^5$, $s \\le 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2018] Kreuzsummen", "background": "首先介绍一下Kakuro(カックロ) 这个游戏。\n\n游戏规则为：\n\n• 方形空格中填入1 ~ 9 的整数。\n\n• 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。\n\n• 无论是横向还是纵向，连续方格中的数字不能重复。\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n![](https://cdn.luogu.com.cn/upload/pic/17947.png)\n\n左边为一个Kakuro 游戏，右边为这个游戏的唯一解。\n\n我们称一开始给出的数字为线索，称需要填入数字的地方为空格。如果一个格子包含线索那么就不需要填入数字。我们约定所有的谜题都非空，即至少有一个空格需要被填入。\n\n**注意：在以下题目中的游戏规则可能会有所不同，请认真阅读在每个\n题目下的规则。**", "description": "游戏规则：\n\n• 方形空格中填入1 ~ k 的整数。\n\n• 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。\n\n• 无论是横向还是纵向，连续方格中的数字不能重复。\n\nApia 给了Rimbaud 一个Kakuro 谜题。心不灵手不巧的Rimbaud 发现自己总是做不出Kakuro。她怀疑原因是Apia 给的题目难度太高而不是自己太菜。所以她想评价一下这个题目的难度。\n\nRimbaud 认为一个Kakuro 谜题的难度为每个空格的候选数个数的和。我们来定义一下对于每个空格的候选数，这里的候选数为只考虑这个格子在初始谜题下对应的行和列线索和数字不能重复的条件下可以填的数字集合。\n\n如果某连续4 个空格对应的线索为10，那么这四个数只可能是1 + 2 + 3 + 4，也就是这几个空格在这个线索的限制下候选数集合为{1, 2, 3, 4}。\n\n更一般的，如果某连续c 个空格对应的线索为s，那么考虑所有数值1 ~ k 之间，不重复并且和为s 的c 元组，这几个空格在这个线索限制下的候选数集合为出现在这些c 元组中的所有数字。对于每个空格，它的候选数集合为行限制下的候选数和列限制下的候选数的交。\n\n![](https://cdn.luogu.com.cn/upload/pic/17946.png)\n\n在这个谜题中，我们考虑第2 行第2 列的空格。这个空格的行线索为16，对应的候选数集合为{7, 9}。这个空格的列线索为23，对应的候选数{6, 8, 9}，所以这个空格的候选数集合为{9}。第2 行第3 列的空格的行线索对应的候选数集合为{7, 9}，列线索的I 应的候选数集合为{6, 7, 8, 9}，所以这个空格的候选数集合为{7, 9}。注意虽然我们可以通过先确定第2 行第2 列的数字，然后根据行线索推算出第2 行第3 列的数字，但是Rimbaud **只会考虑初始的线索**。\n\n请帮助Rimbaud 求出这个谜题的难度即所有的空格的候选数个数的和。", "inputFormat": "第一行，四个正整数表示n, m, k, T 表示这个游戏的行，列，数值范围和总线索个数。\n接下来T 行，每行五个正整数，$t, x, y_1, y_2, s(t \\in \\{0, 1\\}, y_1 ≤ y_2)$。其中t 表示这个线索的种类，如果t = 0，那么表示这个线索为行线索，第x 行第y1 列到y2 列之间的数字和为s。如果t = 1，那么表示这个线索为行线索，\n第x 列第y1 行到y2 行之间的数字和为s。数据中的行和列都从1 开始标号。\n\n这个谜题的空格为所有线索对应的空格的并集。输入保证这个从格式上来说一定是个合法的Kakuro 谜题，即每一段连续的空格的左边或者上面的格子包含线索，并且每个空格出现了恰好两次。\n\n**数据中可能出现某些位置的候选数集合为空或者无解的情况**。对于这种情况还是只需要按定义求出这个谜题的难度即可。", "outputFormat": "输出一个整数表示答案。", "hint": "// 下面为这个样例的解释。\n\n-1 -1 -1 -1 -1 -1 -1 -1\n\n-1 1 2 -1 -1 3 3 2\n\n-1 2 2 -1 2 4 4 2\n\n-1 3 4 1 2 5 -1 -1\n\n-1 -1 1 5 -1 6 5 -1\n\n-1 -1 -1 4 5 5 5 3\n\n-1 8 8 5 6 -1 4 3\n\n-1 2 3 3 -1 -1 2 2\n\n对于10% 的数据，保证$n,m ≤ 3$。\n\n对于30% 的数据，保证$n,m ≤ 50$。\n\n对于50% 的数据，保证$n,m ≤ 500$。\n\n对于另外20% 的数据，保证只有第一行第一列包含线索，剩下的地方全都是空格。\n\n对于100% 的数据，保证$3 ≤ n, m, T ≤ 10^5, 1 ≤ k ≤ 10^5, s ≤ 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P4489", "type": "P", "difficulty": 5, "samples": [["2 \n3 \n2 \n0 \n1 \n2 \n2 \n1 \n1 1 0 \n1 1 1 \n0 1 1", "4"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "2009", "CTSC/CTS"], "title": "[CTSC2009] 纷繁世界", "background": "这是一个纷繁复杂的世界。\n\n某一天清晨你起床很迟，没有吃上早饭。于是你骑着自行车去超市，但是你又发现商店的工作人员已经重新贴上了价格标签，零食价格都涨了 $50\\%$。你一怒之下就这样饿了一个上午…… \n\n当然，事情也许完全不会这样发展。 \n\n某一天清晨你起床比较迟，但还是没有吃上早饭。于是你骑着自行车去超市，恰好商店的工作人员还没有把涨价后的价格标签贴在零食上。于是你顺利的买了一些早餐然后逍遥而去…… \n\n或许你会起得更早，也或许商店的工作人员会迟到。 \n\n有时候，人们只是按照预想的顺序去完成一些事情，不过可能有一些事件，它们发生时间的前后顺序会影响世界的发展。 \n\n比如，如果商店只有一个西瓜，你想买，我也想买，那么我们买西瓜的先后顺序就会直接影响到谁最后能够买到西瓜。 \n\n这样一个复杂的世界，分析它的运行规律是一件非常重要的工作，也是你所要研究的。", "description": "简单起见，假定总共有 $N$ 个人以及 $M$ 种不同类型事件。定义事件之间的二元关系“相关”：\n\n- 相关关系是一个二元关系，就是说我们只能定义两种类型的事件间是否相关；\n- 同一种类型的事件之间一定是相关的；\n- 若事件 $x$ 与事件 $y$ 是相关的，那么事件 $y$ 与事件 $x$ 也一定是相关的。\n\n令 $Q_i = (Q_{i, 1}, Q_{i, 2}, \\cdots, Q_{i, C_i})$ 表示第 $i$ 个人计划完成的事件序列（称为计划序列），$C_i$ 表示 $Q_i$ 的长度。$Q_i$ 中每个事件 $Q_{i,j}$ 都是 $M$ 种事件中的某一种，且同一种类型的事件可以发生多次。 \n\n随着时间的推移每个计划序列中的事件都会发生一次且恰好一次；为了简单起见，不会有任何两个事件发生在同一时刻。 \n\n为了描述事件的发生顺序，定义 $P = (Q_{i_1, j_1}, Q_{i_2, j_2}, \\cdots, Q_{i_l, j_l})$ 为世界的一条发展轨迹，$P$ 是满足如下条件的有序序列：\n\n1. 对于每个人，计划序列中的每个事件 $Q_{i,j}$ 都在 $P$ 出现一次且恰好一次；\n2. 对于属于同一个计划序列的两个事件 $Q_{i,j_1}$ 和 $Q_{i,j_2}$（$1 \\leq j_1 < j_2 \\leq C_i$），$Q_{i,j_1}$ 一定发生在 $Q_{i,j_2}$ 之前（也就是在 $P$ 中位于更靠前的位置）。\n\n两条轨迹 $P_1$ 和 $P_2$ 被定义为本质不同的，当且仅当存在两个相关的事件 $Q_{i,j}$ 和 $Q_{u,v}$，他们在 $P_1$ 和 $P_2$ 中发生的先后顺序不同，也就是说，如果在 $P_1$ 中 $Q_{i,j}$ 发生在 $Q_{u,v}$ 之前且在 $P_2$ 中 $Q_{i,j}$ 发生在 $Q_{u,v}$ 之后，那么 $P_1$ 和 $P_2$ 就是本质不同的；如果在 $P_1$ 中 $Q_{i,j}$ 发生在 $Q_{u,v}$ 之后且在 $P_2$ 中 $Q_{i,j}$ 发生在 $Q_{u,v}$ 之前，那么 $P_1$ 和 $P_2$ 也是本质不同的。\n\n注意：本质相同具有传递性，即若 $P_1$ 与 $P_2$ 本质相同且 $P_2$ 与 $P_3$ 本质相同，那么 $P_1$ 与 $P_3$ 一定也本质相同。\n\n给定 $N, M$、每个人计划序列以及事件之间的相关关系。你需要计算一共有多少种本质不同的世界运行轨迹。", "inputFormat": "输入的第一行包括一个整数，表示人数 $N$。 \n\n输入的第二行包括一个整数，表示事件种类数 $M$，所有类型的事件按照 $0$ 至 $M - 1$ 编号。\n\n接下来依次给出每个人的计划序列的描述，对于第 $i$ 个人： \n\n首先一行一个整数表示序列长度 $C_i$ 。 \n\n第二行包含 $C_i$ 个整数，依次给出 $Q_i$ 中的每个事件 $Q_{i,j}$。 \n\n最后 $M$ 行输入一个 $M$ 行 $M$ 列的矩阵 $dep$ 用来描述相关关系，每行包含 $M$ 个整数，都是 $0$ 或者 $1$。$dep(i,j)$ 表示矩阵自上往下的第 $i$ 行，自左往右的第 $j$ 列所包含的整数。若 $dep(i,j)$ 的值为 $1$ ，那么第 $i$ 类事件和第 $j$ 类事件就是相关的，否则这两类事件不相关。", "outputFormat": "输出只有一行，一个整数表示本质不同的世界轨迹数 $T$。", "hint": "### 样例说明\n\n样例中有 $2$ 个人与 $3$ 类事件，$C_1 = C_2 = 2$。$Q_{1,0} = 0, Q_{1,1} = 1, Q_{2,0} = 2, Q_{2,1} = 1$。\n\n一共有 $4$ 种不同的发生轨迹：\n\n- $P_1 = (Q_{1,0}, Q_{1,1}, Q_{2,0}, Q_{2,1})$；\n- $P_2 = (Q_{1,0}, Q_{2,0}, Q_{1,1}, Q_{2,1})$；\n- $P_3 = (Q_{1,0}, Q_{2,0}, Q_{2,1}, Q_{1,1})$；\n- $P_4 = (Q_{2,0}, Q_{2,1}, Q_{1,0}, Q_{1,1})$。\n\n对于其他任何合法的发展轨迹，都一定和这四条轨迹中的某一条本质相同。例如 $P = (Q_{2,0}, Q_{1,0}, Q_{2,1}, Q_{1,1})$ 与 $P_3$ 是本质相同的，因为两条轨迹只交换了 $Q_{1,0} = 0$ 和 $Q_{2,0} = 2$ 的顺序，但是这两类事件是不相关的。\n\n### 数据规模\n\n对于 $100\\%$ 的数据，总人数 $N \\leq 10$，事件种类数 $M \\leq 15$，计划序列长度 $C_i \\leq 20$，世界轨迹数 $T \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2009] A Complicated World", "background": "This is a complex and intricate world.\n\nOne morning you woke up late and missed breakfast. You rode your bike to the supermarket, only to find that the staff had already put up new price tags and all snacks had gone up by $50\\%$. In anger, you stayed hungry the whole morning.\n\nOf course, things might not have turned out that way.\n\nAnother morning you woke up a bit late and still missed breakfast. You rode your bike to the supermarket, and it happened that the staff had not yet put up the new price tags. You smoothly bought some breakfast and went on your way.\n\nPerhaps you would get up earlier, or perhaps the store staff would arrive late.\n\nSometimes people complete tasks in an expected order, but for some events, the relative order in which they occur can influence how the world develops.\n\nFor example, if the store has only one watermelon, and both you and I want to buy it, then the order in which we try to buy it will directly determine who gets it.\n\nAnalyzing the rules of operation in such a complicated world is very important, and that is exactly what you are going to study.", "description": "For simplicity, assume there are $N$ people and $M$ types of events. Define a binary relation “related” between event types:\n\n- The relation is binary, meaning we only determine whether two types of events are related.\n- Events of the same type are always related.\n- If event $x$ is related to event $y$, then event $y$ is also related to event $x$.\n\nLet $Q_i = (Q_{i, 1}, Q_{i, 2}, \\cdots, Q_{i, C_i})$ be the sequence of events person $i$ plans to complete (called the plan sequence), where $C_i$ is the length of $Q_i$. Each event $Q_{i, j}$ is one of the $M$ event types, and events of the same type may occur multiple times.\n\nAs time goes by, each event in every plan sequence will occur exactly once, and no two events occur at the same moment.\n\nTo describe the order in which events occur, define $P = (Q_{i_1, j_1}, Q_{i_2, j_2}, \\cdots, Q_{i_l, j_l})$ as a development trajectory of the world. $P$ is an ordered sequence satisfying:\n\n1. For every person, each event $Q_{i, j}$ in their plan sequence appears in $P$ exactly once.\n2. For any two events $Q_{i, j_1}$ and $Q_{i, j_2}$ belonging to the same plan sequence ($1 \\leq j_1 < j_2 \\leq C_i$), $Q_{i, j_1}$ must occur before $Q_{i, j_2}$ (i.e., appear earlier in $P$).\n\nTwo trajectories $P_1$ and $P_2$ are defined to be essentially different if and only if there exist two related events $Q_{i, j}$ and $Q_{u, v}$ whose relative order differs in $P_1$ and $P_2$. In other words, if in $P_1$ the event $Q_{i, j}$ occurs before $Q_{u, v}$ while in $P_2$ the event $Q_{i, j}$ occurs after $Q_{u, v}$, then $P_1$ and $P_2$ are essentially different; similarly, if in $P_1$ $Q_{i, j}$ occurs after $Q_{u, v}$ but in $P_2$ it occurs before $Q_{u, v}$, then $P_1$ and $P_2$ are also essentially different.\n\nNote: “Essentially the same” is transitive. That is, if $P_1$ is essentially the same as $P_2$, and $P_2$ is essentially the same as $P_3$, then $P_1$ is necessarily essentially the same as $P_3$.\n\nGiven $N$, $M$, each person’s plan sequence, and the relatedness between event types, compute how many essentially different world development trajectories there are.", "inputFormat": "- The first line contains an integer denoting the number of people $N$.\n- The second line contains an integer denoting the number of event types $M$. All event types are numbered from $0$ to $M - 1$.\n- Then, for each person $i$, the description of their plan sequence is given:\n  - The first line contains one integer, the sequence length $C_i$.\n  - The second line contains $C_i$ integers, giving each event $Q_{i, j}$ in $Q_i$ in order.\n- Finally, $M$ lines follow, containing an $M \\times M$ matrix dep that describes the relatedness. Each line contains $M$ integers, each being $0$ or $1$. dep(i, j) denotes the integer in the $i$-th row (from top to bottom) and the $j$-th column (from left to right). If dep(i, j) equals $1$, then event type $i$ and event type $j$ are related; otherwise, they are unrelated.", "outputFormat": "Output a single line containing one integer, the number $T$ of essentially different world trajectories.", "hint": "Sample Explanation\n\nThere are $2$ people and $3$ event types, with $C_1 = C_2 = 2$. $Q_{1,0} = 0$, $Q_{1,1} = 1$, $Q_{2,0} = 2$, $Q_{2,1} = 1$.\n\nThere are $4$ different development trajectories:\n- $P_1 = (Q_{1,0}, Q_{1,1}, Q_{2,0}, Q_{2,1})$;\n- $P_2 = (Q_{1,0}, Q_{2,0}, Q_{1,1}, Q_{2,1})$;\n- $P_3 = (Q_{1,0}, Q_{2,0}, Q_{2,1}, Q_{1,1})$;\n- $P_4 = (Q_{2,0}, Q_{2,1}, Q_{1,0}, Q_{1,1})$.\n\nAny other valid development trajectory is necessarily essentially the same as one of these four. For example, $P = (Q_{2,0}, Q_{1,0}, Q_{2,1}, Q_{1,1})$ is essentially the same as $P_3$, because the two trajectories only swap the order of $Q_{1,0} = 0$ and $Q_{2,0} = 2$, and those two event types are unrelated.\n\nConstraints\n\nFor $100\\%$ of the testdata: $N \\leq 10$, $M \\leq 15$, $C_i \\leq 20$, $T \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2009] 纷繁世界", "background": "这是一个纷繁复杂的世界。\n\n某一天清晨你起床很迟，没有吃上早饭。于是你骑着自行车去超市，但是你又发现商店的工作人员已经重新贴上了价格标签，零食价格都涨了 $50\\%$。你一怒之下就这样饿了一个上午…… \n\n当然，事情也许完全不会这样发展。 \n\n某一天清晨你起床比较迟，但还是没有吃上早饭。于是你骑着自行车去超市，恰好商店的工作人员还没有把涨价后的价格标签贴在零食上。于是你顺利的买了一些早餐然后逍遥而去…… \n\n或许你会起得更早，也或许商店的工作人员会迟到。 \n\n有时候，人们只是按照预想的顺序去完成一些事情，不过可能有一些事件，它们发生时间的前后顺序会影响世界的发展。 \n\n比如，如果商店只有一个西瓜，你想买，我也想买，那么我们买西瓜的先后顺序就会直接影响到谁最后能够买到西瓜。 \n\n这样一个复杂的世界，分析它的运行规律是一件非常重要的工作，也是你所要研究的。", "description": "简单起见，假定总共有 $N$ 个人以及 $M$ 种不同类型事件。定义事件之间的二元关系“相关”：\n\n- 相关关系是一个二元关系，就是说我们只能定义两种类型的事件间是否相关；\n- 同一种类型的事件之间一定是相关的；\n- 若事件 $x$ 与事件 $y$ 是相关的，那么事件 $y$ 与事件 $x$ 也一定是相关的。\n\n令 $Q_i = (Q_{i, 1}, Q_{i, 2}, \\cdots, Q_{i, C_i})$ 表示第 $i$ 个人计划完成的事件序列（称为计划序列），$C_i$ 表示 $Q_i$ 的长度。$Q_i$ 中每个事件 $Q_{i,j}$ 都是 $M$ 种事件中的某一种，且同一种类型的事件可以发生多次。 \n\n随着时间的推移每个计划序列中的事件都会发生一次且恰好一次；为了简单起见，不会有任何两个事件发生在同一时刻。 \n\n为了描述事件的发生顺序，定义 $P = (Q_{i_1, j_1}, Q_{i_2, j_2}, \\cdots, Q_{i_l, j_l})$ 为世界的一条发展轨迹，$P$ 是满足如下条件的有序序列：\n\n1. 对于每个人，计划序列中的每个事件 $Q_{i,j}$ 都在 $P$ 出现一次且恰好一次；\n2. 对于属于同一个计划序列的两个事件 $Q_{i,j_1}$ 和 $Q_{i,j_2}$（$1 \\leq j_1 < j_2 \\leq C_i$），$Q_{i,j_1}$ 一定发生在 $Q_{i,j_2}$ 之前（也就是在 $P$ 中位于更靠前的位置）。\n\n两条轨迹 $P_1$ 和 $P_2$ 被定义为本质不同的，当且仅当存在两个相关的事件 $Q_{i,j}$ 和 $Q_{u,v}$，他们在 $P_1$ 和 $P_2$ 中发生的先后顺序不同，也就是说，如果在 $P_1$ 中 $Q_{i,j}$ 发生在 $Q_{u,v}$ 之前且在 $P_2$ 中 $Q_{i,j}$ 发生在 $Q_{u,v}$ 之后，那么 $P_1$ 和 $P_2$ 就是本质不同的；如果在 $P_1$ 中 $Q_{i,j}$ 发生在 $Q_{u,v}$ 之后且在 $P_2$ 中 $Q_{i,j}$ 发生在 $Q_{u,v}$ 之前，那么 $P_1$ 和 $P_2$ 也是本质不同的。\n\n注意：本质相同具有传递性，即若 $P_1$ 与 $P_2$ 本质相同且 $P_2$ 与 $P_3$ 本质相同，那么 $P_1$ 与 $P_3$ 一定也本质相同。\n\n给定 $N, M$、每个人计划序列以及事件之间的相关关系。你需要计算一共有多少种本质不同的世界运行轨迹。", "inputFormat": "输入的第一行包括一个整数，表示人数 $N$。 \n\n输入的第二行包括一个整数，表示事件种类数 $M$，所有类型的事件按照 $0$ 至 $M - 1$ 编号。\n\n接下来依次给出每个人的计划序列的描述，对于第 $i$ 个人： \n\n首先一行一个整数表示序列长度 $C_i$ 。 \n\n第二行包含 $C_i$ 个整数，依次给出 $Q_i$ 中的每个事件 $Q_{i,j}$。 \n\n最后 $M$ 行输入一个 $M$ 行 $M$ 列的矩阵 $dep$ 用来描述相关关系，每行包含 $M$ 个整数，都是 $0$ 或者 $1$。$dep(i,j)$ 表示矩阵自上往下的第 $i$ 行，自左往右的第 $j$ 列所包含的整数。若 $dep(i,j)$ 的值为 $1$ ，那么第 $i$ 类事件和第 $j$ 类事件就是相关的，否则这两类事件不相关。", "outputFormat": "输出只有一行，一个整数表示本质不同的世界轨迹数 $T$。", "hint": "### 样例说明\n\n样例中有 $2$ 个人与 $3$ 类事件，$C_1 = C_2 = 2$。$Q_{1,0} = 0, Q_{1,1} = 1, Q_{2,0} = 2, Q_{2,1} = 1$。\n\n一共有 $4$ 种不同的发生轨迹：\n\n- $P_1 = (Q_{1,0}, Q_{1,1}, Q_{2,0}, Q_{2,1})$；\n- $P_2 = (Q_{1,0}, Q_{2,0}, Q_{1,1}, Q_{2,1})$；\n- $P_3 = (Q_{1,0}, Q_{2,0}, Q_{2,1}, Q_{1,1})$；\n- $P_4 = (Q_{2,0}, Q_{2,1}, Q_{1,0}, Q_{1,1})$。\n\n对于其他任何合法的发展轨迹，都一定和这四条轨迹中的某一条本质相同。例如 $P = (Q_{2,0}, Q_{1,0}, Q_{2,1}, Q_{1,1})$ 与 $P_3$ 是本质相同的，因为两条轨迹只交换了 $Q_{1,0} = 0$ 和 $Q_{2,0} = 2$ 的顺序，但是这两类事件是不相关的。\n\n### 数据规模\n\n对于 $100\\%$ 的数据，总人数 $N \\leq 10$，事件种类数 $M \\leq 15$，计划序列长度 $C_i \\leq 20$，世界轨迹数 $T \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4490", "type": "P", "difficulty": 6, "samples": [["36 2 \n3 \n99 100 105 100 \n101 100 95 100 \n100 99 100 105", "0.000"], ["10 9.8 \n3 \n0 0 0 0 \n1 0 100 0 \n0 50 0 1", "25.0000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["计算几何", "2009", "Special Judge", "凸包", "CTSC/CTS"], "title": "[CTSC2009] 魔幻花园", "background": "", "description": "魔法师栋栋有一个美丽的魔幻花园，在花园里，栋栋种满各式各样的魔幻植物，花园里一年四季都开满着姹紫嫣红的鲜花。栋栋的朋友们都特别喜欢来花园里玩。\n\n花园的浇灌系统是由栋栋特别设计的，栋栋用魔法在花园上空变出了$n$个喷头，这些喷头都连接着附近的圣水河。浇灌的时候，所有的喷头一起喷出一道道水流，水流在空中划出一道道美丽的弧线，最终正好浇灌到n棵最缺水的魔幻植物上。\n\n![喷头](https://cdn.luogu.com.cn/upload/pic/18045.png)\n\n栋栋把每个喷头都设在同一水平高度$h$。所有的喷头都是水平放置的，当水流从喷头喷出时，只有水平的速度(每个喷头的水平速度不一定相同)。魔幻花园里没有风，空气阻力可以忽略。所以在重力的影响下(魔幻花园的重力加速度为$g$)，水流的轨迹是一条完美的抛物线。空间上的任意点都最多被三个喷头喷到，两条水流相交不会影响各自的轨迹。\n\n近些年来魔幻花园附近新建了许多工厂，圣水河受到了污染，栋栋不想受污染的水影响到他的花园，所以他要使用魔法先净化一下浇灌的水。栋栋的魔法只能净化从喷头喷出来的水，他可以施魔法在空中的一个水平面形成一个凸多边形的滤水层，所有通过滤水层的水都会被净化，施这个魔法需要的能量和滤水层的面积成正比，每平方米滤水层需要$1$单位的魔法能量。栋栋想净化所有的水，他最少需要多少能量呢？ \n\n为了更好的描述问题，栋栋在花园建立起了一个三维的直角坐标系，以花园的西北角为坐标轴的原点，从原点向东是$x$轴的正方向，向南是$y$轴的正方向，向上是$z$轴的正方向。这样第$i$个喷头的位置可以用$(x_i,y_i,h)$来表示，而第$j$棵魔幻植物的位置可以用$(x_j',y_j',0)$来表示。", "inputFormat": "输入文件*garden.in*第一行为两个实数$h, g$，表示喷头的高度和魔幻花园的重力加速度。第二行为整数$n$，表示有多少个喷头。 \n\n接下来$n$行，每行四个整数$x_i, y_i, x_i', y_i'$，整数间使用一个空格分隔。表示第i个喷头的坐标是$(x_i, y_i, h)$，它喷出的水正好浇灌到了$(x_i', y_i', 0)$位置的魔幻植物上。", "outputFormat": "输出文件*garden.out*仅有一个实数，表示栋栋最少需要的能量，至少精确到小数点后3位。", "hint": "**【样例说明1】**\n\n在高度为$35$的地方施魔法，此时所有的水流正好汇合到$(100, 100, 35)$这点，所以需要的能量为$0$。\n\n**【样例说明2】**\n\n在高度为$10$的地方（即喷头处）施魔法，魔法形成一个直角三角形，三个点的坐标分别为：$(0,0,10), (1,0,10), (0,50,10)$，面积为$25.000$，所以需要的魔法能量也为$25.000$。\n\n**【评分标准】**\n\n对于每个测试点，如果你的答案与标准答案的差不超过$0.001$，则得到该测试点的全部分数；如果你的答案与标准答案的差超过$0.001$但不超过$0.002$，则得到50%的分数；否则得0分。\n\n**【数据规模】**\n\n对于20%的数据，$1 \\leq n \\leq 10$\n\n对于50%的数据，$1 \\leq n \\leq 50$\n\n对于100%的数据，$1 \\leq n \\leq 100$\n\n$0 < h \\leq 10000.0$\n\n$0 < g \\leq 100.0$\n\n$0 \\leq x_i, y_i, x_i', y_i' \\leq 1000$\n\n**【提示】**\n\n水从喷头喷出到地面的过程可以看成一个平抛运动。平抛运动可以分解为向\n水平方向和竖直方向的两个分运动：\n\n令$L = (x_i - x_i')^2 + (y_i - y_i')^2$，则\n\n初始速度$v_0 = \\sqrt{\\frac{Lg}{2h}}$\n\n$t$时刻的水平分速度：$v_{\\text{平}}(t) = v_0$\n\n$t$时刻的竖直分速度：$v_{\\text{竖}}(t) = gt$\n\n$t$时刻的速度：$v(t) = \\sqrt{v_{\\text{平}}^2(t) + v_{\\text{竖}}^2(t)}$", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2009] Magic Garden", "background": "", "description": "Wizard Dongdong has a beautiful magic garden filled with all kinds of magical plants, blooming with colorful flowers throughout the year. Dongdong’s friends love to come and play in the garden.\n\nThe garden’s irrigation system is specially designed by Dongdong. He used magic to create $n$ sprinklers suspended over the garden, all connected to the nearby Holy Water River. When irrigating, all sprinklers simultaneously eject streams of water. The water traces beautiful arcs in the air and lands precisely on the $n$ most water-starved magical plants.\n\n![Sprinklers](https://cdn.luogu.com.cn/upload/pic/18045.png)\n\nDongdong placed every sprinkler at the same height $h$. All sprinklers are oriented horizontally, so when water is ejected, it has only horizontal velocity (the horizontal velocity may differ between sprinklers). There is no wind in the magic garden, and air resistance is negligible. Therefore, under gravity (the gravitational acceleration in the magic garden is $g$), the water follows perfect parabolic trajectories. Any point in space is reached by water from at most three sprinklers, and intersections of water streams do not affect their trajectories.\n\nIn recent years, many factories have been built near the magic garden, and the Holy Water River has become polluted. Dongdong does not want polluted water to affect his garden, so he intends to purify the irrigation water using magic. His magic can only purify water as it leaves the sprinklers. He can cast a spell to create a convex polygon filter layer lying in some horizontal plane in the air. All water passing through this filter layer will be purified. The energy required to cast this spell is proportional to the area of the filter layer: each square meter of filter layer requires $1$ unit of magical energy. Dongdong wants to purify all the water. What is the minimum energy he needs?\n\nTo better describe the problem, Dongdong sets up a 3D Cartesian coordinate system in the garden with the northwest corner as the origin. The positive $x$-axis points east, the positive $y$-axis points south, and the positive $z$-axis points upward. Thus the position of the $i$-th sprinkler is $(x_i, y_i, h)$, and the position of the $j$-th magical plant is $(x_j', y_j', 0)$.", "inputFormat": "The first line contains two real numbers $h, g$, representing the sprinklers’ height and the gravitational acceleration in the magic garden.\n\nThe second line contains an integer $n$, the number of sprinklers.\n\nEach of the next $n$ lines contains four integers $x_i, y_i, x_i', y_i'$, separated by a space. This means the $i$-th sprinkler is at $(x_i, y_i, h)$, and its water lands exactly on the magical plant at $(x_i', y_i', 0)$.", "outputFormat": "Output a single real number: the minimum energy required by Dongdong, accurate to at least 3 decimal places.", "hint": "【Sample Explanation 1】\n\nIf the magic is cast at height $35$, all water streams converge at the point $(100, 100, 35)$, so the required energy is $0$.\n\n【Sample Explanation 2】\n\nIf the magic is cast at height $10$ (i.e., at the sprinklers), the magic forms a right triangle with vertices $(0, 0, 10)$, $(1, 0, 10)$, and $(0, 50, 10)$. Its area is $25.000$, so the required magical energy is also $25.000$.\n\n【Scoring】\n\nFor each test point, if your answer differs from the standard answer by no more than $0.001$, you receive full score for that test point; if the difference is greater than $0.001$ but no more than $0.002$, you receive 50% of the score; otherwise, you receive 0.\n\n【Constraints】\n\n- For 20% of the testdata, $1 \\leq n \\leq 10$.\n- For 50% of the testdata, $1 \\leq n \\leq 50$.\n- For 100% of the testdata, $1 \\leq n \\leq 100$.\n- $0 < h \\leq 10000.0$.\n- $0 < g \\leq 100.0$.\n- $0 \\leq x_i, y_i, x_i', y_i' \\leq 1000$.\n\n【Tips】\n\nThe motion of water from the sprinkler to the ground can be regarded as horizontal projectile motion. It can be decomposed into two component motions along the horizontal and vertical directions.\n\nLet $L = (x_i - x_i')^2 + (y_i - y_i')^2$. Then:\n\nInitial speed: $v_0 = \\sqrt{\\frac{Lg}{2h}}$.\n\nHorizontal component of velocity at time $t$: $v_{\\text{平}}(t) = v_0$.\n\nVertical component of velocity at time $t$: $v_{\\text{竖}}(t) = gt$.\n\nSpeed at time $t$: $v(t) = \\sqrt{v_{\\text{平}}^2(t) + v_{\\text{竖}}^2(t)}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2009] 魔幻花园", "background": "", "description": "魔法师栋栋有一个美丽的魔幻花园，在花园里，栋栋种满各式各样的魔幻植物，花园里一年四季都开满着姹紫嫣红的鲜花。栋栋的朋友们都特别喜欢来花园里玩。\n\n花园的浇灌系统是由栋栋特别设计的，栋栋用魔法在花园上空变出了$n$个喷头，这些喷头都连接着附近的圣水河。浇灌的时候，所有的喷头一起喷出一道道水流，水流在空中划出一道道美丽的弧线，最终正好浇灌到n棵最缺水的魔幻植物上。\n\n![喷头](https://cdn.luogu.com.cn/upload/pic/18045.png)\n\n栋栋把每个喷头都设在同一水平高度$h$。所有的喷头都是水平放置的，当水流从喷头喷出时，只有水平的速度(每个喷头的水平速度不一定相同)。魔幻花园里没有风，空气阻力可以忽略。所以在重力的影响下(魔幻花园的重力加速度为$g$)，水流的轨迹是一条完美的抛物线。空间上的任意点都最多被三个喷头喷到，两条水流相交不会影响各自的轨迹。\n\n近些年来魔幻花园附近新建了许多工厂，圣水河受到了污染，栋栋不想受污染的水影响到他的花园，所以他要使用魔法先净化一下浇灌的水。栋栋的魔法只能净化从喷头喷出来的水，他可以施魔法在空中的一个水平面形成一个凸多边形的滤水层，所有通过滤水层的水都会被净化，施这个魔法需要的能量和滤水层的面积成正比，每平方米滤水层需要$1$单位的魔法能量。栋栋想净化所有的水，他最少需要多少能量呢？ \n\n为了更好的描述问题，栋栋在花园建立起了一个三维的直角坐标系，以花园的西北角为坐标轴的原点，从原点向东是$x$轴的正方向，向南是$y$轴的正方向，向上是$z$轴的正方向。这样第$i$个喷头的位置可以用$(x_i,y_i,h)$来表示，而第$j$棵魔幻植物的位置可以用$(x_j',y_j',0)$来表示。", "inputFormat": "输入文件*garden.in*第一行为两个实数$h, g$，表示喷头的高度和魔幻花园的重力加速度。第二行为整数$n$，表示有多少个喷头。 \n\n接下来$n$行，每行四个整数$x_i, y_i, x_i', y_i'$，整数间使用一个空格分隔。表示第i个喷头的坐标是$(x_i, y_i, h)$，它喷出的水正好浇灌到了$(x_i', y_i', 0)$位置的魔幻植物上。", "outputFormat": "输出文件*garden.out*仅有一个实数，表示栋栋最少需要的能量，至少精确到小数点后3位。", "hint": "**【样例说明1】**\n\n在高度为$35$的地方施魔法，此时所有的水流正好汇合到$(100, 100, 35)$这点，所以需要的能量为$0$。\n\n**【样例说明2】**\n\n在高度为$10$的地方（即喷头处）施魔法，魔法形成一个直角三角形，三个点的坐标分别为：$(0,0,10), (1,0,10), (0,50,10)$，面积为$25.000$，所以需要的魔法能量也为$25.000$。\n\n**【评分标准】**\n\n对于每个测试点，如果你的答案与标准答案的差不超过$0.001$，则得到该测试点的全部分数；如果你的答案与标准答案的差超过$0.001$但不超过$0.002$，则得到50%的分数；否则得0分。\n\n**【数据规模】**\n\n对于20%的数据，$1 \\leq n \\leq 10$\n\n对于50%的数据，$1 \\leq n \\leq 50$\n\n对于100%的数据，$1 \\leq n \\leq 100$\n\n$0 < h \\leq 10000.0$\n\n$0 < g \\leq 100.0$\n\n$0 \\leq x_i, y_i, x_i', y_i' \\leq 1000$\n\n**【提示】**\n\n水从喷头喷出到地面的过程可以看成一个平抛运动。平抛运动可以分解为向\n水平方向和竖直方向的两个分运动：\n\n令$L = (x_i - x_i')^2 + (y_i - y_i')^2$，则\n\n初始速度$v_0 = \\sqrt{\\frac{Lg}{2h}}$\n\n$t$时刻的水平分速度：$v_{\\text{平}}(t) = v_0$\n\n$t$时刻的竖直分速度：$v_{\\text{竖}}(t) = gt$\n\n$t$时刻的速度：$v(t) = \\sqrt{v_{\\text{平}}^2(t) + v_{\\text{竖}}^2(t)}$", "locale": "zh-CN"}}}
{"pid": "P4491", "type": "P", "difficulty": 6, "samples": [["8 8 3\n3999 8477 9694 8454 3308 8961 3018 2255 4910", "524070430"], ["见 sample.zip/data2.in", "见 sample.zip/data2.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "河南", "各省省选", "O2优化", "容斥原理", "生成函数", "快速数论变换 NTT"], "title": "[HAOI2018] 染色", "background": "HAOI2018 Round2 第二题", "description": "为了报答小 C 的苹果，小 G 打算送给热爱美术的小 C 一块画布，这块画布可以抽象为一个长度为 $N$ 的序列，每个位置都可以被染成 $M$ 种颜色中的某一种。\n\n然而小 C 只关心序列的 $N$ 个位置中出现次数恰好为 $S$ 的颜色种数，如果恰好出现了 $S$ 次的颜色有 $K$ 种，则小 C 会产生 $W_k$ 的愉悦度。\n\n小 C 希望知道对于所有可能的染色方案，他能获得的愉悦度的和对 $1004535809$\n取模的结果是多少。", "inputFormat": "从标准输入读入数据。第一行三个整数 $N, M, S$。\n\n接下来一行 $M + 1$ 个整数，第 $i$ 个数表示 $W_{i-1}$。", "outputFormat": "输出到标准输出中。输出一个整数表示答案。", "hint": "特殊性质: $\\forall 1 \\le i \\le m, W_i = 0$。\n\n对于 $100\\%$ 的数据，满足 $1 \\le N \\le 10 ^ 7$，$1 \\le M \\le 10 ^ 5$，$1 \\le S \\le 150$，$0 \\le W_i < 1004535809$。\n\n![Data](https://cdn.luogu.com.cn/upload/pic/18057.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2018] Coloring", "background": "HAOI2018 Round 2 Problem 2.", "description": "To repay Xiao C for the apples, Xiao G plans to give art-loving Xiao C a canvas. This canvas can be abstracted as a sequence of length $N$, and each position can be painted with one of $M$ colors.\n\nHowever, Xiao C only cares about the number of colors that appear exactly $S$ times among the $N$ positions. If there are $K$ colors that appear exactly $S$ times, then Xiao C will gain happiness $W_k$.\n\nXiao C wants to know, over all possible colorings, what the sum of the happiness he can obtain is, modulo $1004535809$.", "inputFormat": "Read from standard input. The first line contains three integers $N, M, S$.\n\nThe next line contains $M + 1$ integers; the $i$-th number denotes $W_{i-1}$.", "outputFormat": "Output to standard output. Output a single integer representing the answer.", "hint": "Special property: $\\forall 1 \\le i \\le M, W_i = 0$.\n\nConstraints: For $100\\%$ of the testdata, $1 \\le N \\le 10^7$, $1 \\le M \\le 10^5$, $1 \\le S \\le 150$, $0 \\le W_i < 1004535809$.\n\n![Data](https://cdn.luogu.com.cn/upload/pic/18057.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2018] 染色", "background": "HAOI2018 Round2 第二题", "description": "为了报答小 C 的苹果，小 G 打算送给热爱美术的小 C 一块画布，这块画布可以抽象为一个长度为 $N$ 的序列，每个位置都可以被染成 $M$ 种颜色中的某一种。\n\n然而小 C 只关心序列的 $N$ 个位置中出现次数恰好为 $S$ 的颜色种数，如果恰好出现了 $S$ 次的颜色有 $K$ 种，则小 C 会产生 $W_k$ 的愉悦度。\n\n小 C 希望知道对于所有可能的染色方案，他能获得的愉悦度的和对 $1004535809$\n取模的结果是多少。", "inputFormat": "从标准输入读入数据。第一行三个整数 $N, M, S$。\n\n接下来一行 $M + 1$ 个整数，第 $i$ 个数表示 $W_{i-1}$。", "outputFormat": "输出到标准输出中。输出一个整数表示答案。", "hint": "特殊性质: $\\forall 1 \\le i \\le m, W_i = 0$。\n\n对于 $100\\%$ 的数据，满足 $1 \\le N \\le 10 ^ 7$，$1 \\le M \\le 10 ^ 5$，$1 \\le S \\le 150$，$0 \\le W_i < 1004535809$。\n\n![Data](https://cdn.luogu.com.cn/upload/pic/18057.png)\n", "locale": "zh-CN"}}}
{"pid": "P4492", "type": "P", "difficulty": 6, "samples": [["3 610745795", "24"], ["305 1000000007", "865018107"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "河南", "各省省选", "O2优化", "树形 DP", "组合数学", "排列组合", "概率论"], "title": "[HAOI2018] 苹果树", "background": "HAOI2018 Round2 第一题", "description": "小 C 在自己家的花园里种了一棵苹果树, 树上每个结点都有恰好两个分支. 经过细心的观察, 小 C 发现每一天这棵树都会生长出一个新的结点.\n\n第一天的时候, 果树会长出一个根结点, 以后每一天, 果树会随机选择一个当前树中没有长出过结点 的分支, 然后在这个分支上长出一个新结点, 新结点与分支所属的结点之间连接上一条边.\n\n小 C 定义一棵果树的不便度为树上两两结点之间的距离之和, 两个结点之间 的距离定义为从一个点走到另一个点的路径经过的边数.\n\n现在他非常好奇, 如果 $N$ 天之后小 G 来他家摘苹果, 这个不便度的期望 $E$ 是多少. 但是小 C 讨厌分数, 所以他只想知道 $E \\times N !$ 对 $P$ 取模的结果, 可以证明这是一个整数.", "inputFormat": "从标准输入中读入数据. 一行两个整数 $N$, $P$ .", "outputFormat": "输出到标准输出中. 输出一个整数表示答案．", "hint": "![Explanation](https://cdn.luogu.com.cn/upload/pic/18067.png)\n\n以上是所有 $N = 3$ 时可能的苹果树形态, 其中编号表示这个结点是第几天生\n长出来的, 显然每种情况两两结点的距离均为 $4$ .\n\n### 数据范围与约定\n| 测试点编号   | $N$  | $P$  |\n| :--------: | :--: | :--: |\n| $1$ |  $\\le 10$    |  $\\le 10^9 + 7$    |\n| $2$ |  $\\le 10$    |   $\\le 10^9 + 7$    |\n| $3$ |  $\\le 500$    |  $\\le 10^9 + 7$     |\n| $4$ |  $\\le 500$    |   $\\le 10^9 + 7$    |\n| $5$ |  $\\le 500$    |   $\\le 10^9 + 7$    |\n| $6$ |  $\\le 2000$    |   $= 10^9 + 7$    |\n| $7$ |  $\\le 2000$    |   $= 10^9 + 7$    |\n| $8$ |  $\\le 2000$    |   $\\le 10^9 + 7$    |\n| $9$ |  $\\le 2000$    |   $\\le 10^9 + 7$    |\n| $10$ | $\\le 2000$     |    $\\le 10^9 + 7$   |\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2018] Apple Tree", "background": "HAOI2018 Round2 Problem 1.", "description": "Xiao C planted an apple tree in his garden. Every node on the tree has exactly two branches. After careful observation, Xiao C found that each day the tree grows exactly one new node.\n\nOn the first day, the tree grows a root node. On every subsequent day, the tree randomly chooses one branch in the current tree that has not yet produced a node, and grows a new node on that branch. The new node is connected by an edge to the node that the branch belongs to.\n\nXiao C defines the “inconvenience” of an apple tree as the sum of distances between all pairs of nodes on the tree. The distance between two nodes is defined as the number of edges on the path from one to the other.\n\nHe is very curious: if Xiao G comes to pick apples after $N$ days, what is the expected inconvenience $E$? However, Xiao C hates fractions, so he only wants to know the result of $E \\times N !$ modulo $P$. It can be proven that this is an integer.", "inputFormat": "Read from standard input. A single line contains two integers $N$, $P$.", "outputFormat": "Print to standard output. Output a single integer representing the answer.", "hint": "![Explanation](https://cdn.luogu.com.cn/upload/pic/18067.png)\n\nThe above shows all possible apple tree shapes when $N = 3$, where the label on each node indicates the day on which it grew. Clearly, in every case the sum of pairwise node distances is $4$.\n\n### Constraints\n| Test point ID | $N$ | $P$ |\n| :--------: | :--: | :--: |\n| $1$ | $\\le 10$ | $\\le 10^9 + 7$ |\n| $2$ | $\\le 10$ | $\\le 10^9 + 7$ |\n| $3$ | $\\le 500$ | $\\le 10^9 + 7$ |\n| $4$ | $\\le 500$ | $\\le 10^9 + 7$ |\n| $5$ | $\\le 500$ | $\\le 10^9 + 7$ |\n| $6$ | $\\le 2000$ | $= 10^9 + 7$ |\n| $7$ | $\\le 2000$ | $= 10^9 + 7$ |\n| $8$ | $\\le 2000$ | $\\le 10^9 + 7$ |\n| $9$ | $\\le 2000$ | $\\le 10^9 + 7$ |\n| $10$ | $\\le 2000$ | $\\le 10^9 + 7$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2018] 苹果树", "background": "HAOI2018 Round2 第一题", "description": "小 C 在自己家的花园里种了一棵苹果树, 树上每个结点都有恰好两个分支. 经过细心的观察, 小 C 发现每一天这棵树都会生长出一个新的结点.\n\n第一天的时候, 果树会长出一个根结点, 以后每一天, 果树会随机选择一个当前树中没有长出过结点 的分支, 然后在这个分支上长出一个新结点, 新结点与分支所属的结点之间连接上一条边.\n\n小 C 定义一棵果树的不便度为树上两两结点之间的距离之和, 两个结点之间 的距离定义为从一个点走到另一个点的路径经过的边数.\n\n现在他非常好奇, 如果 $N$ 天之后小 G 来他家摘苹果, 这个不便度的期望 $E$ 是多少. 但是小 C 讨厌分数, 所以他只想知道 $E \\times N !$ 对 $P$ 取模的结果, 可以证明这是一个整数.", "inputFormat": "从标准输入中读入数据. 一行两个整数 $N$, $P$ .", "outputFormat": "输出到标准输出中. 输出一个整数表示答案．", "hint": "![Explanation](https://cdn.luogu.com.cn/upload/pic/18067.png)\n\n以上是所有 $N = 3$ 时可能的苹果树形态, 其中编号表示这个结点是第几天生\n长出来的, 显然每种情况两两结点的距离均为 $4$ .\n\n### 数据范围与约定\n| 测试点编号   | $N$  | $P$  |\n| :--------: | :--: | :--: |\n| $1$ |  $\\le 10$    |  $\\le 10^9 + 7$    |\n| $2$ |  $\\le 10$    |   $\\le 10^9 + 7$    |\n| $3$ |  $\\le 500$    |  $\\le 10^9 + 7$     |\n| $4$ |  $\\le 500$    |   $\\le 10^9 + 7$    |\n| $5$ |  $\\le 500$    |   $\\le 10^9 + 7$    |\n| $6$ |  $\\le 2000$    |   $= 10^9 + 7$    |\n| $7$ |  $\\le 2000$    |   $= 10^9 + 7$    |\n| $8$ |  $\\le 2000$    |   $\\le 10^9 + 7$    |\n| $9$ |  $\\le 2000$    |   $\\le 10^9 + 7$    |\n| $10$ | $\\le 2000$     |    $\\le 10^9 + 7$   |\n\n", "locale": "zh-CN"}}}
{"pid": "P4493", "type": "P", "difficulty": 7, "samples": [["10 11\nabcbababab\nababcbabab\n5\n1 9 7 9\n3 10 8 10\n1 10 1 2\n5 7 2 3\n1 5 3 6", "6\n10\n22\n5\n10"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "河南", "各省省选", "O2优化"], "title": "[HAOI2018] 字串覆盖", "background": null, "description": "小 C 对字符串颇有研究，他觉得传统的字符串匹配太无聊了，于是他想到了这样一个问题。\n\n对于两个长度为 $n$ 的串 $A,B$，小 C 每次会给出给出 $4$ 个参数 $s,t,l,r$。令 $A$ 从 $s$ 到 $t$ 的\n子串（从 $1$ 开始标号）为 $T$，令 $B$ 从 $l$ 到 $r$ 的子串为 $P$。然后他会进行下面的操作：\n\n如果 $T$ 的某个子串与 $P$ 相同，我们就可以覆盖 $T$ 的这个子串，并获得 $K-i$ 的收益，其中 $i$ 是初始时 $A$ 中（注意不是 $T$ 中）这个子串的起始位置，$K$ 是给定的参数。一个位置不能被覆盖多次．覆盖操作可以进行任意多次，你需要输出获得收益的最大值。\n\n注意每次询问都是独立的，即进行一次询问后，覆盖的位置会复原。", "inputFormat": "第一行两个整数 $n,K$ 表示字符串长度和参数。\n\n接下来一行一个字符串 $A$。\n\n接下来一行一个字符串 $B$。\n\n接下来一行一个整数 $q$，表示询问个数。\n\n接下来 $q$ 行，每行四个整数 $s,t,l,r$ 表示一次询问。", "outputFormat": "输出 $q$ 行，每行一个整数，表示一个询问的答案．", "hint": "样例 $1$ 解释 ![](https://cdn.luogu.com.cn/upload/pic/18143.png)\n\n对于所有数据，有 $1\\le n,q\\le 10^5$，$A,B$ 仅由小写英文字母组成，$ 1\\le s\\le t\\le n$，$ 1\\le l\\le r\\le n$，$n<K\\le 10^9$。\nHAOI2018 round1 T3\n\n对于 $ n = 10^5 $ 的测试点，满足 $51\\le r−l\\le2\\times 10^3$ 的询问不超过 $11000$ 个，且 $l,r$ 均匀随机\n\n数据范围\n![](https://cdn.luogu.com.cn/upload/pic/18142.png)", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2018] Substring Coverage", "background": "", "description": "Xiao C is quite into strings. He finds traditional string matching too boring, so he came up with the following problem.\n\nFor two strings $A, B$ of length $n$, each time he gives four parameters $s, t, l, r$. Let $T$ be the substring of $A$ from $s$ to $t$ (1-indexed), and let $P$ be the substring of $B$ from $l$ to $r$. Then he performs the following operation:\n\nIf some substring of $T$ equals $P$, we can cover this substring of $T$ and gain $K - i$, where $i$ is the starting position of this substring in $A$ at the beginning (note: not in $T$), and $K$ is a given parameter. A position cannot be covered more than once. The covering operation can be performed any number of times. You need to output the maximum total gain.\n\nNote that each query is independent, i.e., after finishing a query, the covered positions are restored.", "inputFormat": "The first line contains two integers $n, K$, denoting the string length and the parameter.\n\nThe next line contains a string $A$.\n\nThe next line contains a string $B$.\n\nThe next line contains an integer $q$, denoting the number of queries.\n\nEach of the next $q$ lines contains four integers $s, t, l, r$, describing one query.", "outputFormat": "Output $q$ lines, each containing one integer, the answer for each query.", "hint": "Explanation for Sample 1: ![](https://cdn.luogu.com.cn/upload/pic/18143.png)\n\nFor all testdata, $1 \\le n, q \\le 10^5$, $A, B$ consist only of lowercase English letters, $1 \\le s \\le t \\le n$, $1 \\le l \\le r \\le n$, $n < K \\le 10^9$. HAOI2018 Round 1 T3.\n\nFor the testpoint with $n = 10^5$, the number of queries satisfying $51 \\le r - l \\le 2 \\times 10^3$ does not exceed $11000$, and $l, r$ are uniformly random.\n\nConstraints\n![](https://cdn.luogu.com.cn/upload/pic/18142.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2018] 字串覆盖", "background": null, "description": "小 C 对字符串颇有研究，他觉得传统的字符串匹配太无聊了，于是他想到了这样一个问题。\n\n对于两个长度为 $n$ 的串 $A,B$，小 C 每次会给出给出 $4$ 个参数 $s,t,l,r$。令 $A$ 从 $s$ 到 $t$ 的\n子串（从 $1$ 开始标号）为 $T$，令 $B$ 从 $l$ 到 $r$ 的子串为 $P$。然后他会进行下面的操作：\n\n如果 $T$ 的某个子串与 $P$ 相同，我们就可以覆盖 $T$ 的这个子串，并获得 $K-i$ 的收益，其中 $i$ 是初始时 $A$ 中（注意不是 $T$ 中）这个子串的起始位置，$K$ 是给定的参数。一个位置不能被覆盖多次．覆盖操作可以进行任意多次，你需要输出获得收益的最大值。\n\n注意每次询问都是独立的，即进行一次询问后，覆盖的位置会复原。", "inputFormat": "第一行两个整数 $n,K$ 表示字符串长度和参数。\n\n接下来一行一个字符串 $A$。\n\n接下来一行一个字符串 $B$。\n\n接下来一行一个整数 $q$，表示询问个数。\n\n接下来 $q$ 行，每行四个整数 $s,t,l,r$ 表示一次询问。", "outputFormat": "输出 $q$ 行，每行一个整数，表示一个询问的答案．", "hint": "样例 $1$ 解释 ![](https://cdn.luogu.com.cn/upload/pic/18143.png)\n\n对于所有数据，有 $1\\le n,q\\le 10^5$，$A,B$ 仅由小写英文字母组成，$ 1\\le s\\le t\\le n$，$ 1\\le l\\le r\\le n$，$n<K\\le 10^9$。\nHAOI2018 round1 T3\n\n对于 $ n = 10^5 $ 的测试点，满足 $51\\le r−l\\le2\\times 10^3$ 的询问不超过 $11000$ 个，且 $l,r$ 均匀随机\n\n数据范围\n![](https://cdn.luogu.com.cn/upload/pic/18142.png)", "locale": "zh-CN"}}}
{"pid": "P4494", "type": "P", "difficulty": 6, "samples": [["2\n5 5\n1 2\n2 3\n3 4\n2 4\n3 5\n00000\n5 4\n1 2\n2 3\n2 4\n2 5\n11111", "2 2 1 1 1 2\n0 1 0 1 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "河南", "各省省选", "O2优化"], "title": "[HAOI2018] 反色游戏", "background": null, "description": "小 C 和小 G 经常在一起研究搏弈论问题，有一天他们想到了这样一个游戏——\n\n有一张 $n$ 个点 $m$ 条边的无向图，初始时每个节点有一个颜色，要么是黑色，要么是白色。\n\n现在他们对于每条边做出一次抉择：要么将这条边连接的两个节点都反色（黑变白，白变黑），要么不作处理。\n\n他们想把所有节点都变为白色，于是他们想知道在所有 $2^m$ 种可能的决策中，有多少种方案能达成这个目标。\n\n然而，小 G 认为这个问题太水了，于是他还想知道，对于第 $i$ 个点，在删去这个点及与它相连的边后，新的答案是多少。\n\n由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模后的结果。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行两个整数 $n,m$ 表示图的点数和边数。\n\n接下来 $m$ 行，每行两个整数 $u,v$，描述无向图的一条边 $(u,v)$。\n\n接下来一行一个长度为 $n$ 的 01 串：\n\n- 如果第 $i$ 个字符为 $\\tt 0$，表示第 $i$ 个点为白色；\n- 如果第 $i$ 个字符为 $\\tt 1$，表示第 $i$ 个点为黑色。", "outputFormat": "对于每组数据，输出一行 $n+1$ 个整数：\n\n第一个整数表示不删去任何点时的答案（输出后不要换行）；\n\n接下来 $n$ 个整数，第 $i$ 个表示删去第 $i$ 个点时的答案。\n\n答案对 $10^9+7$ 取模。", "hint": "对于所有数据，有 $1\\le T\\le l0^5,1\\le n,m\\le10^5,1\\le u,v\\le n$，且给定的无向图没有重边和自环。\n\n![](https://cdn.luogu.com.cn/upload/pic/18145.png)\n\n*[Source: HAOI2018 Day 1 T2]*", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2018] Color Inversion Game", "background": "", "description": "Xiao C and Xiao G often study game theory together. One day they came up with the following game—\n\nThere is an undirected graph with $n$ vertices and $m$ edges. Initially, each vertex has a color: either black or white.\n\nFor each edge, they make one decision: either flip the colors of both endpoints of this edge (black becomes white, white becomes black), or do nothing.\n\nThey want to make all vertices white, so they would like to know, among all $2^m$ possible decisions, how many ways can achieve this goal.\n\nHowever, Xiao G thinks this is too easy, so he also wants to know, for the $i$-th vertex, after deleting this vertex and all edges incident to it, what the new answer is.\n\nSince the answer can be large, you only need to output the result modulo $10^9+7$.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases.\n\nFor each test case:\n\nThe first line contains two integers $n, m$, the numbers of vertices and edges.\n\nThe next $m$ lines each contain two integers $u, v$, describing an undirected edge $(u, v)$.\n\nThen one line contains a binary string of length $n$:\n- If the $i$-th character is $\\tt 0$, vertex $i$ is white.\n- If the $i$-th character is $\\tt 1$, vertex $i$ is black.", "outputFormat": "For each test case, output one line with $n+1$ integers:\nThe first integer is the answer when no vertex is deleted (do not add a line break right after printing it); then output $n$ integers, where the $i$-th is the answer after deleting vertex $i$. Each answer is taken modulo $10^9+7$.", "hint": "Constraints: For all testdata, $1 \\le T \\le 10^5, 1 \\le n, m \\le 10^5, 1 \\le u, v \\le n$, and the given undirected graph has no multiple edges or self-loops.\n\n![](https://cdn.luogu.com.cn/upload/pic/18145.png)\n\n*[Source: HAOI2018 Day 1 T2]*\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2018] 反色游戏", "background": null, "description": "小 C 和小 G 经常在一起研究搏弈论问题，有一天他们想到了这样一个游戏——\n\n有一张 $n$ 个点 $m$ 条边的无向图，初始时每个节点有一个颜色，要么是黑色，要么是白色。\n\n现在他们对于每条边做出一次抉择：要么将这条边连接的两个节点都反色（黑变白，白变黑），要么不作处理。\n\n他们想把所有节点都变为白色，于是他们想知道在所有 $2^m$ 种可能的决策中，有多少种方案能达成这个目标。\n\n然而，小 G 认为这个问题太水了，于是他还想知道，对于第 $i$ 个点，在删去这个点及与它相连的边后，新的答案是多少。\n\n由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模后的结果。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行两个整数 $n,m$ 表示图的点数和边数。\n\n接下来 $m$ 行，每行两个整数 $u,v$，描述无向图的一条边 $(u,v)$。\n\n接下来一行一个长度为 $n$ 的 01 串：\n\n- 如果第 $i$ 个字符为 $\\tt 0$，表示第 $i$ 个点为白色；\n- 如果第 $i$ 个字符为 $\\tt 1$，表示第 $i$ 个点为黑色。", "outputFormat": "对于每组数据，输出一行 $n+1$ 个整数：\n\n第一个整数表示不删去任何点时的答案（输出后不要换行）；\n\n接下来 $n$ 个整数，第 $i$ 个表示删去第 $i$ 个点时的答案。\n\n答案对 $10^9+7$ 取模。", "hint": "对于所有数据，有 $1\\le T\\le l0^5,1\\le n,m\\le10^5,1\\le u,v\\le n$，且给定的无向图没有重边和自环。\n\n![](https://cdn.luogu.com.cn/upload/pic/18145.png)\n\n*[Source: HAOI2018 Day 1 T2]*", "locale": "zh-CN"}}}
{"pid": "P4495", "type": "P", "difficulty": 6, "samples": [["3 3 6\n1 3 4\n5 2 3", "5\n6\n6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2018", "河南", "各省省选", "O2优化", "枚举"], "title": "[HAOI2018] 奇怪的背包", "background": "", "description": "小 C 非常擅长背包问题，他有一个奇怪的背包，这个背包有一个参数 $P$ ，当他向这个背包内放入若干个物品后，背包的重量是物品总体积对 $P$ 取模后的结果。\n\n现在小 C 有 $n$ 种体积不同的物品，第 $i$ 种占用体积为 $V_i$ ，每种物品都有无限个。他会进行 $q$ 次询问，每次询问给出重量 $w_i$ ，你需要回答有多少种放入物品的方案，能将一个初始为空的背包的重量变为 $w_i$。注意，两种方案被认为是不同的，当且仅当放入物品的种类不同，而与每种物品放入的个数无关．不难发现总的方案数为 $2^n$。\n\n由于答案可能很大，你只需要输出答案对 $10^9 + 7$ 取模的结果。", "inputFormat": "第一行三个整数 $n, q, P$，含义见问题描述。\n\n接下来一行 $n$ 个整数表示 $V_i$。\n\n接下来一行 $q$ 个整数表示 $w_i$。", "outputFormat": "输出 $q$ 行，每行一个整数表示答案。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/18144.png)\nHAOI2018 round1 T1", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2018] Strange Knapsack", "background": "", "description": "Xiao C is very good at knapsack problems. He has a strange knapsack with a parameter $P$. After he puts some items into this knapsack, the knapsack’s weight is the total volume of the items modulo $P$.\n\nNow there are $n$ types of items with different volumes. The $i$-th type has volume $V_i$, and each type has an unlimited supply. He will make $q$ queries. For each query, a weight $w_i$ is given. You need to answer how many ways there are to put items so that the weight of an initially empty knapsack becomes $w_i$. Note that two ways are considered different if and only if the types of items used are different, regardless of how many of each type are used. It is not hard to see that the total number of ways is $2^n$.\n\nSince the answer may be large, you only need to output it modulo $10^9 + 7$.", "inputFormat": "The first line contains three integers $n, q, P$, as described above.\n\nThe next line contains $n$ integers denoting $V_i$.\n\nThe next line contains $q$ integers denoting $w_i$.", "outputFormat": "Output $q$ lines, each containing one integer, the answer for that query.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/18144.png)\nHAOI2018 round1 T1\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2018] 奇怪的背包", "background": "", "description": "小 C 非常擅长背包问题，他有一个奇怪的背包，这个背包有一个参数 $P$ ，当他向这个背包内放入若干个物品后，背包的重量是物品总体积对 $P$ 取模后的结果。\n\n现在小 C 有 $n$ 种体积不同的物品，第 $i$ 种占用体积为 $V_i$ ，每种物品都有无限个。他会进行 $q$ 次询问，每次询问给出重量 $w_i$ ，你需要回答有多少种放入物品的方案，能将一个初始为空的背包的重量变为 $w_i$。注意，两种方案被认为是不同的，当且仅当放入物品的种类不同，而与每种物品放入的个数无关．不难发现总的方案数为 $2^n$。\n\n由于答案可能很大，你只需要输出答案对 $10^9 + 7$ 取模的结果。", "inputFormat": "第一行三个整数 $n, q, P$，含义见问题描述。\n\n接下来一行 $n$ 个整数表示 $V_i$。\n\n接下来一行 $q$ 个整数表示 $w_i$。", "outputFormat": "输出 $q$ 行，每行一个整数表示答案。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/18144.png)\nHAOI2018 round1 T1", "locale": "zh-CN"}}}
{"pid": "P4496", "type": "P", "difficulty": 7, "samples": [["3 1\n1 5\n2 4\n3 6\n1 2 3", "9\n2 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "提交答案", "Special Judge", "CTSC/CTS"], "title": "[CTSC2009] 移民站选址", "background": "", "description": "2323年，随着科技的发展以及地球日趋严重的人口压力，人类开始大规模向火星移民。令人欣慰的是，移民工程的第一步取得了巨大的成功，已经在火星表面建立了$N$个移民站，其中第i个移民站的坐标是$(u_i, v_i)$。但是在进行后续的移民工作时，人们遇到了一个严峻的问题：如何选择新建的移民站的地址。经过调查确定，需要在火星上新建$M$个移民站，已知原有的第$i$个移民站和新建的第$j$个移民站之间信息传输的流量是$A_{i,j}$，新建的第$j$个移民站和第$k$个移民站之间信息传输的流量是$B_{j,k}$，同时假定，将一个单位流量的信息传输一个单位距离的费用是$1$，这里的距离定义为曼哈顿距离。两个点$(x_1, y_1)$和$(x_2, y_2)$的曼哈顿距离定义如下：\n\n$$ \\mathrm{ManhattanDist}( (x_1, y_1), (x_2, y_2) ) = |x_1 - x_2| + |y_1 - y_2| $$\n\n现在的问题是，给定原有的$N$个移民站的地址和信息流量传输矩阵$A$、$B$，需要你为这$M$个新的移民站选择地址，使得信息传输总费用最小。", "inputFormat": "输入文件为*locate1.in~locate10.in*，第一行为两个整数$N$、$M$，表示原有移民站的数目和需要新建的移民站的数目。接下来的N行每行包含两个整数，表示原有的移民站的坐标；接下来$N$行每行包含$M$个整数，表示信息流量传输矩阵$A$；最后$M-1$行中，第$i$行包含$M-i$个整数，其中的第$j$个表示$B_{i,i+j}$。", "outputFormat": "输出文件为*locate1.out~locate10.out*，*locate?.out*对应*locate?.in*的答案。输出的第一行为一个整数，表示你所计算出的信息传输费用。接下来的$M$行每行包含两个整数，其中第$i$行表示第$i$个新建的移民站的坐标。", "hint": "本题输入数据下载：[百度网盘](https://pan.baidu.com/s/1hEbcB45kL25wbXqEeew7Yg)\n\n**【评分标准】**\n\n每个测试点单独评分。\n\n对于每一个测试点，如果你给出的输出文件不合法，如文件格式错误、输出\n解不符合要求等，该测试点得 0 分。否则设你的输出答案长度为 ans，对于不同的测试点，我们还设有 9 个评分相关的常数 c1 ≤ c2 ≤ c3 ≤ c4 ≤ c5 ≤ c6\n≤ c7 ≤ c8 ≤ c9 ≤ c10，你在该测试点中的得分由下列陈述得出：\n\n- 如果 ans > c10，得0分。\n- 如果 ans ≤ c10，得1分。\n- 如果 ans ≤ c9，得2分。\n- 如果 ans ≤ c8，得3分。\n- 如果 ans ≤ c7，得4分。\n- 如果 ans ≤ c6，得5分。\n- 如果 ans ≤ c5，得6分。\n- 如果 ans ≤ c4，得7分。\n- 如果 ans ≤ c3，得8分。\n- 如果 ans ≤ c2，得9分。\n- 如果 ans ≤ c1，得10分。\n- ~~如果 ans < c1，得12分。~~\n- 如果满足多个条件，取得分最大者为最终得分。\n\n**【特别提示】**\n\n请妥善保存输入文件*locate\\*.in* 和你的输出*locate\\*.out*，及时备份，以免误删。☺", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2009] Immigration Station Site Selection", "background": "", "description": "In the year 2323, with technological advances and the increasingly severe population pressure on Earth, humanity began large-scale migration to Mars. Encouragingly, the first step of the migration project achieved great success, and $N$ immigration stations have already been established on the surface of Mars, where the $i$-th station is at coordinates $(u_i, v_i)$. However, when proceeding with subsequent migration work, people encountered a serious problem: how to choose the locations for the new immigration stations. After investigation, it has been determined that $M$ new immigration stations need to be built on Mars. It is known that the information transmission flow between the original $i$-th station and the new $j$-th station is $A_{i,j}$, and the information transmission flow between the new $j$-th station and the $k$-th new station is $B_{j,k}$. At the same time, assume that the cost to transmit one unit of flow over one unit of distance is $1$, where the distance is defined as the Manhattan distance. The Manhattan distance between two points $(x_1, y_1)$ and $(x_2, y_2)$ is defined as follows:\n\n$$ \\mathrm{ManhattanDist}( (x_1, y_1), (x_2, y_2) ) = |x_1 - x_2| + |y_1 - y_2| $$\n\nNow the problem is: given the addresses of the $N$ existing immigration stations and the information flow matrices $A$ and $B$, you need to choose locations for these $M$ new immigration stations so that the total information transmission cost is minimized.", "inputFormat": "The input files are *locate1.in~locate10.in*. The first line contains two integers $N$, $M$, representing the number of existing immigration stations and the number of new stations to be built. The next $N$ lines each contain two integers, representing the coordinates of the existing stations. The next $N$ lines each contain $M$ integers, representing the information flow matrix $A$. In the final $M-1$ lines, the $i$-th line contains $M-i$ integers, where the $j$-th of them represents $B_{i,i+j}$.", "outputFormat": "The output files are *locate1.out~locate10.out*, where *locate?.out* corresponds to the answer for *locate?.in*. The first line of the output is an integer, representing the total information transmission cost you computed. The next $M$ lines each contain two integers; the $i$-th line represents the coordinates of the $i$-th newly built immigration station.", "hint": "The input testdata for this problem can be downloaded from: [Baidu Netdisk](https://pan.baidu.com/s/1hEbcB45kL25wbXqEeew7Yg).\n\n【Scoring Criteria】\n\nEach test point is scored independently.\n\nFor each test point, if your output file is invalid (e.g., file format error, output not meeting requirements, etc.), you receive 0 points for that test point. Otherwise, let your answer be $ans$. For different test points, we also set 10 scoring-related constants satisfying $c_1 \\le c_2 \\le c_3 \\le c_4 \\le c_5 \\le c_6 \\le c_7 \\le c_8 \\le c_9 \\le c_{10}$. Your score for that test point is determined by the following statements:\n\n- If $ans > c_{10}$, you get 0 points.\n- If $ans \\le c_{10}$, you get 1 point.\n- If $ans \\le c_9$, you get 2 points.\n- If $ans \\le c_8$, you get 3 points.\n- If $ans \\le c_7$, you get 4 points.\n- If $ans \\le c_6$, you get 5 points.\n- If $ans \\le c_5$, you get 6 points.\n- If $ans \\le c_4$, you get 7 points.\n- If $ans \\le c_3$, you get 8 points.\n- If $ans \\le c_2$, you get 9 points.\n- If $ans \\le c_1$, you get 10 points.\n- ~~If $ans < c_1$, you get 12 points.~~\n- If multiple conditions are satisfied, the highest applicable score is taken as the final score.\n\n【Special Reminder】\n\nPlease properly save the input files *locate\\*.in* and your outputs *locate\\*.out*, and back them up in time to avoid accidental deletion. ☺\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2009] 移民站选址", "background": "", "description": "2323年，随着科技的发展以及地球日趋严重的人口压力，人类开始大规模向火星移民。令人欣慰的是，移民工程的第一步取得了巨大的成功，已经在火星表面建立了$N$个移民站，其中第i个移民站的坐标是$(u_i, v_i)$。但是在进行后续的移民工作时，人们遇到了一个严峻的问题：如何选择新建的移民站的地址。经过调查确定，需要在火星上新建$M$个移民站，已知原有的第$i$个移民站和新建的第$j$个移民站之间信息传输的流量是$A_{i,j}$，新建的第$j$个移民站和第$k$个移民站之间信息传输的流量是$B_{j,k}$，同时假定，将一个单位流量的信息传输一个单位距离的费用是$1$，这里的距离定义为曼哈顿距离。两个点$(x_1, y_1)$和$(x_2, y_2)$的曼哈顿距离定义如下：\n\n$$ \\mathrm{ManhattanDist}( (x_1, y_1), (x_2, y_2) ) = |x_1 - x_2| + |y_1 - y_2| $$\n\n现在的问题是，给定原有的$N$个移民站的地址和信息流量传输矩阵$A$、$B$，需要你为这$M$个新的移民站选择地址，使得信息传输总费用最小。", "inputFormat": "输入文件为*locate1.in~locate10.in*，第一行为两个整数$N$、$M$，表示原有移民站的数目和需要新建的移民站的数目。接下来的N行每行包含两个整数，表示原有的移民站的坐标；接下来$N$行每行包含$M$个整数，表示信息流量传输矩阵$A$；最后$M-1$行中，第$i$行包含$M-i$个整数，其中的第$j$个表示$B_{i,i+j}$。", "outputFormat": "输出文件为*locate1.out~locate10.out*，*locate?.out*对应*locate?.in*的答案。输出的第一行为一个整数，表示你所计算出的信息传输费用。接下来的$M$行每行包含两个整数，其中第$i$行表示第$i$个新建的移民站的坐标。", "hint": "本题输入数据下载：[百度网盘](https://pan.baidu.com/s/1hEbcB45kL25wbXqEeew7Yg)\n\n**【评分标准】**\n\n每个测试点单独评分。\n\n对于每一个测试点，如果你给出的输出文件不合法，如文件格式错误、输出\n解不符合要求等，该测试点得 0 分。否则设你的输出答案长度为 ans，对于不同的测试点，我们还设有 9 个评分相关的常数 c1 ≤ c2 ≤ c3 ≤ c4 ≤ c5 ≤ c6\n≤ c7 ≤ c8 ≤ c9 ≤ c10，你在该测试点中的得分由下列陈述得出：\n\n- 如果 ans > c10，得0分。\n- 如果 ans ≤ c10，得1分。\n- 如果 ans ≤ c9，得2分。\n- 如果 ans ≤ c8，得3分。\n- 如果 ans ≤ c7，得4分。\n- 如果 ans ≤ c6，得5分。\n- 如果 ans ≤ c5，得6分。\n- 如果 ans ≤ c4，得7分。\n- 如果 ans ≤ c3，得8分。\n- 如果 ans ≤ c2，得9分。\n- 如果 ans ≤ c1，得10分。\n- ~~如果 ans < c1，得12分。~~\n- 如果满足多个条件，取得分最大者为最终得分。\n\n**【特别提示】**\n\n请妥善保存输入文件*locate\\*.in* 和你的输出*locate\\*.out*，及时备份，以免误删。☺", "locale": "zh-CN"}}}
{"pid": "P4497", "type": "P", "difficulty": 7, "samples": [["2 \n5 9 \n9 10 7 6 8 \n1 \n0 4 5 2 \n0 3 5 4 \n1 \n0 2 5 -2 \n0 3 5 -3 \n0 4 5 -2 \n0 5 5 -4 \n1 \n4 3 \n2 4 3 5 \n1 \n0 3 3 3 \n1 ", "3 1 \n5 -1 \n0 0 \n4 -1 \n4 -1 "]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2011", "Special Judge", "WC"], "title": "[WC2011] 拼点游戏", "background": "", "description": "小 W 和小 Y 都很喜欢玩一种“拼点游戏”。游戏中两个人分别通过某种操作产生一个数作为自己的“点数”，点数大的一方获胜。“拼点游戏”的规则如下：\n\n1. 游戏开始时，给定一个包含 $n$ 个元素的正整数序列 $U=(u_1,u_2,\\cdots,u_n)$。\n2. 定义 $U$ 的一个下标序列 $I=(i_1,i_2,\\cdots,i_m)$ 是满足 $1\\leq i_1<i_2<\\cdots<i_m\\leq n$ 的一个整数序列（ $m$ 可以为 0 ，即序列可以为空），并且其对应 $U$ 的子序列为 $V=(u_{i_1},u_{i_2},\\cdots,u_{i_m})$。\n3. 定义下标序列 $I=(i_1,i_2,\\cdots,i_m)$ 对应的点数 $D(I)$ 为： $D(I)=\\sum_{p=1}^m u_{i_p}\\times (-1)^p$。\n4. 进行游戏时两人分别选择一个下标序列，谁选择的下标序列对应的点数 $D(I)$ 大，谁就获胜。\n\n然而在每次游戏中，小 W 总是能准确无误的算出点数最大的最优下标序列。为了让游戏更加具有竞技性，他们制定了下列额外规则：\n\nEx1. 小W可以选择一个非空区间 $[l,r]$，并将 $u_l,u_{l+1},\\cdots,u_r$ 同时增加一个整数 $c$，产生的新序列将取代原序列 $U$。\n\nEx2. 当他们对于当前的 $U$ 序列进行一次“拼点游戏”时，允许小 Y 在小 W 选出最优下标序列 $I=(i_1,i_2,\\cdots,i_m)$ 之后，对 $I_W$ 进行任意次修改操作。每次修改操作规则如下：\n\n(1)任意选择一个正整数k满足݉ $2k+1\\leq m$，以及两个非负整数 $z_1,z_2$ 满足 $i_{2k}+z_1<i_{2k+1}-z_2$；\n\n(2)将 $i_{2k}$ 修改为 $i_{2k}+z_1$，将 $i_{2k+1}$ 修改为 $i_{2k+1}-z_2$。\n\n若小 W 选出的下标序列 $I_W$ 经过小 Y 若干次修改操作之后所对应的点数小于等于 $0$，则小 Y 获胜。\n\n现在给出小 W 所进行的 Ex1 操作的信息，请你对于每一次“拼点游戏”\n，帮助他们计算：\n\na)小 W 一开始所能选出的最优下标序列对应的点数是多少？\n\nb)小 Y 最少需要进行几次修改操作才能获胜？即使得 $D(I_W)\\leq 0$。", "inputFormat": "输入文件 joy.in 的第一行包含一个正整数 $T$，表示测试数据的组数。接下来为 $T$ 组数据。\n\n每一组数据的第一行包含两个整数 $n$ 和 $q$，分别表示 $U$ 中的元素个数和事件个数。\n\n接下来的一行，包含 $n$个 用一个空格隔开的正整数，第 $i$ 个整数为初始的序列中第 $i$ 个元素 $u_i$。\n\n接下来 $q$ 行，每行代表一个事件（按事件发生顺序输入）。每行的第一个数非 $0$ 即 $1$，表示这个事件的类型。\n\n若为 $0$ ：在 $0$ 之后还有三个整数 $l$，$r$ 和 $c$（这四个数之间均有一个空格）表示小 W 将 $u_l,u_{l+1},\\cdots,u_r$ 增加 $c$；\n\n若为 $1$：表示两人进行了一次“拼点游戏”，你需要输出相应的结果。\n\n输入数据保证序列 $U$ 中的所有元素总是正整数。", "outputFormat": "输出文件为joy.out。对于每一组测试数据，依次对每一次“拼点游戏”输出一行包含两个由一个空格隔开的整数 $D_{max}$ 和 $X$，其中\n\n$D_{max}$ 为对于当前序列 $U$，小 W 所能选出的最优下标序列所对应的点数；\n\n$X$ 表示小 Y 最少需要进行几次修改操作才能获胜。如果小 Y 不论多少次操作都无法获胜，则输出```-1```。\n\n数据保证最优下标序列总是唯一的。", "hint": "【评分标准】\n\n一个测试点包含多组测试数据，对于该测试点：\n\n如果所有的 $D_{max}$ 均正确但某个 $X$ 不正确，则可以得到3分；\n\n如果所有的 $X$ 均正确但某个 $D_{max}$ 不正确，则可以得到7分；\n\n如果所有回答均正确，则可以得到 10 分。\n\n【样例说明】\n\n输入数据包含两组测试数据。\n\n在第一组测试数据中：第一次“拼点游戏”时，最优下标序列为 $(1,2,4,5)$，小 Y 只需要进行一次修改操作：选择 $k=1$，以及非负整数 $z_1=1,z_2=0$。这样经过修改操作之后下标序列将变为 $(1,3,4,5)$，小 Y 获胜。\n\n第三次“拼点游戏”时，序列 $U$ 为 $(9,8,6,5,3)$，小 W 所选择的最优下标序列为空序列，所产生的点数为 $0$。在这种情况下，小 Y 无法进行任何修改操作（也无需进行任何修改操作），此时小 Y 已经直接获胜。\n\n【数据规模】\n\n对于 10% 的数据满足 $n,q\\leq 13$；\n\n对于 30% 的数据满足 $n,q\\leq 1000$；\n\n对于另外 20% 的数据满足 $T=1$ 且 $n\\leq 40000$；\n\n对于 100% 的数据满足 $T\\leq 3$ 且 $n,q\\leq 10^5$，同时初始序列 $U$ 满足 $0 <u_i< 2^{31}$，$|c|<10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[WC2011] Point-Picking Game", "background": "", "description": "Xiao W and Xiao Y both enjoy a “point-picking game.” In the game, each of the two players produces a number as their “score” through some operation, and the player with the larger score wins. The rules of the “point-picking game” are as follows:\n1. At the start of the game, you are given a positive integer sequence with $n$ elements, $U=(u_1, u_2, \\cdots, u_n)$.\n2. An index sequence $I=(i_1, i_2, \\cdots, i_m)$ of $U$ is an integer sequence satisfying $1 \\leq i_1 < i_2 < \\cdots < i_m \\leq n$ (where $m$ can be $0$, i.e., the sequence can be empty), and its corresponding subsequence of $U$ is $V=(u_{i_1}, u_{i_2}, \\cdots, u_{i_m})$.\n3. The score $D(I)$ corresponding to the index sequence $I=(i_1, i_2, \\cdots, i_m)$ is defined as $D(I)=\\sum_{p=1}^m u_{i_p} \\times (-1)^p$.\n4. During the game, the two players each choose an index sequence, and the one whose chosen index sequence corresponds to a larger score $D(I)$ wins.\n\nHowever, in every game, Xiao W can always compute, accurately and flawlessly, the optimal index sequence that maximizes the score. To make the game more competitive, they added the following extra rules:\n\nEx1. Xiao W may choose a non-empty interval $[l, r]$ and increase $u_l, u_{l+1}, \\cdots, u_r$ by an integer $c$ simultaneously; the new sequence replaces the original sequence $U$.\n\nEx2. When they play a “point-picking game” on the current sequence $U$, Xiao Y is allowed, after Xiao W has chosen the optimal index sequence $I_W=(i_1, i_2, \\cdots, i_m)$, to modify $I_W$ any number of times. Each modification follows the rules below:\n(1) Arbitrarily choose a positive integer $k$ satisfying $2k+1 \\leq m$, and two non-negative integers $z_1, z_2$ satisfying $i_{2k} + z_1 < i_{2k+1} - z_2$;\n(2) Change $i_{2k}$ to $i_{2k} + z_1$, and change $i_{2k+1}$ to $i_{2k+1} - z_2$.\n\nIf, after some number of modifications by Xiao Y to the index sequence $I_W$ chosen by Xiao W, the corresponding score is less than or equal to $0$, then Xiao Y wins.\n\nNow, given the information about Xiao W’s Ex1 operations, for each “point-picking game,” please help them compute:\na) What is the score of the optimal index sequence that Xiao W can initially choose?\nb) What is the minimum number of modification operations Xiao Y needs in order to win, i.e., to make $D(I_W) \\leq 0$?", "inputFormat": "The first line of the input file joy.in contains a positive integer $T$, the number of groups of testdata. Then follow $T$ groups of data.\n\nFor each group of data, the first line contains two integers $n$ and $q$, denoting the number of elements in $U$ and the number of events, respectively.\n\nThe next line contains $n$ positive integers separated by single spaces, where the $i$-th integer is the $i$-th element $u_i$ in the initial sequence.\n\nThe following $q$ lines each describe an event (given in chronological order). The first number in each line is either $0$ or $1$, indicating the type of the event.\n\nIf it is $0$: after the $0$ there are three integers $l$, $r$, and $c$ (all separated by single spaces), meaning Xiao W increases $u_l, u_{l+1}, \\cdots, u_r$ by $c$.\n\nIf it is $1$: the two players play a “point-picking game,” and you need to output the corresponding result.\n\nThe input guarantees that all elements in the sequence $U$ are always positive integers.", "outputFormat": "The output file is joy.out. For each group of testdata, for each “point-picking game” in order, output one line containing two integers separated by a single space, $D_{max}$ and $X$, where\n- $D_{max}$ is the score of the optimal index sequence that Xiao W can choose for the current sequence $U$;\n- $X$ is the minimum number of modification operations that Xiao Y needs to win. If Xiao Y cannot win no matter how many operations are performed, output ```-1```.\n\nThe data guarantee that the optimal index sequence is always unique.", "hint": "Scoring rules:\n- A test point contains multiple groups of testdata. For that test point:\n  - If all $D_{max}$ are correct but some $X$ is incorrect, you get 3 points.\n  - If all $X$ are correct but some $D_{max}$ is incorrect, you get 7 points.\n  - If all answers are correct, you get 10 points.\n\nSample explanation:\n- The input contains two groups of testdata.\n- In the first group: In the first “point-picking game,” the optimal index sequence is $(1, 2, 4, 5)$. Xiao Y needs only one modification: choose $k=1$ and non-negative integers $z_1=1$, $z_2=0$. After the modification, the index sequence becomes $(1, 3, 4, 5)$, and Xiao Y wins.\n- In the third “point-picking game,” the sequence $U$ is $(9, 8, 6, 5, 3)$. Xiao W chooses the empty sequence as the optimal index sequence, yielding a score of $0$. In this case, Xiao Y cannot make any modification (nor is any modification needed), and Xiao Y already wins.\n\nConstraints:\n- For 10% of the data, $n, q \\leq 13$.\n- For 30% of the data, $n, q \\leq 1000$.\n- For another 20% of the data, $T=1$ and $n \\leq 40000$.\n- For 100% of the data, $T \\leq 3$ and $n, q \\leq 10^5$, and the initial sequence $U$ satisfies $0 < u_i < 2^{31}$ and $|c| < 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2011] 拼点游戏", "background": "", "description": "小 W 和小 Y 都很喜欢玩一种“拼点游戏”。游戏中两个人分别通过某种操作产生一个数作为自己的“点数”，点数大的一方获胜。“拼点游戏”的规则如下：\n\n1. 游戏开始时，给定一个包含 $n$ 个元素的正整数序列 $U=(u_1,u_2,\\cdots,u_n)$。\n2. 定义 $U$ 的一个下标序列 $I=(i_1,i_2,\\cdots,i_m)$ 是满足 $1\\leq i_1<i_2<\\cdots<i_m\\leq n$ 的一个整数序列（ $m$ 可以为 0 ，即序列可以为空），并且其对应 $U$ 的子序列为 $V=(u_{i_1},u_{i_2},\\cdots,u_{i_m})$。\n3. 定义下标序列 $I=(i_1,i_2,\\cdots,i_m)$ 对应的点数 $D(I)$ 为： $D(I)=\\sum_{p=1}^m u_{i_p}\\times (-1)^p$。\n4. 进行游戏时两人分别选择一个下标序列，谁选择的下标序列对应的点数 $D(I)$ 大，谁就获胜。\n\n然而在每次游戏中，小 W 总是能准确无误的算出点数最大的最优下标序列。为了让游戏更加具有竞技性，他们制定了下列额外规则：\n\nEx1. 小W可以选择一个非空区间 $[l,r]$，并将 $u_l,u_{l+1},\\cdots,u_r$ 同时增加一个整数 $c$，产生的新序列将取代原序列 $U$。\n\nEx2. 当他们对于当前的 $U$ 序列进行一次“拼点游戏”时，允许小 Y 在小 W 选出最优下标序列 $I=(i_1,i_2,\\cdots,i_m)$ 之后，对 $I_W$ 进行任意次修改操作。每次修改操作规则如下：\n\n(1)任意选择一个正整数k满足݉ $2k+1\\leq m$，以及两个非负整数 $z_1,z_2$ 满足 $i_{2k}+z_1<i_{2k+1}-z_2$；\n\n(2)将 $i_{2k}$ 修改为 $i_{2k}+z_1$，将 $i_{2k+1}$ 修改为 $i_{2k+1}-z_2$。\n\n若小 W 选出的下标序列 $I_W$ 经过小 Y 若干次修改操作之后所对应的点数小于等于 $0$，则小 Y 获胜。\n\n现在给出小 W 所进行的 Ex1 操作的信息，请你对于每一次“拼点游戏”\n，帮助他们计算：\n\na)小 W 一开始所能选出的最优下标序列对应的点数是多少？\n\nb)小 Y 最少需要进行几次修改操作才能获胜？即使得 $D(I_W)\\leq 0$。", "inputFormat": "输入文件 joy.in 的第一行包含一个正整数 $T$，表示测试数据的组数。接下来为 $T$ 组数据。\n\n每一组数据的第一行包含两个整数 $n$ 和 $q$，分别表示 $U$ 中的元素个数和事件个数。\n\n接下来的一行，包含 $n$个 用一个空格隔开的正整数，第 $i$ 个整数为初始的序列中第 $i$ 个元素 $u_i$。\n\n接下来 $q$ 行，每行代表一个事件（按事件发生顺序输入）。每行的第一个数非 $0$ 即 $1$，表示这个事件的类型。\n\n若为 $0$ ：在 $0$ 之后还有三个整数 $l$，$r$ 和 $c$（这四个数之间均有一个空格）表示小 W 将 $u_l,u_{l+1},\\cdots,u_r$ 增加 $c$；\n\n若为 $1$：表示两人进行了一次“拼点游戏”，你需要输出相应的结果。\n\n输入数据保证序列 $U$ 中的所有元素总是正整数。", "outputFormat": "输出文件为joy.out。对于每一组测试数据，依次对每一次“拼点游戏”输出一行包含两个由一个空格隔开的整数 $D_{max}$ 和 $X$，其中\n\n$D_{max}$ 为对于当前序列 $U$，小 W 所能选出的最优下标序列所对应的点数；\n\n$X$ 表示小 Y 最少需要进行几次修改操作才能获胜。如果小 Y 不论多少次操作都无法获胜，则输出```-1```。\n\n数据保证最优下标序列总是唯一的。", "hint": "【评分标准】\n\n一个测试点包含多组测试数据，对于该测试点：\n\n如果所有的 $D_{max}$ 均正确但某个 $X$ 不正确，则可以得到3分；\n\n如果所有的 $X$ 均正确但某个 $D_{max}$ 不正确，则可以得到7分；\n\n如果所有回答均正确，则可以得到 10 分。\n\n【样例说明】\n\n输入数据包含两组测试数据。\n\n在第一组测试数据中：第一次“拼点游戏”时，最优下标序列为 $(1,2,4,5)$，小 Y 只需要进行一次修改操作：选择 $k=1$，以及非负整数 $z_1=1,z_2=0$。这样经过修改操作之后下标序列将变为 $(1,3,4,5)$，小 Y 获胜。\n\n第三次“拼点游戏”时，序列 $U$ 为 $(9,8,6,5,3)$，小 W 所选择的最优下标序列为空序列，所产生的点数为 $0$。在这种情况下，小 Y 无法进行任何修改操作（也无需进行任何修改操作），此时小 Y 已经直接获胜。\n\n【数据规模】\n\n对于 10% 的数据满足 $n,q\\leq 13$；\n\n对于 30% 的数据满足 $n,q\\leq 1000$；\n\n对于另外 20% 的数据满足 $T=1$ 且 $n\\leq 40000$；\n\n对于 100% 的数据满足 $T\\leq 3$ 且 $n,q\\leq 10^5$，同时初始序列 $U$ 满足 $0 <u_i< 2^{31}$，$|c|<10^5$。", "locale": "zh-CN"}}}
{"pid": "P4498", "type": "P", "difficulty": 7, "samples": [["2\n2 1\n0 4\n4 4", "4.000000"], ["2\n2 1\n4 4\n4 -4", "5.464102"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2007", "Special Judge", "WC"], "title": "[WC2007] 疯狂赛车", "background": "布布是一个《泡泡堂》高手，拥有着近乎完美的战绩。他擅长很多地图，例如“小区10”、“海盗14”、“大海02”等等，不过他最喜欢的地图是“赛车”。\n\n在赛车地图中，每个玩家将得到一辆赛车，从起点出发，比赛谁最先到达终点。\n", "description": "在地图中，包括有障碍、加油站、赛车跑道与沙地。障碍不可通过，并且赛车在赛车跑道与沙地上的行进速度是不一样的。\n\n现在我们来考虑一个简化版的赛车游戏。在这个简化版本的赛车游戏中：\n\n* 比赛在一个无限大的沙地平面上举行。\n\n* 赛道是一个从原点出发、由$n$条线段首尾相接组成的折线。\n\n* 出于安全考虑，赛道不会自交（即折线中的任何两条线段，相邻两条线段有且仅有一个公共点，其他任意两条线段均无公共点）。\n\n* 赛车在赛道上的速度为$v_a$，在沙地上的速度为$v_b$，且满足 $v_a\\geq v_b$。\n\n* 为了增加比赛的挑战性，在赛道上逆向行驶是允许的。\n\n布布是一个操作非常精确的选手，他总能按照预想的道路行进至终点，但是他不知道哪个才是最快的路线，聪明的你，能帮助他么？", "inputFormat": "输入文件racing.in的第1行包含一个整数$n$，表示赛道一共有$n$段；第2行包含两个实数$v_a$与$v_b$，分别表示赛车在赛道上与沙地中的行进速度。\n\n接下来的$n$行，每行包含两个整数$x_i$与$y_i$，依次表示赛道的每一个转折点。即赛道的第一个线段是$(0,0)\\rightarrow (x_1 , y_1)$，第二条线段是$(x_1 , y_1)\\rightarrow ( x_2 , y_2)$，依次类推。其中$(x_n , y_n)$为终点。", "outputFormat": "输出文件racing.out仅包含一个实数，表示从起点到终点最少所需时间。精确到小数点后6位。", "hint": "【评分标准】\n\n每一组数据单独评分，对于每一组数据，你的得分按照如下公式计算：\n\n$$YourScore=\\begin{cases}10 &  |YourAnswer-OurAnswer|\\leq 0.0001\\\\  5  & |YourAnswer-OurAnswer|\\leq 0.01 \\\\ 0 &    Otherwise \\end{cases}$$\n\n【数据规模】\n\n对于20%的数据，赛道的折线段平行于坐标轴。\n\n对于40%的数据，$n\\leq 50$ 。\n\n对于100%的数据，$n\\leq 1000$ ，$1\\leq v_b\\leq v_a\\leq 20 $。\n\n所有的坐标都在$[-10^6 , 10^6]$内。\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2007] Crazy Racing", "background": "Bubu is a master of “Paopaotang” (pinyin), with an almost perfect record. He excels on many maps, such as “小区10”, “海盗14”, “大海02”, etc., but his favorite map is “赛车”.\n\nOn the racing map, each player gets a car, starts from the origin, and competes to reach the finish line first.", "description": "The map contains obstacles, gas stations, race track, and sand. Obstacles are impassable, and the car’s speed differs between the race track and the sand.\n\nNow we consider a simplified racing game. In this simplified version:\n\n- The race takes place on an infinite sandy plane.\n- The track is a polyline starting from the origin, composed of $n$ connected segments.\n- For safety, the track does not self-intersect (i.e., in the polyline, adjacent segments share exactly one common point, and any other pair of segments has no common point).\n- The car’s speed on the track is $v_a$, and on the sand is $v_b$, with $v_a \\geq v_b$.\n- To increase the challenge, driving in the reverse direction along the track is allowed.\n\nBubu is extremely precise and can always follow the intended path to the finish, but he does not know which route is the fastest. Can you help him?", "inputFormat": "The first line of the input file racing.in contains an integer $n$, the number of segments in the track. The second line contains two real numbers $v_a$ and $v_b$, representing the car’s speed on the track and on the sand, respectively.\n\nThe next $n$ lines each contain two integers $x_i$ and $y_i$, giving each turning point of the track in order. That is, the first segment of the track is $(0,0)\\rightarrow (x_1 , y_1)$, the second segment is $(x_1 , y_1)\\rightarrow ( x_2 , y_2)$, and so on. Here $(x_n , y_n)$ is the finish point.", "outputFormat": "The output file racing.out contains a single real number, the minimum time required to go from the start to the finish. Print to 6 decimal places.", "hint": "Scoring:\n\n$$YourScore=\\begin{cases}10 &  |YourAnswer-OurAnswer|\\leq 0.0001\\\\  5  & |YourAnswer-OurAnswer|\\leq 0.01 \\\\ 0 &    Otherwise \\end{cases}$$\n\nConstraints:\n\n- For 20% of the testdata, the polyline segments of the track are parallel to the coordinate axes.\n- For 40% of the testdata, $n \\leq 50$.\n- For 100% of the testdata, $n \\leq 1000$, $1 \\leq v_b \\leq v_a \\leq 20$.\n- All coordinates are within $[-10^6 , 10^6]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2007] 疯狂赛车", "background": "布布是一个《泡泡堂》高手，拥有着近乎完美的战绩。他擅长很多地图，例如“小区10”、“海盗14”、“大海02”等等，不过他最喜欢的地图是“赛车”。\n\n在赛车地图中，每个玩家将得到一辆赛车，从起点出发，比赛谁最先到达终点。\n", "description": "在地图中，包括有障碍、加油站、赛车跑道与沙地。障碍不可通过，并且赛车在赛车跑道与沙地上的行进速度是不一样的。\n\n现在我们来考虑一个简化版的赛车游戏。在这个简化版本的赛车游戏中：\n\n* 比赛在一个无限大的沙地平面上举行。\n\n* 赛道是一个从原点出发、由$n$条线段首尾相接组成的折线。\n\n* 出于安全考虑，赛道不会自交（即折线中的任何两条线段，相邻两条线段有且仅有一个公共点，其他任意两条线段均无公共点）。\n\n* 赛车在赛道上的速度为$v_a$，在沙地上的速度为$v_b$，且满足 $v_a\\geq v_b$。\n\n* 为了增加比赛的挑战性，在赛道上逆向行驶是允许的。\n\n布布是一个操作非常精确的选手，他总能按照预想的道路行进至终点，但是他不知道哪个才是最快的路线，聪明的你，能帮助他么？", "inputFormat": "输入文件racing.in的第1行包含一个整数$n$，表示赛道一共有$n$段；第2行包含两个实数$v_a$与$v_b$，分别表示赛车在赛道上与沙地中的行进速度。\n\n接下来的$n$行，每行包含两个整数$x_i$与$y_i$，依次表示赛道的每一个转折点。即赛道的第一个线段是$(0,0)\\rightarrow (x_1 , y_1)$，第二条线段是$(x_1 , y_1)\\rightarrow ( x_2 , y_2)$，依次类推。其中$(x_n , y_n)$为终点。", "outputFormat": "输出文件racing.out仅包含一个实数，表示从起点到终点最少所需时间。精确到小数点后6位。", "hint": "【评分标准】\n\n每一组数据单独评分，对于每一组数据，你的得分按照如下公式计算：\n\n$$YourScore=\\begin{cases}10 &  |YourAnswer-OurAnswer|\\leq 0.0001\\\\  5  & |YourAnswer-OurAnswer|\\leq 0.01 \\\\ 0 &    Otherwise \\end{cases}$$\n\n【数据规模】\n\n对于20%的数据，赛道的折线段平行于坐标轴。\n\n对于40%的数据，$n\\leq 50$ 。\n\n对于100%的数据，$n\\leq 1000$ ，$1\\leq v_b\\leq v_a\\leq 20 $。\n\n所有的坐标都在$[-10^6 , 10^6]$内。\n", "locale": "zh-CN"}}}
{"pid": "P4499", "type": "P", "difficulty": 7, "samples": [["3 1 3\n1 2 4\n1 2 5\n2 3 3\n3 3 1", "1.00"], ["1 1 1\n1 1 100\n1 1 1", "10.00"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "CTSC/CTS"], "title": "[CTSC2011] 无穷图的桥", "background": null, "description": "本题的目标是求一个点数无穷的无向图的桥。\n\n这个无向图具有如下性质：\n\n1. 这个图是一个连通图。\n\n2. 这个图的所有节点分为若干层，分别是第 $1$ 层、第 $2$ 层、第 $3$ 层 $\\cdots$ 共有无穷层，每层共有 $n$ 个节点。为了描述方便，以下用 $\\left(i, x\\right)$ 表示第 $i$ 层的 $x$ 号节点。\n\n3. 同一层内的节点可以相互连边，相邻两层的节点之间可以相互连边，除此之外，其他节点之间不能相互连边。\n\n4. 如果 $\\left(i, x\\right)$ 与 $\\left(i, y\\right)$ 之间有一条权值为 $d$ 的边，那么 $\\left(j, x\\right)$ 与 $\\left(j, y\\right)$ 之间也有一条边，它的权值为 $0.9^{j-i}d$，其中 $j$ 为任意正整数。\n\n5. 如果 $\\left(i, x\\right)$ 与 $\\left(i + 1, y\\right)$ 之间有一条权值为 $d$ 的边，那么 $\\left(j, x\\right)$ 与 $\\left(j+1, y\\right)$ 之间也有一条边，它的权值为 $0.9^{j-i}d$，其中 $j$ 为任意正整数。如下所示的无向图就符合上面的所有性质。\n\n\n一个点数无穷的无向图是连通的，当且仅当对于图中的任意两个节点都存在一条路径将它们连接起来。而一条边是桥，当且仅当这条边被删去后整个图不连通。\n\n![](https://cdn.luogu.com.cn/upload/pic/18051.png )\n\n请你编写程序读入这个点数无穷的连通图，求出其中所有桥的权值之和。例如，在上图中，粗线所示的边就是该图唯一的桥，因此上图中桥的权值之和为 $1$。", "inputFormat": "输入文件 infinite.in 第一行包括三个由空格隔开的非负数 $n$、$m_1$、$m_2$。从第 $2$ 行到第 $m_1+ 1$ 行，每行有三个正整数 $x$、$y$、$d$，表示 $\\left(1, x\\right)$ 与 $\\left(1, y\\right)$ 之间有一条权值为 $d$ 的边。\n\n从第 $m_1+ 2$ 行到第 $m_1+ m_2+ 1$ 行，每行有三个正整数 $x$、$y$、$d$，表示 $\\left(1, x\\right)$ 与 $\\left(2, y\\right)$ 之间有一条权值为 $d$ 的边。每行的三个整数之间都用一个空格隔开。\n\n图中两个点 $x$ 和 $y$ 之间可能有多于 $1$ 条边连接，一条边连接的两个节点可能相同。", "outputFormat": "输出文件 infinite.out 只有一行，包含一个实数，即所有桥的权值之和，四舍五入保留两位小数。", "hint": "## 【样例说明 1】\n\n这就是问题描述中所举的例子。\n\n## 【数据规模】\n\n::cute-table{tuack}\n\n| 数据编号 | $n$ | $m_1$ | $m_2$ |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| 1 | $\\leq10$ | $\\leq50$ | $\\leq50$ |\n| 2 | $\\leq10000$ | $\\leq40000$ | $\\leq40000$ |\n| 3 | $\\leq3 \\times 10^5$ | $\\leq5 \\times 10^5$ | $=1$ |\n| 4~7 | ^ | ^ | $\\leq500$ |\n| 8~10 | ^ | ^ | $\\leq500000$ |\n\n100% 的数据中，$d\\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2011] Bridges of the Infinite Graph", "background": "", "description": "The goal is to find all bridges in an undirected graph with infinitely many nodes.\n\nThis undirected graph has the following properties:\n1. The graph is connected.\n2. All nodes are partitioned into infinitely many layers: layer $1$, layer $2$, layer $3$, $\\cdots$, with $n$ nodes in each layer. For convenience, we denote the $x$-th node in layer $i$ by $(i, x)$.\n3. Edges are allowed between nodes within the same layer, and between nodes in adjacent layers. No other edges are allowed.\n4. If there is an edge of weight $d$ between $(i, x)$ and $(i, y)$, then for any positive integer $j$, there is also an edge between $(j, x)$ and $(j, y)$ with weight $0.9^{j-i} d$, where $j$ is any positive integer.\n5. If there is an edge of weight $d$ between $(i, x)$ and $(i + 1, y)$, then for any positive integer $j$, there is also an edge between $(j, x)$ and $(j + 1, y)$ with weight $0.9^{j-i} d$, where $j$ is any positive integer. The undirected graph shown below satisfies all the properties above.\n\nAn undirected graph with infinitely many nodes is connected if and only if there exists a path between any pair of nodes in the graph. An edge is a bridge if and only if removing it makes the entire graph disconnected.\n\n![](https://cdn.luogu.com.cn/upload/pic/18051.png)\n\nPlease write a program to read this connected infinite graph and compute the sum of weights of all its bridges. For example, in the figure above, the bold edge is the unique bridge, so the sum of weights of bridges is $1$.", "inputFormat": "The input file infinite.in contains three space-separated non-negative integers on the first line: $n$, $m_1$, and $m_2$.  \nFrom line $2$ to line $m_1 + 1$, each line contains three positive integers $x$, $y$, and $d$, indicating that there is an edge of weight $d$ between $(1, x)$ and $(1, y)$.\n\nFrom line $m_1 + 2$ to line $m_1 + m_2 + 1$, each line contains three positive integers $x$, $y$, and $d$, indicating that there is an edge of weight $d$ between $(1, x)$ and $(2, y)$. Each line’s three integers are separated by a single space.\n\nThere may be more than one edge between nodes $x$ and $y$. Self-loops are allowed.", "outputFormat": "The output file infinite.out contains exactly one line with a real number: the sum of weights of all bridges, rounded to two decimal places.", "hint": "[Sample Explanation 1]  \nThis is the same as the example given in the problem statement.\n\nConstraints\n|||||\n| :----------- | :----------- | :----------- | :----------- |\n| Data ID | $n$ | $m_1$ | $m_2$ |\n| 1 | $\\leq 10$ | $\\leq 50$ | $\\leq 50$ |\n| 2 | $\\leq 10000$ | $\\leq 40000$ | $\\leq 40000$ |\n| 3 | $\\leq 300000$ | $\\leq 500000$ | $=1$ |\n| 4~7 | $\\leq 300000$ | $\\leq 500000$ | $\\leq 500$ |\n| 8~10 | $\\leq 300000$ | $\\leq 500000$ | $\\leq 500000$ |\n\nIn 100% of the testdata, $d \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2011] 无穷图的桥", "background": null, "description": "本题的目标是求一个点数无穷的无向图的桥。\n\n这个无向图具有如下性质：\n\n1. 这个图是一个连通图。\n\n2. 这个图的所有节点分为若干层，分别是第 $1$ 层、第 $2$ 层、第 $3$ 层 $\\cdots$ 共有无穷层，每层共有 $n$ 个节点。为了描述方便，以下用 $\\left(i, x\\right)$ 表示第 $i$ 层的 $x$ 号节点。\n\n3. 同一层内的节点可以相互连边，相邻两层的节点之间可以相互连边，除此之外，其他节点之间不能相互连边。\n\n4. 如果 $\\left(i, x\\right)$ 与 $\\left(i, y\\right)$ 之间有一条权值为 $d$ 的边，那么 $\\left(j, x\\right)$ 与 $\\left(j, y\\right)$ 之间也有一条边，它的权值为 $0.9^{j-i}d$，其中 $j$ 为任意正整数。\n\n5. 如果 $\\left(i, x\\right)$ 与 $\\left(i + 1, y\\right)$ 之间有一条权值为 $d$ 的边，那么 $\\left(j, x\\right)$ 与 $\\left(j+1, y\\right)$ 之间也有一条边，它的权值为 $0.9^{j-i}d$，其中 $j$ 为任意正整数。如下所示的无向图就符合上面的所有性质。\n\n\n一个点数无穷的无向图是连通的，当且仅当对于图中的任意两个节点都存在一条路径将它们连接起来。而一条边是桥，当且仅当这条边被删去后整个图不连通。\n\n![](https://cdn.luogu.com.cn/upload/pic/18051.png )\n\n请你编写程序读入这个点数无穷的连通图，求出其中所有桥的权值之和。例如，在上图中，粗线所示的边就是该图唯一的桥，因此上图中桥的权值之和为 $1$。", "inputFormat": "输入文件 infinite.in 第一行包括三个由空格隔开的非负数 $n$、$m_1$、$m_2$。从第 $2$ 行到第 $m_1+ 1$ 行，每行有三个正整数 $x$、$y$、$d$，表示 $\\left(1, x\\right)$ 与 $\\left(1, y\\right)$ 之间有一条权值为 $d$ 的边。\n\n从第 $m_1+ 2$ 行到第 $m_1+ m_2+ 1$ 行，每行有三个正整数 $x$、$y$、$d$，表示 $\\left(1, x\\right)$ 与 $\\left(2, y\\right)$ 之间有一条权值为 $d$ 的边。每行的三个整数之间都用一个空格隔开。\n\n图中两个点 $x$ 和 $y$ 之间可能有多于 $1$ 条边连接，一条边连接的两个节点可能相同。", "outputFormat": "输出文件 infinite.out 只有一行，包含一个实数，即所有桥的权值之和，四舍五入保留两位小数。", "hint": "## 【样例说明 1】\n\n这就是问题描述中所举的例子。\n\n## 【数据规模】\n\n::cute-table{tuack}\n\n| 数据编号 | $n$ | $m_1$ | $m_2$ |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| 1 | $\\leq10$ | $\\leq50$ | $\\leq50$ |\n| 2 | $\\leq10000$ | $\\leq40000$ | $\\leq40000$ |\n| 3 | $\\leq3 \\times 10^5$ | $\\leq5 \\times 10^5$ | $=1$ |\n| 4~7 | ^ | ^ | $\\leq500$ |\n| 8~10 | ^ | ^ | $\\leq500000$ |\n\n100% 的数据中，$d\\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P4500", "type": "P", "difficulty": 7, "samples": [["2 2 998244353\n", "1"], ["3 2 998244353", "499122177"], ["4 2 998244353", "332748118"], ["10 2 998244353", "113919852"], ["50 233 998244353", "634280054"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "各省省选", "浙江"], "title": "[ZJOI2018] 树", "background": "", "description": "九条可怜是一个热爱出题的女孩子。\n\n虽然出题本身是一件非常有趣的事情，但是要把题目给出成正式比赛,就不是那么有趣了：造数据总是一件让人心力憔悴的事情。\n\n在 ZJOI2018 Day 1 中，可怜出了一道和树相关的非常有趣的题，她打算采用一种常用的方式随机生成一棵 $n$ 个节点的有根树：\n\n- 节点 1 作为树的根。\n- 对于 $i \\in [2, n]$ ，独立地从 $[1, i)$ 中等概率随机选取一个节点作为 $i$ 的父亲。\n\n可怜不是很想考虑这样随机出来的数据能不能卡掉暴力,毕竟乱搞也是 OI 比赛的一部分。\n\n可怜比较在意的是题目的区分度，以及是不是所有可能的分数都出现了。因此，可怜希望任何两个测试点的树是有区别的：这样就可能会有错误的程序能只通过其中一个点。\n\n因此，可怜想要计算，通过上面的方法独立的随机生成 $k$ 棵 $n$ 个节点的有根树 $T_1$ 至 $T_k$ ，他们两两同构的概率是多少。\n\n两棵 $n$ 个节点的有根树 $T_1$ 和 $T_2$ 同构当且仅当存在长度为 $n$ 的排列 $p$，满足 $p_1 = 1$ ，且对于 $\\forall i \\in [2, n]$ ，若 $i$ 在 $T_1$ 的父亲是 $f$ ，则 $p_i$ 在 $T_2$ 的父亲是 $p_f$ 。", "inputFormat": "第一行输入三个整数 $n, k, p$，表示节点个数，树的个数以及模数。输入保证 $10^8 \\leq p \\leq 10^9$ 且 $p$ 是质数。", "outputFormat": "输出一行一个整数，表示答案对 $p$ 取模后的值。即如果答案的最简分数表示为 $\\frac{a}{b}$ ，输出 $a \\times b ^{-1} \\bmod p$。\n", "hint": "### 样例解释\n\n在第一组数据中，能够生成的树是唯一的,因此生成的两棵树必定相同。\n\n在第二组数据中，能够生成的树只有两种,他们是不同构的。因此生成的两棵树同构的概率为 $\\frac{1}{2}$ ，在模 998244353 意义下为 499122177。\n\n在第三组数据中，能够生成的树有 6 种,如下图所示。其中第二、三、四棵(第一排中间三棵)是同构的,其余两两不同构。因此生成的两棵树同构的概率为 $\\frac{1}{3}$ ，在模998244353 意义下为 332748118。\n\n![](https://cdn.luogu.com.cn/upload/pic/18417.png)\n\n\n### 数据范围\n\n测试点|　$n$|　$k$|测试点|　$n$|　$k$\n-|-|-|-|-|-\n1|$\\le 5$|$=2$|6|$\\le 50$|$\\le 10^9$\n2|$\\le 10$|$=2$|7|$\\le 200$|$\\le 10^9$\n3|$\\le 20$|$=2$|8|$\\le 500$|$\\le 10^9$\n4|$\\le 50$|$=2$|9|$\\le 1000$|$\\le 10^9$\n5|$\\le 50$|$=2$|10|$\\le 2000$|$\\le 10^9$\n\n对于 100% 的数据,保证 $p$ 是质数且 $10^8 \\le p \\le 10^9 $。\n\n感谢 @Xeonacid 提供题面", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2018] Tree", "background": "", "description": "Jiutiao Kelian (pinyin) is a girl who loves to write problems.\n\nAlthough writing problems itself is very interesting, turning a problem into an official contest task is not so fun: generating testdata is always exhausting.\n\nIn ZJOI 2018 Day 1, Kelian set a very interesting problem about trees. She plans to use a common method to randomly generate a rooted tree with $n$ nodes:\n\n- Node $1$ is the root of the tree.\n- For $i \\in [2, n]$, independently and uniformly at random pick a node from $[1, i)$ as the parent of $i$.\n\nKelian does not really want to think about whether such randomly generated testdata can defeat brute force, since hacking around is also part of OI contests.\n\nWhat Kelian cares about more is the problem's discriminative power, and whether all possible scores appear. Therefore, she hopes that the trees in any two test points are different, so that an incorrect program might pass only one of them.\n\nThus, Kelian wants to compute the probability that, by independently generating $k$ rooted trees with $n$ nodes $T_1$ to $T_k$ using the method above, they are pairwise isomorphic.\n\nTwo rooted trees $T_1$ and $T_2$ with $n$ nodes are isomorphic if and only if there exists a permutation $p$ of length $n$, satisfying $p_1 = 1$, and for all $i \\in [2, n]$, if the parent of $i$ in $T_1$ is $f$, then the parent of $p_i$ in $T_2$ is $p_f$.", "inputFormat": "The first line contains three integers $n, k, p$, denoting the number of nodes, the number of trees, and the modulus. It is guaranteed that $10^8 \\leq p \\leq 10^9$ and $p$ is prime.", "outputFormat": "Output a single integer, the answer modulo $p$. That is, if the answer in lowest terms is $\\frac{a}{b}$, output $a \\times b ^{-1} \\bmod p$.", "hint": "Sample Explanation\n\nIn the first sample, the generated tree is unique, so the two generated trees are necessarily identical.\n\nIn the second sample, there are only two possible generated trees, and they are non-isomorphic. Therefore, the probability that the two generated trees are isomorphic is $\\frac{1}{2}$, which is $499122177$ modulo $998244353$.\n\nIn the third sample, there are $6$ possible generated trees, as shown below. Among them, the second, third, and fourth (the middle three in the first row) are isomorphic, and the remaining ones are pairwise non-isomorphic. Therefore, the probability that the two generated trees are isomorphic is $\\frac{1}{3}$, which is $332748118$ modulo $998244353$.\n\n![](https://cdn.luogu.com.cn/upload/pic/18417.png)\n\nConstraints\n\n测试点| $n$| $k$|测试点| $n$| $k$\n-|-|-|-|-|-\n1|$\\le 5$|$=2$|6|$\\le 50$|$\\le 10^9$\n2|$\\le 10$|$=2$|7|$\\le 200$|$\\le 10^9$\n3|$\\le 20$|$=2$|8|$\\le 500$|$\\le 10^9$\n4|$\\le 50$|$=2$|9|$\\le 1000$|$\\le 10^9$\n5|$\\le 50$|$=2$|10|$\\le 2000$|$\\le 10^9$\n\nFor $100\\%$ of the testdata, it is guaranteed that $p$ is prime and $10^8 \\le p \\le 10^9$.\n\nThanks to @Xeonacid for providing the statement.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2018] 树", "background": "", "description": "九条可怜是一个热爱出题的女孩子。\n\n虽然出题本身是一件非常有趣的事情，但是要把题目给出成正式比赛,就不是那么有趣了：造数据总是一件让人心力憔悴的事情。\n\n在 ZJOI2018 Day 1 中，可怜出了一道和树相关的非常有趣的题，她打算采用一种常用的方式随机生成一棵 $n$ 个节点的有根树：\n\n- 节点 1 作为树的根。\n- 对于 $i \\in [2, n]$ ，独立地从 $[1, i)$ 中等概率随机选取一个节点作为 $i$ 的父亲。\n\n可怜不是很想考虑这样随机出来的数据能不能卡掉暴力,毕竟乱搞也是 OI 比赛的一部分。\n\n可怜比较在意的是题目的区分度，以及是不是所有可能的分数都出现了。因此，可怜希望任何两个测试点的树是有区别的：这样就可能会有错误的程序能只通过其中一个点。\n\n因此，可怜想要计算，通过上面的方法独立的随机生成 $k$ 棵 $n$ 个节点的有根树 $T_1$ 至 $T_k$ ，他们两两同构的概率是多少。\n\n两棵 $n$ 个节点的有根树 $T_1$ 和 $T_2$ 同构当且仅当存在长度为 $n$ 的排列 $p$，满足 $p_1 = 1$ ，且对于 $\\forall i \\in [2, n]$ ，若 $i$ 在 $T_1$ 的父亲是 $f$ ，则 $p_i$ 在 $T_2$ 的父亲是 $p_f$ 。", "inputFormat": "第一行输入三个整数 $n, k, p$，表示节点个数，树的个数以及模数。输入保证 $10^8 \\leq p \\leq 10^9$ 且 $p$ 是质数。", "outputFormat": "输出一行一个整数，表示答案对 $p$ 取模后的值。即如果答案的最简分数表示为 $\\frac{a}{b}$ ，输出 $a \\times b ^{-1} \\bmod p$。\n", "hint": "### 样例解释\n\n在第一组数据中，能够生成的树是唯一的,因此生成的两棵树必定相同。\n\n在第二组数据中，能够生成的树只有两种,他们是不同构的。因此生成的两棵树同构的概率为 $\\frac{1}{2}$ ，在模 998244353 意义下为 499122177。\n\n在第三组数据中，能够生成的树有 6 种,如下图所示。其中第二、三、四棵(第一排中间三棵)是同构的,其余两两不同构。因此生成的两棵树同构的概率为 $\\frac{1}{3}$ ，在模998244353 意义下为 332748118。\n\n![](https://cdn.luogu.com.cn/upload/pic/18417.png)\n\n\n### 数据范围\n\n测试点|　$n$|　$k$|测试点|　$n$|　$k$\n-|-|-|-|-|-\n1|$\\le 5$|$=2$|6|$\\le 50$|$\\le 10^9$\n2|$\\le 10$|$=2$|7|$\\le 200$|$\\le 10^9$\n3|$\\le 20$|$=2$|8|$\\le 500$|$\\le 10^9$\n4|$\\le 50$|$=2$|9|$\\le 1000$|$\\le 10^9$\n5|$\\le 50$|$=2$|10|$\\le 2000$|$\\le 10^9$\n\n对于 100% 的数据,保证 $p$ 是质数且 $10^8 \\le p \\le 10^9 $。\n\n感谢 @Xeonacid 提供题面", "locale": "zh-CN"}}}
{"pid": "P4501", "type": "P", "difficulty": 6, "samples": [["5 5\n2 3 1 4\n1 2 2\n2 1 1 4 10\n3 1 1 3 1 5 1\n3 1 10 2 100 5 1\n5 1 1 2 1 3 1 4 1 5 1", "5\n8\n5\n8\n5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "线段树", "二分", "各省省选", "浙江", "ST 表"], "title": "[ZJOI2018] 胖", "background": "Cedyks 是九条可怜的好朋友（可能这场比赛公开以后就不是了），也是这题的主人公。", "description": "Cedyks 是一个富有的男孩子。他住在著名的 The Place（宫殿）中。\n\nCedyks 是一个努力的男孩子。他每天都做着不一样的题来锻炼他的 The Salt（灵魂）。\n\n这天，他打算在他的宫殿外围修筑一道城墙，城墙上有 $n$ 座瞭望塔。你可以把城墙看做一条线段，瞭望塔是线段上的 $n$ 个点，其中 $1$ 和 $n$ 分别为城墙的两个端点。其中第 $i$ 座瞭望塔和第 $i + 1$ 座瞭望塔的距离为 $w_i$，他们之间的道路是双向的。\n\n城墙很快就修建好了，现在 Cedyks 开始计划修筑他的宫殿到城墙的道路。因为这题的题目名称，Cedyks 打算用他的宫殿到每一个瞭望塔的最短道路之和来衡量一个修建计划。\n\n现在 Cedyks 手上有 $m$ 个设计方案，第 $k$ 个设计方案会在宫殿和瞭望塔之间修建 $T_k$ 条双向道路，第 $i$ 条道路连接着瞭望塔 $a_i$，长度为 $l_i$。\n\n计算到每一个瞭望塔的最短路之和是一个繁重的工程，本来 Cedyks 想用广为流传的 SPFA 算法来求解，但是因为他的 butter（缓冲区）实在是太小了，他只能转而用原始的贝尔福特曼算法来计算，算法的流程大概如下：\n\n1. 定义宫殿是 $0$ 号点，第 $i$ 个瞭望塔是 $i$ 号点，双向边 $(u_i, v_i, l_i)$ 为一条连接 $u_i$ 和 $v_i$ 的双向道路。令 $d$ 为距离数组，最开始 $d_0 = 0, d_i = 10^{18}(i ∈ [1, n])$。\n2. 令辅助数组 $c = d$。依次对于每一条边 $(u_i, v_i,w_i)$ 进行增广，$c_{u_i} = \\min(c_{u_i} , d_{v_i} + w_i)$，$c_{v_i} = \\min(c_{v_i} , d_{u_i} + w_i)$。\n3. 令 $t$ 为 $c$ 和 $d$ 中不一样的位置个数，即令 $S = \\{i|c_i≠d_i\\}$，则 $t = |S|$。若 $t = 0$，说明 $d$ 就是最终的最短路，算法结束。否则令 $d = c$，回到第二步。\n\n因为需要计算的设计方案实在是太多了，所以 Cedyks 雇佣了一些人来帮他进行计算。为了避免这些人用捏造出来的数据偷懒，他定义一个设计方案的校验值为在这个方案上运行贝尔福特曼算法每一次进入第三步 $t$ 的和。他会让好几个雇佣来的人计算同样的设计方案，并比对每一个人给出的校验值。\n\n你是 Cedyks 雇佣来的苦力之一，聪明的你发现在这个情形下计算最短路的长度的和是一件非常简单的事情。但是寄人篱下不得不低头，你不得不再计算出每一个方案的校验值来交差。", "inputFormat": "第一行输入两个整数 $n,m$，表示瞭望塔个数和设计方案个数。\n\n接下来一行 $n - 1$ 个数 $w_i$，表示瞭望塔 $i$ 和 $i + 1$ 之间道路的长度。\n\n接下来 $m$ 行，每行描述一个设计方案。第一个整数 $K$ 表示设计方案中的道路数量，接下来 $K$ 个数对 $(a_i, l_i)$ 为一条宫殿到瞭望塔的边。", "outputFormat": "对于每一个设计方案，输出一行一个整数表示校验值。", "hint": "### 样例解释\n\n对于第一个设计方案，每一个阶段 $d$ 的变化为：\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,10^{18},2,10^{18},10^{18},10^{18}] \\rightarrow$ $[0,4,2,5,10^{18},10^{18}] \\rightarrow [0,4,2,5,6,10^{18}] \\rightarrow [0,4,2,5,6,10]$。\n\n因此校验值为 $1+2+1+1=5$。\n\n对于第二个设计方案，每一个阶段 $d$ 的变化为：\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,1,10^{18},10^{18},10,10^{18}] \\rightarrow$ $[0,1,3,11,10,14] \\rightarrow [0,1,3,6,10,14] \\rightarrow [0,1,3,6,7,14] \\rightarrow [0,1,3,6,7,11]$。\n\n因此校验值为 $2+3+1+1+1=8$。\n\n对于第三个设计方案，每一个阶段 $d$ 的变化为：\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,1,10^{18},1,10^{18},1] \\rightarrow [0,1,3,1,2,1]$。\n\n因此校验值为 $3+1+1=5$。\n\n对于第四个设计方案，每一个阶段 $d$ 的变化为：\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,10,100,10^{18},10^{18},1] \\rightarrow$ $[0,10,12,103,5,1] \\rightarrow [0,10,12,6,5,1] \\rightarrow [0,10,9,5,1]$。\n\n因此校验值为 $3+3+1+1=8$。\n\n对于第五个设计方案，每一个阶段 $d$ 的变化为：\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,1,1,1,1,1]$\n\n因此校验值为 $5$。\n\n### 数据范围\n\n测试点|$n$|$m$|$K$|其他约定\n-|-|-|-|-\n1,2|$\\le 1000$|$\\le 1000$|$\\le 100$|无\n3,4|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$\\le 100$|无\n5,6|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$1 \\le w_i,l_i \\le 50$\n7,8,9,10|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|无\n\n\n对于 $100\\%$ 的数据，保证每个设计方案 $a_i$ 两两不同且 $1\\le a_i\\le n$。  \n对于 $100\\%$ 的数据，保证 $1\\le w_i,l_i\\le 10^9,1\\le\\sum K\\le 2\\times 10^5$。\n\n感谢 @Xeonacid 提供题面", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2018] Fat", "background": "Cedyks is the good friend of nine pitiful people (maybe not after this contest becomes public), and also the main character of this problem.", "description": "Cedyks is a rich boy. He lives in the famous The Place (palace).\n\nCedyks is a hard-working boy. Every day he solves different problems to train his The Salt (soul).\n\nOne day, he plans to build a wall around his palace. There are $n$ watchtowers on the wall. You can regard the wall as a line segment, and the watchtowers as $n$ points on the segment, where $1$ and $n$ are the two endpoints of the wall. The distance between watchtower $i$ and watchtower $i + 1$ is $w_i$, and the road between them is bidirectional.\n\nThe wall is built soon. Now Cedyks starts planning the roads from his palace to the wall. Because of the problem title, Cedyks decides to measure a construction plan by the sum of the shortest path lengths from his palace to every watchtower.\n\nNow Cedyks has $m$ design plans. In the $k$-th plan, $T_k$ bidirectional roads will be built between the palace and the watchtowers. The $i$-th road connects to watchtower $a_i$ and has length $l_i$.\n\nComputing the sum of shortest paths to every watchtower is heavy work. Originally, Cedyks wanted to use the well-known SPFA algorithm, but because his butter (buffer) is too small, he has to use the primitive Bellman-Ford algorithm instead. The process is roughly as follows:\n\n1. Define the palace as node $0$, and the $i$-th watchtower as node $i$. A bidirectional edge $(u_i, v_i, l_i)$ is a bidirectional road connecting $u_i$ and $v_i$. Let $d$ be the distance array. Initially, $d_0 = 0, d_i = 10^{18}(i ∈ [1, n])$.\n2. Let the auxiliary array $c = d$. For each edge $(u_i, v_i, w_i)$ in order, relax it: $c_{u_i} = \\min(c_{u_i} , d_{v_i} + w_i)$, $c_{v_i} = \\min(c_{v_i} , d_{u_i} + w_i)$.\n3. Let $t$ be the number of positions where $c$ and $d$ differ. That is, let $S = \\{i|c_i≠d_i\\}$, then $t = |S|$. If $t = 0$, it means $d$ is the final shortest path result, and the algorithm ends. Otherwise, set $d = c$ and go back to step 2.\n\nBecause there are too many design plans to compute, Cedyks hires some people to help. To prevent them from slacking off with made-up data, he defines the checksum value of a design plan as the sum of $t$ every time the Bellman-Ford algorithm enters step 3 when running on this plan. He will ask several hired people to compute the same plan and compare the checksum values they provide.\n\nYou are one of the laborers hired by Cedyks. Being smart, you find that in this situation, computing the sum of shortest path lengths is very easy. However, since you have to obey, you still need to compute the checksum value for each plan to report.", "inputFormat": "The first line contains two integers $n,m$, representing the number of watchtowers and the number of design plans.\n\nThe next line contains $n - 1$ numbers $w_i$, representing the length of the road between watchtower $i$ and watchtower $i + 1$.\n\nThen follow $m$ lines, each describing a design plan. The first integer $K$ is the number of roads in the plan. Then follow $K$ pairs $(a_i, l_i)$, each representing an edge from the palace to watchtower $a_i$ with length $l_i$.", "outputFormat": "For each design plan, output one line with one integer, representing the checksum value.", "hint": "### Sample Explanation\n\nFor the first design plan, the changes of $d$ at each stage are:\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,10^{18},2,10^{18},10^{18},10^{18}] \\rightarrow$ $[0,4,2,5,10^{18},10^{18}] \\rightarrow [0,4,2,5,6,10^{18}] \\rightarrow [0,4,2,5,6,10]$.\n\nSo the checksum value is $1+2+1+1=5$.\n\nFor the second design plan, the changes of $d$ at each stage are:\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,1,10^{18},10^{18},10,10^{18}] \\rightarrow$ $[0,1,3,11,10,14] \\rightarrow [0,1,3,6,10,14] \\rightarrow [0,1,3,6,7,14] \\rightarrow [0,1,3,6,7,11]$.\n\nSo the checksum value is $2+3+1+1+1=8$.\n\nFor the third design plan, the changes of $d$ at each stage are:\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,1,10^{18},1,10^{18},1] \\rightarrow [0,1,3,1,2,1]$。\n\nSo the checksum value is $3+1+1=5$.\n\nFor the fourth design plan, the changes of $d$ at each stage are:\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,10,100,10^{18},10^{18},1] \\rightarrow$ $[0,10,12,103,5,1] \\rightarrow [0,10,12,6,5,1] \\rightarrow [0,10,9,5,1]$。\n\nSo the checksum value is $3+3+1+1=8$.\n\nFor the fifth design plan, the changes of $d$ at each stage are:\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,1,1,1,1,1]$\n\nSo the checksum value is $5$.\n\n### Constraints\n\nTest point|$n$|$m$|$K$|Other constraints\n-|-|-|-|-\n1,2|$\\le 1000$|$\\le 1000$|$\\le 100$|None\n3,4|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$\\le 100$|None\n5,6|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$1 \\le w_i,l_i \\le 50$\n7,8,9,10|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|None\n\nFor $100\\%$ of the testdata, it is guaranteed that within each design plan, all $a_i$ are pairwise distinct and $1\\le a_i\\le n$.  \nFor $100\\%$ of the testdata, it is guaranteed that $1\\le w_i,l_i\\le 10^9,1\\le\\sum K\\le 2\\times 10^5$.\n\nThanks to @Xeonacid for providing the statement.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2018] 胖", "background": "Cedyks 是九条可怜的好朋友（可能这场比赛公开以后就不是了），也是这题的主人公。", "description": "Cedyks 是一个富有的男孩子。他住在著名的 The Place（宫殿）中。\n\nCedyks 是一个努力的男孩子。他每天都做着不一样的题来锻炼他的 The Salt（灵魂）。\n\n这天，他打算在他的宫殿外围修筑一道城墙，城墙上有 $n$ 座瞭望塔。你可以把城墙看做一条线段，瞭望塔是线段上的 $n$ 个点，其中 $1$ 和 $n$ 分别为城墙的两个端点。其中第 $i$ 座瞭望塔和第 $i + 1$ 座瞭望塔的距离为 $w_i$，他们之间的道路是双向的。\n\n城墙很快就修建好了，现在 Cedyks 开始计划修筑他的宫殿到城墙的道路。因为这题的题目名称，Cedyks 打算用他的宫殿到每一个瞭望塔的最短道路之和来衡量一个修建计划。\n\n现在 Cedyks 手上有 $m$ 个设计方案，第 $k$ 个设计方案会在宫殿和瞭望塔之间修建 $T_k$ 条双向道路，第 $i$ 条道路连接着瞭望塔 $a_i$，长度为 $l_i$。\n\n计算到每一个瞭望塔的最短路之和是一个繁重的工程，本来 Cedyks 想用广为流传的 SPFA 算法来求解，但是因为他的 butter（缓冲区）实在是太小了，他只能转而用原始的贝尔福特曼算法来计算，算法的流程大概如下：\n\n1. 定义宫殿是 $0$ 号点，第 $i$ 个瞭望塔是 $i$ 号点，双向边 $(u_i, v_i, l_i)$ 为一条连接 $u_i$ 和 $v_i$ 的双向道路。令 $d$ 为距离数组，最开始 $d_0 = 0, d_i = 10^{18}(i ∈ [1, n])$。\n2. 令辅助数组 $c = d$。依次对于每一条边 $(u_i, v_i,w_i)$ 进行增广，$c_{u_i} = \\min(c_{u_i} , d_{v_i} + w_i)$，$c_{v_i} = \\min(c_{v_i} , d_{u_i} + w_i)$。\n3. 令 $t$ 为 $c$ 和 $d$ 中不一样的位置个数，即令 $S = \\{i|c_i≠d_i\\}$，则 $t = |S|$。若 $t = 0$，说明 $d$ 就是最终的最短路，算法结束。否则令 $d = c$，回到第二步。\n\n因为需要计算的设计方案实在是太多了，所以 Cedyks 雇佣了一些人来帮他进行计算。为了避免这些人用捏造出来的数据偷懒，他定义一个设计方案的校验值为在这个方案上运行贝尔福特曼算法每一次进入第三步 $t$ 的和。他会让好几个雇佣来的人计算同样的设计方案，并比对每一个人给出的校验值。\n\n你是 Cedyks 雇佣来的苦力之一，聪明的你发现在这个情形下计算最短路的长度的和是一件非常简单的事情。但是寄人篱下不得不低头，你不得不再计算出每一个方案的校验值来交差。", "inputFormat": "第一行输入两个整数 $n,m$，表示瞭望塔个数和设计方案个数。\n\n接下来一行 $n - 1$ 个数 $w_i$，表示瞭望塔 $i$ 和 $i + 1$ 之间道路的长度。\n\n接下来 $m$ 行，每行描述一个设计方案。第一个整数 $K$ 表示设计方案中的道路数量，接下来 $K$ 个数对 $(a_i, l_i)$ 为一条宫殿到瞭望塔的边。", "outputFormat": "对于每一个设计方案，输出一行一个整数表示校验值。", "hint": "### 样例解释\n\n对于第一个设计方案，每一个阶段 $d$ 的变化为：\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,10^{18},2,10^{18},10^{18},10^{18}] \\rightarrow$ $[0,4,2,5,10^{18},10^{18}] \\rightarrow [0,4,2,5,6,10^{18}] \\rightarrow [0,4,2,5,6,10]$。\n\n因此校验值为 $1+2+1+1=5$。\n\n对于第二个设计方案，每一个阶段 $d$ 的变化为：\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,1,10^{18},10^{18},10,10^{18}] \\rightarrow$ $[0,1,3,11,10,14] \\rightarrow [0,1,3,6,10,14] \\rightarrow [0,1,3,6,7,14] \\rightarrow [0,1,3,6,7,11]$。\n\n因此校验值为 $2+3+1+1+1=8$。\n\n对于第三个设计方案，每一个阶段 $d$ 的变化为：\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,1,10^{18},1,10^{18},1] \\rightarrow [0,1,3,1,2,1]$。\n\n因此校验值为 $3+1+1=5$。\n\n对于第四个设计方案，每一个阶段 $d$ 的变化为：\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,10,100,10^{18},10^{18},1] \\rightarrow$ $[0,10,12,103,5,1] \\rightarrow [0,10,12,6,5,1] \\rightarrow [0,10,9,5,1]$。\n\n因此校验值为 $3+3+1+1=8$。\n\n对于第五个设计方案，每一个阶段 $d$ 的变化为：\n\n- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \\rightarrow [0,1,1,1,1,1]$\n\n因此校验值为 $5$。\n\n### 数据范围\n\n测试点|$n$|$m$|$K$|其他约定\n-|-|-|-|-\n1,2|$\\le 1000$|$\\le 1000$|$\\le 100$|无\n3,4|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$\\le 100$|无\n5,6|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$1 \\le w_i,l_i \\le 50$\n7,8,9,10|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|$\\le 2 \\times 10^5$|无\n\n\n对于 $100\\%$ 的数据，保证每个设计方案 $a_i$ 两两不同且 $1\\le a_i\\le n$。  \n对于 $100\\%$ 的数据，保证 $1\\le w_i,l_i\\le 10^9,1\\le\\sum K\\le 2\\times 10^5$。\n\n感谢 @Xeonacid 提供题面", "locale": "zh-CN"}}}
{"pid": "P4502", "type": "P", "difficulty": 7, "samples": [["4\n0 0 1 1\n0 0\n2 0\n0 1\n1 1", "3.7853981633974474\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "各省省选", "浙江", "Special Judge"], "title": "[ZJOI2018] 保镖", "background": "", "description": "九条可怜是一个贪玩的女孩子。\n\n一个可爱的女孩子出门在外和朋友玩，难免会遇到危险，于是可怜的爸爸悄悄的安插了 $n$ 位保镖在暗中保护她。因为可怜是一个要强的女孩子，所以她的爸爸不想让她知道她的身边有这么多的保镖，因此保镖们必须通过定期的换岗来避免被可怜发现。\n\n一次理想的换岗是：距离可怜远的保镖被换到了较近的位置，距离可怜近的保镖被换到了较远的位置。经过一系列安排，保镖们会按照如下的方式进行换岗：\n\n换岗时，可怜和保镖们的位置可以被抽象成二维平面直角坐标系上的点。设可怜的位置为 $O$，保镖的位置为 $P_i$，换岗后的位置为 $P'_i$\n在换岗前后，保镖和可怜的相对位置不变。即对于 $\\forall i \\in [1,n]$，$P'_i$ 在射线 $OP_i$ 上。\n在换岗前后，保镖和可怜的距离变成了原来的倒数。即对于 $\\forall i \\in [1,n]$，$|OP_i||OP'_i|=1$。\n同时，保镖的位置决定了可怜的安全度。如果在外围的保镖越多，那么他们能观察到的信息就越多，可怜就越安全。因此，我们定义这些保镖的位置的凸包的**顶点个数**为可怜的安全度。\n\n然而，可怜的行踪总是神出鬼没的。这一天，保镖们跟丢了可怜，只知道可怜下次会在以 $(x_1,y_1)$ 为左下角，以 $(x_2,y_2)$ 为右上角的矩形区域内出现，具体的位置服从这个矩形区域内的均匀分布（可以理解为等概率随机）。因为保镖们已经有很长时间没有换岗了，于是他们打算在可怜下次出现的时候换岗。同时，在极小的概率下，可怜可能会出现在和某个保镖相同的位置上。这时这个保镖会被发现，从而他会保持位置不动，而其他的保镖还是会按照上述规则进行换岗。\n\n现在，可怜的爸爸想要计算，保镖们在换岗后，可怜的安全度的期望是多少。\n\n如果你对凸包不太熟悉，这儿给出凸包形式化的定义：\n\n对于一个简单多边形，它是凸多边形当且仅当它内部任意两点的连线在它的内部。\n对于一个点集 $P$，它的凸包为包含所有点面积最小的没有三个连续顶点共线的凸多边形。", "inputFormat": "第一行输入一个整数 $n$， 表示保镖的数量。\n\n第二行输入四个整数 $x_1,y_1,x_2,y_2$， 表示可怜可能出现的矩形区域。\n\n接下来 $n$ 行每行两个整数 $a,b$，表示一个保镖的坐标。保证保镖的坐标两两不同。", "outputFormat": "输出一行一个实数表示凸包节点数的期望。\n\n当你的答案与标准输出的绝对误差或相对误差在 $10^{-7}$ 内时，就会被视为正确。\n\n样例", "hint": "### 样例解释\n这儿画出可怜出现在 (1,0) 时的情况，如下图所示，1,2,4 号保镖的位置保持不变，分别为 $P_1,P_2,P_4$，3 号保镖从 $P_3$ 变到了 $P'_3$，坐标为 $(\\frac{1}{2},\\frac{1}{2})$。 \n\n![](https://cdn.luogu.com.cn/upload/pic/18418.png)\n\n这时四个保镖的位置 $P_1,P_2,P'_3,P_4$ 的凸包为三角形 $P_1,P_4,P_2$，因此可怜的安全度为 3。注意这时 $P'_3$ 正好落在边 $P_1P_4$ 上，但是根据凸包的定义，它不是顶点。\n\n### 数据范围\n\n测试点|　$n$|测试点|　$n$\n-|-|-|-\n1|$\\le 3$|6|$\\le 50$\n2|$\\le 4$|7|$\\le 350$\n3|$\\le 4$|8|$\\le 350$\n4|$\\le 50$|9|$\\le 2000$\n5|$\\le 50$|10|$\\le 2000$\n\n对于 100% 的数据，保证 $0 \\leq a,b,x_0,x_1,y_0,y_1 \\leq 10^5,x_0<x_1,y_0<y_1,n \\geq 3$。\n\n对于 100% 的数据，保证保镖的位置两两不同。\n\n同时为了避免可能出现的精度误差，在所有实际的测试数据以及大样例中，保证可怜可能出现的矩形区域的长宽都不小于 $10^3$，即 $x_1-x_0,y_1-y_0 \\geq 10^3$.", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2018] Bodyguards", "background": "", "description": "Jiutiao Kelian is a playful girl.\n\nWhen a cute girl goes out to play with friends, danger may arise. So Kelian’s father secretly stationed $n$ bodyguards to protect her from the shadows. Because Kelian is strong-willed, her father does not want her to notice the many bodyguards around her, so the bodyguards must regularly rotate their posts to avoid being discovered.\n\nAn ideal rotation is: the bodyguards far from Kelian are moved closer, and the ones close to Kelian are moved farther. After some planning, the bodyguards will rotate according to the following rules:\n\n- During rotation, Kelian and the bodyguards’ positions can be abstracted as points in a 2D Cartesian plane. Let Kelian’s position be $O$, a bodyguard’s position be $P_i$, and the position after rotation be $P'_i$.\n- Before and after rotation, the relative direction between each bodyguard and Kelian remains the same. That is, for $\\forall i \\in [1, n]$, $P'_i$ lies on the ray $OP_i$.\n- Before and after rotation, the distance between each bodyguard and Kelian becomes the reciprocal of the original. That is, for $\\forall i \\in [1, n]$, $|OP_i|\\,|OP'_i| = 1$.\n\nMeanwhile, Kelian’s safety level is determined by the bodyguards’ positions. The more bodyguards on the outside, the more information they can observe, and the safer Kelian is. Therefore, we define the number of vertices of the convex hull of the bodyguards’ positions as Kelian’s safety level.\n\nHowever, Kelian’s whereabouts are unpredictable. On this day, the bodyguards lost track of her and only know that next time she will appear inside the rectangle with lower-left corner $(x_1, y_1)$ and upper-right corner $(x_2, y_2)$, with a uniform distribution over this rectangle (i.e., equally likely). Since it has been a long time since the last rotation, they plan to rotate when Kelian appears next. Also, with a very small probability, Kelian may appear at exactly the same location as some bodyguard. In that case, that bodyguard will be discovered and will remain still, while the other bodyguards still rotate according to the rules above.\n\nNow, Kelian’s father wants to compute the expected value of Kelian’s safety level (the number of convex hull vertices) after the rotation.\n\nIf you are not familiar with convex hulls, here is a formal definition:\n\n- A simple polygon is a convex polygon if and only if the line segment between any two interior points lies entirely inside it.\n- For a point set $P$, its convex hull is the convex polygon of minimum area that contains all points and has no three consecutive vertices collinear.", "inputFormat": "- The first line contains an integer $n$, the number of bodyguards.\n- The second line contains four integers $x_1, y_1, x_2, y_2$, describing the rectangle where Kelian may appear.\n- Each of the next $n$ lines contains two integers $a, b$, the coordinates of a bodyguard. All bodyguards’ positions are pairwise distinct.", "outputFormat": "Output a single real number: the expected number of vertices of the convex hull.\n\nYour answer will be accepted if its absolute or relative error is within $10^{-7}$.", "hint": "Sample Explanation  \nHere we draw the situation when Kelian appears at $(1, 0)$, as shown below. Bodyguards 1, 2, and 4 keep their positions, denoted $P_1, P_2, P_4$. Bodyguard 3 moves from $P_3$ to $P'_3$ with coordinates $(\\frac{1}{2}, \\frac{1}{2})$.\n\n![](https://cdn.luogu.com.cn/upload/pic/18418.png)\n\nAt this moment, the convex hull of $P_1, P_2, P'_3, P_4$ is the triangle $P_1, P_4, P_2$, so Kelian’s safety level is 3. Note that $P'_3$ lies exactly on edge $P_1P_4$, but by the definition of the convex hull, it is not a vertex.\n\nConstraints\n\n测试点|　$n$|测试点|　$n$\n-|-|-|-\n1|$\\le 3$|6|$\\le 50$\n2|$\\le 4$|7|$\\le 350$\n3|$\\le 4$|8|$\\le 350$\n4|$\\le 50$|9|$\\le 2000$\n5|$\\le 50$|10|$\\le 2000$\n\nFor 100% of the testdata, it is guaranteed that $0 \\le a, b, x_1, y_1, x_2, y_2 \\le 10^5$, $x_1 < x_2$, $y_1 < y_2$, and $n \\ge 3$.\n\nFor 100% of the testdata, the bodyguards’ positions are pairwise distinct.\n\nTo avoid possible precision issues, in all actual testdata and large samples, the width and height of the rectangle where Kelian may appear are at least $10^3$, i.e., $x_2 - x_1, y_2 - y_1 \\ge 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2018] 保镖", "background": "", "description": "九条可怜是一个贪玩的女孩子。\n\n一个可爱的女孩子出门在外和朋友玩，难免会遇到危险，于是可怜的爸爸悄悄的安插了 $n$ 位保镖在暗中保护她。因为可怜是一个要强的女孩子，所以她的爸爸不想让她知道她的身边有这么多的保镖，因此保镖们必须通过定期的换岗来避免被可怜发现。\n\n一次理想的换岗是：距离可怜远的保镖被换到了较近的位置，距离可怜近的保镖被换到了较远的位置。经过一系列安排，保镖们会按照如下的方式进行换岗：\n\n换岗时，可怜和保镖们的位置可以被抽象成二维平面直角坐标系上的点。设可怜的位置为 $O$，保镖的位置为 $P_i$，换岗后的位置为 $P'_i$\n在换岗前后，保镖和可怜的相对位置不变。即对于 $\\forall i \\in [1,n]$，$P'_i$ 在射线 $OP_i$ 上。\n在换岗前后，保镖和可怜的距离变成了原来的倒数。即对于 $\\forall i \\in [1,n]$，$|OP_i||OP'_i|=1$。\n同时，保镖的位置决定了可怜的安全度。如果在外围的保镖越多，那么他们能观察到的信息就越多，可怜就越安全。因此，我们定义这些保镖的位置的凸包的**顶点个数**为可怜的安全度。\n\n然而，可怜的行踪总是神出鬼没的。这一天，保镖们跟丢了可怜，只知道可怜下次会在以 $(x_1,y_1)$ 为左下角，以 $(x_2,y_2)$ 为右上角的矩形区域内出现，具体的位置服从这个矩形区域内的均匀分布（可以理解为等概率随机）。因为保镖们已经有很长时间没有换岗了，于是他们打算在可怜下次出现的时候换岗。同时，在极小的概率下，可怜可能会出现在和某个保镖相同的位置上。这时这个保镖会被发现，从而他会保持位置不动，而其他的保镖还是会按照上述规则进行换岗。\n\n现在，可怜的爸爸想要计算，保镖们在换岗后，可怜的安全度的期望是多少。\n\n如果你对凸包不太熟悉，这儿给出凸包形式化的定义：\n\n对于一个简单多边形，它是凸多边形当且仅当它内部任意两点的连线在它的内部。\n对于一个点集 $P$，它的凸包为包含所有点面积最小的没有三个连续顶点共线的凸多边形。", "inputFormat": "第一行输入一个整数 $n$， 表示保镖的数量。\n\n第二行输入四个整数 $x_1,y_1,x_2,y_2$， 表示可怜可能出现的矩形区域。\n\n接下来 $n$ 行每行两个整数 $a,b$，表示一个保镖的坐标。保证保镖的坐标两两不同。", "outputFormat": "输出一行一个实数表示凸包节点数的期望。\n\n当你的答案与标准输出的绝对误差或相对误差在 $10^{-7}$ 内时，就会被视为正确。\n\n样例", "hint": "### 样例解释\n这儿画出可怜出现在 (1,0) 时的情况，如下图所示，1,2,4 号保镖的位置保持不变，分别为 $P_1,P_2,P_4$，3 号保镖从 $P_3$ 变到了 $P'_3$，坐标为 $(\\frac{1}{2},\\frac{1}{2})$。 \n\n![](https://cdn.luogu.com.cn/upload/pic/18418.png)\n\n这时四个保镖的位置 $P_1,P_2,P'_3,P_4$ 的凸包为三角形 $P_1,P_4,P_2$，因此可怜的安全度为 3。注意这时 $P'_3$ 正好落在边 $P_1P_4$ 上，但是根据凸包的定义，它不是顶点。\n\n### 数据范围\n\n测试点|　$n$|测试点|　$n$\n-|-|-|-\n1|$\\le 3$|6|$\\le 50$\n2|$\\le 4$|7|$\\le 350$\n3|$\\le 4$|8|$\\le 350$\n4|$\\le 50$|9|$\\le 2000$\n5|$\\le 50$|10|$\\le 2000$\n\n对于 100% 的数据，保证 $0 \\leq a,b,x_0,x_1,y_0,y_1 \\leq 10^5,x_0<x_1,y_0<y_1,n \\geq 3$。\n\n对于 100% 的数据，保证保镖的位置两两不同。\n\n同时为了避免可能出现的精度误差，在所有实际的测试数据以及大样例中，保证可怜可能出现的矩形区域的长宽都不小于 $10^3$，即 $x_1-x_0,y_1-y_0 \\geq 10^3$.", "locale": "zh-CN"}}}
{"pid": "P4503", "type": "P", "difficulty": 5, "samples": [["4 3 64\nFax\nfax\nmax\nmac", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "2014", "哈希 hashing", "CTSC/CTS"], "title": "[CTSC2014] 企鹅 QQ", "background": "PenguinQQ 是中国最大、最具影响力的 SNS（Social Networking Services）网站，以实名制为基础，为用户提供日志、群、即时通讯、相册、集市等丰富强大的互联网功能体验，满足用户对社交、资讯、娱乐、交易等多方面的需求。", "description": "小 Q 是 PenguinQQ 网站的管理员，他最近在进行一项有趣的研究——哪些账户是同一个人注册的。经过长时间的分析，小 Q 发现同一个人注册的账户名称总是很相似的，例如 Penguin1，Penguin2，Penguin3……于是小 Q 决定先对这种相似的情形进行统计。\n\n小 Q 定义，若两个账户名称是相似的，当且仅当这两个字符串等长且恰好只有一位不同。例如“Penguin1”和“Penguin2”是相似的，但“Penguin1”和“2Penguin”不是相似的。而小 Q 想知道，在给定的 $n$ 个账户名称中，有多少对是相似的。\n\n为了简化你的工作，小 Q 给你的 $n$ 个字符串长度均等于$L$ ，且只包含大小写字母、数字、下划线以及‘@’共 $64$ 种字符，而且不存在两个相同的账户名称。", "inputFormat": "第一行包含三个正整数 $N,L,S$。其中 $N$ 表示账户名称数量，$L$ 表示账户名称长度，$S$ 用来表示字符集规模大小，它的值只可能为 $2$ 或 $64$。\n\n若 $S$ 等于 $2$，账户名称中只包含字符 `0` 和 `1` 共 $2$ 种字符；\n\n若 $S$ 等于 $64$，账户名称中可能包含大小写字母、数字、下划线以及 `@` 共 $64$ 种字符。\n\n随后 $N$ 行，每行一个长度为 $L$ 的字符串，用来描述一个账户名称。数据保证 $N$ 个字符串是两两不同的。", "outputFormat": "仅一行一个正整数，表示共有多少对相似的账户名称。", "hint": "$4$ 对相似的字符串分别为：Fax 与 fax，Fax 与 max，fax 与 max，max 与 mac。\n\n测试点编号|$N$|$L$|$S$\n:-:|:-:|:-:|:-:\n$1$|$50$|$10$|$64$\n$2$|$500$|$100$|$64$\n$3$|$3000$|$100$|$2$\n$4$|$3000$|$100$|$64$\n$5$|$30000$|$50$|$2$\n$6$|$30000$|$50$|$64$\n$7$|$30000$|$200$|$2$\n$8$|$30000$|$200$|$64$\n$9$|$30000$|$200$|$2$\n$10$|$30000$|$200$|$64$", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2014] Penguin QQ", "background": "PenguinQQ is China’s largest and most influential SNS (Social Networking Services) website. Based on a real-name system, it provides powerful and rich Internet features such as blogs, groups, instant messaging, photo albums, and a marketplace, meeting users’ needs in socializing, information, entertainment, and transactions.", "description": "Xiao Q (pinyin) is an administrator of the PenguinQQ website. He is studying an interesting question: which accounts were registered by the same person. After long analysis, Xiao Q found that accounts registered by the same person usually have very similar names, such as Penguin1, Penguin2, Penguin3... So he decides to first count such similar cases.\n\nXiao Q defines two account names to be similar if and only if the two strings have the same length and differ in exactly one position. For example, “Penguin1” and “Penguin2” are similar, while “Penguin1” and “2Penguin” are not. Given $n$ account names, he wants to know how many pairs are similar.\n\nTo simplify your work, the $n$ strings all have length $L$, and they contain only uppercase and lowercase letters, digits, the underscore, and `@` — a total of $64$ characters. Moreover, no two account names are identical.", "inputFormat": "The first line contains three positive integers $N, L, S$. Here $N$ is the number of account names, $L$ is the length of each account name, and $S$ is the alphabet size, whose value is either $2$ or $64$.\n\nIf $S$ equals $2$, account names contain only the characters `0` and `1`.\n\nIf $S$ equals $64$, account names may contain uppercase and lowercase letters, digits, the underscore, and `@` — a total of $64$ characters.\n\nThen $N$ lines follow, each containing a string of length $L$ that describes an account name. It is guaranteed that the $N$ strings are pairwise distinct.", "outputFormat": "Output a single integer on one line, the number of pairs of similar account names.", "hint": "The $4$ similar pairs are: Fax and fax, Fax and max, fax and max, max and mac.\n\n测试点编号|$N$|$L$|$S$\n:-:|:-:|:-:|:-:\n$1$|$50$|$10$|$64$\n$2$|$500$|$100$|$64$\n$3$|$3000$|$100$|$2$\n$4$|$3000$|$100$|$64$\n$5$|$30000$|$50$|$2$\n$6$|$30000$|$50$|$64$\n$7$|$30000$|$200$|$2$\n$8$|$30000$|$200$|$64$\n$9$|$30000$|$200$|$2$\n$10$|$30000$|$200$|$64$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2014] 企鹅 QQ", "background": "PenguinQQ 是中国最大、最具影响力的 SNS（Social Networking Services）网站，以实名制为基础，为用户提供日志、群、即时通讯、相册、集市等丰富强大的互联网功能体验，满足用户对社交、资讯、娱乐、交易等多方面的需求。", "description": "小 Q 是 PenguinQQ 网站的管理员，他最近在进行一项有趣的研究——哪些账户是同一个人注册的。经过长时间的分析，小 Q 发现同一个人注册的账户名称总是很相似的，例如 Penguin1，Penguin2，Penguin3……于是小 Q 决定先对这种相似的情形进行统计。\n\n小 Q 定义，若两个账户名称是相似的，当且仅当这两个字符串等长且恰好只有一位不同。例如“Penguin1”和“Penguin2”是相似的，但“Penguin1”和“2Penguin”不是相似的。而小 Q 想知道，在给定的 $n$ 个账户名称中，有多少对是相似的。\n\n为了简化你的工作，小 Q 给你的 $n$ 个字符串长度均等于$L$ ，且只包含大小写字母、数字、下划线以及‘@’共 $64$ 种字符，而且不存在两个相同的账户名称。", "inputFormat": "第一行包含三个正整数 $N,L,S$。其中 $N$ 表示账户名称数量，$L$ 表示账户名称长度，$S$ 用来表示字符集规模大小，它的值只可能为 $2$ 或 $64$。\n\n若 $S$ 等于 $2$，账户名称中只包含字符 `0` 和 `1` 共 $2$ 种字符；\n\n若 $S$ 等于 $64$，账户名称中可能包含大小写字母、数字、下划线以及 `@` 共 $64$ 种字符。\n\n随后 $N$ 行，每行一个长度为 $L$ 的字符串，用来描述一个账户名称。数据保证 $N$ 个字符串是两两不同的。", "outputFormat": "仅一行一个正整数，表示共有多少对相似的账户名称。", "hint": "$4$ 对相似的字符串分别为：Fax 与 fax，Fax 与 max，fax 与 max，max 与 mac。\n\n测试点编号|$N$|$L$|$S$\n:-:|:-:|:-:|:-:\n$1$|$50$|$10$|$64$\n$2$|$500$|$100$|$64$\n$3$|$3000$|$100$|$2$\n$4$|$3000$|$100$|$64$\n$5$|$30000$|$50$|$2$\n$6$|$30000$|$50$|$64$\n$7$|$30000$|$200$|$2$\n$8$|$30000$|$200$|$64$\n$9$|$30000$|$200$|$2$\n$10$|$30000$|$200$|$64$", "locale": "zh-CN"}}}
{"pid": "P4504", "type": "P", "difficulty": 7, "samples": [["3\n1\n6 7 1 \n4 1 8 \n8 3 3 \n2\n7 5 8 \n10 5 7 \n10 5 5 \n10\n1 3 1 2 2\n1 2 2 3 5\n2 3 2 2 2\n1 2 3 2 5\n1 3 1 2 3\n2 1 2 2 3\n1 3 2 1 2\n2 2 1 1 1\n1 2 1 2 5\n2 3 1 1 2", "0.083836\n0.095256\n0.078828\n0.146900"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "Special Judge", "CTSC/CTS"], "title": "[CTSC2014] 插线板", "background": "", "description": "Allison有非常多的电子设备，比如iMac,iPod,iPhone和iPad。所以她准备购买插线板来给电子设备充电。在做了大量的网络调研后，Allison发现了一款美丽精巧的天翼牌排插（如左下图所示）。在见到这个插线板的第一眼，Allison就被它的精美造型所吸引，于是她一次性购买了n个这种型号的插线板。 \n\n可是问题也随之而来，Allison的家中只有一个插座，她需要通过插线板的连接将电一层一层地导出（如右上图所示）。 \n\n插线板的连接方式是树形结构的：每个插线板的插头插在另一个插线板的插空中（除了根节点），插线板的连接不允许构成环。 \n\n每个插线板有火线，零线，地线三根导线，随着插线板数量的增加、导线的磨损，电路中导线与导线之间接触产生的电阻已经到了不能被忽视的地步。\n \n如何来描述插线板的树形结构以及导线之间的电阻关系呢？Allison思考出来一个数学模型：用$a_i$代表第$i$个插线板的编号，$f_i$代表第$i$个插线板的插头所差的插线板（即$a_i$在树中的父亲），$1$代表火线，$2$代表零线，$3$代表地线，则整个网络的电阻可以用$R(a_i,f_i,x,y)(x,y∈\\{1,2,3\\})$来描述，它代表$a_i$的$x$线与$f_i$的$y$线之间的电阻值（在这个数学模型中，Allison认为火线和零线也是可能连接并且产生电阻的）下面是一个例子： \n\n![](https://cdn.luogu.com.cn/upload/pic/17985.png)\n\n由于时间的推移，导线与导线之间的电阻还可能发生变化。现在，Allison想知道在插线板树形电路中，当前时刻$a_i$插线板的$x$线和$a_j$插线板的$y$线之间的电阻是多少。规定插线板的树根节点不再插向其他插线板，且编号为$1$。 ", "inputFormat": "第一行包含一个正整数$n$，表示插线板的个数。 \n\n接下来$4(n-1)$行，每4行为一个块。 \n\n第$i$块的第一行为一个整数$f_i$【注：原题如此。实际应该是$f_{i+1}$，下同】，表示编号为$i+1$的插线板的父亲为$f_i$【注：同上】插线板。\n \n接下来一个$3\\times3$的矩阵$g_{xy}$，第$x$行第$y$个数表示编号为$i+1$的插线板的$x$线和$f_i$【注：同上】的$y$线之间的电阻的**倒数**。 \n\n接下来一个整数$q$，表示$q$个操作数。\n \n第一个整数位$k$，若$k=1$则接下来包含四个整数$a_i,x_i,x_j,g$，表示将$a_i$插线板的$x_i$线与$a_i$插线板的父亲$f_i$【注：原题如此。实际应该是$f_{a_i}$】的$x_j$线之间的电阻值改为$g$的倒数。保证$2≤a_i≤n$。\n \n若$k=2$，则接下来包含四个整数$a_i,x_i,a_j,x_j$，表示询问$a_i$插线板的$x_i$线与$a_j$插线板的$x_j$线之间的电阻大小。保证$a_i≠a_j$。 ", "outputFormat": "对每个询问，输出一行实数，表示两条线之间的电阻。 \n\n若|(选手输出-标准输出)/标准输出|$≤10^{-3}$，则被认为该电阻值正确，若所有电阻值皆正确，则可获得该测试点的得分。 ", "hint": "对于所有测试数据，输入保证是一棵树。$0<$输入中电阻的倒数$≤10$。 \n\n测试点编号| 特点\n:-:|:-:\n$1\\sim6$|$n≤100,q≤1000$，保证输入中只有查询没有修改\n$7\\sim10$|$n≤1000,q≤1000$，保证数据是一条链\n$11\\sim16$|$n≤10000,q≤10000$，保证树的高度不超过$30$\n$17\\sim20$|$n≤10000,q≤10000$", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2014] Power Strip", "background": "", "description": "Allison has a lot of electronic devices, such as an iMac, iPod, iPhone, and iPad. So she plans to buy power strips to charge them. After doing a lot of online research, Allison found a beautiful and delicate Tianyi-brand power strip (as shown in the lower-left picture). At first sight, Allison was attracted by its exquisite design, so she bought $n$ power strips of this model at once.\n\nBut then a problem arose: Allison’s home has only one wall socket. She needs to connect power strips so that electricity can be carried out layer by layer (as shown in the lower-right picture).\n\nThe connection of power strips forms a tree structure: the plug of each power strip is inserted into a socket of another power strip (except the root node), and the connections are not allowed to form a cycle.\n\nEach power strip has three wires: live, neutral, and ground. As the number of power strips increases and wires wear out, the contact resistance between wires in the circuit has become too significant to ignore.\n\nHow can we describe the tree structure of the power strips and the resistance relationships between wires? Allison came up with a mathematical model: use $a_i$ to denote the ID of the $i$-th power strip, and $f_i$ to denote the power strip into which the plug of the $i$-th power strip is inserted (i.e., the parent of $a_i$ in the tree). Let $1$ represent the live wire, $2$ the neutral wire, and $3$ the ground wire. Then the resistance of the whole network can be described by $R(a_i,f_i,x,y)(x,y∈\\{1,2,3\\})$, which represents the resistance between wire $x$ of $a_i$ and wire $y$ of $f_i$ (in this model, Allison assumes that the live wire and neutral wire may also be connected and produce resistance). An example is shown below:\n\n![](https://cdn.luogu.com.cn/upload/pic/17985.png)\n\nAs time passes, the resistance between wires may also change. Now Allison wants to know, in the current power-strip tree circuit, what the resistance is between wire $x$ of power strip $a_i$ and wire $y$ of power strip $a_j$. The root node of the tree is not plugged into any other power strip, and its ID is $1$.", "inputFormat": "The first line contains a positive integer $n$, the number of power strips.\n\nThe next $4(n-1)$ lines are divided into blocks, each block consisting of 4 lines.\n\nIn the $i$-th block, the first line contains an integer $f_{i+1}$, meaning that the parent of power strip $i+1$ is $f_{i+1}$.\n\nThen follows a $3\\times3$ matrix $g_{xy}$. The number in row $x$, column $y$ is the **reciprocal** of the resistance between wire $x$ of power strip $i+1$ and wire $y$ of power strip $f_{i+1}$.\n\nThen an integer $q$ is given, denoting the number of operations.\n\nEach operation starts with an integer $k$.\n\n- If $k=1$, then four integers $a_i,x_i,x_j,g$ follow, meaning to change the resistance between wire $x_i$ of power strip $a_i$ and wire $x_j$ of its parent $f_{a_i}$ to the reciprocal of $g$. It is guaranteed that $2≤a_i≤n$.\n- If $k=2$, then four integers $a_i,x_i,a_j,x_j$ follow, meaning to query the resistance between wire $x_i$ of power strip $a_i$ and wire $x_j$ of power strip $a_j$. It is guaranteed that $a_i≠a_j$.", "outputFormat": "For each query, output one line with a real number, representing the resistance between the two wires.\n\nIf $|(\\text{your output}-\\text{standard output})/\\text{standard output}|≤10^{-3}$, then the resistance value is considered correct. If all resistance values are correct, you will get the score for that test point.", "hint": "For all testdata, the input is guaranteed to be a tree. $0<$ the reciprocal of each resistance in the input $≤10$.\n\nTest point ID | Feature\n:-:|:-:\n$1\\sim6$ | $n≤100,q≤1000$, and the input contains only queries, no modifications\n$7\\sim10$ | $n≤1000,q≤1000$, and the tree is a chain\n$11\\sim16$ | $n≤10000,q≤10000$, and the height of the tree does not exceed $30$\n$17\\sim20$ | $n≤10000,q≤10000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2014] 插线板", "background": "", "description": "Allison有非常多的电子设备，比如iMac,iPod,iPhone和iPad。所以她准备购买插线板来给电子设备充电。在做了大量的网络调研后，Allison发现了一款美丽精巧的天翼牌排插（如左下图所示）。在见到这个插线板的第一眼，Allison就被它的精美造型所吸引，于是她一次性购买了n个这种型号的插线板。 \n\n可是问题也随之而来，Allison的家中只有一个插座，她需要通过插线板的连接将电一层一层地导出（如右上图所示）。 \n\n插线板的连接方式是树形结构的：每个插线板的插头插在另一个插线板的插空中（除了根节点），插线板的连接不允许构成环。 \n\n每个插线板有火线，零线，地线三根导线，随着插线板数量的增加、导线的磨损，电路中导线与导线之间接触产生的电阻已经到了不能被忽视的地步。\n \n如何来描述插线板的树形结构以及导线之间的电阻关系呢？Allison思考出来一个数学模型：用$a_i$代表第$i$个插线板的编号，$f_i$代表第$i$个插线板的插头所差的插线板（即$a_i$在树中的父亲），$1$代表火线，$2$代表零线，$3$代表地线，则整个网络的电阻可以用$R(a_i,f_i,x,y)(x,y∈\\{1,2,3\\})$来描述，它代表$a_i$的$x$线与$f_i$的$y$线之间的电阻值（在这个数学模型中，Allison认为火线和零线也是可能连接并且产生电阻的）下面是一个例子： \n\n![](https://cdn.luogu.com.cn/upload/pic/17985.png)\n\n由于时间的推移，导线与导线之间的电阻还可能发生变化。现在，Allison想知道在插线板树形电路中，当前时刻$a_i$插线板的$x$线和$a_j$插线板的$y$线之间的电阻是多少。规定插线板的树根节点不再插向其他插线板，且编号为$1$。 ", "inputFormat": "第一行包含一个正整数$n$，表示插线板的个数。 \n\n接下来$4(n-1)$行，每4行为一个块。 \n\n第$i$块的第一行为一个整数$f_i$【注：原题如此。实际应该是$f_{i+1}$，下同】，表示编号为$i+1$的插线板的父亲为$f_i$【注：同上】插线板。\n \n接下来一个$3\\times3$的矩阵$g_{xy}$，第$x$行第$y$个数表示编号为$i+1$的插线板的$x$线和$f_i$【注：同上】的$y$线之间的电阻的**倒数**。 \n\n接下来一个整数$q$，表示$q$个操作数。\n \n第一个整数位$k$，若$k=1$则接下来包含四个整数$a_i,x_i,x_j,g$，表示将$a_i$插线板的$x_i$线与$a_i$插线板的父亲$f_i$【注：原题如此。实际应该是$f_{a_i}$】的$x_j$线之间的电阻值改为$g$的倒数。保证$2≤a_i≤n$。\n \n若$k=2$，则接下来包含四个整数$a_i,x_i,a_j,x_j$，表示询问$a_i$插线板的$x_i$线与$a_j$插线板的$x_j$线之间的电阻大小。保证$a_i≠a_j$。 ", "outputFormat": "对每个询问，输出一行实数，表示两条线之间的电阻。 \n\n若|(选手输出-标准输出)/标准输出|$≤10^{-3}$，则被认为该电阻值正确，若所有电阻值皆正确，则可获得该测试点的得分。 ", "hint": "对于所有测试数据，输入保证是一棵树。$0<$输入中电阻的倒数$≤10$。 \n\n测试点编号| 特点\n:-:|:-:\n$1\\sim6$|$n≤100,q≤1000$，保证输入中只有查询没有修改\n$7\\sim10$|$n≤1000,q≤1000$，保证数据是一条链\n$11\\sim16$|$n≤10000,q≤10000$，保证树的高度不超过$30$\n$17\\sim20$|$n≤10000,q≤10000$", "locale": "zh-CN"}}}
{"pid": "P4505", "type": "P", "difficulty": 5, "samples": [["2\n5\n3 2 1 3 2\n5\n1 1 1 1 1", "3\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "CTSC/CTS"], "title": "[CTSC2013] 组合子逻辑", "background": "", "description": "组合子逻辑是 Moses Schönfinkel 和 Haskell Curry 发明的一种符号系统，用于消除数理逻辑中对于变量的需要。本题考察一种与真实世界的组合子演算略有差别的组合子系统。\n\n一个组合子项是下列形式之一：\n\n$$P$$\n\n$$(E_1\\;E_2)$$\n\n其中 $P$ 表示一个基本函数，$E_1$以及$E_2$表示一个组合子项(可以相同)。不满足以上形式表达式均非组合子项。\n\n我们将一个组合子项 $E$ 的参数个数 $np(E)$如下：\n\n$np(P)$ = 基本函数 $P$ 的参数个数；\n\n$np((E_1\\;E_2)) = np(E_1) - 1$。\n\n本题中，我们用一个正整数同时表示一个基本函数，以及该基本函数的参数个数。\n\n对于一个组合子项 $E$，如果它和它包含的所有组合子项的参数个数 $np$ 均为正整数，那么我们称这个 $E$ 为范式。\n\n我们经常组合子项简化表示：如果一个组合子项$E$含有连续子序列$(… ((E_1\\;E_2)\\;E_3) …E_n)$ (其中 $n ≥ 3$)，其中$E_k$表示组合子项(可以是简化表示的)，那么将该部分替换为$(E_1\\;E_2\\;E_3 … E_n)$，其他部分不变，得到表达式 $E$ 的一个简化表示。一个组合子项可以被简化表示多次。\n\n给定一个基本函数序列，问至少需要添加多少对括号，才能使得该表达式成为一个范式的简化表示(即满足范式的性质)；如果无论如何怎样添加括号，均不能得到范式的简化表示，输出$-1$。", "inputFormat": "第一行包含一个正整数 $T$，表示有 $T$ 次询问。\n\n接下来 $2T$ 行。\n\n第 $2k$ 行有一个正整数$n_k$，表示第 $k$ 次询问的序列中基本函数的个数。\n\n第 $2k + 1$ 行有$n_k$个正整数，其中第 $i$ 个整数表示序列中第 $i$ 个基本函数。", "outputFormat": "输出 $T$ 行，每行一个整数，表示对应询问的输出结果。", "hint": "**【样例说明】**\n\n第一次询问：一个最优方案是(3 (2 1) (3 2))。可以证明不存在添加括号对数更少的方案。\n\n第二次询问：容易证明不存在合法方案。\n\n**【数据规模和约定】**\n\n令 $TN$ 表示输入中所有$n_k$的和。\n\n测试点编号|规模\n:-:|:-:\n1|$T ≤ 30,n_k ≤ 3$\n2|$T ≤ 30,n_k ≤ 15$\n3|$TN ≤ 100$\n4|$TN ≤ 500$\n5|$TN ≤ 2000$\n6|$TN ≤ 5000$\n7|$TN ≤ 5000$\n8|$TN ≤ 1000000$\n9|$TN ≤ 2000000$\n10|$TN ≤ 2000000$", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2013] Combinatory Logic", "background": "", "description": "Combinatory logic is a symbolic system invented by Moses Schönfinkel and Haskell Curry to eliminate the need for variables in mathematical logic. This problem considers a combinator system that slightly differs from the one in the real world.\n\nA combinator term is one of the following forms:\n\n$$P$$\n\n$$(E_1\\;E_2)$$\n\nHere $P$ denotes a primitive function, and $E_1$ and $E_2$ are combinator terms (they may be the same). Any expression not in the above forms is not a combinator term.\n\nWe define the number of arguments of a combinator term $E$, denoted $np(E)$, as follows:\n\n$np(P)$ equals the number of arguments (arity) of the primitive function $P$.\n\n$np((E_1\\;E_2)) = np(E_1) - 1$.\n\nIn this problem, we use a positive integer to denote both a primitive function and the arity of that primitive function.\n\nFor a combinator term $E$, if $np$ of $E$ and of all combinator subterms it contains are positive integers, we say that $E$ is in normal form.\n\nWe often use a simplified notation for combinator terms: if a combinator term $E$ contains a consecutive subsequence $(… ((E_1\\;E_2)\\;E_3) …E_n)$ (where $n ≥ 3$), where each $E_k$ denotes a combinator term (which may itself be in simplified notation), then we replace that part by $(E_1\\;E_2\\;E_3 … E_n)$ while keeping the rest unchanged, obtaining a simplified representation of $E$. A combinator term may be simplified in this way multiple times.\n\nGiven a sequence of primitive functions, determine the minimum number of pairs of parentheses that must be added to make the expression a simplified representation of a normal form (i.e., it satisfies the normal-form property). If it is impossible to obtain a simplified representation of a normal form no matter how you add parentheses, output $-1$.", "inputFormat": "The first line contains a positive integer $T$, the number of queries.\n\nThen follow $2T$ lines.\n\nLine $2k$ contains a positive integer $n_k$, the number of primitive functions in the sequence of the $k$-th query.\n\nLine $2k + 1$ contains $n_k$ positive integers, where the $i$-th integer denotes the $i$-th primitive function in the sequence.", "outputFormat": "Output $T$ lines, each containing one integer, the answer for the corresponding query.", "hint": "【Sample Explanation】\n\nFor the first query: an optimal plan is (3 (2 1) (3 2)). One can prove that there is no plan that uses fewer pairs of parentheses.\n\nFor the second query: it is easy to prove that no valid plan exists.\n\n【Constraints】\n\nLet $TN$ denote the sum of all $n_k$ in the input.\n\n测试点编号|规模\n:-:|:-:\n1|$T ≤ 30, n_k ≤ 3$\n2|$T ≤ 30, n_k ≤ 15$\n3|$TN ≤ 100$\n4|$TN ≤ 500$\n5|$TN ≤ 2000$\n6|$TN ≤ 5000$\n7|$TN ≤ 5000$\n8|$TN ≤ 1000000$\n9|$TN ≤ 2000000$\n10|$TN ≤ 2000000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2013] 组合子逻辑", "background": "", "description": "组合子逻辑是 Moses Schönfinkel 和 Haskell Curry 发明的一种符号系统，用于消除数理逻辑中对于变量的需要。本题考察一种与真实世界的组合子演算略有差别的组合子系统。\n\n一个组合子项是下列形式之一：\n\n$$P$$\n\n$$(E_1\\;E_2)$$\n\n其中 $P$ 表示一个基本函数，$E_1$以及$E_2$表示一个组合子项(可以相同)。不满足以上形式表达式均非组合子项。\n\n我们将一个组合子项 $E$ 的参数个数 $np(E)$如下：\n\n$np(P)$ = 基本函数 $P$ 的参数个数；\n\n$np((E_1\\;E_2)) = np(E_1) - 1$。\n\n本题中，我们用一个正整数同时表示一个基本函数，以及该基本函数的参数个数。\n\n对于一个组合子项 $E$，如果它和它包含的所有组合子项的参数个数 $np$ 均为正整数，那么我们称这个 $E$ 为范式。\n\n我们经常组合子项简化表示：如果一个组合子项$E$含有连续子序列$(… ((E_1\\;E_2)\\;E_3) …E_n)$ (其中 $n ≥ 3$)，其中$E_k$表示组合子项(可以是简化表示的)，那么将该部分替换为$(E_1\\;E_2\\;E_3 … E_n)$，其他部分不变，得到表达式 $E$ 的一个简化表示。一个组合子项可以被简化表示多次。\n\n给定一个基本函数序列，问至少需要添加多少对括号，才能使得该表达式成为一个范式的简化表示(即满足范式的性质)；如果无论如何怎样添加括号，均不能得到范式的简化表示，输出$-1$。", "inputFormat": "第一行包含一个正整数 $T$，表示有 $T$ 次询问。\n\n接下来 $2T$ 行。\n\n第 $2k$ 行有一个正整数$n_k$，表示第 $k$ 次询问的序列中基本函数的个数。\n\n第 $2k + 1$ 行有$n_k$个正整数，其中第 $i$ 个整数表示序列中第 $i$ 个基本函数。", "outputFormat": "输出 $T$ 行，每行一个整数，表示对应询问的输出结果。", "hint": "**【样例说明】**\n\n第一次询问：一个最优方案是(3 (2 1) (3 2))。可以证明不存在添加括号对数更少的方案。\n\n第二次询问：容易证明不存在合法方案。\n\n**【数据规模和约定】**\n\n令 $TN$ 表示输入中所有$n_k$的和。\n\n测试点编号|规模\n:-:|:-:\n1|$T ≤ 30,n_k ≤ 3$\n2|$T ≤ 30,n_k ≤ 15$\n3|$TN ≤ 100$\n4|$TN ≤ 500$\n5|$TN ≤ 2000$\n6|$TN ≤ 5000$\n7|$TN ≤ 5000$\n8|$TN ≤ 1000000$\n9|$TN ≤ 2000000$\n10|$TN ≤ 2000000$", "locale": "zh-CN"}}}
{"pid": "P4506", "type": "P", "difficulty": 6, "samples": [["8x^7-258x^5+2112x^3-512x", "8(x-4)^2(x-1/2)x(x+1/2)(x+4)^2"], ["-x^2+2x-1", "-(x-1)^2"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2013", "CTSC/CTS"], "title": "[CTSC2013] 因式分解", "background": "", "description": "通过代数基本定理，我们知道若计算重根，一个 n 次的多项式在复数域内恰好有 n 个零点(函数值为 0 的点)。现给定一个整系数多项式 F[x]，它的 n 个零点恰好都是有理数(即可以写成两个整数相除的形式)；同时，若我们把它所有的非零零点(函数自变量不为 0，函数值为 0)去重，则可以得到 r 个互不相同的非零零点，其中第 i 个非零零点可以被表示成下式：\n\n$$sgn_i \\times \\frac{q_i}{p_i}$$\n\n式中$sgn_i$表示第 i 个零点的符号，$p_i$和$q_i$为互质的两个正整数。\n\n现在告诉你 F[x]，要求你输出将他因式分解后的形式。", "inputFormat": "输入只有一行，包含多项式 F[x]。\n\n多项式一定是如下的形式：\n\n$a_n x$^$n + a_{n-1}x$^${n - 1} + ⋯ a_1x + a_0$\n\n次数一定为从高到低，其中$a_i$为整数，并且若$a_i$为 0，则省略该项，若$a_i$为负数，则省略之前的加号，若$a_i$的绝对值为 1 且 i 不为 0，则不输出 1，并且保证$a_n$不为 0.\n\n详见样例输入。", "outputFormat": "输出一行，表示因式分解后的形式，格式如下：\n\n$a_n (x + u_1/v_1)$^$t_1(x + u_2/v_2)$^$t_2 … (x + u_s/v_s)$^$t_s$\n\n其中 u，v 互质，且 v 为正整数。\n\n其中$u_i/v_i$从大到小排列，若$u_i/v_i = 0$ 则该项为 $x$^$t_i$，若$u_i/v_i$为负数，则省略加号，若$v_i$为 $1$，则省略$/v_i$。\n\n若$t_i$为 $1$ 则省略^$t_i$。\n\n若$a_n$为$±1$ 则将 $1$ 省略。\n\n详见样例输出。", "hint": "测试点编号|多项式最高次数|互异零点数|系数范围(绝对值)\n:-:|:-:|:-:|:-:\n$1$|$2$|$2$|$≤ 10$\n$2$|$4$|$4$|$≤ 100$\n$3$|$7$|$7$|$≤ 10 ^ 6$\n$4$|$10$|$10$|$≤ 10 ^ 7$\n$5$|$12$|$12$|$≤ 10 ^ {16}$\n$6$|$35$|$5$|$≤ 10 ^ {24}$\n$7$|$39$|$5$|$≤ 10 ^ {68}$\n$8$|$46$|$4$|$≤ 10 ^ {104}$\n$9$|$80$|$2$|$≤ 10 ^ {12}$\n$10$|$50$|$1$|$≤ 10 ^ {316}$\n\n$p_i,q_i$满足：\n\n$$\\prod_{i=1}^rp_i≤10^6,\\prod_{i=1}^rq_i≤10^6$$", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2013] Factorization", "background": "", "description": "By the Fundamental Theorem of Algebra, counting multiplicity, a degree $n$ polynomial over the complex numbers has exactly $n$ zeros (points where the function value is $0$). You are given an integer-coefficient polynomial $F[x]$ whose $n$ zeros are all rational numbers (i.e., can be written as a ratio of two integers). If we deduplicate all nonzero zeros (the variable is not $0$ while the function value is $0$), we obtain $r$ distinct nonzero zeros, where the $i$-th nonzero zero can be written as:\n$$sgn_i \\times \\frac{q_i}{p_i}$$\nHere $sgn_i$ denotes the sign of the $i$-th zero, and $p_i$ and $q_i$ are two coprime positive integers.\n\nYou are given $F[x]$. Output its factorized form.", "inputFormat": "The input contains exactly one line: the polynomial $F[x]$.\n\nThe polynomial is always given in the following form:\n$ a_n x^n + a_{n-1} x^{n-1} + \\cdots + a_1 x + a_0 $\n\nThe terms are in descending degree. Each $a_i$ is an integer. If $a_i = 0$, that term is omitted. If $a_i$ is negative, the preceding plus sign is omitted. If $|a_i| = 1$ and $i \\ne 0$, the $1$ is not printed. It is guaranteed that $a_n \\ne 0$. See the sample input.", "outputFormat": "Output one line: the factorized form in the following format:\n$ a_n (x + u_1 / v_1)^{t_1} (x + u_2 / v_2)^{t_2} \\cdots (x + u_s / v_s)^{t_s} $\n\nHere $u$ and $v$ are coprime, and $v$ is a positive integer.\n\n$u_i / v_i$ are sorted from largest to smallest. If $u_i / v_i = 0$, that factor is $x^{t_i}$. If $u_i / v_i$ is negative, the plus sign is omitted. If $v_i = 1$, then $/ v_i$ is omitted.\n\nIf $t_i = 1$, the exponent is omitted.\n\nIf $a_n = \\pm 1$, the $1$ is omitted. See the sample output.", "hint": "测试点编号|多项式最高次数|互异零点数|系数范围(绝对值)\n:-:|:-:|:-:|:-:\n$1$|$2$|$2$|$\\le 10$\n$2$|$4$|$4$|$\\le 100$\n$3$|$7$|$7$|$\\le 10^6$\n$4$|$10$|$10$|$\\le 10^7$\n$5$|$12$|$12$|$\\le 10^{16}$\n$6$|$35$|$5$|$\\le 10^{24}$\n$7$|$39$|$5$|$\\le 10^{68}$\n$8$|$46$|$4$|$\\le 10^{104}$\n$9$|$80$|$2$|$\\le 10^{12}$\n$10$|$50$|$1$|$\\le 10^{316}$\n\n$p_i, q_i$ satisfy:\n$$\\prod_{i=1}^r p_i \\le 10^6, \\prod_{i=1}^r q_i \\le 10^6.$$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2013] 因式分解", "background": "", "description": "通过代数基本定理，我们知道若计算重根，一个 n 次的多项式在复数域内恰好有 n 个零点(函数值为 0 的点)。现给定一个整系数多项式 F[x]，它的 n 个零点恰好都是有理数(即可以写成两个整数相除的形式)；同时，若我们把它所有的非零零点(函数自变量不为 0，函数值为 0)去重，则可以得到 r 个互不相同的非零零点，其中第 i 个非零零点可以被表示成下式：\n\n$$sgn_i \\times \\frac{q_i}{p_i}$$\n\n式中$sgn_i$表示第 i 个零点的符号，$p_i$和$q_i$为互质的两个正整数。\n\n现在告诉你 F[x]，要求你输出将他因式分解后的形式。", "inputFormat": "输入只有一行，包含多项式 F[x]。\n\n多项式一定是如下的形式：\n\n$a_n x$^$n + a_{n-1}x$^${n - 1} + ⋯ a_1x + a_0$\n\n次数一定为从高到低，其中$a_i$为整数，并且若$a_i$为 0，则省略该项，若$a_i$为负数，则省略之前的加号，若$a_i$的绝对值为 1 且 i 不为 0，则不输出 1，并且保证$a_n$不为 0.\n\n详见样例输入。", "outputFormat": "输出一行，表示因式分解后的形式，格式如下：\n\n$a_n (x + u_1/v_1)$^$t_1(x + u_2/v_2)$^$t_2 … (x + u_s/v_s)$^$t_s$\n\n其中 u，v 互质，且 v 为正整数。\n\n其中$u_i/v_i$从大到小排列，若$u_i/v_i = 0$ 则该项为 $x$^$t_i$，若$u_i/v_i$为负数，则省略加号，若$v_i$为 $1$，则省略$/v_i$。\n\n若$t_i$为 $1$ 则省略^$t_i$。\n\n若$a_n$为$±1$ 则将 $1$ 省略。\n\n详见样例输出。", "hint": "测试点编号|多项式最高次数|互异零点数|系数范围(绝对值)\n:-:|:-:|:-:|:-:\n$1$|$2$|$2$|$≤ 10$\n$2$|$4$|$4$|$≤ 100$\n$3$|$7$|$7$|$≤ 10 ^ 6$\n$4$|$10$|$10$|$≤ 10 ^ 7$\n$5$|$12$|$12$|$≤ 10 ^ {16}$\n$6$|$35$|$5$|$≤ 10 ^ {24}$\n$7$|$39$|$5$|$≤ 10 ^ {68}$\n$8$|$46$|$4$|$≤ 10 ^ {104}$\n$9$|$80$|$2$|$≤ 10 ^ {12}$\n$10$|$50$|$1$|$≤ 10 ^ {316}$\n\n$p_i,q_i$满足：\n\n$$\\prod_{i=1}^rp_i≤10^6,\\prod_{i=1}^rq_i≤10^6$$", "locale": "zh-CN"}}}
{"pid": "P4507", "type": "P", "difficulty": 6, "samples": [["3 4\n0.50 0.60 0.40\n0.40 0.50 0.70\n0.60 0.30 0.50\n110\n011\n111\n000", "0.71304348\n0.66086957\n1.00000000\n0.00000000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2013", "Special Judge", "CTSC/CTS"], "title": "[CTSC2013] 猴子大战", "background": "", "description": "小 Q 和小 M 最近发明了一种卡牌游戏，叫猴子大战。\n\n游戏最初小 Q 和小 M 各会取得一部分猴子牌。每局游戏，他们两个需要分别等概率地从自己的猴子牌中抽取一张进行战斗。获胜的一方将获得双方的猴子牌。如果一方获得了所有的猴子牌，则该方获得整场游戏的胜利。否则游戏将一直进行下去。\n\n在进行了若干场比赛以后，小 Q 和小 M 算出了一张胜率表，为每张猴子牌之间进行战斗双方获胜的概率。由于每场战斗一定会决出胜负，而且胜率不受先后顺序的影响，因此对于任意的两张猴子牌 A 和 B，A 战胜 B 的概率加 B 战胜 A 的概率为 $1$。\n\n由于自己老是输给小 M，小 Q 开始怀疑自己每次拿到的猴子牌是否能获得胜利。他希望求出自己拿到的每种猴子牌组合的获胜的概率。\n\n由于小 Q 接下来还有在 CD 市体育中心数以万计的运动计划，因此这个问题只能交给你来解决了。", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $m$，表示猴子牌的总张数和需要求的猴子牌组合的个数。\n\n接下来有 $n$ 行，每行包含 $n$ 个实数，每个实数保留了两位小数。这 $n$ 行中，其中第 $i$ 行第 $j$ 列的数为$P_{i,j}$，表示第 i 张猴子牌战胜第 $j$ 张猴子牌的概率。保证$P_{i,j} + P_{j,i} = 1$。特别地，$P_{i,i} = 0.5$，没有特殊意义。\n\n最后有 $m$ 行。每行包含一个长度为 $n$ 的无空格分隔的 $01$ 串，表示一个猴子牌的组合。其中第 $i$ 个字符如果为 $0$，表示最初第 $i$ 张牌在小 M 处，否则表示在小 Q 处。", "outputFormat": "输出 $m$ 行，每行一个实数，四舍五入保留八位小数（请强制输出八位浮点数），依次表示每个给定的猴子牌组合下小 Q 获胜的概率。", "hint": "**【评分方法】**\n\n你的答案的每一行如果与我们给定的参考答案的差别均不超过 $2 \\times 10^{-6}$，则获得该测试点的得分，否则不得分。\n\n参考答案保证与真实值的差别不超过 $10 ^ {-8}$，因此如果你输出的答案保证与真实值差别不超过 $2 \\times 10^{-6}\\sim 10 ^ {-8}$，才能保证正确。\n\n**【数据规模及约定】**\n\n对于每组数据，$n$ 的取值如下\n\n测试点编号|$n$|测试点编号|$n$\n:-:|:-:|:-:|:-:\n1|$n = 2$|6|$n = 20$\n2|$n = 5$|7|$n = 40$\n3|$n = 7$|8|$n = 60$\n4|$n = 8$|9|$n = 80$\n5|$n = 10$|10|$n = 100$\n\n对于 100%的数据，保证 $1 ≤ n ≤ 100$，$1 ≤ m ≤ n^2$。$0 ≤ P_{i,j} ≤ 1$，$P_{i,j}$恰好包含 $2$ 位小数，且 $P_{i,j} + P_{j,i} = 1$.表示猴子牌组合的 $01$ 串长度均为 $n$，且不含其他字符。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2013] Monkey War", "background": "", "description": "Xiao Q and Xiao M recently invented a card game called Monkey War.\n\nAt the start, Xiao Q and Xiao M each receive some monkey cards. In each round, the two players independently draw one card uniformly at random from their own current cards to fight. The winner takes both cards used in that round. If one player obtains all the monkey cards, that player wins the whole game; otherwise, the game continues.\n\nAfter several matches, Xiao Q and Xiao M computed a win-rate table that gives, for every pair of monkey cards, the probability that one card beats the other. Since every fight has a decisive outcome and the win rate does not depend on order, for any two cards A and B, the probability that A beats B plus the probability that B beats A is $1$.\n\nSince he keeps losing to Xiao M, Xiao Q starts to doubt whether the cards he gets can ever win overall. He wants the probability that he wins for every initial allocation of monkey cards he might receive.\n\nBecause Xiao Q has tens of thousands of sports plans coming up at the CD City Sports Center, this problem is left to you to solve.", "inputFormat": "The first line contains two positive integers $n$ and $m$, the total number of monkey cards and the number of initial allocations to query.\n\nThe next $n$ lines each contain $n$ real numbers with two decimal places. Among these $n$ lines, the number in row $i$, column $j$ is $P_{i,j}$, the probability that card $i$ beats card $j$. It is guaranteed that $P_{i,j} + P_{j,i} = 1$. In particular, $P_{i,i} = 0.5$, which has no special meaning.\n\nThe last $m$ lines each contain a length-$n$ 01 string with no spaces, representing an initial allocation of cards. If the $i$-th character is '0', then card $i$ initially belongs to Xiao M; otherwise it belongs to Xiao Q.", "outputFormat": "Output $m$ lines. Each line should contain a real number, rounded to 8 decimal places (print exactly 8 digits after the decimal point), representing Xiao Q’s probability of winning under the corresponding initial allocation.", "hint": "Scoring method:\n- If each line of your output differs from the reference answer by at most $2 \\times 10^{-6}$, you will receive credit for that test point; otherwise, you will receive no credit.\n- The reference answers differ from the true values by at most $10^{-8}$. Therefore, to be correct, your output should differ from the true values by at most $2 \\times 10^{-6} \\sim 10^{-8}$.\n\nConstraints:\n- For each set of testdata, $n$ takes the following values:\n\nTest point ID|$n$|Test point ID|$n$\n:-:|:-:|:-:|:-:\n1|$n = 2$|6|$n = 20$\n2|$n = 5$|7|$n = 40$\n3|$n = 7$|8|$n = 60$\n4|$n = 8$|9|$n = 80$\n5|$n = 10$|10|$n = 100$\n\n- For 100% of the testdata, $1 \\le n \\le 100$, $1 \\le m \\le n^2$. $0 \\le P_{i,j} \\le 1$, $P_{i,j}$ has exactly 2 decimal places, and $P_{i,j} + P_{j,i} = 1$. The 01 strings that represent initial allocations all have length $n$ and contain no other characters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2013] 猴子大战", "background": "", "description": "小 Q 和小 M 最近发明了一种卡牌游戏，叫猴子大战。\n\n游戏最初小 Q 和小 M 各会取得一部分猴子牌。每局游戏，他们两个需要分别等概率地从自己的猴子牌中抽取一张进行战斗。获胜的一方将获得双方的猴子牌。如果一方获得了所有的猴子牌，则该方获得整场游戏的胜利。否则游戏将一直进行下去。\n\n在进行了若干场比赛以后，小 Q 和小 M 算出了一张胜率表，为每张猴子牌之间进行战斗双方获胜的概率。由于每场战斗一定会决出胜负，而且胜率不受先后顺序的影响，因此对于任意的两张猴子牌 A 和 B，A 战胜 B 的概率加 B 战胜 A 的概率为 $1$。\n\n由于自己老是输给小 M，小 Q 开始怀疑自己每次拿到的猴子牌是否能获得胜利。他希望求出自己拿到的每种猴子牌组合的获胜的概率。\n\n由于小 Q 接下来还有在 CD 市体育中心数以万计的运动计划，因此这个问题只能交给你来解决了。", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $m$，表示猴子牌的总张数和需要求的猴子牌组合的个数。\n\n接下来有 $n$ 行，每行包含 $n$ 个实数，每个实数保留了两位小数。这 $n$ 行中，其中第 $i$ 行第 $j$ 列的数为$P_{i,j}$，表示第 i 张猴子牌战胜第 $j$ 张猴子牌的概率。保证$P_{i,j} + P_{j,i} = 1$。特别地，$P_{i,i} = 0.5$，没有特殊意义。\n\n最后有 $m$ 行。每行包含一个长度为 $n$ 的无空格分隔的 $01$ 串，表示一个猴子牌的组合。其中第 $i$ 个字符如果为 $0$，表示最初第 $i$ 张牌在小 M 处，否则表示在小 Q 处。", "outputFormat": "输出 $m$ 行，每行一个实数，四舍五入保留八位小数（请强制输出八位浮点数），依次表示每个给定的猴子牌组合下小 Q 获胜的概率。", "hint": "**【评分方法】**\n\n你的答案的每一行如果与我们给定的参考答案的差别均不超过 $2 \\times 10^{-6}$，则获得该测试点的得分，否则不得分。\n\n参考答案保证与真实值的差别不超过 $10 ^ {-8}$，因此如果你输出的答案保证与真实值差别不超过 $2 \\times 10^{-6}\\sim 10 ^ {-8}$，才能保证正确。\n\n**【数据规模及约定】**\n\n对于每组数据，$n$ 的取值如下\n\n测试点编号|$n$|测试点编号|$n$\n:-:|:-:|:-:|:-:\n1|$n = 2$|6|$n = 20$\n2|$n = 5$|7|$n = 40$\n3|$n = 7$|8|$n = 60$\n4|$n = 8$|9|$n = 80$\n5|$n = 10$|10|$n = 100$\n\n对于 100%的数据，保证 $1 ≤ n ≤ 100$，$1 ≤ m ≤ n^2$。$0 ≤ P_{i,j} ≤ 1$，$P_{i,j}$恰好包含 $2$ 位小数，且 $P_{i,j} + P_{j,i} = 1$.表示猴子牌组合的 $01$ 串长度均为 $n$，且不含其他字符。", "locale": "zh-CN"}}}
{"pid": "P4508", "type": "P", "difficulty": 7, "samples": [["8 6 1\n0.0 0.0 0.0\n0.0 0.0 1.0\n0.0 1.0 1.0\n0.0 1.0 0.0\n1.0 0.0 0.0\n1.0 0.0 1.0\n1.0 1.0 1.0\n1.0 1.0 0.0\n4 2 3 7 6\n4 5 6 7 8\n4 1 2 3 4\n4 1 2 6 5\n4 4 3 7 8\n4 1 4 8 5\n2.0 0.33 0.25\n2.0 0.67 0.25\n2.0 0.33 0.75\n-1.0 0.0 0.0", "0.17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "提交答案", "CTSC/CTS"], "title": "[CTSC2011] 杀菌计划", "background": "输入数据下发链接: https://pan.baidu.com/s/1ltIqAf8bdtnAFrFTnVtgHA", "description": "栋栋有一个凸多面体形状的漂亮盒子，这个盒子的每个面都由形状为凸多边形的透明玻璃薄壁组成。\n\n每隔一段时间，栋栋就要使用一个激光发射器给他的盒子杀菌。激光发射器能发射出一束激光，当激光照射到盒子的玻璃薄壁时，会把薄壁内外两面的细菌杀死，同时有大量光线透射过玻璃，少量光线被玻璃反射。透射过玻璃的光线沿原方向前进，反射的光线遵循光线的镜面反射定理，即在反射时反射光线、入射光线和镜面的法线在同一平面内，反射光线与入射光线分居法线两侧，反射角（反射光线与法线的夹角）等于入射角（入射光线与法线的夹角）。\n\n我们认为激光被玻璃反射k 次后的能量不足以杀死细菌（即使有多个这样的光线同时照射在玻璃薄壁上也不能杀死细菌），而k 次反射前激光照射到的细菌都会被杀死。\n\n激光发射器的发射口是三角形的，当发射激光时，整个发射口都会发出激光。\n\n给定盒子和激光发射器的位置，栋栋想知道，盒子的玻璃薄壁上有多大面积\n的细菌被杀死了。由于盒子的内外两面的细菌必然是同时被杀死或者同时不被杀死，所以只要算出外面被杀死的细菌面积即可。\n\n注意，激光或经过反射的激光可能与某些表面平行，但本题的数据保证激光或经过反射的激光不会照射到与之平行的表面。", "inputFormat": "本题是一道提交答案型试题，所有输入数据box1.in ~ box10.in 已放在了试题的目录下。每个输入数据满足下面的输入格式，每两个数之间用一个空格隔开：\n\n输入的第一行包含三个整数$n, m, k$，分别表示盒子的顶点数、盒子的面数和光线的反射次数。\n\n接下来$n$ 行，第$i$ 行包含三个实数$x_i, y_i, z_i$，表示盒子第$i$ 个顶点的坐标。\n\n接下来$m$ 行，每行描述盒子的一个表面，每行第一个数$t_j$，表示该表面的多边形的顶点个数，接下来$t_j$ 个整数，表示这$t_j$ 个顶点对应的盒子顶点的编号，这些编号按顶点在面上的顺时针或逆时针顺序给出。\n\n接下来三行，每行$3$ 个整数$x, y, z$，分别表示激光发射器发射口的坐标。\n\n接下来$1$ 行，包含3 个整数$Δx, Δy, Δz$，表示出射光线的方向是沿着向量$(Δx, Δy, Δz)$的方向。", "outputFormat": "针对给定的10 个输入文件box1.in ~ box10.in，你需要分别提交你的输出文\n件 box1.out ~ box10.out。每个输出文件包含一个实数，四舍五入保留两位小数，表示被杀死的细菌的面积。当一个表面被多次照射到时，这个表面的面积只计算一次。", "hint": "样例数据如下图所示，盒子是一个正方体的形状，激光从右边照射过来，照\n射到右侧面上，并透射过右侧面照射到左侧面上，将左右两侧面上的两个三角形区域的细菌杀死。在照射到左右侧面后激光都会发生反射，但由k=1，反射光线已不能将细菌杀死，所以不用考虑。\n\n![](https://cdn.luogu.com.cn/upload/pic/17995.png)", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2011] Sterilization Plan", "background": "Input data download link: https://pan.baidu.com/s/1ltIqAf8bdtnAFrFTnVtgHA.", "description": "Dongdong has a beautiful box shaped like a convex polyhedron. Each face of the box is a thin, transparent glass panel in the shape of a convex polygon.\n\nFrom time to time, Dongdong uses a laser emitter to sterilize his box. The emitter emits a laser beam. When the beam hits a glass panel, it kills the bacteria on both the inner and outer sides of that panel. A large portion of the light transmits through the glass, and a small portion is reflected. The transmitted light continues in the same direction. The reflected light obeys the law of specular reflection: at the point of reflection, the reflected ray, the incident ray, and the surface normal lie in the same plane; the reflected ray and the incident ray lie on opposite sides of the normal; and the angle of reflection (between the reflected ray and the normal) equals the angle of incidence (between the incident ray and the normal).\n\nWe assume that after being reflected $k$ times, the laser does not have enough energy to kill bacteria (even if multiple such rays hit a glass panel simultaneously, they still cannot kill bacteria). Before $k$ reflections, all bacteria illuminated by the laser are killed.\n\nThe emitter’s aperture is triangular, and when the laser is fired, the entire aperture emits light.\n\nGiven the box and the position of the laser emitter, Dongdong wants to know the total area of bacteria killed on the box’s glass panels. Since the bacteria on the inner and outer sides of a panel are either both killed or both not killed, it suffices to compute the area killed on the outside.\n\nNote: A laser ray or a reflected ray may be parallel to some surfaces, but the testdata guarantees that no ray will illuminate any surface that is parallel to it.", "inputFormat": "This is an answer-only problem. All input files box1.in ~ box10.in are provided in the problem directory. Each input file follows the format below, with a single space between any two numbers.\n\n- The first line contains three integers $n, m, k$, denoting the number of vertices of the box, the number of faces, and the reflection limit, respectively.\n- The next $n$ lines: line $i$ contains three real numbers $x_i, y_i, z_i$, which are the coordinates of vertex $i$ of the box.\n- The next $m$ lines: each line describes one face of the box. The first number is $t_j$, the number of vertices of this polygonal face, followed by $t_j$ integers giving the indices of the corresponding box vertices in clockwise or counterclockwise order along the face.\n- The next three lines: each contains $3$ integers $x, y, z$, giving the coordinates of the laser emitter’s triangular aperture (these are its three vertices).\n- The next one line contains $3$ integers $\\Delta x, \\Delta y, \\Delta z$, indicating that the emitted rays travel in the direction of the vector $(\\Delta x, \\Delta y, \\Delta z)$.", "outputFormat": "For the given 10 input files box1.in ~ box10.in, you must submit 10 corresponding output files box1.out ~ box10.out. Each output file contains a single real number, rounded to two decimal places, representing the total area of bacteria killed. If a face is illuminated multiple times, its area is counted only once.", "hint": "As shown in the sample figure, the box is a cube. The laser comes from the right, hits the right face, and, after transmitting through the right face, hits the left face, killing two triangular regions on the left and right faces. The rays also reflect at both faces, but since $k = 1$, the reflected rays can no longer kill bacteria, so they can be ignored.\n\n![](https://cdn.luogu.com.cn/upload/pic/17995.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2011] 杀菌计划", "background": "输入数据下发链接: https://pan.baidu.com/s/1ltIqAf8bdtnAFrFTnVtgHA", "description": "栋栋有一个凸多面体形状的漂亮盒子，这个盒子的每个面都由形状为凸多边形的透明玻璃薄壁组成。\n\n每隔一段时间，栋栋就要使用一个激光发射器给他的盒子杀菌。激光发射器能发射出一束激光，当激光照射到盒子的玻璃薄壁时，会把薄壁内外两面的细菌杀死，同时有大量光线透射过玻璃，少量光线被玻璃反射。透射过玻璃的光线沿原方向前进，反射的光线遵循光线的镜面反射定理，即在反射时反射光线、入射光线和镜面的法线在同一平面内，反射光线与入射光线分居法线两侧，反射角（反射光线与法线的夹角）等于入射角（入射光线与法线的夹角）。\n\n我们认为激光被玻璃反射k 次后的能量不足以杀死细菌（即使有多个这样的光线同时照射在玻璃薄壁上也不能杀死细菌），而k 次反射前激光照射到的细菌都会被杀死。\n\n激光发射器的发射口是三角形的，当发射激光时，整个发射口都会发出激光。\n\n给定盒子和激光发射器的位置，栋栋想知道，盒子的玻璃薄壁上有多大面积\n的细菌被杀死了。由于盒子的内外两面的细菌必然是同时被杀死或者同时不被杀死，所以只要算出外面被杀死的细菌面积即可。\n\n注意，激光或经过反射的激光可能与某些表面平行，但本题的数据保证激光或经过反射的激光不会照射到与之平行的表面。", "inputFormat": "本题是一道提交答案型试题，所有输入数据box1.in ~ box10.in 已放在了试题的目录下。每个输入数据满足下面的输入格式，每两个数之间用一个空格隔开：\n\n输入的第一行包含三个整数$n, m, k$，分别表示盒子的顶点数、盒子的面数和光线的反射次数。\n\n接下来$n$ 行，第$i$ 行包含三个实数$x_i, y_i, z_i$，表示盒子第$i$ 个顶点的坐标。\n\n接下来$m$ 行，每行描述盒子的一个表面，每行第一个数$t_j$，表示该表面的多边形的顶点个数，接下来$t_j$ 个整数，表示这$t_j$ 个顶点对应的盒子顶点的编号，这些编号按顶点在面上的顺时针或逆时针顺序给出。\n\n接下来三行，每行$3$ 个整数$x, y, z$，分别表示激光发射器发射口的坐标。\n\n接下来$1$ 行，包含3 个整数$Δx, Δy, Δz$，表示出射光线的方向是沿着向量$(Δx, Δy, Δz)$的方向。", "outputFormat": "针对给定的10 个输入文件box1.in ~ box10.in，你需要分别提交你的输出文\n件 box1.out ~ box10.out。每个输出文件包含一个实数，四舍五入保留两位小数，表示被杀死的细菌的面积。当一个表面被多次照射到时，这个表面的面积只计算一次。", "hint": "样例数据如下图所示，盒子是一个正方体的形状，激光从右边照射过来，照\n射到右侧面上，并透射过右侧面照射到左侧面上，将左右两侧面上的两个三角形区域的细菌杀死。在照射到左右侧面后激光都会发生反射，但由k=1，反射光线已不能将细菌杀死，所以不用考虑。\n\n![](https://cdn.luogu.com.cn/upload/pic/17995.png)", "locale": "zh-CN"}}}
{"pid": "P4509", "type": "P", "difficulty": 6, "samples": [["2 3 0\n0 0\n1 1\nH 0 1 0 -1 1\nH 1 0 1 1 1\nH 2 -1 -1 1 1", "1\n0\n1"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "CTSC/CTS"], "title": "[CTSC2015] 葱", "background": "", "description": "小葱和小绪是一对好朋友，自从小葱11连出了1UR2SR之后，小绪就觉得小葱的人品特别好，于是小绪给小葱出了一道题来测试小葱的人品。 \n\n小绪首先在平面上画了$N$个点，分别是$P_1,P_2,...,P_N$。\n\n小绪把这$N个点$顺次相连，即连接$(P_1,P_2),(P_2,P_3),...,(P_{N-1},P_N)$，得到$N-1$条线段。 \n\n之后小绪每次在平面上画出一条直线，然后问小葱这条直线与多少条线段相交。特别的，在线段端点处相交算作相交，直线完全覆盖线段时也算作相交。 这样的问题自然难不倒小葱，小葱只需要凭自己的人品用直觉就能给出正确的答案。 \n\n小绪想测试小葱的人品究竟有多好，于是他加大了问题的难度： 除了每次询问以外，小绪会不时地讲一个新的点$P$插入到$P_i$和$P_{i+1}$之间，然后按照顺序对所有的点重新标记下标，即在$P_i$之后的点的下标会依次增加，而点$P$会变成新的点$P_{i+1}$。\n\n特别的，点$P$也可以插入到第一个点之前或最后一个点之后。\n \n人品超级好的小葱依旧能够轻松的给出答案，于是小绪又进一步提高了难度： \n\n每次插入或提问之后，小绪都将操作后的所有线段记录了下来，称作一个历史版本。历史版本$T$表示在第$T$次操作后得到的历史版本。 \n\n插入新点的操作改为了在某一个历史版本$T$的基础上，插入一个点$P$，并得到一个新的历史版本。 \n\n小绪对小葱的提问改为了对于一个历史版本$T$，给出一条直线，询问这条直线会与多少条线段相交。 \n\n小葱虽然人品很好，但面对这样的问题却也束手无策了，他只好找到来参加CTSC的你，请你来帮他解决这个问题。 ", "inputFormat": "第一行两个整数$N,M,C$，表示一开始的点数和总共的操作数，以及数据是否加密。\n\n如果$C=1$，那么代表数据被加密过，每次询问操作中的$X_0,Y_0,X,Y$以及插入操作中的$X,Y$都是被加密过的数据，你需要将它们异或last_ans从而得到正确的数据，其中last_ans是上一次询问的答案，刚开始last_ans=0。 \n\n接下来$N$行每行两个整数，其中第$i$行的两个整数表示$P_i$的横坐标和纵坐标。 \n\n接下来$M$行，表示小绪的$M$次操作，其中第$i$行（从$1$开始标号）操作后得到的结果为历史版本$i$。\n \n对于每次操作，首先会有一个字母代表小绪的这次操作的操作类型。\n \n如果这个字母是$'H'$，代表本次操作为一次询问操作。接下来会有五个整数$T,X_0,Y_0,X,Y$，代表在历史版本$T$的情况下，小绪给出一条经过$(X_0,Y_0)$，方向为$(X,Y)$的直线，小葱要回答出它会和多少条直线相交。 \n\n如果这个字母是$'Z'$，代表本次操作为一次插入操作。接下来会有四个数$T,i,X,Y$，代表小绪在历史版本$T$的基础上，在$P_i$后面插入了一个坐标为$(X,Y)$的点。特别地，如果$i=0$，表示该点在$P_1$之前。 ", "outputFormat": "要求对每一次询问操作，输出一行一个整数代表小葱应该回答的正确答案。 ", "hint": "样例解释1： \n\n对于第三次询问，直线完全覆盖了线段，小绪会认为这也算相交。 \n\n\n数据规模和约定： \n\n保证每次询问操作的$T$一定小于等于当前操作的数量，所有输入数据均为整数。 \n\n有以下$4$类特殊数据，它们两两没有交集： \n\n1. 对于10%的数据，保证$1≤N,M≤1000$； \n\n2. 对于15%的数据，保证对于第$i$次操作，$T=i-1$； \n\n3. 对于15%的数据，保证$C=0$且不存在修改操作； \n\n4. 对于15%的数据，对于询问操作，保证$Y=0$（加密过的数据指解密后的$Y$），即给出的直线平行于$x$轴。 \n\n以上数据还保证$1≤N,M≤5*10^4$。 \n\n对于100%的数据，保证$1≤N,M≤10^5$，所有的坐标范围在$[-10^8,10^8]$内，且每组数据中所有询问的答案总和不超过$10^6$，插入操作的次数不会超过$5*10^4$。注意这些线段可能会互相相交。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2015] Onion", "background": "", "description": "Xiao Cong and Xiao Xu are good friends. Since Xiao Cong pulled 1 UR and 2 SR in an 11-roll, Xiao Xu felt that Xiao Cong is very lucky, so he gave him a problem to test his luck.\n\nXiao Xu first drew $N$ points on the plane, denoted as $P_1, P_2, ..., P_N$.\n\nHe connected these $N$ points in order, that is, he connected $(P_1, P_2), (P_2, P_3), ..., (P_{N-1}, P_N)$ to obtain $N-1$ line segments.\n\nThen, each time Xiao Xu drew a line on the plane and asked how many segments this line intersects. In particular, intersection at a segment endpoint counts as intersecting, and if the line completely covers a segment, it also counts as intersecting. Such a question is obviously easy for Xiao Cong; he can give the correct answer by intuition alone thanks to his luck.\n\nTo further test Xiao Cong’s luck, Xiao Xu increased the difficulty: in addition to each query, he would occasionally insert a new point $P$ between $P_i$ and $P_{i+1}$, then relabel all points in order; that is, the indices of points after $P_i$ increase by one, and point $P$ becomes the new point $P_{i+1}$.\n\nIn particular, point $P$ can also be inserted before the first point or after the last point.\n\nXiao Cong is still able to answer easily, so Xiao Xu raised the difficulty again:\n\nAfter each insertion or query, Xiao Xu recorded all the resulting segments and regarded them as a historical version. Historical version $T$ denotes the state after the $T$-th operation.\n\nThe insertion operation was changed to: based on a certain historical version $T$, insert a point $P$ to obtain a new historical version.\n\nThe query was changed to: for a historical version $T$, given a line, ask how many segments this line will intersect.\n\nAlthough Xiao Cong has great luck, he is helpless in the face of such a problem. He turns to you, a participant of CTSC, to help him solve it.", "inputFormat": "The first line contains three integers $N, M, C$, denoting the initial number of points, the total number of operations, and whether the data are encrypted.\n\nIf $C=1$, it means the data are encrypted. In each query operation, $X_0, Y_0, X, Y$ and in each insertion operation, $X, Y$ are encrypted; you need to XOR them with last_ans to obtain the correct data, where last_ans is the answer to the previous query. Initially, last_ans $= 0$.\n\nThe next $N$ lines each contain two integers; on the $i$-th line, the two integers denote the coordinates of $P_i$.\n\nThe next $M$ lines describe Xiao Xu’s $M$ operations. The result after the $i$-th operation (1-indexed) is historical version $i$.\n\nFor each operation, there is first a letter indicating the operation type.\n\n- If the letter is 'H', this is a query operation. Then five integers $T, X_0, Y_0, X, Y$ follow, meaning that under historical version $T$, Xiao Xu gives a line passing through $(X_0, Y_0)$ with direction $(X, Y)$, and Xiao Cong must answer how many segments it intersects.\n- If the letter is 'Z', this is an insertion operation. Then four numbers $T, i, X, Y$ follow, meaning that based on historical version $T$, Xiao Xu inserts a point with coordinates $(X, Y)$ after $P_i$. In particular, if $i=0$, it means the point is inserted before $P_1$.", "outputFormat": "For each query operation, output one line with one integer representing the correct answer Xiao Cong should give.", "hint": "Sample explanation 1:\n\nFor the third query, the line completely covers a segment, and Xiao Xu considers this as intersecting as well.\n\nConstraints and notes:\n\nAll operations satisfy that in each query operation, $T$ is less than or equal to the current number of operations, and all input numbers are integers.\n\nThere are the following 4 special testdata groups, which are pairwise disjoint:\n\n1. For 10% of the testdata, $1 \\le N, M \\le 1000$.\n2. For 15% of the testdata, for the $i$-th operation, $T = i - 1$.\n3. For 15% of the testdata, $C=0$ and there are no modification operations.\n4. For 15% of the testdata, for query operations, $Y=0$ (this refers to the decrypted data), i.e., the given line is parallel to the $x$-axis.\n\nThe above testdata also guarantee $1 \\le N, M \\le 5 \\times 10^4$.\n\nFor 100% of the testdata, $1 \\le N, M \\le 10^5$, all coordinates are within $[-10^8, 10^8]$, and within each dataset the sum of answers over all queries does not exceed $10^6$. The number of insertion operations does not exceed $5 \\times 10^4$. Note that these segments may intersect each other.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2015] 葱", "background": "", "description": "小葱和小绪是一对好朋友，自从小葱11连出了1UR2SR之后，小绪就觉得小葱的人品特别好，于是小绪给小葱出了一道题来测试小葱的人品。 \n\n小绪首先在平面上画了$N$个点，分别是$P_1,P_2,...,P_N$。\n\n小绪把这$N个点$顺次相连，即连接$(P_1,P_2),(P_2,P_3),...,(P_{N-1},P_N)$，得到$N-1$条线段。 \n\n之后小绪每次在平面上画出一条直线，然后问小葱这条直线与多少条线段相交。特别的，在线段端点处相交算作相交，直线完全覆盖线段时也算作相交。 这样的问题自然难不倒小葱，小葱只需要凭自己的人品用直觉就能给出正确的答案。 \n\n小绪想测试小葱的人品究竟有多好，于是他加大了问题的难度： 除了每次询问以外，小绪会不时地讲一个新的点$P$插入到$P_i$和$P_{i+1}$之间，然后按照顺序对所有的点重新标记下标，即在$P_i$之后的点的下标会依次增加，而点$P$会变成新的点$P_{i+1}$。\n\n特别的，点$P$也可以插入到第一个点之前或最后一个点之后。\n \n人品超级好的小葱依旧能够轻松的给出答案，于是小绪又进一步提高了难度： \n\n每次插入或提问之后，小绪都将操作后的所有线段记录了下来，称作一个历史版本。历史版本$T$表示在第$T$次操作后得到的历史版本。 \n\n插入新点的操作改为了在某一个历史版本$T$的基础上，插入一个点$P$，并得到一个新的历史版本。 \n\n小绪对小葱的提问改为了对于一个历史版本$T$，给出一条直线，询问这条直线会与多少条线段相交。 \n\n小葱虽然人品很好，但面对这样的问题却也束手无策了，他只好找到来参加CTSC的你，请你来帮他解决这个问题。 ", "inputFormat": "第一行两个整数$N,M,C$，表示一开始的点数和总共的操作数，以及数据是否加密。\n\n如果$C=1$，那么代表数据被加密过，每次询问操作中的$X_0,Y_0,X,Y$以及插入操作中的$X,Y$都是被加密过的数据，你需要将它们异或last_ans从而得到正确的数据，其中last_ans是上一次询问的答案，刚开始last_ans=0。 \n\n接下来$N$行每行两个整数，其中第$i$行的两个整数表示$P_i$的横坐标和纵坐标。 \n\n接下来$M$行，表示小绪的$M$次操作，其中第$i$行（从$1$开始标号）操作后得到的结果为历史版本$i$。\n \n对于每次操作，首先会有一个字母代表小绪的这次操作的操作类型。\n \n如果这个字母是$'H'$，代表本次操作为一次询问操作。接下来会有五个整数$T,X_0,Y_0,X,Y$，代表在历史版本$T$的情况下，小绪给出一条经过$(X_0,Y_0)$，方向为$(X,Y)$的直线，小葱要回答出它会和多少条直线相交。 \n\n如果这个字母是$'Z'$，代表本次操作为一次插入操作。接下来会有四个数$T,i,X,Y$，代表小绪在历史版本$T$的基础上，在$P_i$后面插入了一个坐标为$(X,Y)$的点。特别地，如果$i=0$，表示该点在$P_1$之前。 ", "outputFormat": "要求对每一次询问操作，输出一行一个整数代表小葱应该回答的正确答案。 ", "hint": "样例解释1： \n\n对于第三次询问，直线完全覆盖了线段，小绪会认为这也算相交。 \n\n\n数据规模和约定： \n\n保证每次询问操作的$T$一定小于等于当前操作的数量，所有输入数据均为整数。 \n\n有以下$4$类特殊数据，它们两两没有交集： \n\n1. 对于10%的数据，保证$1≤N,M≤1000$； \n\n2. 对于15%的数据，保证对于第$i$次操作，$T=i-1$； \n\n3. 对于15%的数据，保证$C=0$且不存在修改操作； \n\n4. 对于15%的数据，对于询问操作，保证$Y=0$（加密过的数据指解密后的$Y$），即给出的直线平行于$x$轴。 \n\n以上数据还保证$1≤N,M≤5*10^4$。 \n\n对于100%的数据，保证$1≤N,M≤10^5$，所有的坐标范围在$[-10^8,10^8]$内，且每组数据中所有询问的答案总和不超过$10^6$，插入操作的次数不会超过$5*10^4$。注意这些线段可能会互相相交。", "locale": "zh-CN"}}}
{"pid": "P4510", "type": "P", "difficulty": 7, "samples": [["3 2 6 2\nMMMFFF\n10000 200 10 10000 200 10\n1 2 3 \n4 5 6 \n2 5 20 0.1\n3 6 20 0.9\n", "360\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2015", "网络流", "CTSC/CTS"], "title": "[CTSC2015] 性别改造计划", "background": "", "description": "21 世纪是生命科学的世纪。人类投入了大量人力物力研究生命科学，旨在对各类生物的生存机理产生更加深入的理解，以更好地了解人类自身，提高生活质量。Q 国政府首先在绵羊中开展了性别改造研究，希望通过基因重组改变性别的方式增强整个绵羊种群的生存能力。若此计划能够顺利研究成功，人类将掌握随意改变动物性别的黑科技，这将是生命科学研究史上一个重要的里程碑。\n\nQ 国政府从绵羊群中挑出 $M$ 只绵羊作为实验样本，这 $M$ 只绵羊中存在 $K$ 条长度为 $N$ 的单一性别的血缘链。所谓 “血缘链” 是指的一条由父（母）子（女）关系组成的链，比如 “爷爷 - 爸爸 - 儿子” 就是一条血缘链。“单一性别” 的意思是每条血缘链中所有个体的性别均一致，同为雄性或同为雌性。血缘链长度指的是一条血缘链中个体的数量，比如 “爷爷 - 爸爸 - 儿子” 是一条长度为 $3$ 的血缘链。这 $K$ 条血缘链并不相交。\n\n注意并不是每只绵羊都必须属于一条血缘链，有些绵羊可能不属于任何血缘链，因此 $N\\times K\\leq M$。除去血缘链外，同辈绵羊还会有 “繁衍关系” 的存在。两只异性绵羊如果曾经繁殖过后代，那么它们之间就会产生 “繁衍关系”。注意繁衍关系只会出现在同辈异性绵羊个体之间，这里 “同辈” 表示两只绵羊的辈份相同，即绵羊只会与它的兄弟姐妹辈产生 “繁衍关系”，而不会与父母或子女或其他更远的辈份之间产生 “繁衍关系”。\n\n对绵羊进行性别修改需要花费巨大的实验开销，修改绵羊 $i$ 的性别需要花费 $c_i$ 的修改代价。除此以外，修改绵羊性别还会对繁衍关系的稳定度产生影响：每对繁衍关系 $j$ 有初始稳定度 $b_j$ 和衰减系数 $d_j$，当所有的性别修改操作完成后，若双方性别均未改变，则此关系稳定度 $s_j = b_j$，若双方性别互换，则稳定度 $s_j = \\lfloor b_jd_j\\rfloor$，其他情况下稳定度 $s_j = 0$。\n\n给定每只绵羊的性别，性别修改代价，所有血缘链关系很繁衍关系，Q 国政府希望你来设计一套性别改造方案，使总收益最大。收益计算方式如下：\n\n$$\nP = \\lfloor 10 \\ln(1 + A) \\rfloor \\times S - C\n$$\n\n其中 $A$ 为改造后血缘链相邻两者为异性的情况数量，$S$ 为改造后繁衍关系稳定度之和，即 $S = \\sum\\limits_js_j$，$C$ 为修改绵羊性别带来的代价之和，即 $C = \\sum\\limits_ic_i$。", "inputFormat": "第一行包含四个非负整数 $N, K, M, P$，分别为血缘链的长度，血缘链的数量，实验样本中的总绵羊数和繁衍关系的数量。\n\n第二行为一个 $M$ 个字符的字符串，每个字符为 `M` 或 `F`，描述了这 $M$ 只绵羊的初始性别。`M` 表示雄性，`F` 表示雌性。\n\n第三行 $M$ 个正整数 $c_i$，表示修改每只绵羊性别的代价。\n\n下面 $K$ 行每行 $N$ 个整数，分别描述这 $K$ 个血缘链中绵羊编号（所有绵羊用 $1$ 到 $M$ 的整数编号），保证每条链中的绵羊均为同性，且链互不交叠。\n\n下面 $P$ 行每行三个整数 $x, y, b$ 和一个实数 $d$，表示绵羊 $x$ 与绵羊 $y$ 存在繁衍关系，且初始关系稳定度为 $b$，衰减系数为 $d$。\n\n保证 $x$ 与 $y$ 的初始性别不同，$x$ 和 $y$ 为同辈，同一条关系只会在数据中描述一次。", "outputFormat": "仅包含一行一个整数，表示改造计划的最大收益。", "hint": "**【样例解释】**\n\n改性别为 `MMFFFM`。收益为 $\\lfloor 10 \\ln(1 + 2) \\rfloor \\times(20 + 18) - (10 + 10) = 360$。$A = 2$ 是因为血缘链 $1 - 2 - 3$ 中 $2$ 与 $3$ 性别的不同，血缘链 $4 - 5 - 6$ 中 $5$ 与 $6$ 的性别不同。\n\n**【数据范围】**\n\n对于 $10\\%$ 的数据，满足 $M\\leq 20$。\n\n对于 $10\\%$ 的数据，满足 $d_j = 0$。\n\n对于 $10\\%$ 的数据，满足 $d_j = 0.5$。\n\n上述三类数据两两没有交集。 \n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 50$，$1\\leq K\\leq 4$，$1\\leq M\\leq 10 ^ 3$，$1\\leq P\\leq 10 ^ 4$，$0 \\leq d_j\\leq 1$，$0\\leq b_j, c_i \\le 10 ^ 4$，$d_j$ 的小数位数不超过 $6$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2015] Gender Modification Plan", "background": "", "description": "The 21st century is the century of life sciences. Humanity has invested extensive manpower and resources into life science research, aiming for a deeper understanding of the survival mechanisms of various organisms, so as to better understand ourselves and improve quality of life. The government of Country Q first launched gender modification research in sheep, hoping to enhance the survival ability of the entire sheep population by changing gender through gene recombination. If this plan succeeds, humans will master the black technology of arbitrarily changing animal gender, which will be an important milestone in the history of life science research.\n\nThe government of Country Q selects $M$ sheep from the flock as experimental samples. Among these $M$ sheep, there exist $K$ bloodline chains of length $N$, each of a single gender. A “bloodline chain” is a chain consisting of parent–child relationships, e.g., “grandfather – father – son” is a bloodline chain. “Single gender” means that all individuals in each bloodline chain are of the same gender, either all male or all female. The length of a bloodline chain is the number of individuals in the chain, e.g., “grandfather – father – son” has length $3$. These $K$ bloodline chains do not intersect.\n\nNote that not every sheep must belong to a bloodline chain; some sheep might belong to none. Therefore, $N \\times K \\leq M$. Beyond the bloodline chains, there can also be “mating relationships” among same-generation sheep. Two opposite-sex sheep that have reproduced offspring form a “mating relationship.” Note that a mating relationship only occurs between opposite-sex individuals of the same generation. Here, “same generation” means they are of the same generation level, i.e., a sheep only forms mating relationships with its siblings’ generation, and never with its parents, children, or individuals of more distant generations.\n\nChanging a sheep’s gender incurs a large experimental cost: changing the gender of sheep $i$ costs $c_i$. Furthermore, changing genders affects the stability of mating relationships: for each mating relationship $j$, there is an initial stability $b_j$ and an attenuation factor $d_j$. After all gender modifications are completed, if neither side’s gender changed, the stability is $s_j = b_j$; if both sides’ genders were flipped, then $s_j = \\lfloor b_j d_j \\rfloor$; in all other cases, $s_j = 0$.\n\nGiven each sheep’s gender, the gender change cost, all bloodline chains, and all mating relationships, Country Q asks you to design a gender modification plan to maximize the total profit. The profit is computed as follows:\n$$\nP = \\lfloor 10 \\ln(1 + A) \\rfloor \\times S - C.\n$$\nHere $A$ is the number of adjacent pairs within the bloodline chains that are of opposite gender after modification, $S$ is the sum of the stabilities of all mating relationships after modification, i.e., $S = \\sum\\limits_j s_j$, and $C$ is the total cost of gender changes, i.e., $C = \\sum\\limits_i c_i$.", "inputFormat": "- The first line contains four non-negative integers $N$, $K$, $M$, $P$, denoting the length of each bloodline chain, the number of bloodline chains, the total number of sheep in the sample, and the number of mating relationships, respectively.\n- The second line is a string of $M$ characters, each being `M` or `F`, describing the initial gender of the $M$ sheep. `M` stands for male, `F` stands for female.\n- The third line contains $M$ positive integers $c_i$, the cost to change the gender of each sheep.\n- The next $K$ lines each contain $N$ integers, giving the indices (from $1$ to $M$) of the sheep in each of the $K$ bloodline chains. It is guaranteed that each chain is single-gender and that the chains are disjoint.\n- The next $P$ lines each contain three integers $x$, $y$, $b$ and a real number $d$, indicating that sheep $x$ and sheep $y$ have a mating relationship with initial stability $b$ and attenuation factor $d$.\n\nIt is guaranteed that the initial genders of $x$ and $y$ are different, $x$ and $y$ are of the same generation, and each relationship appears at most once in the input.", "outputFormat": "Output a single integer on one line, the maximum achievable profit under the modification plan.", "hint": "Sample explanation:\nChange genders to `MMFFFM`. The profit is $\\lfloor 10 \\ln(1 + 2) \\rfloor \\times (20 + 18) - (10 + 10) = 360$. Here $A = 2$ because in bloodline chain $1 - 2 - 3$, sheep $2$ and $3$ are of different genders, and in bloodline chain $4 - 5 - 6$, sheep $5$ and $6$ are of different genders.\n\nConstraints:\n- For $10\\%$ of the testdata, $M \\leq 20$.\n- For $10\\%$ of the testdata, $d_j = 0$.\n- For $10\\%$ of the testdata, $d_j = 0.5$. These three categories are pairwise disjoint.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 50$, $1 \\leq K \\leq 4$, $1 \\leq M \\leq 10^3$, $1 \\leq P \\leq 10^4$, $0 \\leq d_j \\leq 1$, $0 \\leq b_j, c_i \\leq 10^4$, and the number of decimal places of $d_j$ does not exceed $6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2015] 性别改造计划", "background": "", "description": "21 世纪是生命科学的世纪。人类投入了大量人力物力研究生命科学，旨在对各类生物的生存机理产生更加深入的理解，以更好地了解人类自身，提高生活质量。Q 国政府首先在绵羊中开展了性别改造研究，希望通过基因重组改变性别的方式增强整个绵羊种群的生存能力。若此计划能够顺利研究成功，人类将掌握随意改变动物性别的黑科技，这将是生命科学研究史上一个重要的里程碑。\n\nQ 国政府从绵羊群中挑出 $M$ 只绵羊作为实验样本，这 $M$ 只绵羊中存在 $K$ 条长度为 $N$ 的单一性别的血缘链。所谓 “血缘链” 是指的一条由父（母）子（女）关系组成的链，比如 “爷爷 - 爸爸 - 儿子” 就是一条血缘链。“单一性别” 的意思是每条血缘链中所有个体的性别均一致，同为雄性或同为雌性。血缘链长度指的是一条血缘链中个体的数量，比如 “爷爷 - 爸爸 - 儿子” 是一条长度为 $3$ 的血缘链。这 $K$ 条血缘链并不相交。\n\n注意并不是每只绵羊都必须属于一条血缘链，有些绵羊可能不属于任何血缘链，因此 $N\\times K\\leq M$。除去血缘链外，同辈绵羊还会有 “繁衍关系” 的存在。两只异性绵羊如果曾经繁殖过后代，那么它们之间就会产生 “繁衍关系”。注意繁衍关系只会出现在同辈异性绵羊个体之间，这里 “同辈” 表示两只绵羊的辈份相同，即绵羊只会与它的兄弟姐妹辈产生 “繁衍关系”，而不会与父母或子女或其他更远的辈份之间产生 “繁衍关系”。\n\n对绵羊进行性别修改需要花费巨大的实验开销，修改绵羊 $i$ 的性别需要花费 $c_i$ 的修改代价。除此以外，修改绵羊性别还会对繁衍关系的稳定度产生影响：每对繁衍关系 $j$ 有初始稳定度 $b_j$ 和衰减系数 $d_j$，当所有的性别修改操作完成后，若双方性别均未改变，则此关系稳定度 $s_j = b_j$，若双方性别互换，则稳定度 $s_j = \\lfloor b_jd_j\\rfloor$，其他情况下稳定度 $s_j = 0$。\n\n给定每只绵羊的性别，性别修改代价，所有血缘链关系很繁衍关系，Q 国政府希望你来设计一套性别改造方案，使总收益最大。收益计算方式如下：\n\n$$\nP = \\lfloor 10 \\ln(1 + A) \\rfloor \\times S - C\n$$\n\n其中 $A$ 为改造后血缘链相邻两者为异性的情况数量，$S$ 为改造后繁衍关系稳定度之和，即 $S = \\sum\\limits_js_j$，$C$ 为修改绵羊性别带来的代价之和，即 $C = \\sum\\limits_ic_i$。", "inputFormat": "第一行包含四个非负整数 $N, K, M, P$，分别为血缘链的长度，血缘链的数量，实验样本中的总绵羊数和繁衍关系的数量。\n\n第二行为一个 $M$ 个字符的字符串，每个字符为 `M` 或 `F`，描述了这 $M$ 只绵羊的初始性别。`M` 表示雄性，`F` 表示雌性。\n\n第三行 $M$ 个正整数 $c_i$，表示修改每只绵羊性别的代价。\n\n下面 $K$ 行每行 $N$ 个整数，分别描述这 $K$ 个血缘链中绵羊编号（所有绵羊用 $1$ 到 $M$ 的整数编号），保证每条链中的绵羊均为同性，且链互不交叠。\n\n下面 $P$ 行每行三个整数 $x, y, b$ 和一个实数 $d$，表示绵羊 $x$ 与绵羊 $y$ 存在繁衍关系，且初始关系稳定度为 $b$，衰减系数为 $d$。\n\n保证 $x$ 与 $y$ 的初始性别不同，$x$ 和 $y$ 为同辈，同一条关系只会在数据中描述一次。", "outputFormat": "仅包含一行一个整数，表示改造计划的最大收益。", "hint": "**【样例解释】**\n\n改性别为 `MMFFFM`。收益为 $\\lfloor 10 \\ln(1 + 2) \\rfloor \\times(20 + 18) - (10 + 10) = 360$。$A = 2$ 是因为血缘链 $1 - 2 - 3$ 中 $2$ 与 $3$ 性别的不同，血缘链 $4 - 5 - 6$ 中 $5$ 与 $6$ 的性别不同。\n\n**【数据范围】**\n\n对于 $10\\%$ 的数据，满足 $M\\leq 20$。\n\n对于 $10\\%$ 的数据，满足 $d_j = 0$。\n\n对于 $10\\%$ 的数据，满足 $d_j = 0.5$。\n\n上述三类数据两两没有交集。 \n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 50$，$1\\leq K\\leq 4$，$1\\leq M\\leq 10 ^ 3$，$1\\leq P\\leq 10 ^ 4$，$0 \\leq d_j\\leq 1$，$0\\leq b_j, c_i \\le 10 ^ 4$，$d_j$ 的小数位数不超过 $6$。", "locale": "zh-CN"}}}
{"pid": "P4511", "type": "P", "difficulty": 6, "samples": [["5 10\nADD 1 5811\nADD 3 5032\nDEL 3 5032\nADD 3 5550\nADD 5 3486\nDEL 1 5811\nDEL 3 5550\nADD 4 5116\nADD 3 9563\nADD 5 94", "5811\n10843\n5811\n11361\n14847\n9036\n3486\n8602\n18165\n18259"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000, 233000]}, "tags": ["2015", "线段树", "线段树分治", "CTSC/CTS", "反悔贪心"], "title": "[CTSC2015] 日程管理", "background": "", "description": "幽香是幻想乡中一个非常有地位的人。她日理万机，事务繁多，反倒自己已经快管理不过来了。于是他决定开发一个日程管理软件来帮助自己管理任务。 \n\n对于每个任务 $i$ 有一个对应的截止日期 $t_i$ 以及收益 $p_i$，表示若幽香能在不晚于第 $t_i$ 天完成这个任务，便可以得到 $p_i$ 的收益。幽香办事的能力非常强，任何任务都可以用恰好一天的时间做完。但由于任务实在太多了，有时候并不能完成所有任务，于是幽香会想知道这个情况下，完成任务可以给她带来的最大的累积收益是多少。\n \n由于幻想乡的人们十分善变，任务总是不断发生着变化。幽香希望这个管理软件还能够支持插入一个任务，和删除一个任务的操作。 \n\n具体的说，幽香希望支持以下 $2$ 个操作： \n\n1. `ADD t p`：表示新添一个截止日期为 $t$，收益为 $p$ 的任务。 \n\n2. `DEL t p`：表示删除一个截止日期为 $t$，收益为 $p$ 的任务。如果有多个这样的任务，只删除一个。数据保证这样的任务一定存在。 \n\n在每次操作执行完毕后，你都需要输出能够完成的任务的最大收益和。 \n\n幽香一共有 $T$ 天需要安排，从第 $1$ 天到第 $T$ 天。你能帮助他写出这个高效率的软件吗？", "inputFormat": "第一行有两个整数 $T$ 和 $Q$，表示天数和操作的个数。 \n\n接下来 $Q$ 行，其中第 $i$ 行表示第 $i$ 个操作，形式为 `ADD t p` 或 `DEL t p`，其具体意义如题面所述。", "outputFormat": "对每一次操作，输出一个整数在执行完该操作后幽香能够获得的最大收益和。", "hint": "数据保证，$1\\le T,Q\\le 3\\times 10^5$。\n\n$\\text{Statement fixed by @Starrykiller.}$", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2015] Schedule Management", "background": "", "description": "Youxiang is a very influential person in Gensokyo. She handles a huge number of affairs every day, and it has become hard for her to manage them all. Therefore, she decides to develop a schedule management program to help manage her tasks.\n\nFor each task $i$, there is a deadline $t_i$ and a profit $p_i$. If Youxiang finishes this task no later than day $t_i$, she will obtain a profit of $p_i$. Youxiang is very capable and can finish any task in exactly one day. However, since there are so many tasks, she cannot always complete all of them. She wants to know, in such cases, what the maximum total profit she can obtain is.\n\nSince people in Gensokyo are fickle, tasks keep changing. Youxiang wants this management program to support inserting a task and deleting a task.\n\nSpecifically, the program should support the following 2 operations:\n\n1. `ADD t p`: Insert a new task with deadline $t$ and profit $p$.\n2. `DEL t p`: Delete one task with deadline $t$ and profit $p$. If multiple such tasks exist, delete exactly one. It is guaranteed that such a task exists.\n\nAfter each operation is executed, you need to output the maximum total profit achievable by completing tasks.\n\nYouxiang has $T$ days to schedule, from day $1$ to day $T$. Can you help her write this efficient program?", "inputFormat": "The first line contains two integers $T$ and $Q$, denoting the number of days and the number of operations.\n\nThe next $Q$ lines describe the operations. The $i$-th line is the $i$-th operation, in the form `ADD t p` or `DEL t p`, with meanings as described above.", "outputFormat": "For each operation, output one integer: the maximum total profit Youxiang can obtain after that operation is performed.", "hint": "It is guaranteed that $1 \\le T, Q \\le 3 \\times 10^5$.\n\n$\\text{Statement fixed by @Starrykiller.}$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2015] 日程管理", "background": "", "description": "幽香是幻想乡中一个非常有地位的人。她日理万机，事务繁多，反倒自己已经快管理不过来了。于是他决定开发一个日程管理软件来帮助自己管理任务。 \n\n对于每个任务 $i$ 有一个对应的截止日期 $t_i$ 以及收益 $p_i$，表示若幽香能在不晚于第 $t_i$ 天完成这个任务，便可以得到 $p_i$ 的收益。幽香办事的能力非常强，任何任务都可以用恰好一天的时间做完。但由于任务实在太多了，有时候并不能完成所有任务，于是幽香会想知道这个情况下，完成任务可以给她带来的最大的累积收益是多少。\n \n由于幻想乡的人们十分善变，任务总是不断发生着变化。幽香希望这个管理软件还能够支持插入一个任务，和删除一个任务的操作。 \n\n具体的说，幽香希望支持以下 $2$ 个操作： \n\n1. `ADD t p`：表示新添一个截止日期为 $t$，收益为 $p$ 的任务。 \n\n2. `DEL t p`：表示删除一个截止日期为 $t$，收益为 $p$ 的任务。如果有多个这样的任务，只删除一个。数据保证这样的任务一定存在。 \n\n在每次操作执行完毕后，你都需要输出能够完成的任务的最大收益和。 \n\n幽香一共有 $T$ 天需要安排，从第 $1$ 天到第 $T$ 天。你能帮助他写出这个高效率的软件吗？", "inputFormat": "第一行有两个整数 $T$ 和 $Q$，表示天数和操作的个数。 \n\n接下来 $Q$ 行，其中第 $i$ 行表示第 $i$ 个操作，形式为 `ADD t p` 或 `DEL t p`，其具体意义如题面所述。", "outputFormat": "对每一次操作，输出一个整数在执行完该操作后幽香能够获得的最大收益和。", "hint": "数据保证，$1\\le T,Q\\le 3\\times 10^5$。\n\n$\\text{Statement fixed by @Starrykiller.}$", "locale": "zh-CN"}}}
{"pid": "P4512", "type": "P", "difficulty": 6, "samples": [["5 1\n1 9 2 6 0 8\n1 7", "237340659 335104102 649004347 448191342 855638018\n760903695"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["快速数论变换 NTT", "模板题"], "title": "【模板】多项式除法", "background": "", "description": "给定一个 $n$ 次多项式 $F(x)$ 和一个 $m$ 次多项式  $G(x)$ ，请求出多项式 $Q(x)$, $R(x)$，满足以下条件：\n\n - $Q(x)$ 次数为 $n-m$，$R(x)$ 次数小于 $m$\n - $F(x) = Q(x) * G(x) + R(x)$\n\n所有的运算在模 $998244353$ 意义下进行。", "inputFormat": "第一行两个整数 $n$，$m$，意义如上。  \n第二行 $n+1$ 个整数，从低到高表示 $F(x)$ 的各个系数。  \n第三行 $m+1$ 个整数，从低到高表示 $G(x)$ 的各个系数。", "outputFormat": "第一行 $n-m+1$ 个整数，从低到高表示 $Q(x)$ 的各个系数。    \n第二行 $m$ 个整数，从低到高表示 $R(x)$ 的各个系数。    \n如果 $R(x)$ 不足 $m-1$ 次，多余的项系数补 $0$。", "hint": "对于所有数据，$1 \\le m < n \\le 10^5$，给出的系数均属于 $[0, 998244353) \\cap \\mathbb{Z}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Polynomial Division", "background": "", "description": "Given an $n$-degree polynomial $F(x)$ and an $m$-degree polynomial $G(x)$, find polynomials $Q(x)$ and $R(x)$ such that:\n- $\\deg Q(x) = n - m$, and $\\deg R(x) < m$.\n- $F(x) = Q(x) * G(x) + R(x)$.\n\nAll operations are performed modulo $998244353$.", "inputFormat": "The first line contains two integers $n$ and $m$, as described above.  \nThe second line contains $n+1$ integers, giving the coefficients of $F(x)$ from low to high degree.  \nThe third line contains $m+1$ integers, giving the coefficients of $G(x)$ from low to high degree.", "outputFormat": "The first line contains $n - m + 1$ integers, giving the coefficients of $Q(x)$ from low to high degree.  \nThe second line contains $m$ integers, giving the coefficients of $R(x)$ from low to high degree.  \nIf $\\deg R(x) < m - 1$, pad the remaining coefficients with $0$.", "hint": "For all testdata, $1 \\le m < n \\le 10^5$, and the given coefficients belong to $[0, 998244353) \\cap \\mathbb{Z}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】多项式除法", "background": "", "description": "给定一个 $n$ 次多项式 $F(x)$ 和一个 $m$ 次多项式  $G(x)$ ，请求出多项式 $Q(x)$, $R(x)$，满足以下条件：\n\n - $Q(x)$ 次数为 $n-m$，$R(x)$ 次数小于 $m$\n - $F(x) = Q(x) * G(x) + R(x)$\n\n所有的运算在模 $998244353$ 意义下进行。", "inputFormat": "第一行两个整数 $n$，$m$，意义如上。  \n第二行 $n+1$ 个整数，从低到高表示 $F(x)$ 的各个系数。  \n第三行 $m+1$ 个整数，从低到高表示 $G(x)$ 的各个系数。", "outputFormat": "第一行 $n-m+1$ 个整数，从低到高表示 $Q(x)$ 的各个系数。    \n第二行 $m$ 个整数，从低到高表示 $R(x)$ 的各个系数。    \n如果 $R(x)$ 不足 $m-1$ 次，多余的项系数补 $0$。", "hint": "对于所有数据，$1 \\le m < n \\le 10^5$，给出的系数均属于 $[0, 998244353) \\cap \\mathbb{Z}$。", "locale": "zh-CN"}}}
{"pid": "P4513", "type": "P", "difficulty": 5, "samples": [["5 3\n1\n2\n-3\n4\n5\n1 2 3\n2 2 -1\n1 2 3", "2\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["线段树", "递归"], "title": "小白逛公园", "background": "小新经常陪小白去公园玩，也就是所谓的遛狗啦…", "description": "在小新家附近有一条“公园路”，路的一边从南到北依次排着 $n$ 个公园，小白早就看花了眼，自己也不清楚该去哪些公园玩了。\n\n一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 $a$ 个和第 $b$ 个公园之间（包括 $a, b$ 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。\n\n那么，就请你来帮小白选择公园吧。", "inputFormat": "第一行，两个整数 $n$ 和 $m$，分别表示表示公园的数量和操作（遛狗或者改变打分）总数。\n\n接下来 $n$ 行，每行一个整数，依次给出小白开始时对公园的打分。\n\n接下来 $m$ 行，每行三个整数。其中第一个整数 $k$ 为 $1$ 或 $2$。\n\n- $k=1$ 表示，小新要带小白出去玩，接下来的两个整数 $a$ 和 $b$ 给出了选择公园的范围 $(1 \\le a,b \\le n)$。测试数据可能会出现 $a > b$ 的情况，需要进行交换；\n- $k=2$ 表示，小白改变了对某个公园的打分，接下来的两个整数 $p$ 和 $s$，表示小白对第 $p$ 个公园的打分变成了 $s(1\\le |s|\\le 1000)$。", "outputFormat": "小白每出去玩一次，都对应输出一行，只包含一个整数，表示小白可以选出的公园得分和的最大值。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 5 \\times 10^5$，$1 \\le m \\le 10^5$，所有打分都是绝对值不超过 $1000$ 的整数。", "locale": "zh-CN", "translations": {"en": {"title": "Xiaobai Strolls in the Park", "background": "Xiaoxin often takes Xiaobai to the park to play, also known as walking the dog....", "description": "Near Xiaoxin’s home there is a “Park Road,” along one side of which $n$ parks are lined up from south to north. Xiaobai is dazzled and is not sure which parks to visit.\n\nAt the beginning, Xiaobai assigns a score to each park based on its scenery. For convenience, every time they go for a walk, Xiaoxin specifies a range, and Xiaobai may choose a contiguous sequence of parks between the $a$-th and $b$-th parks (inclusive). Of course, Xiaobai wants the sum of the selected parks’ scores to be as large as possible. Meanwhile, as some parks’ landscapes change, Xiaobai’s scores may also change.\n\nSo please help Xiaobai choose the parks.", "inputFormat": "- The first line contains two integers $n$ and $m$, representing the number of parks and the total number of operations (walks or score changes).\n- The next $n$ lines each contain one integer, giving the initial score that Xiaobai assigns to each park in order.\n- The next $m$ lines each contain three integers. The first integer $k$ is $1$ or $2$.\n  - If $k = 1$, Xiaoxin is taking Xiaobai out to play. The next two integers $a$ and $b$ give the selectable range of parks $(1 \\le a, b \\le n)$. The testdata may contain cases where $a > b$, in which case you should swap them.\n  - If $k = 2$, Xiaobai changes the score of a park. The next two integers $p$ and $s$ mean the score of the $p$-th park becomes $s$ $(1 \\le |s| \\le 1000)$.", "outputFormat": "For each walk, output one line containing a single integer: the maximum possible sum of scores of the parks Xiaobai can select.", "hint": "### Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 5 \\times 10^5$, $1 \\le m \\le 10^5$, and all scores are integers with absolute value at most $1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小白逛公园", "background": "小新经常陪小白去公园玩，也就是所谓的遛狗啦…", "description": "在小新家附近有一条“公园路”，路的一边从南到北依次排着 $n$ 个公园，小白早就看花了眼，自己也不清楚该去哪些公园玩了。\n\n一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 $a$ 个和第 $b$ 个公园之间（包括 $a, b$ 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。\n\n那么，就请你来帮小白选择公园吧。", "inputFormat": "第一行，两个整数 $n$ 和 $m$，分别表示表示公园的数量和操作（遛狗或者改变打分）总数。\n\n接下来 $n$ 行，每行一个整数，依次给出小白开始时对公园的打分。\n\n接下来 $m$ 行，每行三个整数。其中第一个整数 $k$ 为 $1$ 或 $2$。\n\n- $k=1$ 表示，小新要带小白出去玩，接下来的两个整数 $a$ 和 $b$ 给出了选择公园的范围 $(1 \\le a,b \\le n)$。测试数据可能会出现 $a > b$ 的情况，需要进行交换；\n- $k=2$ 表示，小白改变了对某个公园的打分，接下来的两个整数 $p$ 和 $s$，表示小白对第 $p$ 个公园的打分变成了 $s(1\\le |s|\\le 1000)$。", "outputFormat": "小白每出去玩一次，都对应输出一行，只包含一个整数，表示小白可以选出的公园得分和的最大值。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 5 \\times 10^5$，$1 \\le m \\le 10^5$，所有打分都是绝对值不超过 $1000$ 的整数。", "locale": "zh-CN"}}}
{"pid": "P4514", "type": "P", "difficulty": 5, "samples": [["X 4 4\nL 1 1 3 3 2\nL 2 2 4 4 1\nk 2 2 3 3", "12"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["树状数组", "前缀和", "差分"], "title": "上帝造题的七分钟", "background": "裸体就意味着身体。", "description": "“第一分钟，X 说，要有矩阵，于是便有了一个里面写满了 $0$ 的 $n\\times m$ 矩阵。\n\n第二分钟，L 说，要能修改，于是便有了将左上角为 $(a,b)$，右下角为 $(c,d)$ 的一个矩形区域内的全部数字加上一个值的操作。\n\n第三分钟，k 说，要能查询，于是便有了求给定矩形区域内的全部数字和的操作。\n\n第四分钟，彩虹喵说，要基于二叉树的数据结构，于是便有了数据范围。\n\n第五分钟，和雪说，要有耐心，于是便有了时间限制。\n\n第六分钟，吃钢琴男说，要省点事，于是便有了保证运算过程中及最终结果均不超过 $32$ 位有符号整数类型的表示范围的限制。\n\n第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”。\n\n——《上帝造裸题的七分钟》。\n\n所以这个神圣的任务就交给你了。", "inputFormat": "输入数据的第一行为 `X n m`，代表矩阵大小为 $n\\times m$。  \n从输入数据的第二行开始到文件尾的每一行会出现以下两种操作：  \n-    `L a b c d delta` —— 代表将 $(a,b),(c,d)$ 为顶点的矩形区域内的所有数字加上 $delta$。  \n-    `k a b c d`     —— 代表求 $(a,b),(c,d)$ 为顶点的矩形区域内所有数字的和。  \n\n请注意，$k$ 为小写。  ", "outputFormat": "针对每个 $k$ 操作，在单独的一行输出答案。", "hint": "对于 $10\\%$ 的数据，$1 \\le n \\le 16$，$1 \\le m \\le 16$， 操作不超过 $200$ 个。\n\n对于 $60\\%$ 的数据，$1 \\le n \\le 512$，$1 \\le m \\le 512$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 2048$，$1 \\le m \\le 2048$，$-500 \\le delta \\le 500$，操作不超过 $2\\times 10^5$ 个，保证最终结果均不超过 $32$ 位带符号整数类型的表示范围，但不保证运算过程不超过该范围。", "locale": "zh-CN", "translations": {"en": {"title": "Seven Minutes of God Making a Problem", "background": "Being naked means having a body.", "description": "“Minute 1: X said, let there be a matrix, and so there was an $n\\times m$ matrix filled with $0$.\n\nMinute 2: L said, let it support modifications, and so there was an operation that adds a value to all numbers in a rectangular region whose top-left corner is $(a,b)$ and bottom-right corner is $(c,d)$.\n\nMinute 3: k said, let it support queries, and so there was an operation that computes the sum of all numbers in a given rectangular region.\n\nMinute 4: Rainbow Meow said, it should be based on a data structure related to binary trees, and so there were the Constraints.\n\nMinute 5: Hexue said, be patient, and so there was a time limit.\n\nMinute 6: The piano-eating guy said, save some trouble, and so there was a restriction that during the operations and in the final result, everything will not exceed the range of a 32-bit signed integer type.\n\nMinute 7: This problem was finally completed. However, the godlike problem setters no longer wanted to write the program for it.”.\n\n— “Seven Minutes of God Making a Naked Problem”.\n\nSo this sacred task is handed over to you.", "inputFormat": "The first line of the input is `X n m`, indicating that the matrix size is $n\\times m$.  \nFrom the second line to the end of the file, each line contains one of the following two operations:  \n- `L a b c d delta` — add $delta$ to all numbers in the rectangular region with vertices $(a,b)$ and $(c,d)$.  \n- `k a b c d` — compute the sum of all numbers in the rectangular region with vertices $(a,b)$ and $(c,d)$.  \n\nNote that $k$ is lowercase.", "outputFormat": "For each `k` operation, output the answer on a separate line.", "hint": "For $10\\%$ of the testdata, $1 \\le n \\le 16$, $1 \\le m \\le 16$, and there are no more than $200$ operations.\n\nFor $60\\%$ of the testdata, $1 \\le n \\le 512$, $1 \\le m \\le 512$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 2048$, $1 \\le m \\le 2048$, $-500 \\le delta \\le 500$, and there are no more than $2\\times 10^5$ operations. It is guaranteed that the final results do not exceed the range of a 32-bit signed integer type, but it is not guaranteed that intermediate computations stay within this range.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "上帝造题的七分钟", "background": "裸体就意味着身体。", "description": "“第一分钟，X 说，要有矩阵，于是便有了一个里面写满了 $0$ 的 $n\\times m$ 矩阵。\n\n第二分钟，L 说，要能修改，于是便有了将左上角为 $(a,b)$，右下角为 $(c,d)$ 的一个矩形区域内的全部数字加上一个值的操作。\n\n第三分钟，k 说，要能查询，于是便有了求给定矩形区域内的全部数字和的操作。\n\n第四分钟，彩虹喵说，要基于二叉树的数据结构，于是便有了数据范围。\n\n第五分钟，和雪说，要有耐心，于是便有了时间限制。\n\n第六分钟，吃钢琴男说，要省点事，于是便有了保证运算过程中及最终结果均不超过 $32$ 位有符号整数类型的表示范围的限制。\n\n第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”。\n\n——《上帝造裸题的七分钟》。\n\n所以这个神圣的任务就交给你了。", "inputFormat": "输入数据的第一行为 `X n m`，代表矩阵大小为 $n\\times m$。  \n从输入数据的第二行开始到文件尾的每一行会出现以下两种操作：  \n-    `L a b c d delta` —— 代表将 $(a,b),(c,d)$ 为顶点的矩形区域内的所有数字加上 $delta$。  \n-    `k a b c d`     —— 代表求 $(a,b),(c,d)$ 为顶点的矩形区域内所有数字的和。  \n\n请注意，$k$ 为小写。  ", "outputFormat": "针对每个 $k$ 操作，在单独的一行输出答案。", "hint": "对于 $10\\%$ 的数据，$1 \\le n \\le 16$，$1 \\le m \\le 16$， 操作不超过 $200$ 个。\n\n对于 $60\\%$ 的数据，$1 \\le n \\le 512$，$1 \\le m \\le 512$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 2048$，$1 \\le m \\le 2048$，$-500 \\le delta \\le 500$，操作不超过 $2\\times 10^5$ 个，保证最终结果均不超过 $32$ 位带符号整数类型的表示范围，但不保证运算过程不超过该范围。", "locale": "zh-CN"}}}
{"pid": "P4515", "type": "P", "difficulty": 6, "samples": [["3\n1 1 2\n7 1 6\n5 3 4", "24.0"], ["5\n5 5 99\n5 5 99\n5 5 99\n5 5 99\n5 5 99", "4900.5"], ["4\n5 5 99\n5 5 99\n5 5 99\n5 5 99", "0.0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2009", "容斥原理", "COCI（克罗地亚）"], "title": "[COCI 2009/2010 #6] XOR", "background": null, "description": "坐标系下有若干个等腰直角三角形，且每个等腰直角三角形的直角顶点都在左下方，两腰与坐标轴平行。被奇数个三角形覆盖的面积部分为灰色，被偶数个三角形覆盖的面积部分为白色，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/18669.png)\n\n已知 $N$ 个等腰直角三角形的顶点坐标及腰长，求灰色部分面积。", "inputFormat": "输入第一行包含一个整数 $N$，表示等腰直角三角形数量。\n\n接下来 $N$ 行，每行三个整数 $X, Y, R$，分别表示等腰直角三角形的顶点坐标 $(X, Y)$ 与腰长 $R$。", "outputFormat": "输出包含一个实数，表示灰色部分面积。保留 $1$ 位小数。", "hint": "对于所有数据，$1 \\leq N \\leq 10$，$1 \\leq X, Y, R \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2009/2010 #6] XOR", "background": null, "description": "Mirko and Slavko have built their own LED display. The display is initially\nwhite. During each of the $N$ parts of the testing phase, Mirko attached three\nelectrodes to the display in such way that they formed a right isosceles\ntriangle. He noticed that, after attaching the electrodes, all pixels in the\nenclosing triangle are inverted (white pixels become black, and black pixels\nbecome white).\n\n![](https://cdn.luogu.com.cn/upload/pic/18669.png)\n\nWatching Mirko play with the electrodes, Slavko observed interesting shapes\nemerging on the screen. Mathematically inclined as he is, first thing that\ncrossed his mind was how to calculate total area covered by black pixels. Help\nhim by writing a program to do just that!", "inputFormat": "First line of input contains an integer $N~(1 \\leq N \\leq 10)$, number of triangles\nformed by Mirko's fiddling with electrodes. Each of the following $N$ lines\ncontains three integers $X, Y$ and $R~(1 \\leq X, Y, R \\leq 10^6)$, describing a triangle. $(X, Y)$ are the coordinates of the lower left corner of the triangle, while $R$ represents the length of the two sides of the triangle.", "outputFormat": "The first and only line of output should contain the area covered by black pixels, rounded to one decimal place.", "hint": "For all data, $1 \\leq N \\leq 10$, $1 \\leq X, Y, R \\leq 10^6$.", "locale": "en"}, "zh-CN": {"title": "[COCI 2009/2010 #6] XOR", "background": null, "description": "坐标系下有若干个等腰直角三角形，且每个等腰直角三角形的直角顶点都在左下方，两腰与坐标轴平行。被奇数个三角形覆盖的面积部分为灰色，被偶数个三角形覆盖的面积部分为白色，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/18669.png)\n\n已知 $N$ 个等腰直角三角形的顶点坐标及腰长，求灰色部分面积。", "inputFormat": "输入第一行包含一个整数 $N$，表示等腰直角三角形数量。\n\n接下来 $N$ 行，每行三个整数 $X, Y, R$，分别表示等腰直角三角形的顶点坐标 $(X, Y)$ 与腰长 $R$。", "outputFormat": "输出包含一个实数，表示灰色部分面积。保留 $1$ 位小数。", "hint": "对于所有数据，$1 \\leq N \\leq 10$，$1 \\leq X, Y, R \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4516", "type": "P", "difficulty": 6, "samples": [["5 3\n1 2\n2 3\n3 4\n4 5", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "各省省选", "江苏", "背包 DP", "树形 DP"], "title": "[JSOI2018] 潜入行动", "background": "", "description": "外星人又双叒叕要攻打地球了，外星母舰已经向地球航行！这一次，``JYY`` 已经联系好了黄金舰队，打算联合所有 ``JSOIer`` 抵御外星人的进攻。\n\n在黄金舰队就位之前，``JYY`` 打算事先了解外星人的进攻计划。现在，携带了监听设备的特工已经秘密潜入了外星人的母舰，准备对外星人的通信实施监听。\n\n外星人的母舰可以看成是一棵 $n$ 个节点、 $n-1$ 条边的**无向树**，树上的节点用 $1,2,\\cdots,n$ 编号。``JYY`` 的特工已经装备了隐形模块，可以在外星人母舰中不受限制地活动，可以神不知鬼不觉地在节点上安装监听设备。\n\n如果在节点 $u$ 上安装监听设备，则 ``JYY`` 能够监听与 $u$ **直接相邻**所有的节点的通信。换言之，如果在节点 $u$ 安装监听设备，则对于树中每一条边 $(u,v)$ ，节点 $v$ 都会被监听。特别注意**放置在节点 $u$ 的监听设备并不监听 $u$ 本身的通信**，这是 ``JYY`` 特别为了防止外星人察觉部署的战术。\n\n``JYY`` 的特工一共携带了 $k$ 个监听设备，现在 ``JYY`` 想知道，有多少种不同的放置监听设备的方法，能够使得母舰上**所有节点**的通信都被监听？为了避免浪费，**每个节点至多只能安装一个监听设备，且监听设备必须被用完**。\n", "inputFormat": "输入第一行包含两个整数 $n,k$ ，表示母舰节点的数量 $n$ 和监听设备的数量 $k$ 。\n接下来 $n-1$ 行，每行两个整数 $u,v$ $(1\\le u,v\\le n)$，表示树中的一条边。", "outputFormat": "输出一行，表示满足条件的方案数。因为答案可能很大，你只需要输出答案 $\\text{mod 1,000,000,007}$ 的余数即可。", "hint": "**样例 1 解释**\n\n样例数据是一条链 $1-2-3-4-5$ 。首先，节点 $2$ 和 $4$ 必须放置监听设备，否则 $1,5$ 将无法被监听（放置的监听设备无法监听它所在的节点）。剩下一个设备必须放置在 $3$ 号节点以同时监听 $2,4$ 。因此在 $2,3,4$ 节点放置监听设备是唯一合法的方案。\n\n**数据范围**\n\n存在 $10\\%$ 的数据，$1 \\le n \\le 20$ ；\n\n存在另外 $10\\%$ 的数据，$1 \\le n \\le 100$ ；\n\n存在另外 $10\\%$ 的数据，$1 \\le k \\le 10$ ；\n\n存在另外 $10\\%$ 的数据，输入的树保证是一条链；\n\n对于所有数据，$1\\le n\\le 10^5$​ ，$1\\le k\\le \\min\\{n,100\\}$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2018] Infiltration Operation", "background": "", "description": "The aliens are attacking Earth yet again, and the alien mothership is already en route to Earth. This time, `JYY` has contacted the Golden Fleet and plans to unite all `JSOIer` to resist the alien invasion.\n\nBefore the Golden Fleet takes position, `JYY` intends to first learn the aliens' plan. Now, an agent carrying listening devices has secretly infiltrated the alien mothership to eavesdrop on their communications.\n\nThe alien mothership can be regarded as an **undirected tree** with $n$ nodes and $n-1$ edges. The nodes on the tree are numbered $1,2,\\cdots,n$. The agent employed by `JYY` is equipped with a stealth module, allowing free movement within the mothership and the ability to install listening devices on nodes without being detected.\n\nIf a listening device is installed at node $u$, then `JYY` can monitor the communications of all nodes **directly adjacent** to $u$. In other words, if a device is placed at node $u$, then for every edge $(u,v)$ in the tree, node $v$ will be monitored. Note in particular that a device placed at node $u$ does not monitor the communications of $u$ itself; this is a tactic designed by `JYY` to avoid detection by the aliens.\n\nThe agent carries exactly $k$ listening devices. `JYY` wants to know how many different ways there are to place the devices so that the communications of **all nodes** on the mothership are monitored. To avoid waste, at most one device may be installed on each node, and all devices must be used.", "inputFormat": "The first line of input contains two integers $n,k$, representing the number of nodes $n$ of the mothership and the number of listening devices $k$.\nThe next $n-1$ lines each contain two integers $u,v$ $(1\\le u,v\\le n)$, representing an edge in the tree.", "outputFormat": "Output a single line containing the number of valid configurations. Since the answer may be large, you only need to output the remainder $\\text{mod 1,000,000,007}$.", "hint": "Explanation for Sample 1\n\nThe sample is a chain $1-2-3-4-5$. First, nodes $2$ and $4$ must have devices; otherwise $1$ and $5$ cannot be monitored (a device does not monitor the node it sits on). The remaining device must be placed on node $3$ to monitor both $2$ and $4$. Therefore, placing devices on nodes $2,3,4$ is the only valid configuration.\n\nConstraints\n\n- For $10\\%$ of the testdata, $1 \\le n \\le 20$.\n- For another $10\\%$ of the testdata, $1 \\le n \\le 100$.\n- For another $10\\%$ of the testdata, $1 \\le k \\le 10$.\n- For another $10\\%$ of the testdata, the input tree is a chain.\n- For all testdata, $1\\le n\\le 10^5$, $1\\le k\\le \\min\\{n,100\\}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2018] 潜入行动", "background": "", "description": "外星人又双叒叕要攻打地球了，外星母舰已经向地球航行！这一次，``JYY`` 已经联系好了黄金舰队，打算联合所有 ``JSOIer`` 抵御外星人的进攻。\n\n在黄金舰队就位之前，``JYY`` 打算事先了解外星人的进攻计划。现在，携带了监听设备的特工已经秘密潜入了外星人的母舰，准备对外星人的通信实施监听。\n\n外星人的母舰可以看成是一棵 $n$ 个节点、 $n-1$ 条边的**无向树**，树上的节点用 $1,2,\\cdots,n$ 编号。``JYY`` 的特工已经装备了隐形模块，可以在外星人母舰中不受限制地活动，可以神不知鬼不觉地在节点上安装监听设备。\n\n如果在节点 $u$ 上安装监听设备，则 ``JYY`` 能够监听与 $u$ **直接相邻**所有的节点的通信。换言之，如果在节点 $u$ 安装监听设备，则对于树中每一条边 $(u,v)$ ，节点 $v$ 都会被监听。特别注意**放置在节点 $u$ 的监听设备并不监听 $u$ 本身的通信**，这是 ``JYY`` 特别为了防止外星人察觉部署的战术。\n\n``JYY`` 的特工一共携带了 $k$ 个监听设备，现在 ``JYY`` 想知道，有多少种不同的放置监听设备的方法，能够使得母舰上**所有节点**的通信都被监听？为了避免浪费，**每个节点至多只能安装一个监听设备，且监听设备必须被用完**。\n", "inputFormat": "输入第一行包含两个整数 $n,k$ ，表示母舰节点的数量 $n$ 和监听设备的数量 $k$ 。\n接下来 $n-1$ 行，每行两个整数 $u,v$ $(1\\le u,v\\le n)$，表示树中的一条边。", "outputFormat": "输出一行，表示满足条件的方案数。因为答案可能很大，你只需要输出答案 $\\text{mod 1,000,000,007}$ 的余数即可。", "hint": "**样例 1 解释**\n\n样例数据是一条链 $1-2-3-4-5$ 。首先，节点 $2$ 和 $4$ 必须放置监听设备，否则 $1,5$ 将无法被监听（放置的监听设备无法监听它所在的节点）。剩下一个设备必须放置在 $3$ 号节点以同时监听 $2,4$ 。因此在 $2,3,4$ 节点放置监听设备是唯一合法的方案。\n\n**数据范围**\n\n存在 $10\\%$ 的数据，$1 \\le n \\le 20$ ；\n\n存在另外 $10\\%$ 的数据，$1 \\le n \\le 100$ ；\n\n存在另外 $10\\%$ 的数据，$1 \\le k \\le 10$ ；\n\n存在另外 $10\\%$ 的数据，输入的树保证是一条链；\n\n对于所有数据，$1\\le n\\le 10^5$​ ，$1\\le k\\le \\min\\{n,100\\}$ 。", "locale": "zh-CN"}}}
{"pid": "P4517", "type": "P", "difficulty": 6, "samples": [["3 2\n1 2\n2 3", "750000006"], ["6 6\n1 2\n2 3\n3 1\n1 4\n2 5\n3 6", "468750006"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "各省省选", "江苏", "枚举", "前缀和", "概率论"], "title": "[JSOI2018] 防御网络", "background": "", "description": "虽然成功得到了外星人的进攻计划，但 ``JYY`` 意外地发现,外星母舰对地球的攻击竟然是随机的！必须尽快在地球上部署防御网络,抵御外星人母舰的攻击。\n地球上的防御网络由节点和节点之间的能量连接组成,防御网络可以看成是一个 $n$ 个点、 $m$ 条边的简单无向图 $G(V,E)$ ,每个防御节点对应 $V$ 中的一个节点、每个能量连接对应 $E$ 中的一条边。此外,在防御网络修建时考虑到能量传输效率，防御网络 $G$ 中**每个节点至多只包含在一个简单环中**。\n\n外星母舰的攻击是随机的，每次攻击开始后， ``JYY`` 都会本次攻击的情况选择一些防御节点 $S\\subseteq V$ ，并且用能量连接将这些防御节点连通，从而启动一个防御子网络。换言之， ``JYY`` 会选择 $G$ 中边集的一个子集 $H(S)\\subseteq E$ ,它满足:\n\n1.    (防御子网络**连通**) 如果我们建立新图 $G'(V,H(S))$ ，即用 $H(S)$ 中的边连接 $G$ 中的节点，则对于任意选择的防御节点 $x,y\\in S$ ，它们在 $G'$​​ 中都连通。\n\n2.    (防御子网络**最小**) 在满足条件 1 (防御子网络连通)的前提，选取的边数最小，即 $\\vert H(S)\\vert$ 最小。\n\n$H(S)$ 是点集 $S$ 在图 $G$ 生成的斯坦纳树 (Steiner Tree) ，而 $\\vert H(S)\\vert$ 则是启动防御子网络的最小代价。考虑到外星母舰随机攻击的方式， ``JYY`` 希望你计算启动防御子网络代价的**期望**:\n\n$$\\frac{1}{2^{\\vert V\\vert}}\\sum_{S\\subseteq V}\\vert H(S)\\vert$$", "inputFormat": "输入第一行两个整数 $n,m$ ，分别表示图中的节点数和边数。\n\n接下来 $m$ 行,每行两个整数 $u,v(1\\le u,v\\le n)$ ，表示图中的一条边。输入保证没有自环和重边，并且满足每个节点至多包含在一个简单环中。", "outputFormat": "输出一行，表示启动防御子网络的期望。\n\n假设期望写成最简分式 $P/Q$ 的形式, 则输出 $P⋅Q^{-1} \\text{mod 1,000,000,007}$ 的余数,其中 $Q^{-1}$​​ 为唯一的满足 $Q⋅Q^{-1} ≡ \\text{1 (mod 1,000,000,007)}$ 的整数。", "hint": "**样例解释**\n\n样例输入 1 是一条链，包含以下情况:\n\n1.    $\\{\\}, \\{1\\}, \\{2\\}, \\{3\\},\\vert H(S)\\vert = 0$ ;\n2.    $\\{1, 2\\}, \\{2, 3\\}, \\vert H(S)\\vert = 1$ ;\n3.    $\\{1, 3\\}, \\{1, 2, 3\\}, \\vert H(S)\\vert = 2$ 。\n\n因此 $P/Q=3/4$ ， $P\\cdot Q^{-1} = 750,000,006$ 。\n\n样例输入 2 中 $\\sum_{S\\subseteq V}\\vert H(S)\\vert = 174$ ，因此 $P/Q=87/32$ ， $P⋅Q^{-1}=468,750,006 \\text{ mod 1,000,000,007}$ 。\n\n**数据范围**\n\n对于 $20\\%$ 的数据,有 $1\\le n\\le 8$ 。\n\n对于 $40\\%$ 的数据,有 $1\\le n\\le 20$ 。\n\n对于 $100\\%$ 的数据,有 $1\\le n\\le 200$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2018] Defense Network", "background": "", "description": "Although the attack plan of the aliens has been obtained, ``JYY`` unexpectedly finds that the alien mothership attacks Earth randomly. A defense network must be deployed on Earth as soon as possible to resist the mothership’s attack.\n\nThe defense network on Earth consists of nodes and energy links between nodes. The defense network can be regarded as a simple undirected graph $G(V, E)$ with $n$ vertices and $m$ edges. Each defense node corresponds to a vertex in $V$, and each energy link corresponds to an edge in $E$. In addition, considering energy transmission efficiency when building the defense network, in $G$ each vertex belongs to at most one simple cycle.\n\nSince the mothership’s attack is random, at the beginning of each attack, ``JYY`` will choose some defense nodes $S \\subseteq V$ according to the current attack and use energy links to connect these defense nodes to activate a defense subnetwork. In other words, ``JYY`` will choose a subset of edges $H(S) \\subseteq E$ in $G$, which satisfies:\n\n1. (Defense subnetwork connected) If we build a new graph $G'(V, H(S))$, i.e., connect the vertices in $G$ with the edges in $H(S)$, then for any selected defense vertices $x, y \\in S$, they are connected in $G'$.\n2. (Defense subnetwork minimal) Subject to condition 1 (defense subnetwork connected), the number of selected edges is minimal, i.e., $\\vert H(S)\\vert$ is minimal.\n\n$H(S)$ is the Steiner tree generated by the set $S$ in graph $G$, and $\\vert H(S)\\vert$ is the minimal cost to activate the defense subnetwork. Considering the randomness of the mothership’s attack, ``JYY`` wants you to compute the expectation of the activation cost:\n\n$$\\frac{1}{2^{\\vert V\\vert}}\\sum_{S\\subseteq V}\\vert H(S)\\vert.$$", "inputFormat": "The first line contains two integers $n, m$, denoting the number of vertices and edges in the graph.\n\nThe next $m$ lines each contain two integers $u, v$ $(1 \\le u, v \\le n)$, representing an edge. The input guarantees no self-loops or multiple edges, and that each vertex belongs to at most one simple cycle.", "outputFormat": "Output one line: the expected cost to activate the defense subnetwork.\n\nSuppose the expectation is written in irreducible fraction form $P/Q$. Output the remainder of $P \\cdot Q^{-1} \\text{ mod 1,000,000,007}$, where $Q^{-1}$ is the unique integer satisfying $Q \\cdot Q^{-1} \\equiv \\text{1 (mod 1,000,000,007)}$.", "hint": "Sample explanation.\n\nSample 1 is a path and includes the following cases:\n1. $\\{\\}, \\{1\\}, \\{2\\}, \\{3\\}, \\vert H(S)\\vert = 0$.\n2. $\\{1, 2\\}, \\{2, 3\\}, \\vert H(S)\\vert = 1$.\n3. $\\{1, 3\\}, \\{1, 2, 3\\}, \\vert H(S)\\vert = 2$.\n\nTherefore $P/Q = 3/4$, $P \\cdot Q^{-1} = 750,000,006$.\n\nIn sample input 2, $\\sum_{S\\subseteq V}\\vert H(S)\\vert = 174$, thus $P/Q = 87/32$, $P \\cdot Q^{-1} = 468,750,006 \\text{ mod 1,000,000,007}$.\n\nConstraints\n\n- For 20% of the testdata, $1 \\le n \\le 8$.\n- For 40% of the testdata, $1 \\le n \\le 20$.\n- For 100% of the testdata, $1 \\le n \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2018] 防御网络", "background": "", "description": "虽然成功得到了外星人的进攻计划，但 ``JYY`` 意外地发现,外星母舰对地球的攻击竟然是随机的！必须尽快在地球上部署防御网络,抵御外星人母舰的攻击。\n地球上的防御网络由节点和节点之间的能量连接组成,防御网络可以看成是一个 $n$ 个点、 $m$ 条边的简单无向图 $G(V,E)$ ,每个防御节点对应 $V$ 中的一个节点、每个能量连接对应 $E$ 中的一条边。此外,在防御网络修建时考虑到能量传输效率，防御网络 $G$ 中**每个节点至多只包含在一个简单环中**。\n\n外星母舰的攻击是随机的，每次攻击开始后， ``JYY`` 都会本次攻击的情况选择一些防御节点 $S\\subseteq V$ ，并且用能量连接将这些防御节点连通，从而启动一个防御子网络。换言之， ``JYY`` 会选择 $G$ 中边集的一个子集 $H(S)\\subseteq E$ ,它满足:\n\n1.    (防御子网络**连通**) 如果我们建立新图 $G'(V,H(S))$ ，即用 $H(S)$ 中的边连接 $G$ 中的节点，则对于任意选择的防御节点 $x,y\\in S$ ，它们在 $G'$​​ 中都连通。\n\n2.    (防御子网络**最小**) 在满足条件 1 (防御子网络连通)的前提，选取的边数最小，即 $\\vert H(S)\\vert$ 最小。\n\n$H(S)$ 是点集 $S$ 在图 $G$ 生成的斯坦纳树 (Steiner Tree) ，而 $\\vert H(S)\\vert$ 则是启动防御子网络的最小代价。考虑到外星母舰随机攻击的方式， ``JYY`` 希望你计算启动防御子网络代价的**期望**:\n\n$$\\frac{1}{2^{\\vert V\\vert}}\\sum_{S\\subseteq V}\\vert H(S)\\vert$$", "inputFormat": "输入第一行两个整数 $n,m$ ，分别表示图中的节点数和边数。\n\n接下来 $m$ 行,每行两个整数 $u,v(1\\le u,v\\le n)$ ，表示图中的一条边。输入保证没有自环和重边，并且满足每个节点至多包含在一个简单环中。", "outputFormat": "输出一行，表示启动防御子网络的期望。\n\n假设期望写成最简分式 $P/Q$ 的形式, 则输出 $P⋅Q^{-1} \\text{mod 1,000,000,007}$ 的余数,其中 $Q^{-1}$​​ 为唯一的满足 $Q⋅Q^{-1} ≡ \\text{1 (mod 1,000,000,007)}$ 的整数。", "hint": "**样例解释**\n\n样例输入 1 是一条链，包含以下情况:\n\n1.    $\\{\\}, \\{1\\}, \\{2\\}, \\{3\\},\\vert H(S)\\vert = 0$ ;\n2.    $\\{1, 2\\}, \\{2, 3\\}, \\vert H(S)\\vert = 1$ ;\n3.    $\\{1, 3\\}, \\{1, 2, 3\\}, \\vert H(S)\\vert = 2$ 。\n\n因此 $P/Q=3/4$ ， $P\\cdot Q^{-1} = 750,000,006$ 。\n\n样例输入 2 中 $\\sum_{S\\subseteq V}\\vert H(S)\\vert = 174$ ，因此 $P/Q=87/32$ ， $P⋅Q^{-1}=468,750,006 \\text{ mod 1,000,000,007}$ 。\n\n**数据范围**\n\n对于 $20\\%$ 的数据,有 $1\\le n\\le 8$ 。\n\n对于 $40\\%$ 的数据,有 $1\\le n\\le 20$ 。\n\n对于 $100\\%$ 的数据,有 $1\\le n\\le 200$ 。", "locale": "zh-CN"}}}
{"pid": "P4518", "type": "P", "difficulty": 7, "samples": [["3 1\n0 0\n0 0\n0 0", "1.00000000"], ["3 10\n10 0\n0 10\n10 10", "12.17522858"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "各省省选", "江苏", "Special Judge", "O2优化"], "title": "[JSOI2018] 绝地反击", "background": "", "description": "由于你的出色表现，外星人的进攻已经被成功化解了。现在， ``JYY`` 召集了强大的黄金舰队,准备一击摧毁外星人的母舰。\n\n黄金舰队共有 $n(n\\ge 3)$ 艘飞船,这些飞船能将能量汇聚到同一点（外星人母舰所在位置），从而对外星母舰进行毁灭性的打击。 ``JYY`` 计划将所有飞船同时折跃到母舰附近，瞬间发动攻击结束战斗。\n\n在黄金舰队折跃抵达后，由于各种不稳定因素，舰队中的各艘飞船并未进入最佳攻击位置，因此需要迅速对它们进行调整。现在，所有飞船已经同时完成了折跃，每个飞船都可以看做是平面上的一个点，第 $i(1\\le i\\le n)$ 艘飞船的坐标为 $(x_i,y_i)$ 。外星母舰位于坐标原点 $(0,0)$ 。\n\n为了实现最高效的打击，所有飞船都必须移动到攻击轨道上。攻击轨道是圆心在原点 $(0,0)$ 、半径为 $R$ 的圆。因为发射产生的能量实在太大， ``JYY`` 希望发射时飞船相互之间的距离尽可能大。具体来说， ``JYY`` 希望黄金舰队所有 $n$ 艘飞船均匀地排列在攻击轨道上（所有飞船均为同一型号，因此按任意顺序排列均可），即相邻飞船在攻击轨道（圆弧）上的距离相等且恰好等于 $\\frac{2\\pi R}{n}$​​ 。换言之， ``JYY`` 希望调整所有飞船的位置，使得所有飞船都位于攻击轨道上，且它们恰好位于正 $n$ 边形的 $n$个顶点。\n\n请你帮助 ``JYY`` 计算出打击开始的最短时间（即所有飞船移动到攻击轨道上并等距排列的最少时间）。飞船一单位时间可以在平面上移动一单位距离，且飞船的体积可以看成 $0$ 。因此在你设计的方案中，飞船在某个时刻 “相遇” 是允许的。此外，初始时飞船的坐标也允许重合。", "inputFormat": "输入第一行两个整数 $n,R$ ，表示飞船的数量和攻击轨道的半径。\n\n接下来 $n$ 行,每行两个整数 $(x_i,y_i)$ ，分别表示每一艘飞船的坐标。", "outputFormat": "输出一行，表示所有飞船就位的最短时间（请保留足够的小数位数）。如果你的输出和参考答案差距不超过 $10^{-6}$ 则认为正确。", "hint": "对于 $20\\%$ 的数据，有 $n=3$ 。\n\n对于 $50\\%$ 的数据，有 $n\\le 50$ 。\n\n对于 $100\\%$ 的数据，有 $3 \\le n\\le 200,0 \\le\\vert x_i\\vert,\\vert y_i\\vert,R\\le 100$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2018] Counterattack", "background": "", "description": "Thanks to your excellent performance, the aliens’ attack has been successfully repelled. Now, ``JYY`` has assembled the powerful Golden Fleet, ready to destroy the alien mothership in a single strike.\n\nThe Golden Fleet has $n\\,(n\\ge 3)$ ships. These ships can focus their energy at a single point (the mothership’s location) to deliver a devastating blow. ``JYY`` plans to warp all ships near the mothership simultaneously and launch an attack instantly to end the battle.\n\nAfter the warp, due to various instabilities, the ships are not in optimal attack positions and must be adjusted quickly. Now all ships have completed the warp at the same time, and each ship can be viewed as a point on the plane. The $i$-th ($1\\le i\\le n$) ship is at coordinates $(x_i, y_i)$. The alien mothership is at the origin $(0, 0)$.\n\nTo achieve the most effective strike, all ships must move onto the attack orbit. The attack orbit is the circle centered at $(0, 0)$ with radius $R$. Because the energy released is extremely large, ``JYY`` wants the distances between ships at the moment of firing to be as large as possible. Specifically, ``JYY`` wants all $n$ ships of the Golden Fleet to be evenly arranged on the attack orbit (all ships are identical, so any order is acceptable), that is, the distances along the arc between adjacent ships on the attack orbit are equal and exactly $\\frac{2\\pi R}{n}$. In other words, ``JYY`` wants to adjust all ships so that they all lie on the attack orbit and are exactly at the $n$ vertices of a regular $n$-gon.\n\nPlease help ``JYY`` compute the minimum time to start the strike (i.e., the least time for all ships to move onto the attack orbit and be equally spaced). A ship can move one unit of distance per unit of time in the plane, and the volume of a ship can be considered $0$. Therefore, in your plan, it is allowed for ships to “meet” at some moment. Initially, ships’ coordinates are also allowed to coincide.", "inputFormat": "The first line contains two integers $n, R$, representing the number of ships and the radius of the attack orbit.\n\nThe next $n$ lines each contain two integers $(x_i, y_i)$, representing the coordinates of each ship.", "outputFormat": "Output one line: the minimum time for all ships to be in position (print with sufficient precision). Your answer is considered correct if the absolute error from the reference answer does not exceed $10^{-6}$.", "hint": "- For $20\\%$ of the testdata, $n = 3$.\n- For $50\\%$ of the testdata, $n \\le 50$.\n- For $100\\%$ of the testdata, $3 \\le n \\le 200$, $0 \\le \\lvert x_i \\rvert, \\lvert y_i \\rvert, R \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2018] 绝地反击", "background": "", "description": "由于你的出色表现，外星人的进攻已经被成功化解了。现在， ``JYY`` 召集了强大的黄金舰队,准备一击摧毁外星人的母舰。\n\n黄金舰队共有 $n(n\\ge 3)$ 艘飞船,这些飞船能将能量汇聚到同一点（外星人母舰所在位置），从而对外星母舰进行毁灭性的打击。 ``JYY`` 计划将所有飞船同时折跃到母舰附近，瞬间发动攻击结束战斗。\n\n在黄金舰队折跃抵达后，由于各种不稳定因素，舰队中的各艘飞船并未进入最佳攻击位置，因此需要迅速对它们进行调整。现在，所有飞船已经同时完成了折跃，每个飞船都可以看做是平面上的一个点，第 $i(1\\le i\\le n)$ 艘飞船的坐标为 $(x_i,y_i)$ 。外星母舰位于坐标原点 $(0,0)$ 。\n\n为了实现最高效的打击，所有飞船都必须移动到攻击轨道上。攻击轨道是圆心在原点 $(0,0)$ 、半径为 $R$ 的圆。因为发射产生的能量实在太大， ``JYY`` 希望发射时飞船相互之间的距离尽可能大。具体来说， ``JYY`` 希望黄金舰队所有 $n$ 艘飞船均匀地排列在攻击轨道上（所有飞船均为同一型号，因此按任意顺序排列均可），即相邻飞船在攻击轨道（圆弧）上的距离相等且恰好等于 $\\frac{2\\pi R}{n}$​​ 。换言之， ``JYY`` 希望调整所有飞船的位置，使得所有飞船都位于攻击轨道上，且它们恰好位于正 $n$ 边形的 $n$个顶点。\n\n请你帮助 ``JYY`` 计算出打击开始的最短时间（即所有飞船移动到攻击轨道上并等距排列的最少时间）。飞船一单位时间可以在平面上移动一单位距离，且飞船的体积可以看成 $0$ 。因此在你设计的方案中，飞船在某个时刻 “相遇” 是允许的。此外，初始时飞船的坐标也允许重合。", "inputFormat": "输入第一行两个整数 $n,R$ ，表示飞船的数量和攻击轨道的半径。\n\n接下来 $n$ 行,每行两个整数 $(x_i,y_i)$ ，分别表示每一艘飞船的坐标。", "outputFormat": "输出一行，表示所有飞船就位的最短时间（请保留足够的小数位数）。如果你的输出和参考答案差距不超过 $10^{-6}$ 则认为正确。", "hint": "对于 $20\\%$ 的数据，有 $n=3$ 。\n\n对于 $50\\%$ 的数据，有 $n\\le 50$ 。\n\n对于 $100\\%$ 的数据，有 $3 \\le n\\le 200,0 \\le\\vert x_i\\vert,\\vert y_i\\vert,R\\le 100$ 。", "locale": "zh-CN"}}}
{"pid": "P4519", "type": "P", "difficulty": 2, "samples": [["5\n2\n2\n1\n5", "0"], ["26\n3\n3\n3\n19\n26\n", "2"], ["13\n2\n10\n1\n2\n", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #4] Rasvjeta", "background": "", "description": "It is Advent season. There are M street lights in a street N metres long (the meters of the\nstreet are denoted with numbers from 1 to N). Each of the lights lights up the meter of the\nstreet it’s located in and K meters to the left and to the right of that location. In other words, if\nthe light is located at meter X, it lights up all metres of the street from X - K to X + K,\ninclusively. Of course, it is possible for a meter of the street to be lit up by multiple street\nlights. All lights have distinct locations.\n\nThe problem is that there is a possibility that the lights don’t light up all N metres of the\nstreet. It is your task to determine the minimal amount of additional lights needed to be put\nup (at position from 1 to N) so that the entire street is lit up.", "inputFormat": "The first line of input contains the number N (1 ≤ N ≤ 1000).\n\nThe second line of input contains the number M (1 ≤ M ≤ N).\n\nThe third line contains the number K (0 ≤ K ≤ N).\n\nEach of the following M lines contains a number. The numbers are sorted in ascending order\nand represent the positions of each of the M street lights.\n\nThe positions will be distinct and from the interval [1, N].\n", "outputFormat": "You must output the required number from the task.", "hint": "**Clarification of the first test case:**\n\nIt’s not necessary to add lights to the street, since all N meters are already lit up.\n\n**Clarification of the third test case:**\n\nIt is necessary to add one lamp, for example at location 13.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #4] Rasvjeta", "background": "", "description": "It is Advent season. There are M street lights in a street N metres long (the meters of the\nstreet are denoted with numbers from 1 to N). Each of the lights lights up the meter of the\nstreet it’s located in and K meters to the left and to the right of that location. In other words, if\nthe light is located at meter X, it lights up all metres of the street from X - K to X + K,\ninclusively. Of course, it is possible for a meter of the street to be lit up by multiple street\nlights. All lights have distinct locations.\n\nThe problem is that there is a possibility that the lights don’t light up all N metres of the\nstreet. It is your task to determine the minimal amount of additional lights needed to be put\nup (at position from 1 to N) so that the entire street is lit up.", "inputFormat": "The first line of input contains the number N (1 ≤ N ≤ 1000).\n\nThe second line of input contains the number M (1 ≤ M ≤ N).\n\nThe third line contains the number K (0 ≤ K ≤ N).\n\nEach of the following M lines contains a number. The numbers are sorted in ascending order\nand represent the positions of each of the M street lights.\n\nThe positions will be distinct and from the interval [1, N].\n", "outputFormat": "You must output the required number from the task.", "hint": "**Clarification of the first test case:**\n\nIt’s not necessary to add lights to the street, since all N meters are already lit up.\n\n**Clarification of the third test case:**\n\nIt is necessary to add one lamp, for example at location 13.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #4] Rasvjeta / 路灯", "background": null, "description": "在一条 $N$ 米长的路上有 $M$ 个路灯。每个路灯能够照亮其左右 $K$ 米，即如果在 $X$ 米处安放路灯，则从 $X-K$ 米处到 $X+K$ 米处都被照亮。\n\n但是，有可能这条路上有些地方没有被照亮。请求出至少要再安放多少路灯才能让这条路的 $1$ 米处（**注意**：不是 $0$ 米处）到 $N$ 米处都被照亮。", "inputFormat": "第一行，一个正整数 $N$ 代表路的长度。\n\n第二行，一个正整数 $M$ 代表已经有的路灯的数量。\n\n第三行，一个**非负**整数 $K$ 代表路灯可以照亮的范围。\n\n以后 $M$ 行，第 $i$ 行一个正整数 $a_i$，代表第 $i$ 个路灯在 $a_i$ 米的位置。", "outputFormat": "输出一个非负整数 $D$，代表这条路至少还需要安装 $D$ 个路灯才能使 $1$ 米处到 $N$ 米处都被照亮。", "hint": "### 样例解释\n对于第一组样例，这条路已经被全部照亮了，不需要添加路灯。\n\n对于第三组样例，这条路只有 $13$ 米处没有被照亮，在 $3$ 米和 $13$ 米之间任意添加 $1$ 盏路灯就可以让整条路被照亮。\n\n### 数据范围\n\n对于全部数据，$1 \\le M \\le N \\le 1000,\\ 0 \\le K \\le N,\\ 1 \\le a_i \\le N$。", "locale": "zh-CN"}}}
{"pid": "P4520", "type": "P", "difficulty": 3, "samples": [["3 4 1\n3 4 1 2\n4 2 3 1\n3 4 2 1", "3\n3"], ["4 1 1\n1\n1\n1\n1", "1\n0"], ["4 4 4\n2 3 1 4\n2 3 1 4\n1 3 2 4\n4 3 2 1", "2\n3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2017", "Special Judge", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #4] Izbori", "background": "", "description": "In a land with developed democracy far, far away, presidential elections for the football\nassociation are taking place. This land consists of N counties, and each county has its own\nfootball association. There are M presidential candidates labeled with 1, 2, … M. Each of the\nfootball associations will select exactly one candidate to cast their vote for. The winner of the\nelection is the candidate with the most votes. If multiple candidates get the most amount of\nvotes, the winner is the one with the smallest label.\n\nDuring the election campaign, candidates visited the counties and tried to gain their\nsympathies. After having met all the candidates, each county’s football association\ndetermined the order in which they would cast their vote for each candidate.\n\nFor example, let’s assume that there are four candidates in the election and that one\ncounty’s order is 2, 1, 4, 3. This means that, unless they revoke their candidacy, the\ncandidate with label 2 will get the county’s vote. If candidate 2 revokes their candidacy, and\ncandidate 1 is still in the race, then they will get the vote, and so on.\n\nZdravko is a passionate football fan, and also a close friend of candidate with label K. He\nwants to know which candidate will win if neither of the candidates revokes their candidacy.\n\nHe also wants to know what is the minimal number of candidates he must persuade to\nrevoke their candidacy in order for his friend, candidate K, to become the president of the\nfootball association.\n\nZdravko is currently dealing with other problems, so he is hoping that you will answer these\nquestions.\n", "inputFormat": "The first line of input contains the numbers N (1 ≤ N ≤ 100), M (1 ≤ M ≤ 15) and K (1 ≤ K ≤\nM) from the task.\n\nEach of the following N lines contains the orders given by the counties’ football associations,\ni.e. a permutation of the first M natural numbers.", "outputFormat": "You must output the answers to the questions from the task, each in its own line.", "hint": "The output must consist of two non-empty lines, each containing a single integer. ~~The correct answer to each of the questions is worth 50% of points for that test case.(不会做spj没用)~~\n\n**Clarification of the first test case:**\n\nThe land where the elections are being held consists of 3 counties, and there are 4 candidates for the\npresident of the association. If neither of the candidates revoke their candidacy, candidate 3 will win\nthe elections with two votes. Candidate 1 will only win if all the other candidates revoke their\ncandidacy.\n\n**Clarification of the second test case:**\n\nThere is only one candidate, Zdravko’s friend, so they will surely win.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #4] Izbori", "background": "", "description": "In a land with developed democracy far, far away, presidential elections for the football\nassociation are taking place. This land consists of N counties, and each county has its own\nfootball association. There are M presidential candidates labeled with 1, 2, … M. Each of the\nfootball associations will select exactly one candidate to cast their vote for. The winner of the\nelection is the candidate with the most votes. If multiple candidates get the most amount of\nvotes, the winner is the one with the smallest label.\n\nDuring the election campaign, candidates visited the counties and tried to gain their\nsympathies. After having met all the candidates, each county’s football association\ndetermined the order in which they would cast their vote for each candidate.\n\nFor example, let’s assume that there are four candidates in the election and that one\ncounty’s order is 2, 1, 4, 3. This means that, unless they revoke their candidacy, the\ncandidate with label 2 will get the county’s vote. If candidate 2 revokes their candidacy, and\ncandidate 1 is still in the race, then they will get the vote, and so on.\n\nZdravko is a passionate football fan, and also a close friend of candidate with label K. He\nwants to know which candidate will win if neither of the candidates revokes their candidacy.\n\nHe also wants to know what is the minimal number of candidates he must persuade to\nrevoke their candidacy in order for his friend, candidate K, to become the president of the\nfootball association.\n\nZdravko is currently dealing with other problems, so he is hoping that you will answer these\nquestions.\n", "inputFormat": "The first line of input contains the numbers N (1 ≤ N ≤ 100), M (1 ≤ M ≤ 15) and K (1 ≤ K ≤\nM) from the task.\n\nEach of the following N lines contains the orders given by the counties’ football associations,\ni.e. a permutation of the first M natural numbers.", "outputFormat": "You must output the answers to the questions from the task, each in its own line.", "hint": "The output must consist of two non-empty lines, each containing a single integer. ~~The correct answer to each of the questions is worth 50% of points for that test case.(不会做spj没用)~~\n\n**Clarification of the first test case:**\n\nThe land where the elections are being held consists of 3 counties, and there are 4 candidates for the\npresident of the association. If neither of the candidates revoke their candidacy, candidate 3 will win\nthe elections with two votes. Candidate 1 will only win if all the other candidates revoke their\ncandidacy.\n\n**Clarification of the second test case:**\n\nThere is only one candidate, Zdravko’s friend, so they will surely win.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #4] Izbori", "background": "", "description": "在一个遥远的民主发达的土地上，正在进行足球协会的总统选举。这个土地由 N 个县组成，每个县都有自己的足球协会。有 M 名总统候选人，编号为 1, 2, … M。每个足球协会将选择一个候选人投票。选举的获胜者是获得最多选票的候选人。如果有多个候选人获得最多选票，获胜者是编号最小的候选人。\n\n在竞选期间，候选人访问了各个县，试图赢得他们的支持。在会见了所有候选人后，每个县的足球协会确定了他们为每个候选人投票的顺序。\n\n例如，假设选举中有四名候选人，一个县的投票顺序是 2, 1, 4, 3。这意味着，除非他们撤回候选资格，编号为 2 的候选人将获得该县的选票。如果候选人 2 撤回候选资格，而候选人 1 仍在竞选中，那么他们将获得选票，依此类推。\n\nZdravko 是一个热情的足球迷，也是编号为 K 的候选人的密友。他想知道如果没有候选人撤回候选资格，哪位候选人将获胜。\n\n他还想知道他必须说服多少名候选人撤回候选资格，才能让他的朋友，候选人 K，成为足球协会的主席。\n\nZdravko 目前正在处理其他问题，所以他希望你能回答这些问题。", "inputFormat": "输入的第一行包含任务中的数字 N (1 ≤ N ≤ 100), M (1 ≤ M ≤ 15) 和 K (1 ≤ K ≤ M)。\n\n接下来的 N 行中的每一行包含各县足球协会给出的投票顺序，即前 M 个自然数的一个排列。", "outputFormat": "你必须输出任务中问题的答案，每个答案占一行。", "hint": "输出必须由两个非空行组成，每行包含一个整数。~~每个问题的正确答案在该测试用例中占 50% 的分数。（不会做 spj 没用）~~\n\n**第一个测试用例的说明：**\n\n选举所在的土地由 3 个县组成，有 4 名候选人竞选协会主席。如果没有候选人撤回候选资格，候选人 3 将以两票赢得选举。候选人 1 只有在所有其他候选人撤回候选资格时才会获胜。\n\n**第二个测试用例的说明：**\n\n只有一个候选人，即 Zdravko 的朋友，所以他们肯定会赢。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4521", "type": "P", "difficulty": 5, "samples": [["3 4 4\nR 2 4\nS 4 1\nR 3 2\nR 2 0", "94"], ["3 1 1\nS 1 4\n", "24"], ["2 4 4\nS 2 0\nS 2 3\nR 1 5\nS 1 3", "80"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #4] Automobil", "background": "", "description": "Mirko has found a matrix with N rows and M columns at the back seat of his car. The first\nrow of the matrix consists of numbers 1, 2, … M, the second row of numbers M+1, M+2, …\n2⋅M and so on until the $N^{th}$  \nrow which consists of numbers (N-1)⋅M + 1, (N-1)⋅M + 2, …\nN⋅M, respectively.\n\nFor example, for N = 3 and M = 4:\n\n| - | - | - | - |\n| :----------: | :----------: | :----------: | :----------: |\n| **1** | **2** | **3** | **4** |\n| **5** | **6** | **7** | **8** |\n| **9** | **10** | **11** | **12** |\n\nSuch matrix wasn’t interesting enough to him, so he chose a row or a column K times and\nmultiplied its values with a non-negative integer.\n\nNaturally, now he wants to know the sum of all the values from the matrix. Since this sum\ncan be very large, Mirko will be satisfied with the value modulo $10^9$ + 7. Help Mirko answer\nthis question.", "inputFormat": "The first line of input contains the numbers N (1 ≤ N ≤ 1 000 000), M (1 ≤ M ≤ 1 000\n000) and K (1 ≤ K ≤ 1000) from the task.\n\n - Either the multiplication of the $X^{th}$\nrow with Y, in the form of \"R X Y\", where “R”\nrepresents row multiplication, X is a positive integer (1 ≤ X ≤ N), and Y is a\nnon-negative integer (0 ≤ Y ≤ $10^{9}$\n).\n\n - Or the multiplication of the $X^{th}$ column with Y, in the form of “S X Y”, where “S”\nrepresents column multiplication, X is a positive integer (1 ≤ X ≤ M), and Y is a\nnon-negative integer (0 ≤ Y ≤ $10^{9}$\n).", "outputFormat": "You must output the sum of the final values from the matrix modulo $10^{9}$ + 7", "hint": "In test cases worth a total of 50 points, it will hold 1 ≤ N, M ≤ 1000.\n\n**Clarification of the first test case:**\nAfter multiplying the second row with 4, the fourth column with 1, the third row with 2, and again the\nsecond row with 0, the final matrix looks like this:\n\n| - | - | - | - |\n| :----------: | :----------: | :----------: | :----------: |\n| **1** | **2** | **3** | **4** |\n| **0** | **0** | **0** | **0** |\n| **18** | **20** | **22** | **24** |\n\nThe sum of the elements from the final matrix is 1 + 2 + 3 + 4 + 0 + 0 + 0 + 0 + 18 + 20 + 22 + 24 =\n94.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #4] Automobil", "background": "", "description": "Mirko has found a matrix with N rows and M columns at the back seat of his car. The first\nrow of the matrix consists of numbers 1, 2, … M, the second row of numbers M+1, M+2, …\n2⋅M and so on until the $N^{th}$  \nrow which consists of numbers (N-1)⋅M + 1, (N-1)⋅M + 2, …\nN⋅M, respectively.\n\nFor example, for N = 3 and M = 4:\n\n| - | - | - | - |\n| :----------: | :----------: | :----------: | :----------: |\n| **1** | **2** | **3** | **4** |\n| **5** | **6** | **7** | **8** |\n| **9** | **10** | **11** | **12** |\n\nSuch matrix wasn’t interesting enough to him, so he chose a row or a column K times and\nmultiplied its values with a non-negative integer.\n\nNaturally, now he wants to know the sum of all the values from the matrix. Since this sum\ncan be very large, Mirko will be satisfied with the value modulo $10^9$ + 7. Help Mirko answer\nthis question.", "inputFormat": "The first line of input contains the numbers N (1 ≤ N ≤ 1 000 000), M (1 ≤ M ≤ 1 000\n000) and K (1 ≤ K ≤ 1000) from the task.\n\n - Either the multiplication of the $X^{th}$\nrow with Y, in the form of \"R X Y\", where “R”\nrepresents row multiplication, X is a positive integer (1 ≤ X ≤ N), and Y is a\nnon-negative integer (0 ≤ Y ≤ $10^{9}$\n).\n\n - Or the multiplication of the $X^{th}$ column with Y, in the form of “S X Y”, where “S”\nrepresents column multiplication, X is a positive integer (1 ≤ X ≤ M), and Y is a\nnon-negative integer (0 ≤ Y ≤ $10^{9}$\n).", "outputFormat": "You must output the sum of the final values from the matrix modulo $10^{9}$ + 7", "hint": "In test cases worth a total of 50 points, it will hold 1 ≤ N, M ≤ 1000.\n\n**Clarification of the first test case:**\nAfter multiplying the second row with 4, the fourth column with 1, the third row with 2, and again the\nsecond row with 0, the final matrix looks like this:\n\n| - | - | - | - |\n| :----------: | :----------: | :----------: | :----------: |\n| **1** | **2** | **3** | **4** |\n| **0** | **0** | **0** | **0** |\n| **18** | **20** | **22** | **24** |\n\nThe sum of the elements from the final matrix is 1 + 2 + 3 + 4 + 0 + 0 + 0 + 0 + 18 + 20 + 22 + 24 =\n94.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #4] Automobil", "background": null, "description": "米尔科在他的车后座上发现了一个有 $N$ 行 $M$ 列的矩阵。矩阵的第一行由数字 $1, 2, \\cdots, M$ 组成，第二行由数字 $M+1, M+2, \\cdots, 2M$ 组成，依此类推，直到第 $N$ 行，其由数字 $(N-1)M + 1, (N-1)M + 2, \\cdots, NM$ 组成。\n\n例如，对于 $N = 3$ 和 $M = 4$：\n\n| - | - | - | - |\n| :----------: | :----------: | :----------: | :----------: |\n| **1** | **2** | **3** | **4** |\n| **5** | **6** | **7** | **8** |\n| **9** | **10** | **11** | **12** |\n\n这样的矩阵对他来说不够有趣，所以他选择了一行或一列 $K$ 次，并将其值乘以一个非负整数。\n\n自然地，现在他想知道矩阵中所有值的和。由于这个和可能非常大，米尔科将对其取模 $10^9 + 7$。帮助米尔科回答这个问题。", "inputFormat": "输入的第一行包含任务中的数字 $N$（$1 \\le N \\le 10^6$）, $M$（$1\\le M\\le 10^6$）和 $K$（$1\\le K\\le 10^3$）。\n\n- 或者是将第 $X$ 行乘以 $Y$，形式为 `R X Y`，其中 `R` 表示行乘法，$X$ 是一个正整数（$1\\le X\\le N$），$Y$ 是一个非负整数（$0 \\le Y \\le 10^9$）。\n\n- 或者是将第 $X$ 列乘以 $Y$，形式为 `S X Y`，其中 `S` 表示列乘法，$X$ 是一个正整数（$1\\le X\\le M$），$Y$ 是一个非负整数（$0 \\le Y \\le 10^9$）。", "outputFormat": "你必须输出矩阵最终值的和对 $10^9 + 7$ 取模的结果。", "hint": "在总共价值 $50$ 分的测试用例中，将满足 $1 \\le N, M \\le 10^3$。\n\n**第一个测试用例的说明**：在将第二行乘以 $4$，第四列乘以 $1$，第三行乘以 $2$，再次将第二行乘以 $0$ 之后，最终矩阵如下所示：\n\n| - | - | - | - |\n| :----------: | :----------: | :----------: | :----------: |\n| **1** | **2** | **3** | **4** |\n| **0** | **0** | **0** | **0** |\n| **18** | **20** | **22** | **24** |\n\n最终矩阵中元素的和为 $1 + 2 + 3 + 4 + 0 + 0 + 0 + 0 + 18 + 20 + 22 + 24 = 94$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4522", "type": "P", "difficulty": 4, "samples": [["2 9 2\n0 1", "0 1"], ["6 499 5\n1 0 0 1 1 0", "0 1 1 1 1 0"], ["10 100 10\n0 0 0 1 1 1 1 0 1 1", "1 1 1 1 1 1 1 1 1 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #4] Vođe", "background": "", "description": "As we all very well know, goats and sheep have been fighting for years about the fields\nthey’re grazing. After many fierce fights, the goat leader and the sheep leader decided to\nmeet to try to find a peaceful solution to their problem. After many hours of discussion, they\nagreed that they will play a game for each field and that the winner will get to graze that field.\n\nThe game is played such that a total of N animals (that can be goats or sheep) form a circle\n(the exact order of goats and sheep is an agreement between their leaders). After animal i (1\n≤ i ≤ N-1), the game is continued by animal i+1, and after animal N, the game is continued by\nanimal 1. The animal starting the game can say any positive integer from the interval [1, K],\nbut only if that number is not greater than M. If the animal that started the game said the\nnumber j, then the next animal can say a number in interval [j+1, j+K], but only if that number\nis not greater than M. In other words, each animal can say a number that is greater by\nminimally 1, and maximally by K than the number said by the animal before, but only if the\nnew number is not greater than M. If an animal must say number M, its team (goats or\nsheep) loses.\n\nIf both the goats and the sheep are playing optimally, for each i (1 ≤ i ≤ N), determine who\nwill win the field if the game is started by the $i^{th}$ animal.\n", "inputFormat": "The first line of input contains N, M and K (1 ≤ N, M, K ≤ 5000), the numbers from the task.\nThe following line contains N numbers, 0 if the $i^{th}$  animal is a sheep, and 1 if it’s a goat.", "outputFormat": "Output N space-separated numbers. For each animal i (1 ≤ i ≤ N) output 0 if the sheep will\nwin the field, and 1 if the goats will win, if the $i^{th}$   animal is starting the game.\n", "hint": "In test cases worth a total of 60% of points, it will hold 1 ≤ N, M, K ≤ 500.\n\n**Clarification of the first test case:**\n\nWhen a sheep is playing first, it can play like this:\n\nThe sheep starts with number 2, after which the goat can say 3 or 4. In both cases, the sheep can say\n5, after which the goat can say either 6 or 7. In both cases, the sheep can say 8, after which the goat\ndoesn’t have any other choice but 9 and thus losing the game and the field.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #4] Vođe", "background": "", "description": "As we all very well know, goats and sheep have been fighting for years about the fields\nthey’re grazing. After many fierce fights, the goat leader and the sheep leader decided to\nmeet to try to find a peaceful solution to their problem. After many hours of discussion, they\nagreed that they will play a game for each field and that the winner will get to graze that field.\n\nThe game is played such that a total of N animals (that can be goats or sheep) form a circle\n(the exact order of goats and sheep is an agreement between their leaders). After animal i (1\n≤ i ≤ N-1), the game is continued by animal i+1, and after animal N, the game is continued by\nanimal 1. The animal starting the game can say any positive integer from the interval [1, K],\nbut only if that number is not greater than M. If the animal that started the game said the\nnumber j, then the next animal can say a number in interval [j+1, j+K], but only if that number\nis not greater than M. In other words, each animal can say a number that is greater by\nminimally 1, and maximally by K than the number said by the animal before, but only if the\nnew number is not greater than M. If an animal must say number M, its team (goats or\nsheep) loses.\n\nIf both the goats and the sheep are playing optimally, for each i (1 ≤ i ≤ N), determine who\nwill win the field if the game is started by the $i^{th}$ animal.\n", "inputFormat": "The first line of input contains N, M and K (1 ≤ N, M, K ≤ 5000), the numbers from the task.\nThe following line contains N numbers, 0 if the $i^{th}$  animal is a sheep, and 1 if it’s a goat.", "outputFormat": "Output N space-separated numbers. For each animal i (1 ≤ i ≤ N) output 0 if the sheep will\nwin the field, and 1 if the goats will win, if the $i^{th}$   animal is starting the game.\n", "hint": "In test cases worth a total of 60% of points, it will hold 1 ≤ N, M, K ≤ 500.\n\n**Clarification of the first test case:**\n\nWhen a sheep is playing first, it can play like this:\n\nThe sheep starts with number 2, after which the goat can say 3 or 4. In both cases, the sheep can say\n5, after which the goat can say either 6 or 7. In both cases, the sheep can say 8, after which the goat\ndoesn’t have any other choice but 9 and thus losing the game and the field.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #4] Vođe", "background": null, "description": "众所周知，山羊和绵羊为了它们放牧的田地已经争斗多年。在经历了许多激烈的战斗后，山羊首领和绵羊首领决定会面，尝试为他们的问题找到一个和平的解决方案。经过多小时的讨论，他们同意为每块田地玩一个游戏，胜者将获得在该田地放牧的权利。\n\n游戏的规则是，总共有 $N$ 只动物（可能是山羊或绵羊）围成一个圈（山羊和绵羊的具体顺序由它们的首领协商决定）。在动物 $i$（$1\\le i\\le N-1$）之后，游戏由动物 $i+1$ 继续，而在动物 $N$ 之后，游戏由动物 $1$ 继续。开始游戏的动物可以从区间 $[1,K]$ 中说出任意一个正整数，但这个数字不能大于 $M$。如果开始游戏的动物说了数字 $j$，那么下一个动物可以在区间 $[j+1,j+K]$ 中说一个数字，但这个数字也不能大于 $M$。换句话说，每只动物可以说出比前一只动物所说的数字大至少 $1$、最多 $K$ 的数字，但新数字不能大于 $M$。如果一只动物必须说出数字 $M$，它所在的队伍（山羊或绵羊）就会输掉。\n\n如果山羊和绵羊都以最佳策略进行游戏，对于每个 $i$（$1\\le i\\le N$），确定如果游戏由第 $i$ 只动物开始，谁将赢得这块田地。", "inputFormat": "输入的第一行包含 $N$、$M$ 和 $K$（$1\\le N,M,K\\le 5000$），如题目所述。接下来的行包含 $N$ 个数字，如果第 $i$ 只动物是绵羊，则为 0，如果是山羊，则为 1。", "outputFormat": "输出 $N$ 个以空格分隔的数字。对于每只动物 $i$（$1\\le i\\le N$），如果游戏由第 $i$ 只动物开始时绵羊将赢得田地，则输出 `0`，否则则输出 `1`。", "hint": "在总分值为 $60\\%$ 的测试用例中，将满足 $1\\le N,M,K\\le 500$。\n\n**第一个样例的说明：**\n\n当绵羊先开始时，它可以这样进行游戏：\n\n绵羊以数字 2 开始，之后山羊可以说 3 或 4。在这两种情况下，绵羊可以说 5，之后山羊可以说 6 或 7。在这两种情况下，绵羊可以说 8，之后山羊别无选择只能说 9，从而输掉游戏和田地。\n\n题面翻译由 ChatGPT-4o 提供，123asdf123 修缮。", "locale": "zh-CN"}}}
{"pid": "P4523", "type": "P", "difficulty": 5, "samples": [["4\n1 1 2 3", "3"], ["5\n4 5 7 2 2", "4"], ["6\n4 5 6 5 4 3", "0"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #4] Krov", "background": "", "description": "You are given a histogram consisting of N columns of heights $X_1,X_2,X_N$, respectively. The histogram needs to be transformed into a roof using a series of operations. A roof is a\nhistogram that has the following properties:\n- A single column is called the top of the roof. Let it be the column at position $i$.\n- The height of the column at position $j\\ (1 ≤ j ≤ N)$ is $ h_j = h_i- |i - j|$.\n- All heights $h_j$ are positive integers.\n\nAn operation can be increasing or decreasing the heights of a column of the histogram by $1$.\nIt is your task to determine the minimal number of operations needed in order to transform\nthe given histogram into a roof.\n", "inputFormat": "The first line of input contains the number $N (1 ≤ N ≤ 10^5$\n), the number of columns in the\nhistogram.\n\nThe following line contains $N$ numbers $X_i\\ (1 ≤ X_i ≤ 10^9)$, the initial column heights.", "outputFormat": "You must output the minimal number of operations from the task.\n", "hint": "In test cases worth 60% of total points, it will hold N ≤ 5000.\n\n**Clarification of the first test case:** By increasing the height of the second, third, and fourth column,\nwe created a roof where the fourth column is the top of the roof.\n\n**Clarification of the second test case:** By decreasing the height of the third column three times, and\nincreasing the height of the fourth column, we transformed the histogram into a roof. The example is\nillustrated below.\n\n![](https://cdn.luogu.com.cn/upload/pic/18666.png)", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #4] Krov", "background": "", "description": "You are given a histogram consisting of N columns of heights $X_1,X_2,X_N$, respectively. The histogram needs to be transformed into a roof using a series of operations. A roof is a\nhistogram that has the following properties:\n- A single column is called the top of the roof. Let it be the column at position $i$.\n- The height of the column at position $j\\ (1 ≤ j ≤ N)$ is $ h_j = h_i- |i - j|$.\n- All heights $h_j$ are positive integers.\n\nAn operation can be increasing or decreasing the heights of a column of the histogram by $1$.\nIt is your task to determine the minimal number of operations needed in order to transform\nthe given histogram into a roof.\n", "inputFormat": "The first line of input contains the number $N (1 ≤ N ≤ 10^5$\n), the number of columns in the\nhistogram.\n\nThe following line contains $N$ numbers $X_i\\ (1 ≤ X_i ≤ 10^9)$, the initial column heights.", "outputFormat": "You must output the minimal number of operations from the task.\n", "hint": "In test cases worth 60% of total points, it will hold N ≤ 5000.\n\n**Clarification of the first test case:** By increasing the height of the second, third, and fourth column,\nwe created a roof where the fourth column is the top of the roof.\n\n**Clarification of the second test case:** By decreasing the height of the third column three times, and\nincreasing the height of the fourth column, we transformed the histogram into a roof. The example is\nillustrated below.\n\n![](https://cdn.luogu.com.cn/upload/pic/18666.png)", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #4] Krov", "background": "", "description": "给定一个由 N 个柱子组成的直方图，其高度分别为 $X_1, X_2, \\ldots, X_N$。需要通过一系列操作将直方图转换为屋顶。屋顶是具有以下性质的直方图：  \n- 单个柱子称为屋顶的顶点。设其为位置 $i$ 的柱子。  \n- 位置 $j\\ (1 \\leq j \\leq N)$ 的柱子的高度为 $h_j = h_i - |i - j|$。  \n- 所有高度 $h_j$ 都是正整数。  \n\n一个操作可以是将直方图的某个柱子的高度增加或减少 1。  \n你的任务是确定将给定直方图转换为屋顶所需的最小操作次数。", "inputFormat": "输入的第一行包含一个数 $N\\ (1 \\leq N \\leq 10^5)$，表示直方图中的柱子数量。  \n\n接下来的行包含 $N$ 个数 $X_i\\ (1 \\leq X_i \\leq 10^9)$，表示初始的柱子高度。", "outputFormat": "你必须输出完成任务所需的最小操作次数。", "hint": "在占总分 60% 的测试用例中，将满足 $N \\leq 5000$。  \n\n**第一个测试用例的说明：** 通过增加第二、第三和第四个柱子的高度，我们创建了一个屋顶，其中第四个柱子是屋顶的顶点。  \n\n**第二个测试用例的说明：** 通过将第三个柱子的高度减少三次，并增加第四个柱子的高度，我们将直方图转换为屋顶。例子如下图所示。  \n\n![](https://cdn.luogu.com.cn/upload/pic/18666.png)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4524", "type": "P", "difficulty": 7, "samples": [["4 4\n1 2 2 4\n3 4 4 1\n4 2 1 1\n1 3 3 1\n", "8\n3\n14"], ["4 5\n1 2 1 7\n3 1 3 2\n2 4 5 2\n2 3 1 1\n2 4 7 1", "7\n6\n44"], ["3 2\n1 2 2 5\n2 1 3 3", "9\n-1"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "排序", "最短路", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #4] Ceste", "background": "**原题时限2.5s**", "description": "There’s a country with N cities and M bidirectional roads. Driving on road i takes $T_i$ minutes,\nand costs $C_i$ kunas (Croatian currency).\n\nTo make the arrival to the holiday destination as pleasant as possible, you want to make it\nas fast and as cheap as possible. More specifically, you are in city 1 and want to minimize\nthe product of total money spent and total time spent (overall, with all roads you drove on) in\ngetting to a city from city 1. For each city (except city 1), output the required minimal product\nor -1 if city 1 and that city aren’t connected.\n", "inputFormat": "The first line of input contains numbers N (1 ≤ N ≤ 2000), the number of cities, and M (1 ≤ M\n≤ 2000), the number of roads.\n\nEach of the following M lines contains four numbers,$A_i,B_i,T_i,C_i,(1≤A_i,B_i≤N,1≤T_i,C_i≤2000)$ that denote there is a road connecting cities $A_i$ and $B_i$\n, that it takes $T_i$ minutes to drive\non it, and it costs $C_i$ kunas.\n\nIt is possible that multiple roads exist between two cities, but there will never be a road that\nconnects a city with itself.\n", "outputFormat": "You must output N - 1 lines. In the $i^{th}$\nline, output the required minimal product in order to get\nto city (i + 1), or -1 if cities 1 and (i + 1) aren’t connected.", "hint": "In test cases worth 40% of total points, it will hold $1 ≤ N, M, T_i, C_i ≤ 100$.\n\n**Clarification of the second test case:**\n\nIn order to get to city 2, you need to drive on road 1, for that it takes 1 minute and 7 kunas, so the\nrequired product is 7.\n\nIn order to get to city 3, you need to drive on road 2, for that it takes 3 minutes and 2 kunas, so the\nrequired product is 6.\n\nIn order to get to city 4, you need to drive on roads 2, 4, 5, in that order, and for that it takes a total of\n11 minutes and 4 kunas, so the required product is 44.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #4] Ceste", "background": "**原题时限2.5s**", "description": "There’s a country with N cities and M bidirectional roads. Driving on road i takes $T_i$ minutes,\nand costs $C_i$ kunas (Croatian currency).\n\nTo make the arrival to the holiday destination as pleasant as possible, you want to make it\nas fast and as cheap as possible. More specifically, you are in city 1 and want to minimize\nthe product of total money spent and total time spent (overall, with all roads you drove on) in\ngetting to a city from city 1. For each city (except city 1), output the required minimal product\nor -1 if city 1 and that city aren’t connected.\n", "inputFormat": "The first line of input contains numbers N (1 ≤ N ≤ 2000), the number of cities, and M (1 ≤ M\n≤ 2000), the number of roads.\n\nEach of the following M lines contains four numbers,$A_i,B_i,T_i,C_i,(1≤A_i,B_i≤N,1≤T_i,C_i≤2000)$ that denote there is a road connecting cities $A_i$ and $B_i$\n, that it takes $T_i$ minutes to drive\non it, and it costs $C_i$ kunas.\n\nIt is possible that multiple roads exist between two cities, but there will never be a road that\nconnects a city with itself.\n", "outputFormat": "You must output N - 1 lines. In the $i^{th}$\nline, output the required minimal product in order to get\nto city (i + 1), or -1 if cities 1 and (i + 1) aren’t connected.", "hint": "In test cases worth 40% of total points, it will hold $1 ≤ N, M, T_i, C_i ≤ 100$.\n\n**Clarification of the second test case:**\n\nIn order to get to city 2, you need to drive on road 1, for that it takes 1 minute and 7 kunas, so the\nrequired product is 7.\n\nIn order to get to city 3, you need to drive on road 2, for that it takes 3 minutes and 2 kunas, so the\nrequired product is 6.\n\nIn order to get to city 4, you need to drive on roads 2, 4, 5, in that order, and for that it takes a total of\n11 minutes and 4 kunas, so the required product is 44.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #4] Ceste", "background": "", "description": "有一个无向图，给定 $n$ 个顶点和 $m$ 条边，第 $i$ 条边连接 $A_i$ 和 $B_i$ 两个点且有两个代价 $T_i$ 和 $C_i$。\n\n从第 $i$ 个顶点经过一些边到第 $j$ 个顶点花费的代价为这些边的 $T$ 之和乘以 $C$ 之和。\n\n问题是，对于每一个 $k(2 \\le k \\le n)$，求从1号点出发到 $k$ 号点花费的最小代价。", "inputFormat": "第一行两个整数 $n$ 和 $m$。\n\n接下来 $m$ 行，每行包含4个正整数 $A_i,B_i,T_i,C_i$，表示一条连接 $A_i,B_i$ 的路,代价为 $T_i,C_i$。", "outputFormat": "输出 $n-1$ 行，每行一个正整数，第 $i$ 行的正整数表示从城市1到城市 $i+1$ 的最小代价。", "hint": "对于 $40\\%$ 的数据，满足 $1 \\le n,m,T_i,C_i \\le 100$。\n\n对于 $100\\%$ 的数据，满足 $1 \\le n,m,T_i,C_i \\le 2000,1 \\le A_i,B_i \\le n$。\n\n可能存在重边，不存在自环。\n\n样例2解释：\n\n为了到达城市2，我们选择第一条道路，花费1T与7C，代价为7。\n\n为了到达城市3，我们选择第二条道路，花费3T与2C，代价为6。\n\n为了到达城市4，我们选择道路2，4，5，花费11T与4C，代价为44。\n\n2025/10/31 增加 hack 数据一组", "locale": "zh-CN"}}}
{"pid": "P4525", "type": "P", "difficulty": 5, "samples": [["1 2 3 4 5 6", "2.732937"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["数学", "递归", "积分", "定积分", "模板题"], "title": "【模板】自适应辛普森法 1", "background": null, "description": "试计算积分\n\n$\\displaystyle{\\int_L^R\\frac{cx+d}{ax+b}\\mathrm{d}x}$\n\n结果保留至小数点后 $6$ 位。\n\n数据保证计算过程中分母不为 $0$ 且积分能够收敛。", "inputFormat": "一行，包含 $6$ 个实数 $a,b,c,d,L,R$。", "outputFormat": "一行，积分值，保留至小数点后 $6$ 位。", "hint": "$a,b,c,d\\in[-10,10]$，$-100\\le L<R\\le 100$ 且 $R-L\\ge1$。\n\n保证输入的数至多只有一位小数。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Adaptive Simpson's Rule 1", "background": "", "description": "Compute the integral\n\n$\\displaystyle{\\int_L^R\\frac{cx+d}{ax+b}\\mathrm{d}x}$\n\nRound the result to $6$ decimal places.\n\nThe testdata guarantees that the denominator is not $0$ during the computation and the integral converges.", "inputFormat": "One line containing $6$ real numbers $a,b,c,d,L,R$.", "outputFormat": "One line with the value of the integral, rounded to $6$ decimal places.", "hint": "$a,b,c,d\\in[-10,10]$，$-100\\le L<R\\le 100$ 且 $R-L\\ge1$。\n\nIt is guaranteed that each input number has at most one decimal place.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】自适应辛普森法 1", "background": null, "description": "试计算积分\n\n$\\displaystyle{\\int_L^R\\frac{cx+d}{ax+b}\\mathrm{d}x}$\n\n结果保留至小数点后 $6$ 位。\n\n数据保证计算过程中分母不为 $0$ 且积分能够收敛。", "inputFormat": "一行，包含 $6$ 个实数 $a,b,c,d,L,R$。", "outputFormat": "一行，积分值，保留至小数点后 $6$ 位。", "hint": "$a,b,c,d\\in[-10,10]$，$-100\\le L<R\\le 100$ 且 $R-L\\ge1$。\n\n保证输入的数至多只有一位小数。", "locale": "zh-CN"}}}
{"pid": "P4526", "type": "P", "difficulty": 6, "samples": [["2.33", "1.51068"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["数学", "积分", "定积分", "模板题"], "title": "【模板】自适应辛普森法 2", "background": "", "description": "试计算积分\n\n$\\displaystyle{\\int_0^\\infty x^{\\frac{a}{x}-x}\\mathrm{d}x}$\n\n保留至小数点后$5$位。若积分发散，请输出$\\text{orz}$。", "inputFormat": "一行，包含一个实数，为$a$的值", "outputFormat": "一行，积分值或$\\text{orz}$", "hint": "$|a|\\le50$。\n\n请注意时空限制。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Adaptive Simpson's Method 2", "background": "", "description": "Compute the integral\n\n$\\displaystyle{\\int_0^\\infty x^{\\frac{a}{x}-x}\\mathrm{d}x}$\n\nKeep $5$ digits after the decimal point. If the integral diverges, output $\\text{orz}$.", "inputFormat": "One line containing a real number, the value of $a$.", "outputFormat": "One line: the integral value or $\\text{orz}$.", "hint": "$|a|\\le50$.\n\nPlease pay attention to the time and memory limits.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】自适应辛普森法 2", "background": "", "description": "试计算积分\n\n$\\displaystyle{\\int_0^\\infty x^{\\frac{a}{x}-x}\\mathrm{d}x}$\n\n保留至小数点后$5$位。若积分发散，请输出$\\text{orz}$。", "inputFormat": "一行，包含一个实数，为$a$的值", "outputFormat": "一行，积分值或$\\text{orz}$", "hint": "$|a|\\le50$。\n\n请注意时空限制。", "locale": "zh-CN"}}}
{"pid": "P4527", "type": "P", "difficulty": 7, "samples": [["1 0 0 1 0\n10001 2\n3\n1 10\n2 12\n4 15", "3265\n5816\n0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2008", "树套树", "CTSC/CTS"], "title": "[CTSC2008] 奥运抽奖", "background": "", "description": "距 $2008$ 年北京奥运会开幕还有90天时，CTSC 准备为志愿者们举行一次抽奖活动。作为志愿者的一员，你对这次抽奖活动自然是万分期待。\n\nCTSC 委员会介绍了抽奖活动的规则。设总共有 $p$ 个参加抽奖的志愿者，开始时每一个志愿者领取一个 $0 \\sim p-1$ 的号码。任意两个志愿者领取的号码不同。  \n\n屏幕的正中央是五福娃的头像，他们不停的眨眼欢迎大家。开始抽奖时，工作人员按下屏幕旁边的按钮，等待屏幕上的画面静止下来。这时，福娃们都停止眨眼了。  \n\n当然，画面静止时，有的福娃的眼睛可能是睁开的，有的是闭上的。如果所有福娃的眼睛都闭上了，工作人员需要重新按一 下按钮。这样，直到至少有一个福娃的眼睛是睁开的。接着，工作人员开始观察有哪些福娃的眼睛是睁开的。\n\n工作人员对五个福娃都标了号。贝贝、晶晶、欢欢、迎迎、妮妮的标号分别是 $2$、$3$、$4$、$5$、$6$（工作人员认为 $0$ 和 $1$ 都不是好数字）。定义幸运数字如下：\n\n- 如果一个福娃的眼睛是睁开的，那么他（她）对应的标号就是幸运数字；\n\n- 如果数字 $l_1$ 和 $l_2$（可能相等）都是幸运数字，那么他们的乘积也是幸运数字；\n\n- 其他的数字都不是幸运数字。\n\n用 $L$ 表示所有数字的集合，例如，如果贝贝、晶晶的眼睛是睁开的，欢欢、迎迎、妮妮的眼睛是闭上的，则 $L=\\{2,3,4,6,8,9,12,…\\}$。令 $l(x)$ 表示第 $x$ 大的幸运数字。例如，上面的例子中，$l(1)=2$，$l(4)=6$ 等等。\n\n接着，工作人员开始随机产生两个数，小的数是 $a$，大的数字是 $b$。定义集合 $T_{a,b}$ 为：$T_{a,b}=\\{d|d∈L,l(a)|d,d|l(b)\\}$（其中 $x|y$ 表示 $x$ 整除 $y$ ）\n\n定义一个自然数的有限子集的特征值 $f$ 如下：\n\n- 空集的特征值为$0$。\n\n- 对于非空集合 $S$，令 $d$ 为 $S$ 中的最小元素，则\n\n$$f(S)=d+f(S\\backslash d)+q\\times d\\times f(S\\backslash d)$$\n\n其中， $S\\backslash d$ 表示把 $S$ 删除元素 $d$ 后的集合，$q$ 是一个给定的非负整数。\n\n在 $a$ 和 $b$ 产生以后，中奖的志愿者就确定了，他的号码是 $f(T_{a,b})$ 除以 $p$ 的余数。工作人员会产生多次 $a$，$b$，这样就能形成多个中奖者。  \n\n但是，抽奖现场的程序需要很长的时间才能算出中奖的志愿者。出于对中奖结果的热切期待，你便想要重新写一下计算程序，于是，你的目光移向了前面的键盘……。", "inputFormat": "输入的第一行给出用空格隔开的五个数，每个数不是 $0$ 就是 $1$，分别表示贝贝、晶晶、欢欢、迎迎、妮妮的眼睛是否睁开。$0$ 对应眼睛闭上，$1$ 对应眼睛睁开。$5$ 个数不可能都是 $0$。\n\n第二行给出了用空格隔开的两个数，$p$ 和 $q$。 其中 $p$ 表示参加抽奖的志愿者的人数，$q$ 如前所述，用来计算集合的特征值。\n\n第三行给出了数 $n$，表示抽取的 $a$ 和 $b$ 的次数。\n\n接下来的 $n$ 行，每一行有两个数 $a$、$b$，中间用空格隔开，表示一次抽奖产生的两个数。", "outputFormat": "输出共 $n$ 行，每一行一个整数，表示一次抽奖中中奖者的号码。顺序与输入的 $n$ 对 $a$、$b$ 一一对应。当然，一个人可能中奖多次。", "hint": "【样例说明】\n\n贝贝和迎迎的眼睛是睁开的，因此，前面 $15$ 个幸运数字是 $2$、$4$、$5$、$8$、$10$、$16$、$20$、$25$、$32$、$40$、$50$、$64$、$80$、$100$、$125$。  \n\n$l(1) = 2$，$l(10) = 40$。既是 $2$ 的倍数，又是 $40$ 的约数的幸运数字有 $2$、$4$、$8$、$10$、$20$、$40$。  \n所以 $T_{1,10} = \\{2,4,8,10,20,40\\}$。$T_{1,10}$ 的特征值的计算过程为：\n\n$f(\\emptyset )=0$\n\n$f(\\{40\\})=40+0+2\\times40\\times0=40$\n\n$f(\\{20,40\\})=20+40+2\\times20\\times40=1660$\n\n$f(\\{10,20,40\\})=10+1660+2\\times10\\times1660=34870$\n\n$f(\\{8,10,20,40\\})=8+34870+2\\times8\\times34870=592798$\n\n$f(\\{4,8,10,20,40\\})=4+592798+2\\times4\\times592798=5335186$\n\n$f(\\{2,4,8,10,20,40\\})=2+5335186+2\\times2\\times5335186=26675932$\n\n所以中奖者的号码就是 $26675932$ 除以 $10001$ 的余数 —— $3265$。\n类似的，$T_{2,12} = \\{4,8,16,32,64\\}$，它的特征值是 $21167932$，除以 $10001$ 的余数是 $5816$。而 $T_{4,15} = \\emptyset$。\n\n【数据规模】   \n对于 $20\\%$ 数据，$1 ≤ a ≤ b ≤1000$，$n ≤ 2000$；   \n对于 $60\\%$ 的数据，$p$ 为素数；   \n对于 $100\\%$ 的数据，$1 ≤ a ≤ b ≤ 10^5$，$n ≤ 10^5$，$p, q ≤ 2 \\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2008] Olympic Lottery", "background": "", "description": "With $90$ days left before the opening of the Beijing $2008$ Olympics, CTSC plans to hold a lottery for volunteers. As one of the volunteers, you are very excited about it.\n\nThe CTSC committee introduces the rules. Suppose there are $p$ volunteers in total. At the beginning, each volunteer receives a distinct number from $0$ to $p-1$.\n\nIn the center of the screen are the avatars of the five Fuwa (Beibei, Jingjing, Huanhuan, Yingying, Nini), blinking to welcome everyone. When the lottery starts, the staff presses the button next to the screen and waits for the screen to stop. At that moment, the Fuwa stop blinking.\n\nOf course, when the screen stops, some Fuwa may have their eyes open while others have them closed. If all Fuwa have their eyes closed, the staff presses the button again, repeating this until at least one Fuwa has eyes open. Then, the staff observes which Fuwa have their eyes open.\n\nThe five Fuwa are labeled as follows: Beibei, Jingjing, Huanhuan, Yingying, Nini are labeled $2$, $3$, $4$, $5$, $6$ respectively (the staff think $0$ and $1$ are not good numbers). Lucky numbers are defined as follows:\n\n- If a Fuwa’s eyes are open, then his/her label is a lucky number.\n- If numbers $l_1$ and $l_2$ (possibly equal) are lucky numbers, then their product is also a lucky number.\n- All other numbers are not lucky.\n\nLet $L$ denote the set of all lucky numbers. For example, if Beibei and Jingjing have eyes open while Huanhuan, Yingying, and Nini have eyes closed, then $L=\\{2,3,4,6,8,9,12,\\dots\\}$. Let $l(x)$ denote the $x$-th lucky number in ascending order. For example, in the above case, $l(1)=2$, $l(4)=6$, and so on.\n\nNext, the staff randomly generates two numbers; let the smaller one be $a$ and the larger one be $b$. Define the set $T_{a,b}$ by\n$$T_{a,b}=\\{\\,d \\mid d\\in L,\\ l(a)\\mid d,\\ d\\mid l(b)\\,\\}$$\n(where $x\\mid y$ means $x$ divides $y$).\n\nDefine the characteristic value $f$ of a finite subset of natural numbers as follows:\n\n- The characteristic value of the empty set is $0$.\n- For a non-empty set $S$, let $d$ be the smallest element of $S$. Then\n$$f(S)=d+f(S\\backslash d)+q\\times d\\times f(S\\backslash d),$$\nwhere $S\\backslash d$ denotes the set obtained by removing the element $d$ from $S$, and $q$ is a given non-negative integer.\n\nAfter $a$ and $b$ are generated, the winner’s number is the remainder when $f(T_{a,b})$ is divided by $p$. The staff will generate many pairs $(a,b)$, thus producing multiple winners.\n\nHowever, the on-site program takes a long time to compute the winners. Eager to know the results, you decide to rewrite the computation program, and your eyes turn to the keyboard in front of you.", "inputFormat": "The first line contains five space-separated numbers, each either $0$ or $1$, indicating whether Beibei, Jingjing, Huanhuan, Yingying, and Nini have their eyes open. Here $0$ means closed and $1$ means open. The $5$ numbers cannot all be $0$.\n\nThe second line contains two space-separated numbers $p$ and $q$. Here $p$ is the number of volunteers, and $q$ is as described above for computing the characteristic value of a set.\n\nThe third line contains the number $n$, the number of generated pairs $(a,b)$.\n\nEach of the next $n$ lines contains two space-separated integers $a$ and $b$, representing one lottery draw.", "outputFormat": "Output $n$ lines, each containing one integer, the winner’s number for that draw. The order corresponds one-to-one with the $n$ pairs $(a,b)$ in the input. Of course, a person may win multiple times.", "hint": "Sample explanation:\n\nBeibei and Yingying have their eyes open. Therefore, the first $15$ lucky numbers are $2,4,5,8,10,16,20,25,32,40,50,64,80,100,125$.\n\n$l(1)=2$, $l(10)=40$. The lucky numbers that are multiples of $2$ and divisors of $40$ are $2,4,8,10,20,40$.\nSo $T_{1,10}=\\{2,4,8,10,20,40\\}$. The characteristic value of $T_{1,10}$ is computed as follows:\n\n$f(\\emptyset)=0$\n\n$f(\\{40\\})=40+0+2\\times40\\times0=40$\n\n$f(\\{20,40\\})=20+40+2\\times20\\times40=1660$\n\n$f(\\{10,20,40\\})=10+1660+2\\times10\\times1660=34870$\n\n$f(\\{8,10,20,40\\})=8+34870+2\\times8\\times34870=592798$\n\n$f(\\{4,8,10,20,40\\})=4+592798+2\\times4\\times592798=5335186$\n\n$f(\\{2,4,8,10,20,40\\})=2+5335186+2\\times2\\times5335186=26675932$\n\nTherefore, the winner’s number is the remainder of $26675932$ divided by $10001$, which is $3265$.\nSimilarly, $T_{2,12}=\\{4,8,16,32,64\\}$, whose characteristic value is $21167932$, and its remainder modulo $10001$ is $5816$. Also, $T_{4,15}=\\emptyset$.\n\nConstraints:\n- For $20\\%$ of the testdata, $1 \\le a \\le b \\le 1000$, $n \\le 2000$.\n- For $60\\%$ of the testdata, $p$ is prime.\n- For $100\\%$ of the testdata, $1 \\le a \\le b \\le 10^5$, $n \\le 10^5$, $p, q \\le 2\\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2008] 奥运抽奖", "background": "", "description": "距 $2008$ 年北京奥运会开幕还有90天时，CTSC 准备为志愿者们举行一次抽奖活动。作为志愿者的一员，你对这次抽奖活动自然是万分期待。\n\nCTSC 委员会介绍了抽奖活动的规则。设总共有 $p$ 个参加抽奖的志愿者，开始时每一个志愿者领取一个 $0 \\sim p-1$ 的号码。任意两个志愿者领取的号码不同。  \n\n屏幕的正中央是五福娃的头像，他们不停的眨眼欢迎大家。开始抽奖时，工作人员按下屏幕旁边的按钮，等待屏幕上的画面静止下来。这时，福娃们都停止眨眼了。  \n\n当然，画面静止时，有的福娃的眼睛可能是睁开的，有的是闭上的。如果所有福娃的眼睛都闭上了，工作人员需要重新按一 下按钮。这样，直到至少有一个福娃的眼睛是睁开的。接着，工作人员开始观察有哪些福娃的眼睛是睁开的。\n\n工作人员对五个福娃都标了号。贝贝、晶晶、欢欢、迎迎、妮妮的标号分别是 $2$、$3$、$4$、$5$、$6$（工作人员认为 $0$ 和 $1$ 都不是好数字）。定义幸运数字如下：\n\n- 如果一个福娃的眼睛是睁开的，那么他（她）对应的标号就是幸运数字；\n\n- 如果数字 $l_1$ 和 $l_2$（可能相等）都是幸运数字，那么他们的乘积也是幸运数字；\n\n- 其他的数字都不是幸运数字。\n\n用 $L$ 表示所有数字的集合，例如，如果贝贝、晶晶的眼睛是睁开的，欢欢、迎迎、妮妮的眼睛是闭上的，则 $L=\\{2,3,4,6,8,9,12,…\\}$。令 $l(x)$ 表示第 $x$ 大的幸运数字。例如，上面的例子中，$l(1)=2$，$l(4)=6$ 等等。\n\n接着，工作人员开始随机产生两个数，小的数是 $a$，大的数字是 $b$。定义集合 $T_{a,b}$ 为：$T_{a,b}=\\{d|d∈L,l(a)|d,d|l(b)\\}$（其中 $x|y$ 表示 $x$ 整除 $y$ ）\n\n定义一个自然数的有限子集的特征值 $f$ 如下：\n\n- 空集的特征值为$0$。\n\n- 对于非空集合 $S$，令 $d$ 为 $S$ 中的最小元素，则\n\n$$f(S)=d+f(S\\backslash d)+q\\times d\\times f(S\\backslash d)$$\n\n其中， $S\\backslash d$ 表示把 $S$ 删除元素 $d$ 后的集合，$q$ 是一个给定的非负整数。\n\n在 $a$ 和 $b$ 产生以后，中奖的志愿者就确定了，他的号码是 $f(T_{a,b})$ 除以 $p$ 的余数。工作人员会产生多次 $a$，$b$，这样就能形成多个中奖者。  \n\n但是，抽奖现场的程序需要很长的时间才能算出中奖的志愿者。出于对中奖结果的热切期待，你便想要重新写一下计算程序，于是，你的目光移向了前面的键盘……。", "inputFormat": "输入的第一行给出用空格隔开的五个数，每个数不是 $0$ 就是 $1$，分别表示贝贝、晶晶、欢欢、迎迎、妮妮的眼睛是否睁开。$0$ 对应眼睛闭上，$1$ 对应眼睛睁开。$5$ 个数不可能都是 $0$。\n\n第二行给出了用空格隔开的两个数，$p$ 和 $q$。 其中 $p$ 表示参加抽奖的志愿者的人数，$q$ 如前所述，用来计算集合的特征值。\n\n第三行给出了数 $n$，表示抽取的 $a$ 和 $b$ 的次数。\n\n接下来的 $n$ 行，每一行有两个数 $a$、$b$，中间用空格隔开，表示一次抽奖产生的两个数。", "outputFormat": "输出共 $n$ 行，每一行一个整数，表示一次抽奖中中奖者的号码。顺序与输入的 $n$ 对 $a$、$b$ 一一对应。当然，一个人可能中奖多次。", "hint": "【样例说明】\n\n贝贝和迎迎的眼睛是睁开的，因此，前面 $15$ 个幸运数字是 $2$、$4$、$5$、$8$、$10$、$16$、$20$、$25$、$32$、$40$、$50$、$64$、$80$、$100$、$125$。  \n\n$l(1) = 2$，$l(10) = 40$。既是 $2$ 的倍数，又是 $40$ 的约数的幸运数字有 $2$、$4$、$8$、$10$、$20$、$40$。  \n所以 $T_{1,10} = \\{2,4,8,10,20,40\\}$。$T_{1,10}$ 的特征值的计算过程为：\n\n$f(\\emptyset )=0$\n\n$f(\\{40\\})=40+0+2\\times40\\times0=40$\n\n$f(\\{20,40\\})=20+40+2\\times20\\times40=1660$\n\n$f(\\{10,20,40\\})=10+1660+2\\times10\\times1660=34870$\n\n$f(\\{8,10,20,40\\})=8+34870+2\\times8\\times34870=592798$\n\n$f(\\{4,8,10,20,40\\})=4+592798+2\\times4\\times592798=5335186$\n\n$f(\\{2,4,8,10,20,40\\})=2+5335186+2\\times2\\times5335186=26675932$\n\n所以中奖者的号码就是 $26675932$ 除以 $10001$ 的余数 —— $3265$。\n类似的，$T_{2,12} = \\{4,8,16,32,64\\}$，它的特征值是 $21167932$，除以 $10001$ 的余数是 $5816$。而 $T_{4,15} = \\emptyset$。\n\n【数据规模】   \n对于 $20\\%$ 数据，$1 ≤ a ≤ b ≤1000$，$n ≤ 2000$；   \n对于 $60\\%$ 的数据，$p$ 为素数；   \n对于 $100\\%$ 的数据，$1 ≤ a ≤ b ≤ 10^5$，$n ≤ 10^5$，$p, q ≤ 2 \\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4528", "type": "P", "difficulty": 7, "samples": [["5\n1 5 3 2 4", "0"], ["4\n1 2 4 3", "16777215"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2008", "线段树", "树状数组", "容斥原理", "CTSC/CTS"], "title": "[CTSC2008] 图腾", "background": "", "description": "在完成了古越州圆盘密码的研究之后，考古学家小布来到了南美大陆的西部。相传很久以前在这片土地上生活着两个部落，一个部落崇拜闪电，另一个部落崇拜高山，他们分别用闪电和山峰的形状作为各自部落的图腾。\n\n小布的团队在山洞里发现了一幅巨大的壁画，壁画上被标记出了$N$个点，经测量发现这$N$个点的水平位置和竖直位置是两两不同的。小布认为这幅壁画所包含的信息仅与这$N$个点的相对位置有关，因此不妨设坐标分别为$(1, y_1) , (2, y_2), ..., (n, y_n)$，其中$y_1\\sim y_n$是$1\\sim N$的一个排列。\n\n小布的团队打算研究在这幅壁画中包含着多少个图腾，其中闪电图腾的定义图示如下（**图腾的形式只与$4$个纵坐标值的相对大小排列顺序有关**）：\n\n![](https://cdn.luogu.com.cn/upload/pic/18466.png)\n\n即$1≤a<b<c<d≤N,y_a<y_c<y_b<y_d$\n\n崇拜高山的部落有两个氏族，因而山峰图腾有如下两种形式，左边为$A$类，右边为$B$类（**同样，图腾的形式也都只与$4$个纵坐标值的大小排列顺序有关**）：\n\n![](https://cdn.luogu.com.cn/upload/pic/18467.png)\n\n即$1≤a<b<c<d≤N,y_a<y_b<y_d<y_c$\n\n即$1≤a<b<c<d≤N,y_a<y_d<y_c<y_b$\n\n小布的团队希望知道，这$N$个点中两个部落图腾数目的差值。因此在本题中，你需要帮助小布的团队编写一个程序，计算闪电图腾数目减去山峰图腾数目的值，由于该值可能绝对值较大，本题中只需输出该值对$16777216$的余数（注意余数必为正值，例如$-1$对$16777216$的余数为$16777215$）。", "inputFormat": "输入文件totem.in中第一行包含一个整数$N$，为点的数目。\n接下来一行包含$N$个整数，分别为$y_1, y_2, …, y_n$。保证$y_1, y_2, …, y_n$是$1\\sim N$的一个排列。", "outputFormat": "输出文件totem.out仅包含一个数，表示闪电图腾数目与山峰图腾数目的差值对$16777216$的余数。", "hint": "**【样例说明】**\n\n样例一中共有$1$个闪电图腾（$1324$）和$1$个$B$类山峰图腾（$1532$）。\n\n样例二中仅有一个$A$类山峰图腾（$1243$），故差值为$-1$，答案为$16777215$。\n\n**【数据规模】**\n\n对于$10\\%$的数据，$N  ≤ 600$；\n\n对于$40\\%$的数据，$N  ≤ 5000$；\n\n对于$100\\%$的数据，$N ≤ 200000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2008] Totem", "background": "", "description": "After completing the study of the Guyuezhou (Gu Yue Zhou) disk cipher, archaeologist Xiao Bu arrived at the west of the South American continent. It is said that long ago two tribes lived on this land: one worshiped lightning, the other worshiped mountains, and they used the shapes of lightning and peaks as their totems.\n\nXiao Bu’s team discovered a huge mural in a cave. The mural marks $N$ points, and measurements show that the horizontal and vertical coordinates of these $N$ points are pairwise distinct. Xiao Bu believes the information contained in the mural depends only on the relative positions of these $N$ points, so we may set the coordinates as $(1, y_1), (2, y_2), \\ldots, (N, y_N)$, where $y_1 \\sim y_N$ is a permutation of $1 \\sim N$.\n\nThe team plans to study how many totems are contained in the mural. The definition of a lightning totem is illustrated below (the totem’s type depends only on the relative order of the four $y$-values):\n\n![](https://cdn.luogu.com.cn/upload/pic/18466.png)\n\nThat is, $1 \\le a < b < c < d \\le N,\\ y_a < y_c < y_b < y_d$.\n\nThe mountain-worship tribe has two clans, so there are two peak totem types, A on the left and B on the right (again, the totem’s type depends only on the relative order of the four $y$-values):\n\n![](https://cdn.luogu.com.cn/upload/pic/18467.png)\n\nThat is, $1 \\le a < b < c < d \\le N,\\ y_a < y_b < y_d < y_c$.\n\nThat is, $1 \\le a < b < c < d \\le N,\\ y_a < y_d < y_c < y_b$.\n\nXiao Bu’s team wants to know the difference between the counts of the two tribes’ totems. In this problem, you need to compute the number of lightning totems minus the number of peak totems. Since the absolute value of this number can be large, output the result modulo $16777216$ (the remainder must be positive; for example, the remainder of $-1$ modulo $16777216$ is $16777215$).", "inputFormat": "The first line contains an integer $N$, the number of points.  \nThe second line contains $N$ integers $y_1, y_2, \\ldots, y_N$. It is guaranteed that $y_1, y_2, \\ldots, y_N$ is a permutation of $1 \\sim N$.", "outputFormat": "Output a single integer, the remainder modulo $16777216$ of the difference between the number of lightning totems and the number of peak totems.", "hint": "[Sample Explanation]\n\nIn Sample 1, there is 1 lightning totem (1324) and 1 type B peak totem (1532).\n\nIn Sample 2, there is only one type A peak totem (1243), so the difference is $-1$, and the answer is $16777215$.\n\n[Constraints]\n\n- For $10\\%$ of the testdata, $N \\le 600$.\n- For $40\\%$ of the testdata, $N \\le 5000$.\n- For $100\\%$ of the testdata, $N \\le 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2008] 图腾", "background": "", "description": "在完成了古越州圆盘密码的研究之后，考古学家小布来到了南美大陆的西部。相传很久以前在这片土地上生活着两个部落，一个部落崇拜闪电，另一个部落崇拜高山，他们分别用闪电和山峰的形状作为各自部落的图腾。\n\n小布的团队在山洞里发现了一幅巨大的壁画，壁画上被标记出了$N$个点，经测量发现这$N$个点的水平位置和竖直位置是两两不同的。小布认为这幅壁画所包含的信息仅与这$N$个点的相对位置有关，因此不妨设坐标分别为$(1, y_1) , (2, y_2), ..., (n, y_n)$，其中$y_1\\sim y_n$是$1\\sim N$的一个排列。\n\n小布的团队打算研究在这幅壁画中包含着多少个图腾，其中闪电图腾的定义图示如下（**图腾的形式只与$4$个纵坐标值的相对大小排列顺序有关**）：\n\n![](https://cdn.luogu.com.cn/upload/pic/18466.png)\n\n即$1≤a<b<c<d≤N,y_a<y_c<y_b<y_d$\n\n崇拜高山的部落有两个氏族，因而山峰图腾有如下两种形式，左边为$A$类，右边为$B$类（**同样，图腾的形式也都只与$4$个纵坐标值的大小排列顺序有关**）：\n\n![](https://cdn.luogu.com.cn/upload/pic/18467.png)\n\n即$1≤a<b<c<d≤N,y_a<y_b<y_d<y_c$\n\n即$1≤a<b<c<d≤N,y_a<y_d<y_c<y_b$\n\n小布的团队希望知道，这$N$个点中两个部落图腾数目的差值。因此在本题中，你需要帮助小布的团队编写一个程序，计算闪电图腾数目减去山峰图腾数目的值，由于该值可能绝对值较大，本题中只需输出该值对$16777216$的余数（注意余数必为正值，例如$-1$对$16777216$的余数为$16777215$）。", "inputFormat": "输入文件totem.in中第一行包含一个整数$N$，为点的数目。\n接下来一行包含$N$个整数，分别为$y_1, y_2, …, y_n$。保证$y_1, y_2, …, y_n$是$1\\sim N$的一个排列。", "outputFormat": "输出文件totem.out仅包含一个数，表示闪电图腾数目与山峰图腾数目的差值对$16777216$的余数。", "hint": "**【样例说明】**\n\n样例一中共有$1$个闪电图腾（$1324$）和$1$个$B$类山峰图腾（$1532$）。\n\n样例二中仅有一个$A$类山峰图腾（$1243$），故差值为$-1$，答案为$16777215$。\n\n**【数据规模】**\n\n对于$10\\%$的数据，$N  ≤ 600$；\n\n对于$40\\%$的数据，$N  ≤ 5000$；\n\n对于$100\\%$的数据，$N ≤ 200000$。\n", "locale": "zh-CN"}}}
{"pid": "P4529", "type": "P", "difficulty": 6, "samples": [["100 100\n4\n80 80\n70 30\n20 20\n20 80", "312.575"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2003", "四川", "各省省选", "Special Judge"], "title": "[SCOI2003] 切割多边形", "background": "", "description": "我们希望通过切割得到一个凸 $p$ 边形，$p\\le 8$。\n\n一开始的时候，你有一个 $n\\times m$ 的矩形，即它的四角的坐标分别为 $(0,0), (0,m), (n,0), (n,m)$。每次，你可以选择一条直线把当前图形切割成两部分，保留其中一个部分（另一部分扔掉），切割线的长度为此直线在多边形内部的部分的长度。\n\n求出最短的切割线总长度。\n\n下面是一个例子，我们需要得到中间的多边形。\n\n![](https://cdn.luogu.com.cn/upload/pic/18468.png)\n\n分别沿着直线 $1,2,3,4$ 进行切割即可，得到中间的四边形。", "inputFormat": "第一行有两个整数 $n,m\\ (0 < n,m < 500)$。\n\n第二行为一个整数 $p(3\\le p\\le 8)$，以下 $p$ 行每行为两个整数 $x, y(0 < x < n, 0 < y < m)$，为按顺时针给出的各顶点坐标。\n\n数据保证多边形的是凸的，无三点共线，输入数据无错误。", "outputFormat": "仅一行，为最短切割线的总长度，四舍五入到小数点后 $3$ 位。允许有 $0.001$ 的误差。", "hint": "样例对应于图中给出的例子。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2003] Cutting a Polygon", "background": "", "description": "We wish to obtain a convex $p$-gon, $p\\le 8$.\n\nInitially, you have an $n\\times m$ rectangle; that is, its four corner coordinates are $(0,0), (0,m), (n,0), (n,m)$. Each time, you may choose a straight line to cut the current shape into two parts and keep one part (discard the other). The length of a cut is defined as the length of the portion of this line that lies inside the polygon.\n\nFind the minimal total length of all cutting lines.\n\nBelow is an example; we need to obtain the polygon in the middle.\n\n![](https://cdn.luogu.com.cn/upload/pic/18468.png)\n\nCut along lines $1, 2, 3, 4$ respectively to obtain the quadrilateral in the middle.", "inputFormat": "The first line contains two integers $n,m\\ (0 < n,m < 500)$.\n\nThe second line contains an integer $p(3\\le p\\le 8)$, and each of the following $p$ lines contains two integers $x, y(0 < x < n, 0 < y < m)$, which are the vertex coordinates given in clockwise order.\n\nIt is guaranteed that the polygon is convex, no three points are collinear, and the input is valid.", "outputFormat": "Output a single line with the minimal total length of the cutting lines, rounded to $3$ decimal places. An error of $0.001$ is allowed.", "hint": "The sample corresponds to the example shown in the figure.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2003] 切割多边形", "background": "", "description": "我们希望通过切割得到一个凸 $p$ 边形，$p\\le 8$。\n\n一开始的时候，你有一个 $n\\times m$ 的矩形，即它的四角的坐标分别为 $(0,0), (0,m), (n,0), (n,m)$。每次，你可以选择一条直线把当前图形切割成两部分，保留其中一个部分（另一部分扔掉），切割线的长度为此直线在多边形内部的部分的长度。\n\n求出最短的切割线总长度。\n\n下面是一个例子，我们需要得到中间的多边形。\n\n![](https://cdn.luogu.com.cn/upload/pic/18468.png)\n\n分别沿着直线 $1,2,3,4$ 进行切割即可，得到中间的四边形。", "inputFormat": "第一行有两个整数 $n,m\\ (0 < n,m < 500)$。\n\n第二行为一个整数 $p(3\\le p\\le 8)$，以下 $p$ 行每行为两个整数 $x, y(0 < x < n, 0 < y < m)$，为按顺时针给出的各顶点坐标。\n\n数据保证多边形的是凸的，无三点共线，输入数据无错误。", "outputFormat": "仅一行，为最短切割线的总长度，四舍五入到小数点后 $3$ 位。允许有 $0.001$ 的误差。", "hint": "样例对应于图中给出的例子。", "locale": "zh-CN"}}}
{"pid": "P4530", "type": "P", "difficulty": 7, "samples": [["10 2\n0 -1 -2 0 1 2 3 2 10 1\n10 3\n0 -1 -2 0 1 2 3 2 10 1\n0 0", "240\n241"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "CTSC/CTS"], "title": "[CTSC2006] 投篮游戏", "background": "", "description": "在大学里，体育课有很多门，每个人都可以选自己最喜欢的项目。King 这学期选的是篮球，因为篮球课的老师是一个十分有趣的人。\n\n上课的第一天，老师宣布了这门课的评分规则：\n\n有 $n$ 个篮球（$n\\ge m$），老师事先在每个球上写了一个整数（不一定相同，绝对值小于 $10000$）。有 $m$ 个篮，每个篮板上有一个计分器，显示一个整数。一个学生开始考核前先将所有计分器显示值赋为 $1$。\n\n每个学生考核时要进行 $n$ 次投篮：选择任意一个篮球投向任意一个篮。最后他必须将所有球全部投出且每个球恰好投出一次，要求每个篮至少被投进过一次。\n\n如果学生将一个写有整数 $x$ 的篮球投进了某个计分器显示为y的篮，则该篮板上的计分器显示值将从 $y$ 变成 $y\\times x$。\n\n一个学生的**原始得分** $S$ 定义为 $m$ 个计分器的显示值之和，如果 $S$ 越大则老师给这个学生的最终打分越高（事实上，老师根据名次按照正态分布给分，但此超出本题了讨论范围）。\n\nKing 是一个神投手，他保证能将 $n$ 个球全都投进。但是 King 的数学十分糟糕，他不知道该如何安排投篮，才能使得自己的**原始得分**最大，你能帮帮他吗？\n", "inputFormat": "输入有多组数据，每组数据有两行：\n\n第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数，用一个空格分开，表示老师在 $n$ 个篮球上分别写下的整数。\n\n文件以 `0 0` 结尾。一个文件中最多只有 $10$ 组数据。", "outputFormat": "\n每组数据一行，包含一个整数 $S_{max}$，表示最大可能的原始得分。\n\n提示：$S_{max}$ 可能超过任何基本整数类型。$S_{max}$ 也可能比 $0$ 小。", "hint": "\n**【约定】**\n\n- $1≤ m≤n≤ 2000$。\n\n- 恰有 $40\\%$ 的数据满足 $n≤100$。\n\n**【样例说明】**\n\n第一组数据有多解，其中一解为：$(0,0)(-1,-2,1,2,3,2,10,1)$\n\n第二组数据有多解，其中一解为：$(0,0)(1,1)(-1,-2,2,3,2,10)$", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2006] Shooting Game", "background": "", "description": "At university, there are many P.E. classes, and everyone can pick what they like. This semester, King chose basketball because the instructor is a very interesting person.\n\nOn the first day, the instructor announced the grading rules:\n\nThere are $n$ basketballs ($n \\ge m$). The instructor has written an integer on each ball in advance (not necessarily distinct, with absolute value less than $10000$). There are $m$ baskets, and each basket has a counter displaying an integer. Before a student starts, all counters are initialized to $1$.\n\nDuring the assessment, a student will take $n$ shots in total: for each shot, choose any basketball and throw it into any basket. In the end, all balls must be used and each ball must be used exactly once, and every basket must be used at least once.\n\nIf a ball labeled with integer $x$ is thrown into a basket whose counter currently displays $y$, then that basket’s counter changes from $y$ to $y \\times x$.\n\nA student’s raw score $S$ is defined as the sum of the $m$ counters’ displayed values. The larger $S$ is, the higher the final grade the instructor will assign (in fact, the instructor grades by ranking using a normal distribution, but that is beyond the scope of this problem).\n\nKing is a sharpshooter and guarantees every shot goes in. However, King is bad at math and does not know how to arrange the shots to maximize his raw score. Can you help him?", "inputFormat": "Multiple testcases. Each testcase consists of two lines:\n\n- The first line contains two integers $n, m$.\n- The second line contains $n$ integers separated by spaces, which are the integers written on the $n$ basketballs.\n\nThe input ends with a line containing `0 0`. There are at most $10$ testcases in a file.", "outputFormat": "For each testcase, output one line containing an integer $S_{max}$, the maximum possible raw score.", "hint": "- Constraints:\n  - $1 \\le m \\le n \\le 2000$.\n  - Exactly $40\\%$ of the testcases satisfy $n \\le 100$.\n\n- Notes:\n  - $S_{max}$ may exceed any basic integer type.\n  - $S_{max}$ may also be less than $0$.\n\n- Sample Explanation:\n  - The first testcase has multiple solutions; one solution is: $(0,0)(-1,-2,1,2,3,2,10,1)$.\n  - The second testcase has multiple solutions; one solution is: $(0,0)(1,1)(-1,-2,2,3,2,10)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2006] 投篮游戏", "background": "", "description": "在大学里，体育课有很多门，每个人都可以选自己最喜欢的项目。King 这学期选的是篮球，因为篮球课的老师是一个十分有趣的人。\n\n上课的第一天，老师宣布了这门课的评分规则：\n\n有 $n$ 个篮球（$n\\ge m$），老师事先在每个球上写了一个整数（不一定相同，绝对值小于 $10000$）。有 $m$ 个篮，每个篮板上有一个计分器，显示一个整数。一个学生开始考核前先将所有计分器显示值赋为 $1$。\n\n每个学生考核时要进行 $n$ 次投篮：选择任意一个篮球投向任意一个篮。最后他必须将所有球全部投出且每个球恰好投出一次，要求每个篮至少被投进过一次。\n\n如果学生将一个写有整数 $x$ 的篮球投进了某个计分器显示为y的篮，则该篮板上的计分器显示值将从 $y$ 变成 $y\\times x$。\n\n一个学生的**原始得分** $S$ 定义为 $m$ 个计分器的显示值之和，如果 $S$ 越大则老师给这个学生的最终打分越高（事实上，老师根据名次按照正态分布给分，但此超出本题了讨论范围）。\n\nKing 是一个神投手，他保证能将 $n$ 个球全都投进。但是 King 的数学十分糟糕，他不知道该如何安排投篮，才能使得自己的**原始得分**最大，你能帮帮他吗？\n", "inputFormat": "输入有多组数据，每组数据有两行：\n\n第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数，用一个空格分开，表示老师在 $n$ 个篮球上分别写下的整数。\n\n文件以 `0 0` 结尾。一个文件中最多只有 $10$ 组数据。", "outputFormat": "\n每组数据一行，包含一个整数 $S_{max}$，表示最大可能的原始得分。\n\n提示：$S_{max}$ 可能超过任何基本整数类型。$S_{max}$ 也可能比 $0$ 小。", "hint": "\n**【约定】**\n\n- $1≤ m≤n≤ 2000$。\n\n- 恰有 $40\\%$ 的数据满足 $n≤100$。\n\n**【样例说明】**\n\n第一组数据有多解，其中一解为：$(0,0)(-1,-2,1,2,3,2,10,1)$\n\n第二组数据有多解，其中一解为：$(0,0)(1,1)(-1,-2,2,3,2,10)$", "locale": "zh-CN"}}}
{"pid": "P4531", "type": "P", "difficulty": 5, "samples": [["3 4 10000\n40 45 52\n10 27 30 55", "7 8250"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2005", "CTSC/CTS"], "title": "[CTSC2005] 魔术眼镜盒", "background": "", "description": "小花买了一只很有意思的魔术眼镜盒。眼镜盒盖由两半组成，每半水平分割为若干条纸带，如图1所示（左半为盒子底部，右半为盒子顶部）。灰色表示盒子的表面，白色表示空白区域。下图的眼镜盒有 $3$ 个纸带，每个纸带的长度均为 $50$ 毫米，但其他眼镜盒可能有不同数目的纸带，每条纸带的长度也不一定一样。\n\n![](https://cdn.luogu.com.cn/upload/pic/18472.png)\n\n眼镜盒的特别之处在于它有两种折法。图1的(a)和(b)就是它的两种折法，第一种折法把区域 $1，2，3$ 暴露在盒子的表面，而第二种折法把区域 $4，5，6$ 暴露在盒子的表面。如果一个眼镜盒有 $n$ 条纸带，那么折法1暴露出来的区域编号为 $1，2，...，n$，折法2暴露出来的区域编号为 $n+1，n+2，...，2n$ 。第 $i$ 个区域和第 $n+i$ 个区域是全等的。**在本题中，你不需要了解两种折法是怎么互相转化的**。\n\n小花有两种正方形纸片：公式纸片和卡通图片。她想把公式纸片贴在区域 $1，2，3$ 中，而把卡通图片贴在 $4，5，6$ 中，在学习的时候使用折法1，休息的时候使用折法2。每张纸片都必须完全位于区域的内部，纸片边界可以和区域边界重合。不同的纸片必须贴在不同的区域，有的区域内也可以不贴纸片。\n\n标准的眼镜盒长度为 $150$，宽度为 $55$，面积为 $8250$，分为长度相等的三个纸带，因此每个白色区域的尺寸为 $55 \\times 50$。小花有 $3$ 张公式纸片，边长分别为 $40，45$ 和 $52$；$4$ 张卡通纸片，边长分别为 $10, 27, 30, 55$，只能在正面放 $40$ 和 $45$，反面放 $10，27$ 和 $30$。显然，标准眼镜盒并不能满足小花的要求。\n\n好在眼镜盒公司允许用户订做自己的眼镜盒，盒子长度、宽度、纸带数目和每条纸带的长度都是可以任意修改的，即长度可以不是 $150$，宽度也可以不是 $55$。小花发现如果眼镜盒子尺寸不变，而换四条长度为 $40, 45, 55$ 和 $10$ 的纸带，所有纸片就都能放下了，如图2所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/18473.png)\n\n面积越大的眼镜盒越贵，因此小花希望买一个面积不超过 $s$ 的眼镜盒。应该如何选购眼镜盒、设计纸带和贴小纸片，使得眼镜盒上的小纸片总数尽量多？纸片最多的前提下，眼镜盒的面积最小是多大？", "inputFormat": "输入文件的第一行为三个整数 $n，m$ 和 $s$，分别表示公式纸片，卡通纸片的个数，以及眼镜盒的面积上限。第二行有 $n$ 个正整数，表示每个公式纸片的边长；第三行有 $m$ 个正整数，表示每个卡通图片的边长。", "outputFormat": "输出文件仅包含一行，有两个整数 $C_{max}$ 和 $S_{min}$，表示能贴在盒上的纸片个数的最大值，及在此条件下眼镜盒面积的最小值。", "hint": "$1 \\le n,m \\le 5 \\times 10^4, 1 \\le s\\le 10^{13}$，所有纸片边长不超过 $4 \\times 10^4$。\n\n$50 \\%$ 的数据满足 $1 \\le n,m \\le 10^3$", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2005] Magic Glasses Case", "background": "", "description": "Xiaohua bought a very interesting magic glasses case. The lid of the case is made of two halves, and each half is horizontally divided into several paper strips, as shown in Figure 1 (the left half is the bottom part of the case, and the right half is the top part). Gray indicates the surface of the case, and white indicates blank areas. The case in the figure has $3$ strips, and each strip has length $50$ mm, but other cases may have a different number of strips, and the lengths of the strips may also be different.\n\n![](https://cdn.luogu.com.cn/upload/pic/18472.png)\n\nThe special thing about this case is that it can be folded in two ways. Figure 1(a) and (b) show these two folding methods. The first folding method exposes areas $1,2,3$ on the surface of the case, while the second folding method exposes areas $4,5,6$ on the surface. If a case has $n$ strips, then folding method 1 exposes areas numbered $1,2,\\ldots,n$, and folding method 2 exposes areas numbered $n+1,n+2,\\ldots,2n$. Area $i$ and area $n+i$ are congruent. **In this problem, you do not need to know how the two folding methods are converted into each other.**\n\nXiaohua has two kinds of square paper pieces: formula pieces and cartoon pictures. She wants to stick the formula pieces onto areas $1,2,3$, and stick the cartoon pictures onto areas $4,5,6$, so that she can use folding method 1 when studying and folding method 2 when resting. Each paper piece must lie completely inside an area, and its boundary is allowed to coincide with the boundary of the area. Different paper pieces must be placed in different areas, and some areas may also be left empty.\n\nA standard case has length $150$, width $55$, and area $8250$. It is divided into three strips of equal length, so each white area has size $55 \\times 50$. Xiaohua has $3$ formula pieces with side lengths $40,45,52$, and $4$ cartoon pieces with side lengths $10, 27, 30, 55$. She can only place $40$ and $45$ on the front side, and $10,27,30$ on the back side. Obviously, the standard case cannot meet her needs.\n\nFortunately, the case company allows users to customize their own cases: the case length, width, number of strips, and the length of each strip can all be modified arbitrarily. That is, the length does not have to be $150$, and the width does not have to be $55$. Xiaohua found that if the case size stays the same, but the strips are changed to four strips with lengths $40,45,55,10$, then all pieces can fit, as shown in Figure 2.\n\n![](https://cdn.luogu.com.cn/upload/pic/18473.png)\n\nA larger-area case is more expensive, so Xiaohua wants to buy a case with area not exceeding $s$. How should she choose the case, design the strips, and place the small paper pieces, so that the total number of pieces on the case is as large as possible? Under the condition that the number of pieces is maximized, what is the minimum possible area of the case?", "inputFormat": "The first line of the input contains three integers $n,m,s$, representing the numbers of formula pieces, cartoon pieces, and the upper limit on the case area, respectively. The second line contains $n$ positive integers, representing the side length of each formula piece. The third line contains $m$ positive integers, representing the side length of each cartoon picture.", "outputFormat": "The output contains only one line with two integers $C_{max}$ and $S_{min}$, representing the maximum number of pieces that can be stuck onto the case, and the minimum case area under this condition.", "hint": "Constraints: $1 \\le n,m \\le 5 \\times 10^4$, $1 \\le s \\le 10^{13}$. All paper piece side lengths do not exceed $4 \\times 10^4$.\n\nFor $50\\%$ of the testdata: $1 \\le n,m \\le 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2005] 魔术眼镜盒", "background": "", "description": "小花买了一只很有意思的魔术眼镜盒。眼镜盒盖由两半组成，每半水平分割为若干条纸带，如图1所示（左半为盒子底部，右半为盒子顶部）。灰色表示盒子的表面，白色表示空白区域。下图的眼镜盒有 $3$ 个纸带，每个纸带的长度均为 $50$ 毫米，但其他眼镜盒可能有不同数目的纸带，每条纸带的长度也不一定一样。\n\n![](https://cdn.luogu.com.cn/upload/pic/18472.png)\n\n眼镜盒的特别之处在于它有两种折法。图1的(a)和(b)就是它的两种折法，第一种折法把区域 $1，2，3$ 暴露在盒子的表面，而第二种折法把区域 $4，5，6$ 暴露在盒子的表面。如果一个眼镜盒有 $n$ 条纸带，那么折法1暴露出来的区域编号为 $1，2，...，n$，折法2暴露出来的区域编号为 $n+1，n+2，...，2n$ 。第 $i$ 个区域和第 $n+i$ 个区域是全等的。**在本题中，你不需要了解两种折法是怎么互相转化的**。\n\n小花有两种正方形纸片：公式纸片和卡通图片。她想把公式纸片贴在区域 $1，2，3$ 中，而把卡通图片贴在 $4，5，6$ 中，在学习的时候使用折法1，休息的时候使用折法2。每张纸片都必须完全位于区域的内部，纸片边界可以和区域边界重合。不同的纸片必须贴在不同的区域，有的区域内也可以不贴纸片。\n\n标准的眼镜盒长度为 $150$，宽度为 $55$，面积为 $8250$，分为长度相等的三个纸带，因此每个白色区域的尺寸为 $55 \\times 50$。小花有 $3$ 张公式纸片，边长分别为 $40，45$ 和 $52$；$4$ 张卡通纸片，边长分别为 $10, 27, 30, 55$，只能在正面放 $40$ 和 $45$，反面放 $10，27$ 和 $30$。显然，标准眼镜盒并不能满足小花的要求。\n\n好在眼镜盒公司允许用户订做自己的眼镜盒，盒子长度、宽度、纸带数目和每条纸带的长度都是可以任意修改的，即长度可以不是 $150$，宽度也可以不是 $55$。小花发现如果眼镜盒子尺寸不变，而换四条长度为 $40, 45, 55$ 和 $10$ 的纸带，所有纸片就都能放下了，如图2所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/18473.png)\n\n面积越大的眼镜盒越贵，因此小花希望买一个面积不超过 $s$ 的眼镜盒。应该如何选购眼镜盒、设计纸带和贴小纸片，使得眼镜盒上的小纸片总数尽量多？纸片最多的前提下，眼镜盒的面积最小是多大？", "inputFormat": "输入文件的第一行为三个整数 $n，m$ 和 $s$，分别表示公式纸片，卡通纸片的个数，以及眼镜盒的面积上限。第二行有 $n$ 个正整数，表示每个公式纸片的边长；第三行有 $m$ 个正整数，表示每个卡通图片的边长。", "outputFormat": "输出文件仅包含一行，有两个整数 $C_{max}$ 和 $S_{min}$，表示能贴在盒上的纸片个数的最大值，及在此条件下眼镜盒面积的最小值。", "hint": "$1 \\le n,m \\le 5 \\times 10^4, 1 \\le s\\le 10^{13}$，所有纸片边长不超过 $4 \\times 10^4$。\n\n$50 \\%$ 的数据满足 $1 \\le n,m \\le 10^3$", "locale": "zh-CN"}}}
{"pid": "P4532", "type": "P", "difficulty": 0, "samples": [["8 30.0\nA -2\nA 0\nB 7 8 5.0\nB 4 -3 2.0\nB -3 4 1.0\nA 2\nB -4 5 1.0\nA 4", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2005", "CTSC/CTS"], "title": "[CTSC2005] 合并正方形", "background": "", "description": "一个二维平面初始时为空，有一串往平面中加入点的命令。\n\n加入的点有两种，这里称为 A 类点和 B 类点（如图 1，黑色正方形表示 A 类点，小圆黑点表示 B 类点）。A 类点一定位于 $X$ 轴上，而且不会重叠，而 B 类点可以出现在平面上的任何一个位置，可以重叠。每个 B 类点有一个权值 $W$。\n\n![](https://cdn.luogu.com.cn/upload/pic/18474.png)\n\n处理：一、最初，将相邻两个 A 类点之间连一个与 $X$ 轴成 $45$ 度的正方形（如图 2）。二、每次可以将任意两个有公共点的正方形合并为一个大正方形，合并之后两个小正方形消失。图 2 的左数第 $2$、$3$ 的正方形合并后在图 3 中表示为灰边正方形。\n\n![](https://cdn.luogu.com.cn/upload/pic/18475.png)\n\n合并后的正方形将平面划分为 $9$ 个区域，与正方形 $4$ 条边相邻的 $4$ 个区域分别为图 3 中的 I，II，III，IV。落在区域 I 中的 B 类点的权值和记为 $w_1$，落在区域 II 中的 B 类点的权值和记为 $w_2$，落在区域 III 中的 B 类点的权值和记为 $w_3$，落在区域 IV 中的 B 类点的权值和记为 $w_4$。落在灰色正方形内部的 B 类点的权值和记为 $w_5$（B 类点保证不会出现在任何一个区域的边界上），则合并费用为 $w_1+2w_2+3w_3+4w_4+5w_5$。落在其他区域的 B 类点不予考虑。每次合并之后并不影响 B 类点在平面上的位置和它自己所拥有的权值。\n\n每进行一次合并，由 A 类点形成的正方形会减少一个，直到只剩下一个正方形为止。合并总费用为每次合并费用之和。不同合并顺序的合并费用可能会不同。\n\n点是一个一个加入到平面的。加入第 $i$ 个 A 类点后，平面上有 $i$ 个 A 类点和在此之前加入的所有 B 类点。设此时的**最小**合并费用为 $f(i)$。\n\n给定费用限制 $L$，编程求出 A 类点的最大数目 $K$，使得**前 $K$ 个 A 类点**的最小合并费用不超过 $L$，即 $f(K)\\le L$。 ", "inputFormat": "第一行包含两个数 $M$，$L$，表示有 $M$ 条加入点的命令，费用限制为 $L$。\n\n以下包含 $M$ 行，每行一个字母表示点的类型。`A` 表示 A 类点，`B` 表示 B 类点。对于 A 类点，后面一个数表示这个点的 $X$ 坐标；对于 B 类点，后面三个数表示这个点的 $X$，$Y$ 坐标和这个点的权值。", "outputFormat": "输出文件仅包含一个整数 $K_{max}$，即使 $f(K) \\le L$的最大 $K$。", "hint": "### 样例说明\n\n输入最后一个点时，所有点如下图。B 类点旁边的数字为权值。\n\n![](https://cdn.luogu.com.cn/upload/pic/18476.png)\n\n合并前 $3$ 个点的最小费用为 $f(3) = 27$，合并前 $4$ 个点的最小费用 $f(4) = 36$。由于 $f(3) < 30$ 而 $f(4) > 30$，因此最大的 $K$ 为 $3$。\n\n### 约定\n\n$3 \\le \\text{A 类点的数目} \\le 30000$\n\n$5 \\le M \\le 100000$\n\n$X$，$Y$均为整数，绝对值不超过 $10000000$\n\n$L, W$ 均为实数，$0<W \\le 10000$，$L\\le 10^{11}$，所有输入实数最多保留三位小数\n\n$50\\%$ 的数据满足 $M \\le3000$", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2005] Merging Squares", "background": "", "description": "A two-dimensional plane is initially empty. There is a sequence of commands that add points to the plane.\n\nThere are two kinds of points, called type A points and type B points (see Figure 1, where black squares denote type A points and small black dots denote type B points). Type A points always lie on the $X$-axis and never overlap, while type B points can appear anywhere on the plane and may overlap. Each type B point has a weight $W$.\n\n![](https://cdn.luogu.com.cn/upload/pic/18474.png)\n\nProcessing: (1) Initially, between every pair of adjacent type A points, draw a square whose sides make a $45$-degree angle with the $X$-axis (see Figure 2). (2) Each time, you may merge any two squares that share at least one common point into a larger square; after merging, the two smaller squares disappear. The second and third squares from the left in Figure 2 are merged and shown as the gray-edged square in Figure 3.\n\n![](https://cdn.luogu.com.cn/upload/pic/18475.png)\n\nAfter merging, the resulting square divides the plane into $9$ regions. The $4$ regions adjacent to the $4$ sides of the square are labeled I, II, III, IV in Figure 3. Let $w_1$ be the sum of weights of type B points falling into region I, $w_2$ for region II, $w_3$ for region III, and $w_4$ for region IV. Let $w_5$ be the sum of weights of type B points falling inside the gray square (type B points are guaranteed not to lie on the boundaries of any region). Then the cost of this merge is $w_1 + 2 w_2 + 3 w_3 + 4 w_4 + 5 w_5$. Type B points in other regions are ignored. Each merge does not affect the positions or weights of the type B points.\n\nEach time you perform a merge, the number of squares formed by type A points decreases by one, until only one square remains. The total merge cost is the sum of the costs of all merges. Different merge orders may result in different total costs.\n\nPoints are added to the plane one by one. After adding the $i$-th type A point, the plane contains $i$ type A points and all previously added type B points. Let the minimum total merge cost at this moment be $f(i)$.\n\nGiven a cost limit $L$, compute the maximum number $K$ of type A points such that the minimum total merge cost for the first $K$ type A points does not exceed $L$, i.e., $f(K) \\le L$.", "inputFormat": "The first line contains two numbers $M$, $L$, meaning there are $M$ add-point commands and the cost limit is $L$.\n\nThen follow $M$ lines, each starting with a letter indicating the point type. `A` denotes a type A point, and `B` denotes a type B point. For a type A point, one number follows giving its $X$-coordinate; for a type B point, three numbers follow giving its $X$-coordinate, $Y$-coordinate, and weight.", "outputFormat": "Output a single integer $K_{max}$, which is the largest $K$ such that $f(K) \\le L$.", "hint": "Sample explanation:\n\nIn the state after adding the last point, all points are as shown below. The number next to each type B point is its weight.\n\n![](https://cdn.luogu.com.cn/upload/pic/18476.png)\n\nThe minimum cost for the first $3$ type A points is $f(3) = 27$, and for the first $4$ type A points is $f(4) = 36$. Since $f(3) < 30$ and $f(4) > 30$, the maximum $K$ is $3$.\n\nConstraints:\n\n- $3 \\le \\text{number of type A points} \\le 30000$.\n- $5 \\le M \\le 100000$.\n- $X$, $Y$ are integers with absolute value at most $10000000$.\n- $L$, $W$ are real numbers with $0 < W \\le 10000$, $L \\le 10^{11}$; all input real numbers have at most three decimal places.\n- $50\\%$ of the testdata satisfies $M \\le 3000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2005] 合并正方形", "background": "", "description": "一个二维平面初始时为空，有一串往平面中加入点的命令。\n\n加入的点有两种，这里称为 A 类点和 B 类点（如图 1，黑色正方形表示 A 类点，小圆黑点表示 B 类点）。A 类点一定位于 $X$ 轴上，而且不会重叠，而 B 类点可以出现在平面上的任何一个位置，可以重叠。每个 B 类点有一个权值 $W$。\n\n![](https://cdn.luogu.com.cn/upload/pic/18474.png)\n\n处理：一、最初，将相邻两个 A 类点之间连一个与 $X$ 轴成 $45$ 度的正方形（如图 2）。二、每次可以将任意两个有公共点的正方形合并为一个大正方形，合并之后两个小正方形消失。图 2 的左数第 $2$、$3$ 的正方形合并后在图 3 中表示为灰边正方形。\n\n![](https://cdn.luogu.com.cn/upload/pic/18475.png)\n\n合并后的正方形将平面划分为 $9$ 个区域，与正方形 $4$ 条边相邻的 $4$ 个区域分别为图 3 中的 I，II，III，IV。落在区域 I 中的 B 类点的权值和记为 $w_1$，落在区域 II 中的 B 类点的权值和记为 $w_2$，落在区域 III 中的 B 类点的权值和记为 $w_3$，落在区域 IV 中的 B 类点的权值和记为 $w_4$。落在灰色正方形内部的 B 类点的权值和记为 $w_5$（B 类点保证不会出现在任何一个区域的边界上），则合并费用为 $w_1+2w_2+3w_3+4w_4+5w_5$。落在其他区域的 B 类点不予考虑。每次合并之后并不影响 B 类点在平面上的位置和它自己所拥有的权值。\n\n每进行一次合并，由 A 类点形成的正方形会减少一个，直到只剩下一个正方形为止。合并总费用为每次合并费用之和。不同合并顺序的合并费用可能会不同。\n\n点是一个一个加入到平面的。加入第 $i$ 个 A 类点后，平面上有 $i$ 个 A 类点和在此之前加入的所有 B 类点。设此时的**最小**合并费用为 $f(i)$。\n\n给定费用限制 $L$，编程求出 A 类点的最大数目 $K$，使得**前 $K$ 个 A 类点**的最小合并费用不超过 $L$，即 $f(K)\\le L$。 ", "inputFormat": "第一行包含两个数 $M$，$L$，表示有 $M$ 条加入点的命令，费用限制为 $L$。\n\n以下包含 $M$ 行，每行一个字母表示点的类型。`A` 表示 A 类点，`B` 表示 B 类点。对于 A 类点，后面一个数表示这个点的 $X$ 坐标；对于 B 类点，后面三个数表示这个点的 $X$，$Y$ 坐标和这个点的权值。", "outputFormat": "输出文件仅包含一个整数 $K_{max}$，即使 $f(K) \\le L$的最大 $K$。", "hint": "### 样例说明\n\n输入最后一个点时，所有点如下图。B 类点旁边的数字为权值。\n\n![](https://cdn.luogu.com.cn/upload/pic/18476.png)\n\n合并前 $3$ 个点的最小费用为 $f(3) = 27$，合并前 $4$ 个点的最小费用 $f(4) = 36$。由于 $f(3) < 30$ 而 $f(4) > 30$，因此最大的 $K$ 为 $3$。\n\n### 约定\n\n$3 \\le \\text{A 类点的数目} \\le 30000$\n\n$5 \\le M \\le 100000$\n\n$X$，$Y$均为整数，绝对值不超过 $10000000$\n\n$L, W$ 均为实数，$0<W \\le 10000$，$L\\le 10^{11}$，所有输入实数最多保留三位小数\n\n$50\\%$ 的数据满足 $M \\le3000$", "locale": "zh-CN"}}}
{"pid": "P4533", "type": "P", "difficulty": 0, "samples": [["3 2\n1 3 2 4 3 5\n1 1 -1 1 2\n1 1 1 2 3", "3 3 4 4 3 3"], ["3 1\n1 5 2 5 1 3\n2 1 1 1 2 3", "1 2 2 3 2 3"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2005", "CTSC/CTS"], "title": "[CTSC2005] 玩具的重量", "background": null, "description": "冰冰有三个玩具：皮卡秋、维妮孙悟空和芭比娃娃。她并不知道这些玩具的具体重量（采用 NOI 单位），但是知道每个玩具重量的大概范围，如下表：\n\n表 1. \n玩具和它们的最小、最大可能重量|皮卡秋|维妮孙悟空|芭比娃娃\n:-:|:-:|:-:|:-:\n最小可能重量|$1$|$2$|$3$\n最大可能重量|$3$|$4$|$5$\n\n这些范围太粗略，冰冰希望能把它们缩小一些。\n\n正好佳佳有一个电子天平，不仅可以告诉你左右两边是否一样重，还可以告诉你左边比右边重（或轻）多少。天平很大，左右两边都可以放任意多件玩具。\n\n冰冰向佳佳借电子天平，希望能算出每个玩具的精确重量。佳佳为了考验冰冰，只允许她把任意一个玩具往天平的左侧和右侧最多各放一次。例如，如果她曾经把皮卡秋放在天平的左侧，则她不能再次把它放在天平的左侧。冰冰同意了。她一共称量了两次，结果如下（数字表示左边比右边重多少）：\n\n![](https://cdn.luogu.com.cn/upload/pic/18477.png)\n\n根据结果和表 1，可以确定三个玩具的重量一定是 $3,4,3$，也就是说，通过称量结果所得到的更新后的重量范围是：\n\n表2. 根据称量结果所得到的精确范围|皮卡秋|维妮孙悟空|芭比娃娃\n:-:|:-:|:-:|:-:\n最小可能重量|$3$|$4$|$3$\n最大可能重量|$3$|$4$|$3$\n\n冰冰以后还会买很多很多玩具，她不想每次都自己计算每个玩具的重量。她需要写一个程序计算每个玩具最精确的重量下限和上限，你能帮她吗？", "inputFormat": "输入文件第一行包含两个整数 $n$ 和 $m$，即玩具的个数和称量的次数。\n\n第二行包含 $2n$ 个数，第 $2i-1$ 个数和第 $2i$ 个数分别表示第 $i$ 个玩具的重量初始下限和初始上限。\n\n以下 $m$ 行，每行前三个数 $L，R，D$ 表示左边的玩具数、右边的玩具数和左右两边的重量差（$L, R \\ge 0$），接下来的 $L$ 个数为天平左边的玩具编号，再接下来的 $R$ 个数为天平右边的玩具编号。输入保证每个玩具在天平的每一边最多出现一次。", "outputFormat": "输出文件包含 $2n$ 个整数，第 $2i-1$ 个数和第 $2i$ 个数分别表示第 $i$ 个玩具的重量下限和上限，即最小可能的整数重量和最大可能的整数重量。如果无解（可能是天平坏了），只输出一个数 $-1$。", "hint": "【样例解释】\n\n样例 $1$ 对应于题目描述中的例子。\n\n在样例 $2$ 中，冰冰有三个玩具，重量的原始范围为 $1 \\sim 5$, $2 \\sim 5$, $1 \\sim 3$。只有一次称量，天平的左边是玩具 $1$ 和玩具 $2$，右边是玩具 $3$。左边比右边重 $1$ 个单位。根据此结果，可以判断三个玩具的重量范围为 $1 \\sim 2$，$2 \\sim 3$ 和 $2 \\sim 3$。\n\n【约定】\n\n$3 \\le n \\le 200, 1 \\le m \\le 100$，重量上限不超过 $20000$。\n\n$50\\%$ 的数据满足 $3 \\le n \\le 10，1 \\le m \\le 5$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2005] Toy Weights", "background": "", "description": "Bingbing has three toys: Pikachu, Weini Sun Wukong, and a Barbie doll. She does not know their exact weights (in NOI units), but she knows an approximate range for each toy, as shown below:\n\nTable 1.\nToys and their minimum and maximum possible weights|Pikachu|Weini Sun Wukong|Barbie doll\n:-:|:-:|:-:|:-:\nMinimum possible weight|$1$|$2$|$3$\nMaximum possible weight|$3$|$4$|$5$\n\nThese ranges are too coarse, and Bingbing wants to narrow them down.\n\nJiajia happens to have a digital balance. It can tell not only whether the two sides are equal in weight, but also by how much the left side is heavier (or lighter) than the right. The balance is large; either side can hold any number of toys.\n\nBingbing borrows the balance and hopes to determine the exact weight of each toy. To test her, Jiajia allows her to place any toy on the left side and on the right side at most once each. For example, if she has ever placed Pikachu on the left side, she cannot place Pikachu on the left side again. Bingbing agrees. She performs two weighings, and the results are as follows (the number indicates how much heavier the left side is than the right):\n\n![](https://cdn.luogu.com.cn/upload/pic/18477.png)\n\nFrom the results and Table 1, it can be determined that the weights of the three toys must be $3, 4, 3$. That is, the updated ranges obtained from the weighings are:\n\nTable 2. Precise ranges obtained from the weighing results|Pikachu|Weini Sun Wukong|Barbie doll\n:-:|:-:|:-:|:-:\nMinimum possible weight|$3$|$4$|$3$\nMaximum possible weight|$3$|$4$|$3$\n\nBingbing will buy many more toys in the future and does not want to compute the weight of each toy by hand every time. She needs a program to compute the most precise lower and upper bounds of each toy’s weight. Can you help her?", "inputFormat": "The first line contains two integers $n$ and $m$, the number of toys and the number of weighings.\n\nThe second line contains $2n$ numbers. For each $i$, the $(2i-1)$-th and $2i$-th numbers are the initial lower bound and upper bound of the weight of toy $i$.\n\nEach of the following $m$ lines starts with three numbers $L, R, D$, denoting the number of toys on the left, the number of toys on the right, and the weight difference between the two sides (left minus right, with $L, R \\ge 0$). The next $L$ numbers are the indices of the toys on the left side of the balance, followed by $R$ numbers for the right side. The input guarantees that each toy appears on each side of the balance at most once in total.", "outputFormat": "Output $2n$ integers. For each $i$, the $(2i-1)$-th and $2i$-th numbers are the lower and upper bounds of toy $i$’s weight, i.e., the minimum possible integer weight and the maximum possible integer weight. If there is no solution (the balance might be broken), output only $-1$.", "hint": "Sample explanation:\n\nSample $1$ corresponds to the example in the problem statement.\n\nIn sample $2$, Bingbing has three toys with initial ranges $1 \\sim 5$, $2 \\sim 5$, and $1 \\sim 3$. There is only one weighing: the left side has toys $1$ and $2$, and the right side has toy $3$. The left side is heavier by $1$ unit. From this, the ranges can be determined to be $1 \\sim 2$, $2 \\sim 3$, and $2 \\sim 3$.\n\nConstraints:\n\n$3 \\le n \\le 200$, $1 \\le m \\le 100$, and all upper bounds of weights are at most $20000$.\n\n$50\\%$ of the testdata satisfies $3 \\le n \\le 10$, $1 \\le m \\le 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2005] 玩具的重量", "background": null, "description": "冰冰有三个玩具：皮卡秋、维妮孙悟空和芭比娃娃。她并不知道这些玩具的具体重量（采用 NOI 单位），但是知道每个玩具重量的大概范围，如下表：\n\n表 1. \n玩具和它们的最小、最大可能重量|皮卡秋|维妮孙悟空|芭比娃娃\n:-:|:-:|:-:|:-:\n最小可能重量|$1$|$2$|$3$\n最大可能重量|$3$|$4$|$5$\n\n这些范围太粗略，冰冰希望能把它们缩小一些。\n\n正好佳佳有一个电子天平，不仅可以告诉你左右两边是否一样重，还可以告诉你左边比右边重（或轻）多少。天平很大，左右两边都可以放任意多件玩具。\n\n冰冰向佳佳借电子天平，希望能算出每个玩具的精确重量。佳佳为了考验冰冰，只允许她把任意一个玩具往天平的左侧和右侧最多各放一次。例如，如果她曾经把皮卡秋放在天平的左侧，则她不能再次把它放在天平的左侧。冰冰同意了。她一共称量了两次，结果如下（数字表示左边比右边重多少）：\n\n![](https://cdn.luogu.com.cn/upload/pic/18477.png)\n\n根据结果和表 1，可以确定三个玩具的重量一定是 $3,4,3$，也就是说，通过称量结果所得到的更新后的重量范围是：\n\n表2. 根据称量结果所得到的精确范围|皮卡秋|维妮孙悟空|芭比娃娃\n:-:|:-:|:-:|:-:\n最小可能重量|$3$|$4$|$3$\n最大可能重量|$3$|$4$|$3$\n\n冰冰以后还会买很多很多玩具，她不想每次都自己计算每个玩具的重量。她需要写一个程序计算每个玩具最精确的重量下限和上限，你能帮她吗？", "inputFormat": "输入文件第一行包含两个整数 $n$ 和 $m$，即玩具的个数和称量的次数。\n\n第二行包含 $2n$ 个数，第 $2i-1$ 个数和第 $2i$ 个数分别表示第 $i$ 个玩具的重量初始下限和初始上限。\n\n以下 $m$ 行，每行前三个数 $L，R，D$ 表示左边的玩具数、右边的玩具数和左右两边的重量差（$L, R \\ge 0$），接下来的 $L$ 个数为天平左边的玩具编号，再接下来的 $R$ 个数为天平右边的玩具编号。输入保证每个玩具在天平的每一边最多出现一次。", "outputFormat": "输出文件包含 $2n$ 个整数，第 $2i-1$ 个数和第 $2i$ 个数分别表示第 $i$ 个玩具的重量下限和上限，即最小可能的整数重量和最大可能的整数重量。如果无解（可能是天平坏了），只输出一个数 $-1$。", "hint": "【样例解释】\n\n样例 $1$ 对应于题目描述中的例子。\n\n在样例 $2$ 中，冰冰有三个玩具，重量的原始范围为 $1 \\sim 5$, $2 \\sim 5$, $1 \\sim 3$。只有一次称量，天平的左边是玩具 $1$ 和玩具 $2$，右边是玩具 $3$。左边比右边重 $1$ 个单位。根据此结果，可以判断三个玩具的重量范围为 $1 \\sim 2$，$2 \\sim 3$ 和 $2 \\sim 3$。\n\n【约定】\n\n$3 \\le n \\le 200, 1 \\le m \\le 100$，重量上限不超过 $20000$。\n\n$50\\%$ 的数据满足 $3 \\le n \\le 10，1 \\le m \\le 5$。", "locale": "zh-CN"}}}
{"pid": "P4534", "type": "P", "difficulty": 6, "samples": [["4\n0 0\n3 0\n3 3\n0 3\n4\n1 1\n2 1\n2 2\n1 2", "8"], ["4\n0 0\n3 0\n3 3\n0 3\n4\n0 0\n2 0\n2 3\n0 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2004", "CTSC/CTS"], "title": "[CTSC2004] 最优切割", "background": "HURRICANE 小组的成员最近去工厂实习，在实习的过程中遇到了如下的问题。", "description": "HURRICANE 小组要在一个模板内切割出一个零件。\n\n现已知模板和零件都是给定的凸多边形，且零件在模板中的位置已经固定。\n\n对于零件来说，除相邻的两边外，其任何两条边的延长线的交点都在模板之外。\n\n由于工厂的加工条件所限，切割时，每一刀必须沿零件的某一条边所在的直线切下，把模板分成两部分，然后保留含有零件的一部分，再继续切割。\n\n切割的每一刀的费用为模板上切痕的长度，现在你需要求出切割出这个零件所需的最小总费用。", "inputFormat": "第一行输入一个正整数 $n$，表示模板的顶点个数。\n\n接下来 $n$ 行每行输入两个实数 $x,y$，为按逆时针方向给出的模板顶点的坐标。\n\n第 $n+2$ 行输入一个正整数 $m$，表示零件的顶点个数。\n\n接下来 $m$ 行每行输入两个实数 $x,y$，为按逆时针方向给出的零件顶点的坐标。", "outputFormat": "输出一个整数，表示所需最小总费用四舍五入到整数后的值。", "hint": "对于 $100\\%$ 的数据，保证 $3\\le n,m\\le 2000$ 且 $|x|,|y|\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2004] Optimal Cutting", "background": "Members of the HURRICANE team recently went to a factory for an internship and encountered the following problem during the process.", "description": "The HURRICANE team needs to cut out a part from within a template.\n\nBoth the template and the part are given convex polygons, and the position of the part inside the template is fixed.\n\nFor the part, for any two non-adjacent edges, the intersection point of the extensions of their supporting lines lies outside the template.\n\nDue to factory constraints, each cut must follow the straight line containing some edge of the part, splitting the template into two pieces. Keep the piece that contains the part and continue cutting.\n\nThe cost of each cut is the length of the cut mark on the template. You need to compute the minimum total cost required to cut out the part.", "inputFormat": "The first line contains a positive integer $n$, the number of vertices of the template.\n\nThe next $n$ lines each contain two real numbers $x, y$, giving the coordinates of the template’s vertices listed in counterclockwise order.\n\nThe $(n+2)$-th line contains a positive integer $m$, the number of vertices of the part.\n\nThe next $m$ lines each contain two real numbers $x, y$, giving the coordinates of the part’s vertices listed in counterclockwise order.", "outputFormat": "Output a single integer, which is the minimum total cost rounded to the nearest integer.", "hint": "For $100\\%$ of the testdata, it is guaranteed that $3 \\le n, m \\le 2000$ and $|x|, |y| \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2004] 最优切割", "background": "HURRICANE 小组的成员最近去工厂实习，在实习的过程中遇到了如下的问题。", "description": "HURRICANE 小组要在一个模板内切割出一个零件。\n\n现已知模板和零件都是给定的凸多边形，且零件在模板中的位置已经固定。\n\n对于零件来说，除相邻的两边外，其任何两条边的延长线的交点都在模板之外。\n\n由于工厂的加工条件所限，切割时，每一刀必须沿零件的某一条边所在的直线切下，把模板分成两部分，然后保留含有零件的一部分，再继续切割。\n\n切割的每一刀的费用为模板上切痕的长度，现在你需要求出切割出这个零件所需的最小总费用。", "inputFormat": "第一行输入一个正整数 $n$，表示模板的顶点个数。\n\n接下来 $n$ 行每行输入两个实数 $x,y$，为按逆时针方向给出的模板顶点的坐标。\n\n第 $n+2$ 行输入一个正整数 $m$，表示零件的顶点个数。\n\n接下来 $m$ 行每行输入两个实数 $x,y$，为按逆时针方向给出的零件顶点的坐标。", "outputFormat": "输出一个整数，表示所需最小总费用四舍五入到整数后的值。", "hint": "对于 $100\\%$ 的数据，保证 $3\\le n,m\\le 2000$ 且 $|x|,|y|\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4535", "type": "P", "difficulty": 7, "samples": [["4 12333+33\n312331", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "CTSC/CTS"], "title": "[CTSC2004] 数字搜索", "background": "HURRICANE小组最近接到了一个搜索文本的任务，即从一个由数字构成的长文本中，匹配满足指定条件的子串。搜索的条件采用形如‘(0+10\\*1)\\*10\\*’这样的正则表达式来描述。其中正则表达式的归纳定义如下：\n\n1. 0, 1, …, 9，0\\*, 1\\*, …, 9\\*是正则表达式；\n\n2. 如果A和B是正则表达式，则(A)，A+B，AB，(A)\\*都是正则表达式；\n\n3. 只有按以上方法构造出来的表达式才是正则表达式。\n\n其中，A+B表示“或者”关系，AB表示“连接”关系，(A)\\*表示A的内容“重复”零次或者多次。比如正则表达式(12+3)(4+5)6\\*，就可以匹配以124，125，34，35之一开头，之后接零0个或任意多个6的字符串（例如字符串12566）。正则表达式(1+0)\\*可以匹配所有由0和1构成的字符串，或者是空串。如果一个正则表达式不能匹配空串，则称它是非空的。**本题考虑的都是非空正则表达式**。\n\n如果在给定文本的某一个位置，存在一个以该位置结束的子串，能够被给定的非空正则表达式匹配，则称该位置是可匹配的。现在HURRICANE小组接到的任务就是找出所有可匹配的位置。你能帮助他们完成这个任务么？", "description": "你的程序需要根据给定的输入，给出符合题意的输出：\n\n- 输入包括一个满足如上定义的正则表达式，以及一长串文本；\n\n- 你需要根据输入的正则表达式及文本，找出文本中所有可匹配的位置；\n\n- 你给出的输出需要包括所有可匹配的位置。", "inputFormat": "输入文件regular.in的第一行描述一个正则表达式，第二行为需要处理的文本：\n\n- 第一行的正则表达式包括由一个空格分开的两个部分：\n\n- 一个非负整数n（1≤ n≤ 10），表示我们所要考虑的数字集（即在正则表达式和文本中所出现的数字）是0, 1, …, n–1。\n\n- 接下来是一个正则表达式，它由{‘(‘, ’)’, ’+’, ’*’}中的4个符号和{0, …, n–1}中的数字构成，表达式的长度不超过500个字符。\n\n- 第二行为一个由0到n-1之间数字构成的字符串，为需要处理的文本。该文本长度不超过10,000,000个字符。", "outputFormat": "输出文件只有一行，包括一些由空格分开的整数，按从小到大的顺序依次输出所需处理的文本中每一个可匹配的位置。", "hint": "**说明：**对于输入示例，需要处理的文本是’312331’，其中只有第5个字符所在的位置（下划线所在处）是可匹配的。这时正则表达式’12333+33'中的’33’可以与之匹配。\n\n**提示：**在本次的测试数据中，有6个测试点中的正则表达式不出现’*’，其中有3个测试点，正则表达式只由数字和’+’构成。有一个测试点的待处理文本不超过1,000,000个字符。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2004] Digit Search", "background": "The HURRICANE team recently received a task to search text, namely to match substrings in a long text composed of digits that satisfy specified conditions. The search conditions are described by regular expressions such as ‘(0+10\\*1)\\*10\\*’. The inductive definition of regular expressions is as follows:\n\n1. 0, 1, …, 9, 0\\*, 1\\*, …, 9\\* are regular expressions.\n2. If A and B are regular expressions, then (A), A+B, AB, (A)\\* are regular expressions.\n3. Only expressions constructed in the above ways are regular expressions.\n\nHere, A+B denotes the “or” relation, AB denotes “concatenation,” and (A)\\* denotes “repeat” the content of A zero or more times. For example, the regular expression (12+3)(4+5)6\\* matches strings that start with one of 124, 125, 34, 35, followed by zero or any number of 6's (for example, the string 12566). The regular expression (1+0)\\* matches all strings composed of 0 and 1, or the empty string. If a regular expression cannot match the empty string, it is called nonempty. In this problem, we only consider nonempty regular expressions.\n\nIf, at some position in the given text, there exists a substring ending at that position that can be matched by the given nonempty regular expression, then that position is called matchable. The task given to the HURRICANE team is to find all matchable positions. Can you help them complete this task?", "description": "Your program needs to produce output according to the given input:\n\n- The input consists of a regular expression defined as above and a long piece of text.\n- Based on the input regular expression and text, you need to find all matchable positions in the text.\n- Your output should include all matchable positions.", "inputFormat": "The input file regular.in contains a regular expression on the first line and the text to be processed on the second line:\n\n- The first line contains two parts separated by a space:\n  - A nonnegative integer n ($1 \\le n \\le 10$), indicating that the set of digits we consider (i.e., digits appearing in the regular expression and the text) is $0, 1, \\ldots, n-1$.\n  - Next is a regular expression, composed of the 4 symbols from {‘(‘, ’)’, ’+’, ’*’} and the digits from $\\{0, \\ldots, n-1\\}$, with length not exceeding 500 characters.\n- The second line is a string composed of digits from 0 to $n-1$, which is the text to be processed. The length of this text does not exceed 10,000,000 characters.", "outputFormat": "The output file contains only one line, consisting of integers separated by spaces, output in ascending order, representing every matchable position in the text to be processed.", "hint": "Explanation: For the sample input, the text to be processed is ’312331’, and only the 5th character position (the underlined one) is matchable. Here, ’33’ in the regular expression ’12333+33’ can match it.\n\nHint: In the testdata for this problem, in 6 test points the regular expression does not contain ’*’. Among these, in 3 test points, the regular expression consists only of digits and ’+’. In one test point, the text to be processed does not exceed 1,000,000 characters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2004] 数字搜索", "background": "HURRICANE小组最近接到了一个搜索文本的任务，即从一个由数字构成的长文本中，匹配满足指定条件的子串。搜索的条件采用形如‘(0+10\\*1)\\*10\\*’这样的正则表达式来描述。其中正则表达式的归纳定义如下：\n\n1. 0, 1, …, 9，0\\*, 1\\*, …, 9\\*是正则表达式；\n\n2. 如果A和B是正则表达式，则(A)，A+B，AB，(A)\\*都是正则表达式；\n\n3. 只有按以上方法构造出来的表达式才是正则表达式。\n\n其中，A+B表示“或者”关系，AB表示“连接”关系，(A)\\*表示A的内容“重复”零次或者多次。比如正则表达式(12+3)(4+5)6\\*，就可以匹配以124，125，34，35之一开头，之后接零0个或任意多个6的字符串（例如字符串12566）。正则表达式(1+0)\\*可以匹配所有由0和1构成的字符串，或者是空串。如果一个正则表达式不能匹配空串，则称它是非空的。**本题考虑的都是非空正则表达式**。\n\n如果在给定文本的某一个位置，存在一个以该位置结束的子串，能够被给定的非空正则表达式匹配，则称该位置是可匹配的。现在HURRICANE小组接到的任务就是找出所有可匹配的位置。你能帮助他们完成这个任务么？", "description": "你的程序需要根据给定的输入，给出符合题意的输出：\n\n- 输入包括一个满足如上定义的正则表达式，以及一长串文本；\n\n- 你需要根据输入的正则表达式及文本，找出文本中所有可匹配的位置；\n\n- 你给出的输出需要包括所有可匹配的位置。", "inputFormat": "输入文件regular.in的第一行描述一个正则表达式，第二行为需要处理的文本：\n\n- 第一行的正则表达式包括由一个空格分开的两个部分：\n\n- 一个非负整数n（1≤ n≤ 10），表示我们所要考虑的数字集（即在正则表达式和文本中所出现的数字）是0, 1, …, n–1。\n\n- 接下来是一个正则表达式，它由{‘(‘, ’)’, ’+’, ’*’}中的4个符号和{0, …, n–1}中的数字构成，表达式的长度不超过500个字符。\n\n- 第二行为一个由0到n-1之间数字构成的字符串，为需要处理的文本。该文本长度不超过10,000,000个字符。", "outputFormat": "输出文件只有一行，包括一些由空格分开的整数，按从小到大的顺序依次输出所需处理的文本中每一个可匹配的位置。", "hint": "**说明：**对于输入示例，需要处理的文本是’312331’，其中只有第5个字符所在的位置（下划线所在处）是可匹配的。这时正则表达式’12333+33'中的’33’可以与之匹配。\n\n**提示：**在本次的测试数据中，有6个测试点中的正则表达式不出现’*’，其中有3个测试点，正则表达式只由数字和’+’构成。有一个测试点的待处理文本不超过1,000,000个字符。", "locale": "zh-CN"}}}
{"pid": "P4536", "type": "P", "difficulty": 4, "samples": [["T312", "T314\nT34\nT4"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "2007", "重庆", "各省省选", "递归", "深度优先搜索 DFS"], "title": "[CQOI2007] 三角形", "background": "", "description": "画一个等边三角形，把三边的中点连接起来，得到四个三角形，把它们称为 $T_1,T_2,T_3,T_4$，如图1。\n\n把前三个三角形也这样划分，得到 $12$ 个更小的三角形，$T_{11},T_{12},T_{13},T_{14},T_{21},T_{22},T_{23},T_{24},T_{31},T_{32},T_{33},T_{34}$，如图2。\n\n把编号以 $1,2,3$ 结尾的三角形又继续划分……最后得到的分形称为 Sierpinski 三角形。\n\n![](https://cdn.luogu.com.cn/upload/pic/18501.png)\n\n如果三角形 $B$ 不包含三角形 $A$，且 $A$ 的某一条完整的边是 $B$ 的某条边的一部分，则我们说 $A$ 靠在 $B$ 的边上。例如 $T_{12}$ 靠在 $T_{14}$ 和 $T_4$ 上，但不靠在 $T_{32}$ 上。\n\n给出 Spierpinski 三角形中的一个三角形，找出它靠着的所有三角形。", "inputFormat": "输入仅一行，即三角形的编号，以 `T` 开头，后面有 $n$ 个 $1$ 到 $4$ 的数字。仅最后一个数字可能为 $4$。", "outputFormat": "输出每行一个三角形编号，按字典序从小到大排列。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2007] Triangle", "background": "", "description": "Draw an equilateral triangle and connect the midpoints of its three sides to obtain four triangles, denoted $T_1, T_2, T_3, T_4$, as shown in Figure 1.\n\nApply the same subdivision to the first three triangles to obtain $12$ smaller triangles: $T_{11}, T_{12}, T_{13}, T_{14}, T_{21}, T_{22}, T_{23}, T_{24}, T_{31}, T_{32}, T_{33}, T_{34}$, as shown in Figure 2.\n\nContinue subdividing the triangles whose indices end with $1, 2, 3$... The resulting fractal is called the Sierpinski triangle.\n\n![](https://cdn.luogu.com.cn/upload/pic/18501.png)\n\nIf triangle $B$ does not contain triangle $A$, and one entire edge of $A$ is a part of an edge of $B$, then we say $A$ “rests on” an edge of $B$. For example, $T_{12}$ rests on $T_{14}$ and $T_4$, but does not rest on $T_{32}$.\n\nGiven a triangle in the Sierpinski triangle, find all the triangles it “rests on”.", "inputFormat": "The input contains a single line: the index of a triangle. It starts with `T` followed by $n$ digits from $1$ to $4$. Only the last digit may be $4$.", "outputFormat": "Output one triangle index per line, sorted in lexicographical ascending order.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2007] 三角形", "background": "", "description": "画一个等边三角形，把三边的中点连接起来，得到四个三角形，把它们称为 $T_1,T_2,T_3,T_4$，如图1。\n\n把前三个三角形也这样划分，得到 $12$ 个更小的三角形，$T_{11},T_{12},T_{13},T_{14},T_{21},T_{22},T_{23},T_{24},T_{31},T_{32},T_{33},T_{34}$，如图2。\n\n把编号以 $1,2,3$ 结尾的三角形又继续划分……最后得到的分形称为 Sierpinski 三角形。\n\n![](https://cdn.luogu.com.cn/upload/pic/18501.png)\n\n如果三角形 $B$ 不包含三角形 $A$，且 $A$ 的某一条完整的边是 $B$ 的某条边的一部分，则我们说 $A$ 靠在 $B$ 的边上。例如 $T_{12}$ 靠在 $T_{14}$ 和 $T_4$ 上，但不靠在 $T_{32}$ 上。\n\n给出 Spierpinski 三角形中的一个三角形，找出它靠着的所有三角形。", "inputFormat": "输入仅一行，即三角形的编号，以 `T` 开头，后面有 $n$ 个 $1$ 到 $4$ 的数字。仅最后一个数字可能为 $4$。", "outputFormat": "输出每行一个三角形编号，按字典序从小到大排列。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P4537", "type": "P", "difficulty": 4, "samples": [["3 2", "15"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["模拟", "搜索", "2007", "重庆", "各省省选"], "title": "[CQOI2007] 矩形", "background": null, "description": "给一个 $a\\times b$ 矩形，由 $a\\times b$ 个单位正方形组成。你需要沿着网格线把它分成非空的两部分，每部分所有格子连通，且至少有一个格子在原矩形的边界上。“连通”是指任两个格子都可以通过水平或者竖直路径连在一起。 求方案总数。例如 $3\\times 2$ 的矩形有 $15$ 种方案。\n\n![](https://cdn.luogu.com.cn/upload/pic/18502.png)", "inputFormat": "输入仅一行，为两个整数 $a,b$（$1 \\le a \\le 6$，$2 \\le b \\le7$）。", "outputFormat": "输出仅一行，即方案总数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2007] Rectangle", "background": "", "description": "Given an $a\\times b$ rectangle formed by $a\\times b$ unit squares. You need to split it along the grid lines into two non-empty parts such that in each part all cells are connected, and at least one cell lies on the boundary of the original rectangle. “Connected” means any two cells can be connected by a path that moves only horizontally or vertically. Find the total number of such ways. For example, a $3\\times 2$ rectangle has $15$ ways.\n\n![](https://cdn.luogu.com.cn/upload/pic/18502.png)", "inputFormat": "The input contains a single line with two integers $a,b$ ($1 \\le a \\le 6$, $2 \\le b \\le 7$).", "outputFormat": "Output a single line with the total number of ways.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2007] 矩形", "background": null, "description": "给一个 $a\\times b$ 矩形，由 $a\\times b$ 个单位正方形组成。你需要沿着网格线把它分成非空的两部分，每部分所有格子连通，且至少有一个格子在原矩形的边界上。“连通”是指任两个格子都可以通过水平或者竖直路径连在一起。 求方案总数。例如 $3\\times 2$ 的矩形有 $15$ 种方案。\n\n![](https://cdn.luogu.com.cn/upload/pic/18502.png)", "inputFormat": "输入仅一行，为两个整数 $a,b$（$1 \\le a \\le 6$，$2 \\le b \\le7$）。", "outputFormat": "输出仅一行，即方案总数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4538", "type": "P", "difficulty": 0, "samples": [["3 4\n1 2\n1 3\n2 2\n2 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2006", "各省省选", "安徽"], "title": "[AHOI2006] 棋盘上的问题", "background": null, "description": "可可和卡卡画了一张巨大的 $N\\times N$ 的棋盘，他们想在这个棋盘上放尽量多的国际象棋的“車”，使得它们互相不能攻击到对方（車可以沿着棋盘的横向和纵向攻击）。\n\n但这个答案显然就是棋盘的宽度 $N$，于是可可在棋盘上规定了只有在有限的 $M$ 个位置上才能放棋子。（其他位置不能放棋子，而車却可以穿过这个位置去攻击其他的棋子）然而这样也不会难倒两个聪明的小家伙，他们很快算出来这个答案是 $K$。\n\n于是卡卡又提出来一个问题：如果我们在这 $M$ 个可以放棋子的位置中再去掉一个位置，而仍然保证最多能放下 $K$ 个車，可行的方案又有多少种呢？ \n\n[任务] 编写一个程序： \n\n从输入文件中读入棋盘的大小和棋盘上可以放棋子的位置信息； \n\n计算出如题卡卡所说的可行方案的数目； \n\n输出你得到的答案。", "inputFormat": "第一行有两个正整数 $N$ 和 $M$，分别表示棋盘的大小和可以放棋子的位置数目。 \n\n以下 $M$ 行，每行用 $x_i$ 和 $y_i$ 两个整数描述一个位置，表示这个位置是棋盘的第 $x_i$ 行第 $y_i$ 列。\n\n同样的一个位置不会被描述两次。", "outputFormat": "输出文件中只有一个整数，表示可行方案的数目。", "hint": "对于所有数据保证：$1\\le i \\le M\\le 6\\times 10^5,1\\le x_i,y_i\\le N\\le 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2006] Problem on the Chessboard", "background": "", "description": "Keke and Kaka drew a huge $N*N$ chessboard. They want to place as many international chess rooks as possible on this board so that none of them can attack each other (a rook can attack along rows and columns).\n\nBut the answer is obviously the board width $N$, so Keke restricts that pieces can only be placed on a finite set of $M$ positions on the board. (Other positions cannot hold pieces, but rooks can still pass through them to attack other pieces.) However, this does not stump the two smart kids; they quickly figure out that the answer is $K$.\n\nThen Kaka raises another question: If we remove one position from these $M$ allowed positions while still ensuring that at most $K$ rooks can be placed (i.e., the maximum remains $K$), how many feasible choices are there?\n\n[Task] Write a program to:\n\n- Read from the input file the size of the board and the positions on the board where pieces can be placed.\n- Compute the number of feasible choices as Kaka described.\n- Output your answer.", "inputFormat": "The first line contains two positive integers $N$ and $M$, representing the size of the board and the number of positions where pieces can be placed.\n\nThe following $M$ lines each describe one position with two integers $x_i$ and $y_i$, indicating that this position is at row $x_i$, column $y_i$ of the board.\n\nThe same position will not be described twice.", "outputFormat": "The output contains a single integer, representing the number of feasible choices.", "hint": "For all testdata, it is guaranteed that: $1\\le i \\le M\\le 6\\times 10^5,1\\le x_i,y_i\\le N\\le 2\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2006] 棋盘上的问题", "background": null, "description": "可可和卡卡画了一张巨大的 $N\\times N$ 的棋盘，他们想在这个棋盘上放尽量多的国际象棋的“車”，使得它们互相不能攻击到对方（車可以沿着棋盘的横向和纵向攻击）。\n\n但这个答案显然就是棋盘的宽度 $N$，于是可可在棋盘上规定了只有在有限的 $M$ 个位置上才能放棋子。（其他位置不能放棋子，而車却可以穿过这个位置去攻击其他的棋子）然而这样也不会难倒两个聪明的小家伙，他们很快算出来这个答案是 $K$。\n\n于是卡卡又提出来一个问题：如果我们在这 $M$ 个可以放棋子的位置中再去掉一个位置，而仍然保证最多能放下 $K$ 个車，可行的方案又有多少种呢？ \n\n[任务] 编写一个程序： \n\n从输入文件中读入棋盘的大小和棋盘上可以放棋子的位置信息； \n\n计算出如题卡卡所说的可行方案的数目； \n\n输出你得到的答案。", "inputFormat": "第一行有两个正整数 $N$ 和 $M$，分别表示棋盘的大小和可以放棋子的位置数目。 \n\n以下 $M$ 行，每行用 $x_i$ 和 $y_i$ 两个整数描述一个位置，表示这个位置是棋盘的第 $x_i$ 行第 $y_i$ 列。\n\n同样的一个位置不会被描述两次。", "outputFormat": "输出文件中只有一个整数，表示可行方案的数目。", "hint": "对于所有数据保证：$1\\le i \\le M\\le 6\\times 10^5,1\\le x_i,y_i\\le N\\le 2\\times 10^5$。", "locale": "zh-CN"}}}
