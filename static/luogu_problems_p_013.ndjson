{"pid": "P1261", "type": "P", "difficulty": 6, "samples": [["4 3\n2\n3\n1\n1\n1 4 30\n2 3 20\n3 4 20", "9\n"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["图论", "2002", "ICPC", "CERC"], "title": "[CERC2002] 服务器储存信息问题", "background": null, "description": "Byteland 王国准备在各服务器间建立大型网络并提供多种服务。\n\n网络由 $n$ 台服务器组成，用双向的线连接。两台服务器之间最多只能有一条线直接连接，同时，每台服务器最多只能和 $10$ 台服务器直接连接，但是任意两台服务器间必然存在一条路径将它们连接在一起。\n\n每条传输线都有一个固定传输的速度。$\\delta(v,w)$ 表示服务器 $v$ 和 $w$ 之间的最短路径长度，且对任意的 $v$ 有 $\\delta(v,v)=0$。\n\n有些服务器比别的服务器提供更多的服务，它们的重要程度要高一些。我们用 $r(v)$ 表示服务器 $v$ 的重要程度 $\\texttt{rank}$。$\\texttt{rank}$ 越高的服务器越重要。\n\n每台服务器都会存储它附近的服务器的信息。当然，不是所有服务器的信息都存，只有感兴趣的服务器信息才会被存储。服务器 $v$ 对服务器 $w$ 感兴趣是指，不存在服务器 $u$ 满足，$r(u)>r(w)$ 且 $\\delta(v,u)\\le\\delta(v, w)$。\n\n举个例子来说，所有具有最高 $\\texttt{rank}$ 的服务器都会被别的服务器感兴趣。如果 $v$ 是一台具有最高 $\\texttt{rank}$ 的服务器，由于 $\\delta(v,v)=0$，所以 $v$ 只对具有最高 $\\texttt{rank}$ 的服务器感兴趣。\n\n我们定义 $B(v)$ 为 **$v$ 感兴趣**的服务器的集合。我们希望计算所有服务器储存的信息量，即所有服务器的 $|B(v)|$ 之和。Byteland 王国并不希望存储大量的数据，所以所有服务器存储的数据量 （$|B(v)|$ 之和）不会超过 $30n$。\n\n你的任务是写一个程序，读入 Byteland 王国的网络分布，计算所有服务器存储的数据量。", "inputFormat": "第一行两个整数 $n$ 和 $m$。$n$ 表示服务器的数量，$m$ 表示传输线的数量。\n\n接下来 $n$ 行，每行一个整数，第 $i$ 行的整数为 $r(i)$，表示第 $i$ 台服务器的 $\\texttt{rank}$。\n\n接下来 $m$ 行，每行表示各条传输线的信息，包含三个整数 $a,b,t$ 。$a$ 和 $b$ 是传输线所连接的两台服务器的编号，$t$ 是传输线的长度。", "outputFormat": "一个整数，表示所有服务器存储的数据总量，即 $|B(v)|$ 之和。", "hint": "#### 输出解释\n\n$B(1)=\\{1,2\\},B(2)=\\{2\\},B(3)=\\{2,3\\},B(4)=\\{1,2,3,4\\}$。\n\n#### 数据规模\n\n$1\\le n\\le30000,1\\le m\\le5n$\n\n$1\\le r(i)\\le 10$\n\n$1\\le t\\le 1000,1\\le a,b\\le n,a\\neq b$", "locale": "zh-CN", "translations": {"en": {"title": "[CERC/SWERC2002] Servers", "background": null, "description": "The Kingdom of Byteland is preparing to build a large network among its servers and provide various services.\n\nThe network consists of $n$ servers, connected by bidirectional links. There is at most one direct link between any pair of servers. Each server is directly connected to at most $10$ servers. Furthermore, there is a path between any two servers.\n\nEach transmission link has a fixed length. Let $\\delta(v,w)$ denote the length of the shortest path between servers $v$ and $w$, and for any $v$ we have $\\delta(v,v)=0$.\n\nSome servers provide more services than others and are therefore more important. We use $r(v)$ to denote the importance $\\texttt{rank}$ of server $v$. A higher $\\texttt{rank}$ means a more important server.\n\nEach server stores information about nearby servers. Of course, not all servers’ information is stored—only the interesting ones. Server $v$ is interested in server $w$ if there does not exist a server $u$ such that $r(u)>r(w)$ and $\\delta(v,u)\\le\\delta(v,w)$.\n\nFor example, all servers with the highest $\\texttt{rank}$ are interesting to every other server. If $v$ has the highest $\\texttt{rank}$, then since $\\delta(v,v)=0$, $v$ is interested only in servers with the highest $\\texttt{rank}$.\n\nWe define $B(v)$ as the set of servers that server $v$ is interested in. We want to compute the total amount of information stored by all servers, i.e., the sum of $|B(v)|$ over all servers. Byteland does not want to store a large amount of data, so the total amount of stored data (the sum of $|B(v)|$) will not exceed $30n$.\n\nYour task is to write a program that reads the network layout of Byteland and computes the total amount of information stored by all servers.", "inputFormat": "The first line contains two integers $n$ and $m$. Here $n$ is the number of servers and $m$ is the number of transmission links.\n\nThe next $n$ lines each contain one integer. The integer on the $i$-th line is $r(i)$, the $\\texttt{rank}$ of server $i$.\n\nThe next $m$ lines each describe a transmission link with three integers $a,b,t$. Here $a$ and $b$ are the indices of the two servers connected by the link, and $t$ is the length of the link.", "outputFormat": "Output a single integer: the total amount of data stored by all servers, i.e., the sum of $|B(v)|$.", "hint": "Output explanation:\n\n$B(1)=\\{1,2\\},B(2)=\\{2\\},B(3)=\\{2,3\\},B(4)=\\{1,2,3,4\\}$.\n\nConstraints:\n\n$1\\le n\\le30000,1\\le m\\le5n$\n\n$1\\le r(i)\\le 10$\n\n$1\\le t\\le 1000,1\\le a,b\\le n,a\\neq b$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2002] 服务器储存信息问题", "background": null, "description": "Byteland 王国准备在各服务器间建立大型网络并提供多种服务。\n\n网络由 $n$ 台服务器组成，用双向的线连接。两台服务器之间最多只能有一条线直接连接，同时，每台服务器最多只能和 $10$ 台服务器直接连接，但是任意两台服务器间必然存在一条路径将它们连接在一起。\n\n每条传输线都有一个固定传输的速度。$\\delta(v,w)$ 表示服务器 $v$ 和 $w$ 之间的最短路径长度，且对任意的 $v$ 有 $\\delta(v,v)=0$。\n\n有些服务器比别的服务器提供更多的服务，它们的重要程度要高一些。我们用 $r(v)$ 表示服务器 $v$ 的重要程度 $\\texttt{rank}$。$\\texttt{rank}$ 越高的服务器越重要。\n\n每台服务器都会存储它附近的服务器的信息。当然，不是所有服务器的信息都存，只有感兴趣的服务器信息才会被存储。服务器 $v$ 对服务器 $w$ 感兴趣是指，不存在服务器 $u$ 满足，$r(u)>r(w)$ 且 $\\delta(v,u)\\le\\delta(v, w)$。\n\n举个例子来说，所有具有最高 $\\texttt{rank}$ 的服务器都会被别的服务器感兴趣。如果 $v$ 是一台具有最高 $\\texttt{rank}$ 的服务器，由于 $\\delta(v,v)=0$，所以 $v$ 只对具有最高 $\\texttt{rank}$ 的服务器感兴趣。\n\n我们定义 $B(v)$ 为 **$v$ 感兴趣**的服务器的集合。我们希望计算所有服务器储存的信息量，即所有服务器的 $|B(v)|$ 之和。Byteland 王国并不希望存储大量的数据，所以所有服务器存储的数据量 （$|B(v)|$ 之和）不会超过 $30n$。\n\n你的任务是写一个程序，读入 Byteland 王国的网络分布，计算所有服务器存储的数据量。", "inputFormat": "第一行两个整数 $n$ 和 $m$。$n$ 表示服务器的数量，$m$ 表示传输线的数量。\n\n接下来 $n$ 行，每行一个整数，第 $i$ 行的整数为 $r(i)$，表示第 $i$ 台服务器的 $\\texttt{rank}$。\n\n接下来 $m$ 行，每行表示各条传输线的信息，包含三个整数 $a,b,t$ 。$a$ 和 $b$ 是传输线所连接的两台服务器的编号，$t$ 是传输线的长度。", "outputFormat": "一个整数，表示所有服务器存储的数据总量，即 $|B(v)|$ 之和。", "hint": "#### 输出解释\n\n$B(1)=\\{1,2\\},B(2)=\\{2\\},B(3)=\\{2,3\\},B(4)=\\{1,2,3,4\\}$。\n\n#### 数据规模\n\n$1\\le n\\le30000,1\\le m\\le5n$\n\n$1\\le r(i)\\le 10$\n\n$1\\le t\\le 1000,1\\le a,b\\le n,a\\neq b$", "locale": "zh-CN"}}}
{"pid": "P1262", "type": "P", "difficulty": 4, "samples": [["3\n2\n1 10\n2 100\n2\n1 3\n2 3\n", "YES\n110\n"], ["4\n2\n1 100\n4 200\n2\n1 2\n3 4", "NO\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "强连通分量"], "title": "间谍网络", "background": "", "description": "由于外国间谍的大量渗入，国家安全正处于高度的危机之中。如果 A 间谍手中掌握着关于 B 间谍的犯罪证据，则称 A 可以揭发 B。有些间谍收受贿赂，只要给他们一定数量的美元，他们就愿意交出手中掌握的全部情报。所以，如果我们能够收买一些间谍的话，我们就可能控制间谍网中的每一分子。因为一旦我们逮捕了一个间谍，他手中掌握的情报都将归我们所有，这样就有可能逮捕新的间谍，掌握新的情报。\n\n我们的反间谍机关提供了一份资料，包括所有已知的受贿的间谍，以及他们愿意收受的具体数额。同时我们还知道哪些间谍手中具体掌握了哪些间谍的资料。假设总共有 $n$ 个间谍（$n$ 不超过 $3000$），每个间谍分别用 $1$ 到 $3000$ 的整数来标识。\n\n请根据这份资料，判断我们是否有可能控制全部的间谍，如果可以，求出我们所需要支付的最少资金。否则，输出不能被控制的一个间谍。", "inputFormat": "第一行只有一个整数 $n$。\n\n第二行是整数 $p$。表示愿意被收买的人数，$1\\le p\\le n$。\n\n接下来的 $p$ 行，每行有两个整数，第一个数是一个愿意被收买的间谍的编号，第二个数表示他将会被收买的数额。这个数额不超过 $20000$。\n\n紧跟着一行只有一个整数 $r$，$1\\le r\\le8000$。然后 $r$ 行，每行两个正整数，表示数对 $(A, B)$，$A$ 间谍掌握 $B$ 间谍的证据。", "outputFormat": "如果可以控制所有间谍，第一行输出 `YES`，并在第二行输出所需要支付的贿金最小值。否则输出 `NO`，并在第二行输出不能控制的间谍中，编号最小的间谍编号。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Spy Network", "background": "", "description": "Due to the massive infiltration of foreign spies, national security is in a severe crisis. If spy A holds incriminating evidence against spy B, we say that A can expose B. Some spies accept bribes; as long as they are paid a certain amount of dollars, they are willing to hand over all the intelligence they hold. Therefore, if we can buy off some spies, we may be able to control every individual in the spy network. Once we arrest a spy, all the intelligence they hold becomes ours, which may enable us to arrest new spies and acquire new intelligence.\n\nOur counterintelligence agency has provided a dossier that includes all known bribable spies and the exact amount they demand. We also know which spies hold information about which other spies. Assume there are $n$ spies in total ($n \\le 3000$), each identified by an integer from 1 to 3000.\n\nBased on this dossier, determine whether it is possible to control all spies. If it is possible, find the minimum total payment required. Otherwise, output one spy who cannot be controlled.", "inputFormat": "- The first line contains a single integer $n$.\n- The second line contains an integer $p$, the number of spies willing to be bribed, with $1 \\le p \\le n$.\n- The next $p$ lines each contain two integers: the ID of a bribable spy, and the amount required to bribe them. This amount does not exceed 20000.\n- The next line contains a single integer $r$, with $1 \\le r \\le 8000$.\n- The next $r$ lines each contain two positive integers, representing a pair $(A, B)$, meaning spy $A$ holds evidence against spy $B$.", "outputFormat": "- If it is possible to control all spies, output `YES` on the first line, and the minimum total bribe on the second line.\n- Otherwise, output `NO` on the first line, and on the second line output the smallest ID among the spies that cannot be controlled.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "间谍网络", "background": "", "description": "由于外国间谍的大量渗入，国家安全正处于高度的危机之中。如果 A 间谍手中掌握着关于 B 间谍的犯罪证据，则称 A 可以揭发 B。有些间谍收受贿赂，只要给他们一定数量的美元，他们就愿意交出手中掌握的全部情报。所以，如果我们能够收买一些间谍的话，我们就可能控制间谍网中的每一分子。因为一旦我们逮捕了一个间谍，他手中掌握的情报都将归我们所有，这样就有可能逮捕新的间谍，掌握新的情报。\n\n我们的反间谍机关提供了一份资料，包括所有已知的受贿的间谍，以及他们愿意收受的具体数额。同时我们还知道哪些间谍手中具体掌握了哪些间谍的资料。假设总共有 $n$ 个间谍（$n$ 不超过 $3000$），每个间谍分别用 $1$ 到 $3000$ 的整数来标识。\n\n请根据这份资料，判断我们是否有可能控制全部的间谍，如果可以，求出我们所需要支付的最少资金。否则，输出不能被控制的一个间谍。", "inputFormat": "第一行只有一个整数 $n$。\n\n第二行是整数 $p$。表示愿意被收买的人数，$1\\le p\\le n$。\n\n接下来的 $p$ 行，每行有两个整数，第一个数是一个愿意被收买的间谍的编号，第二个数表示他将会被收买的数额。这个数额不超过 $20000$。\n\n紧跟着一行只有一个整数 $r$，$1\\le r\\le8000$。然后 $r$ 行，每行两个正整数，表示数对 $(A, B)$，$A$ 间谍掌握 $B$ 间谍的证据。", "outputFormat": "如果可以控制所有间谍，第一行输出 `YES`，并在第二行输出所需要支付的贿金最小值。否则输出 `NO`，并在第二行输出不能控制的间谍中，编号最小的间谍编号。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1263", "type": "P", "difficulty": 6, "samples": [["3 4\n2 0 0 0\n2 2 2 1\n0 1 0 2\n", "2\n1 2\n3 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2002", "网络流", "Special Judge", "CEOI（中欧）", "连通块", "二分图"], "title": "[CEOI 2002] Royal guards", "background": "", "description": "从前有一个王国，这个王国的城堡是 $m$ 行 $n$ 列的一个矩形，被分为 $m \\times n$ 个方格。一些方格是墙，而另一些是空地。这个王国的国王在城堡里设了一些陷阱，每个陷阱占据一块空地。\n\n一天，国王决定在城堡里布置守卫，他希望安排尽量多的守卫。\n\n守卫们都是经过严格训练的，所以一旦他们发现同行或同列中有人的话，他们立即向那人射击。因此，国王希望能够合理地布置守卫，使他们互相之间不能看见，这样他们就不可能互相射击了。守卫们只能被布置在空地上，不能被布置在陷阱或墙上，且一块空地只能布置一个守卫。如果两个守卫在同一行或同一列，并且他们之间没有墙的话，他们就能互相看见。(守卫就像象棋里的车一样)\n\n你的任务是写一个程序，根据给定的城堡，计算最多可布置多少个守卫，并设计出布置的方案。\n", "inputFormat": "第一行有两个整数 $m$ 和 $n$，表示城堡的规模。\n\n第 $2$ 到第 $(m + 1)$ 行，每行 $n$ 个整数，第 $(i +1)$ 行第 $j$ 列的数 $a_{i, j}$ 表示城堡第 $i$ 行第 $j$ 列的方格的信息，其中 $0$ 表示空地，$1$ 表示陷阱，$2$ 表示墙。", "outputFormat": "**本题存在 Special Judge**。\n\n首先输出一行一个整数 $k$，表示最多可布置的守卫个数。\n\n然后输出 $k$ 行，每行两个整数 $x, y$，表示在第 $x$ 行第 $j$ 列放一个守卫。", "hint": "#### 样例输入输出 1 解释\n\n如图（黑色方格为墙，白色方格为空地，圆圈为陷阱，G表示守卫）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zv6sr9xw.png)\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq m, n \\leq 200$，$0 \\leq a_{i, j} \\leq 2$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2002] Royal guards", "background": "# Description\n\nOnce upon a time there was a kingdom whose castle was a rectangle of $m$ rows and $n$ columns, divided into $m \\times n$ cells. Some cells are walls, and others are empty. The king has set traps in the castle, each trap occupying one empty cell.\n\nOne day, the king decided to deploy guards in the castle, and he wants to place as many guards as possible.\n\nThe guards are strictly trained, so as soon as they find someone in the same row or the same column, they immediately shoot at that person. Therefore, the king wants to place the guards so that they cannot see each other, making it impossible for them to shoot one another. Guards can only be placed on empty cells, not on traps or walls, and at most one guard can be placed on any empty cell. If two guards are in the same row or column and there is no wall between them, they can see each other (guards move like rooks in chess).\n\nYour task is to write a program that, given the castle, computes the maximum number of guards that can be placed and outputs one optimal placement.", "description": "", "inputFormat": "", "outputFormat": "This problem uses Special Judge.\n\nFirst output a single integer $k$, the maximum number of guards that can be placed.\n\nThen output $k$ lines. Each line contains two integers $x, y$, indicating that a guard is placed at row $x$ and column $y$.", "hint": "Explanation for sample input and output 1:\n\nAs shown in the figure (black cells are walls, white cells are empty, circles are traps, and G denotes a guard).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zv6sr9xw.png)\n\nConstraints:\n\nFor all testdata, it is guaranteed that $1 \\leq m, n \\leq 200$ and $0 \\leq a_{i, j} \\leq 2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2002] Royal guards", "background": "", "description": "从前有一个王国，这个王国的城堡是 $m$ 行 $n$ 列的一个矩形，被分为 $m \\times n$ 个方格。一些方格是墙，而另一些是空地。这个王国的国王在城堡里设了一些陷阱，每个陷阱占据一块空地。\n\n一天，国王决定在城堡里布置守卫，他希望安排尽量多的守卫。\n\n守卫们都是经过严格训练的，所以一旦他们发现同行或同列中有人的话，他们立即向那人射击。因此，国王希望能够合理地布置守卫，使他们互相之间不能看见，这样他们就不可能互相射击了。守卫们只能被布置在空地上，不能被布置在陷阱或墙上，且一块空地只能布置一个守卫。如果两个守卫在同一行或同一列，并且他们之间没有墙的话，他们就能互相看见。(守卫就像象棋里的车一样)\n\n你的任务是写一个程序，根据给定的城堡，计算最多可布置多少个守卫，并设计出布置的方案。\n", "inputFormat": "第一行有两个整数 $m$ 和 $n$，表示城堡的规模。\n\n第 $2$ 到第 $(m + 1)$ 行，每行 $n$ 个整数，第 $(i +1)$ 行第 $j$ 列的数 $a_{i, j}$ 表示城堡第 $i$ 行第 $j$ 列的方格的信息，其中 $0$ 表示空地，$1$ 表示陷阱，$2$ 表示墙。", "outputFormat": "**本题存在 Special Judge**。\n\n首先输出一行一个整数 $k$，表示最多可布置的守卫个数。\n\n然后输出 $k$ 行，每行两个整数 $x, y$，表示在第 $x$ 行第 $j$ 列放一个守卫。", "hint": "#### 样例输入输出 1 解释\n\n如图（黑色方格为墙，白色方格为空地，圆圈为陷阱，G表示守卫）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zv6sr9xw.png)\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq m, n \\leq 200$，$0 \\leq a_{i, j} \\leq 2$。", "locale": "zh-CN"}}}
{"pid": "P1264", "type": "P", "difficulty": 6, "samples": [["3\n2 0 1 1 0 2\n0 2 2 2 0 2 2 2 0\n", "1 2 3\n"], ["3\n4 0 2 2 0 4\n0 1 1 1 0 1 1 1 0\n", "1 2\n"], ["4\n0 3 3 1 1 3 3 0\n0 0 0 2 0 0 1 0 0 1 0 0 2 0 0 0\n", "2 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论"], "title": "K-联赛", "background": "", "description": "K-联赛职业足球俱乐部的球迷们都是有组织的训练有素的啦啦队员，就像红魔啦啦队一样（2002 年韩日世界杯上韩国队的啦啦队）。\n\n这个赛季，经过很多场比赛以后，球迷们希望知道他们支持的球队是否还有机会赢得最后的联赛冠军。换句话说，球队是否可以通过某种特定的比赛结果最终取得最高的积分（获胜场次最多），允许出现多支队并列第一的情况。\n\n现在，有 $n$ 支球队，每支队伍已经胜负的场次分别是 $w_i$ 和 $d_i$。同时还有些比赛没有进行，第 $i$ 支球队和第 $j$ 支球队之间还剩 $a_{ij}$ 场比赛要进行。\n\n你需要找出所有可能获得冠军的球队。\n\n所有队参加的比赛数是相同的，并且为了简化问题，你可以认为不存在平局，即比赛结果只有胜或负两种。", "inputFormat": "第一行一个正整数 $n$，表示球队数。\n\n第二行 $2n$ 个正整数，分别表示 $w_1,d_1,w_2,d_2,\\cdots,w_n,d_n$。\n\n第三行 $n^2$ 个正整数，分别表示 $a_{11},a_{12},\\cdots,a_{1n},a_{21},\\cdots,a_{2n},\\cdots,a_{n1},\\cdots,a_{nn}$。", "outputFormat": "仅一行，输出所有可能获得冠军的球队，按其编号升序输出，中间用空格分隔。", "hint": "对于 $100\\%$ 的数据满足，$n\\le 25$，$w_i,d_i\\le 100$，$a_{ij}\\le 10$，$a_{ij}=a_{ji}$，$a_{ii}=0$。", "locale": "zh-CN", "translations": {"en": {"title": "K-League", "background": "", "description": "The fans of the professional football clubs in the K-League are organized and well-trained cheerleaders, like the Red Devils cheer squad (the supporters of Korea’s national team at the 2002 Korea–Japan FIFA World Cup).\n\nThis season, after many matches, the fans want to know whether the team they support still has a chance to win the league title in the end. In other words, can the team, through some possible set of match outcomes, finish with the highest number of points (i.e., the most wins)? Ties for first place are allowed.\n\nThere are $n$ teams. For each team $i$, the numbers of wins and losses already recorded are $w_i$ and $d_i$. There are still some matches to be played: between team $i$ and team $j$, there are $a_{ij}$ remaining matches.\n\nYou need to find all teams that can still possibly become champions.\n\nAll teams will play the same total number of matches, and to simplify the problem, you may assume there are no draws; every match has only two outcomes: win or loss.", "inputFormat": "- The first line contains a positive integer $n$, the number of teams.\n- The second line contains $2n$ non-negative integers, representing $w_1, d_1, w_2, d_2, \\cdots, w_n, d_n$.\n- The third line contains $n^2$ non-negative integers, representing $a_{11}, a_{12}, \\cdots, a_{1n}, a_{21}, \\cdots, a_{2n}, \\cdots, a_{n1}, \\cdots, a_{nn}$ (row-major order).", "outputFormat": "Output a single line containing all teams that can possibly become champions, in ascending order of their indices, separated by spaces.", "hint": "For $100\\%$ of the testdata, $n \\le 25$, $w_i, d_i \\le 100$, $a_{ij} \\le 10$, $a_{ij} = a_{ji}$, $a_{ii} = 0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "K-联赛", "background": "", "description": "K-联赛职业足球俱乐部的球迷们都是有组织的训练有素的啦啦队员，就像红魔啦啦队一样（2002 年韩日世界杯上韩国队的啦啦队）。\n\n这个赛季，经过很多场比赛以后，球迷们希望知道他们支持的球队是否还有机会赢得最后的联赛冠军。换句话说，球队是否可以通过某种特定的比赛结果最终取得最高的积分（获胜场次最多），允许出现多支队并列第一的情况。\n\n现在，有 $n$ 支球队，每支队伍已经胜负的场次分别是 $w_i$ 和 $d_i$。同时还有些比赛没有进行，第 $i$ 支球队和第 $j$ 支球队之间还剩 $a_{ij}$ 场比赛要进行。\n\n你需要找出所有可能获得冠军的球队。\n\n所有队参加的比赛数是相同的，并且为了简化问题，你可以认为不存在平局，即比赛结果只有胜或负两种。", "inputFormat": "第一行一个正整数 $n$，表示球队数。\n\n第二行 $2n$ 个正整数，分别表示 $w_1,d_1,w_2,d_2,\\cdots,w_n,d_n$。\n\n第三行 $n^2$ 个正整数，分别表示 $a_{11},a_{12},\\cdots,a_{1n},a_{21},\\cdots,a_{2n},\\cdots,a_{n1},\\cdots,a_{nn}$。", "outputFormat": "仅一行，输出所有可能获得冠军的球队，按其编号升序输出，中间用空格分隔。", "hint": "对于 $100\\%$ 的数据满足，$n\\le 25$，$w_i,d_i\\le 100$，$a_{ij}\\le 10$，$a_{ij}=a_{ji}$，$a_{ii}=0$。", "locale": "zh-CN"}}}
{"pid": "P1265", "type": "P", "difficulty": 4, "samples": [["4\r\n0 0\r\n1 2\r\n-1 2\r\n0 4", "6.47"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "生成树"], "title": "公路修建", "background": "", "description": "某国有 $n$ 个城市，它们互相之间没有公路相通，因此交通十分不便。为解决这一“行路难”的问题，政府决定修建公路。修建公路的任务由各城市共同完成。\n\n修建工程分若干轮完成。在每一轮中，每个城市选择一个与它最近的城市，申请修建通往该城市的公路。政府负责审批这些申请以决定是否同意修建。\n\n政府审批的规则如下：\n\n1. 如果两个或以上城市申请修建同一条公路，则让它们共同修建；\n2. 如果三个或以上的城市申请修建的公路成环。如下图，A 申请修建公路 AB，B 申请修建公路 BC，C 申请修建公路 CA。则政府将否决其中最短的一条公路的修建申请； \n3. 其他情况的申请一律同意。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/apng39qc.png)\n\n一轮修建结束后，可能会有若干城市可以通过公路直接或间接相连。这些可以互相连通的城市即组成“城市联盟”。在下一轮修建中，每个“城市联盟”将被看作一个城市，发挥一个城市的作用。\n\n当所有城市被组合成一个“城市联盟”时，修建工程也就完成了。\n\n你的任务是根据城市的分布和前面讲到的规则，计算出将要修建的公路总长度。", "inputFormat": "第一行一个整数 $n$，表示城市的数量。（$n \\leq 5000$）\n\n以下 $n$ 行，每行两个整数 $x$ 和 $y$，表示一个城市的坐标。（$-10^6 \\leq x,y \\leq 10^6$）\n", "outputFormat": "一个实数，四舍五入保留两位小数，表示公路总长。（保证有唯一解）\n", "hint": "修建的公路如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p0dtxt2l.png)", "locale": "zh-CN", "translations": {"en": {"title": "Road Construction", "background": "", "description": "There are $n$ cities in a country, and none of them are connected by roads, so travel is very inconvenient. To solve this \"difficult travel\" problem, the government decides to build roads. The construction task will be jointly completed by the cities.\n\nThe construction proceeds in several rounds. In each round, each city selects the nearest city to it and applies to build a road to that city. The government reviews these applications to decide whether to approve construction.\n\nThe government’s approval rules are as follows:\n1. If two or more cities apply to build the same road, they will build it together.\n2. If the roads applied for by three or more cities form a cycle, then, as shown below, A applies for road AB, B applies for road BC, and C applies for road CA. The government will deny the application for the shortest road among them.\n3. All other applications are approved.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/apng39qc.png)\n\nAfter a round of construction, some cities may become directly or indirectly connected by roads. These mutually reachable cities form a \"city alliance\". In the next round of construction, each \"city alliance\" is treated as a single city and acts as one.\n\nWhen all cities have been merged into a single \"city alliance\", the construction is complete.\n\nYour task is to compute the total length of the roads to be built, based on the city distribution and the rules above.\n\n#", "inputFormat": "The first line contains an integer $n$, the number of cities ($n \\leq 5000$).\n\nEach of the following $n$ lines contains two integers $x$ and $y$, the coordinates of a city ($-10^6 \\leq x, y \\leq 10^6$).\n\n#", "outputFormat": "Output a real number, rounded to two decimal places, representing the total road length. (It is guaranteed that the answer is unique.)\n\n#", "hint": "The roads to be built are shown in the figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p0dtxt2l.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "公路修建", "background": "", "description": "某国有 $n$ 个城市，它们互相之间没有公路相通，因此交通十分不便。为解决这一“行路难”的问题，政府决定修建公路。修建公路的任务由各城市共同完成。\n\n修建工程分若干轮完成。在每一轮中，每个城市选择一个与它最近的城市，申请修建通往该城市的公路。政府负责审批这些申请以决定是否同意修建。\n\n政府审批的规则如下：\n\n1. 如果两个或以上城市申请修建同一条公路，则让它们共同修建；\n2. 如果三个或以上的城市申请修建的公路成环。如下图，A 申请修建公路 AB，B 申请修建公路 BC，C 申请修建公路 CA。则政府将否决其中最短的一条公路的修建申请； \n3. 其他情况的申请一律同意。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/apng39qc.png)\n\n一轮修建结束后，可能会有若干城市可以通过公路直接或间接相连。这些可以互相连通的城市即组成“城市联盟”。在下一轮修建中，每个“城市联盟”将被看作一个城市，发挥一个城市的作用。\n\n当所有城市被组合成一个“城市联盟”时，修建工程也就完成了。\n\n你的任务是根据城市的分布和前面讲到的规则，计算出将要修建的公路总长度。", "inputFormat": "第一行一个整数 $n$，表示城市的数量。（$n \\leq 5000$）\n\n以下 $n$ 行，每行两个整数 $x$ 和 $y$，表示一个城市的坐标。（$-10^6 \\leq x,y \\leq 10^6$）\n", "outputFormat": "一个实数，四舍五入保留两位小数，表示公路总长。（保证有唯一解）\n", "hint": "修建的公路如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p0dtxt2l.png)", "locale": "zh-CN"}}}
{"pid": "P1266", "type": "P", "difficulty": 5, "samples": [["6 15 1\n0 1 25 68\n0 2 30 50\n0 5 0 101\n1 2 70 77\n1 3 35 42\n2 0 0 22\n2 1 40 86\n2 3 0 23\n2 4 45 40\n3 1 64 14\n3 5 0 23\n4 1 95 8\n5 1 0 84\n5 2 90 64\n5 3 36 40", "0 5 2 3 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "图论", "启发式搜索", "最短路", "Floyd 算法"], "title": "速度限制", "background": null, "description": "在这个繁忙的社会中，我们往往不再去选择最短的道路，而是选择最快的路线。开车时每条道路的限速成为最关键的问题。不幸的是，有一些限速的标志丢失了，因此你无法得知应该开多快。一种可以辩解的解决方案是，按照原来的速度行驶。你的任务是计算两地间的最快路线。\n\n你将获得一份现代化城市的道路交通信息。为了使问题简化，地图只包括路口和道路。每条道路是有向的，只连接了两个路口，并且最多只有一块限速标志，位于路的起点。两地 $A$ 和 $B$，最多只有一条道路从 $A$ 连接到 $B$。你可以假设加速能够在瞬间完成并且不会有交通堵塞等情况影响你。当然，你的车速不能超过当前的速度限制。", "inputFormat": "第一行是 $3$ 个整数 $N$，$M$ 和 $D$（$2\\leq N\\leq 150$，$1\\leq M\\leq 22500$）。$N$ 表示路口的数目，用 $0 \\sim N-1$ 标记。$M$ 是道路的总数，$D$ 表示你的目的地。\n\n接下来的 $M$ 行，每行描述一条道路，每行有 $4$ 个整数 $A$（$0\\leq A<N$），$B$（$0\\leq B<N$），$V$ （$0\\leq V\\leq 500$）和 $L$（$1\\leq L\\leq 500$），这条路是从 $A$ 到 $B$ 的，速度限制是 $V$，长度为 $L$。如果 $V$ 是 $0$，表示这条路的限速未知。\n\n如果 $V$ 不为 $0$，则经过该路的时间 $T=\\frac{L}{V}$。否则 $T=\\frac{L}{V_{old}}$，$V_{old}$ 是你到达该路口前的速度。开始时你位于 $0$ 点，并且速度为 $70$。", "outputFormat": "输出文件仅一行整数，表示从 $0$ 到 $D$ 经过的城市。\n\n输出的顺序必须按照你经过这些城市的顺序，以 $0$ 开始，以 $D$ 结束。仅有一条最快路线。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Speed Limit", "background": "", "description": "In this busy society, we often do not choose the shortest road but the fastest route. While driving, the speed limit of each road becomes the key factor. Unfortunately, some speed-limit signs are missing, so you cannot know how fast you should drive. A defensible approach is to keep driving at your previous speed. Your task is to compute the fastest route between two places.\n\nYou are given road traffic information for a modern city. To simplify the problem, the map includes only intersections and roads. Each road is directed, connects exactly two intersections, and has at most one speed-limit sign located at the start of the road. For any two intersections $A$ and $B$, there is at most one road from $A$ to $B$. You may assume instantaneous acceleration and no congestion or similar factors. Of course, your speed cannot exceed the current speed limit.", "inputFormat": "The first line contains 3 integers $N$, $M$, and $D$ ($2\\leq N\\leq 150$, $1\\leq M\\leq 22500$). $N$ is the number of intersections, labeled from 0 to $N-1$. $M$ is the total number of roads, and $D$ is your destination.\n\nThe next $M$ lines each describe one road, with 4 integers $A$ ($0\\leq A<N$), $B$ ($0\\leq B<N$), $V$ ($0\\leq V\\leq 500$), and $L$ ($1\\leq L\\leq 500$). This road goes from $A$ to $B$, its speed limit is $V$, and its length is $L$. If $V$ is $0$, the speed limit on this road is unknown.\n\nIf $V$ is not $0$, the travel time is $T=\\frac{L}{V}$. Otherwise $T=\\frac{L}{V_{old}}$, where $V_{old}$ is your speed upon arriving at the intersection before this road. Initially, you are at 0 with speed 70.", "outputFormat": "Output a single line of integers: the sequence of intersections you pass from 0 to $D$, in order, starting with 0 and ending with $D$, separated by spaces. There is only one fastest route.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "速度限制", "background": null, "description": "在这个繁忙的社会中，我们往往不再去选择最短的道路，而是选择最快的路线。开车时每条道路的限速成为最关键的问题。不幸的是，有一些限速的标志丢失了，因此你无法得知应该开多快。一种可以辩解的解决方案是，按照原来的速度行驶。你的任务是计算两地间的最快路线。\n\n你将获得一份现代化城市的道路交通信息。为了使问题简化，地图只包括路口和道路。每条道路是有向的，只连接了两个路口，并且最多只有一块限速标志，位于路的起点。两地 $A$ 和 $B$，最多只有一条道路从 $A$ 连接到 $B$。你可以假设加速能够在瞬间完成并且不会有交通堵塞等情况影响你。当然，你的车速不能超过当前的速度限制。", "inputFormat": "第一行是 $3$ 个整数 $N$，$M$ 和 $D$（$2\\leq N\\leq 150$，$1\\leq M\\leq 22500$）。$N$ 表示路口的数目，用 $0 \\sim N-1$ 标记。$M$ 是道路的总数，$D$ 表示你的目的地。\n\n接下来的 $M$ 行，每行描述一条道路，每行有 $4$ 个整数 $A$（$0\\leq A<N$），$B$（$0\\leq B<N$），$V$ （$0\\leq V\\leq 500$）和 $L$（$1\\leq L\\leq 500$），这条路是从 $A$ 到 $B$ 的，速度限制是 $V$，长度为 $L$。如果 $V$ 是 $0$，表示这条路的限速未知。\n\n如果 $V$ 不为 $0$，则经过该路的时间 $T=\\frac{L}{V}$。否则 $T=\\frac{L}{V_{old}}$，$V_{old}$ 是你到达该路口前的速度。开始时你位于 $0$ 点，并且速度为 $70$。", "outputFormat": "输出文件仅一行整数，表示从 $0$ 到 $D$ 经过的城市。\n\n输出的顺序必须按照你经过这些城市的顺序，以 $0$ 开始，以 $D$ 结束。仅有一条最快路线。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1267", "type": "P", "difficulty": 5, "samples": [["3 \n19 33 32 31 29 3 5 4 30 \n22 25 20 21 12 24 23 34 35 \n14 13 15 26 18 17 8 16 27 \n11 10 9 1 28 7 2 6 36", "17\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树形数据结构"], "title": "排序二叉树", "background": "", "description": "一个边长为 $n$ 的正三角形可以被划分成 $n^2$ 个小的边长为 $1$ 的正三角形，称为单位三角形。边长为 $3$ 的正三角形被分成三层共 $9$ 个小的正三角形，我们把它们从顶到底，从左到右以 $1\\sim 9$ 编号，见下图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mzls92cx.png)\n\n四个这样的边长为 $n$ 的正三角形可以组成一个三棱锥。我们将正三棱锥的三个侧面依顺时针次序（从顶向底视角）编号为 $A,B,C$，底面编号为 $D$。侧面的 $A,B,C$ 号三角形以三棱锥的顶点为顶，底面的 $D$ 号三角形以它与 $A,B$ 三角形的交点为顶。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yyqpdocn.png)\n\n其中 $\\tt .$ 表示这个三角形面的 $1$ 号三角形位置，并依次编号下去。\n\n上图为三棱锥展开后的平面图，每个面上标有圆点的是该面的顶，该图中侧面 $A,B,C$ 分别向纸内方向折叠即可还原成三棱锥。我们把这 $A,B,C,D$ 四个面各自划分成 $n^2$ 个单位三角形。\n\n对于任意两个单位三角形，如有一条边相邻，则称它们为相邻的单位三角形。显然，每个单位三角形有三个相邻的单位三角形。现在，把 $1\\sim 4n^2$ 里的所有整数分别随机填入四个面总共 $4n^2$ 个单位三角形中。\n\n现在要求你编程求由单位三角形组成的最大二叉搜索树。所谓最大二叉搜索树，是指在所有由单位三角形组成的二叉搜索树中节点最多的一棵树。要求当 $i$ 作为二叉搜索树的一个节点时，$i$ 的儿子（如果有的话）和 $i$ 的父亲（如果有的话）必须与 $i$ 有邻边（三棱锥状态下的邻边，而非展开图的邻边）。\n\n一棵二叉搜索树满足这个节点的左子树得每个值全部小于这个节点，这个节点的右子树的每个值全部大于这个节点。", "inputFormat": "输入的第一行为一个整数 $n$，表示展开图中每个面的三角形边长，也就是这个面有 $n^2$ 个单位三角形。\n\n接下来每行 $n^2$ 个整数，一共四行，第一行表示 $A$ 面的单位三角形中填入的数，第二行表示 $B$ 面，以此类推。", "outputFormat": "输出仅一行一个整数，表示最大二叉搜索树的节点个数。", "hint": "### 样例解释\n\n以下以 $A$ 面为例。记 $f(A,x)$ 表示 $A$ 面的第 $x$ 个单位三角形，以此类推。\n\n$f(A,9)$ 与 $f(D,1)$ 有邻边，$f(A,7)$ 与 $f(D,2)$ 有邻边，$f(A,5)$ 与 $f(D,5)$ 有邻边。\n\n$f(A,1)$ 与 $f(B,1)$ 有邻边，$f(A,4)$ 与 $f(B,2)$ 有邻边，$f(A,9)$ 与 $f(B,5)$ 有邻边。\n\n$f(A,1)$ 与 $f(C,1)$ 有邻边，$f(A,2)$ 与 $f(C,4)$ 有邻边，$f(A,5)$ 与 $f(C,9)$ 有邻边。\n\n以数字 $1$ 为二叉搜索树的根，可以得到节点最多的二叉搜索树为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2y8i07id.png)\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leqslant n\\leqslant 18$，保证四个面所有单位三角形上填入的数互不相同且都取自 $[1,4n^2]$。", "locale": "zh-CN", "translations": {"en": {"title": "Binary Search Tree", "background": "", "description": "An equilateral triangle with side length $n$ can be partitioned into $n^2$ small equilateral triangles of side length $1$, called unit triangles. An equilateral triangle with side length $3$ is divided into three layers for a total of $9$ small triangles, which we number $1\\sim 9$ from top to bottom and left to right; see the figure below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mzls92cx.png)\n\nFour such equilateral triangles of side length $n$ can form a regular tetrahedron. We number the three side faces of the tetrahedron, in clockwise order as seen from top to bottom, as $A, B, C$, and the base as $D$. On side faces $A, B, C$, triangle $1$ has the tetrahedron’s apex as its top vertex; on the base face $D$, triangle $1$ has as its top vertex the point where it meets faces $A$ and $B$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yyqpdocn.png)\n\nHere, $\\tt .$ marks the position of triangle $1$ on that face, and the rest are numbered in order accordingly.\n\nThe above is the unfolded net of the tetrahedron. The dotted point on each face marks that face’s top vertex. Folding side faces $A, B, C$ inward reconstructs the tetrahedron. We partition each face $A, B, C, D$ into $n^2$ unit triangles.\n\nTwo unit triangles are adjacent if they share an edge. Clearly, each unit triangle has three adjacent unit triangles. Now, place all integers from $1$ to $4n^2$ randomly into the $4n^2$ unit triangles across the four faces, one number per unit triangle.\n\nYou are to compute the maximum binary search tree formed by unit triangles. The maximum binary search tree is the one with the largest number of nodes among all binary search trees formed by unit triangles. The requirement is that when $i$ is a node of the binary search tree, its children (if any) and its parent (if any) must be adjacent to $i$ by a shared edge in the folded tetrahedron (not adjacency in the unfolded net).\n\nA binary search tree satisfies that every value in a node’s left subtree is strictly less than that node’s value, and every value in the right subtree is strictly greater than that node’s value.", "inputFormat": "The first line contains an integer $n$, the side length of each triangular face in the unfolded net, i.e., each face has $n^2$ unit triangles.\n\nThen follow four lines, each containing $n^2$ integers: the first line gives the numbers on face $A$, the second on face $B$, and so on.", "outputFormat": "Output a single integer, the number of nodes in the maximum binary search tree.", "hint": "### Sample explanation\n\nTake face $A$ as an example. Let $f(A, x)$ denote the $x$-th unit triangle on face $A$, and similarly for other faces.\n\n$f(A,9)$ is adjacent to $f(D,1)$, $f(A,7)$ is adjacent to $f(D,2)$, and $f(A,5)$ is adjacent to $f(D,5)$.\n\n$f(A,1)$ is adjacent to $f(B,1)$, $f(A,4)$ is adjacent to $f(B,2)$, and $f(A,9)$ is adjacent to $f(B,5)$.\n\n$f(A,1)$ is adjacent to $f(C,1)$, $f(A,2)$ is adjacent to $f(C,4)$, and $f(A,5)$ is adjacent to $f(C,9)$.\n\nTaking the number $1$ as the root, one maximum binary search tree is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2y8i07id.png)\n\n### Constraints\n\nFor $100\\%$ of the testdata, $1\\leqslant n\\leqslant 18$. All numbers on the four faces are distinct and are drawn from $[1,4n^2]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "排序二叉树", "background": "", "description": "一个边长为 $n$ 的正三角形可以被划分成 $n^2$ 个小的边长为 $1$ 的正三角形，称为单位三角形。边长为 $3$ 的正三角形被分成三层共 $9$ 个小的正三角形，我们把它们从顶到底，从左到右以 $1\\sim 9$ 编号，见下图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mzls92cx.png)\n\n四个这样的边长为 $n$ 的正三角形可以组成一个三棱锥。我们将正三棱锥的三个侧面依顺时针次序（从顶向底视角）编号为 $A,B,C$，底面编号为 $D$。侧面的 $A,B,C$ 号三角形以三棱锥的顶点为顶，底面的 $D$ 号三角形以它与 $A,B$ 三角形的交点为顶。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yyqpdocn.png)\n\n其中 $\\tt .$ 表示这个三角形面的 $1$ 号三角形位置，并依次编号下去。\n\n上图为三棱锥展开后的平面图，每个面上标有圆点的是该面的顶，该图中侧面 $A,B,C$ 分别向纸内方向折叠即可还原成三棱锥。我们把这 $A,B,C,D$ 四个面各自划分成 $n^2$ 个单位三角形。\n\n对于任意两个单位三角形，如有一条边相邻，则称它们为相邻的单位三角形。显然，每个单位三角形有三个相邻的单位三角形。现在，把 $1\\sim 4n^2$ 里的所有整数分别随机填入四个面总共 $4n^2$ 个单位三角形中。\n\n现在要求你编程求由单位三角形组成的最大二叉搜索树。所谓最大二叉搜索树，是指在所有由单位三角形组成的二叉搜索树中节点最多的一棵树。要求当 $i$ 作为二叉搜索树的一个节点时，$i$ 的儿子（如果有的话）和 $i$ 的父亲（如果有的话）必须与 $i$ 有邻边（三棱锥状态下的邻边，而非展开图的邻边）。\n\n一棵二叉搜索树满足这个节点的左子树得每个值全部小于这个节点，这个节点的右子树的每个值全部大于这个节点。", "inputFormat": "输入的第一行为一个整数 $n$，表示展开图中每个面的三角形边长，也就是这个面有 $n^2$ 个单位三角形。\n\n接下来每行 $n^2$ 个整数，一共四行，第一行表示 $A$ 面的单位三角形中填入的数，第二行表示 $B$ 面，以此类推。", "outputFormat": "输出仅一行一个整数，表示最大二叉搜索树的节点个数。", "hint": "### 样例解释\n\n以下以 $A$ 面为例。记 $f(A,x)$ 表示 $A$ 面的第 $x$ 个单位三角形，以此类推。\n\n$f(A,9)$ 与 $f(D,1)$ 有邻边，$f(A,7)$ 与 $f(D,2)$ 有邻边，$f(A,5)$ 与 $f(D,5)$ 有邻边。\n\n$f(A,1)$ 与 $f(B,1)$ 有邻边，$f(A,4)$ 与 $f(B,2)$ 有邻边，$f(A,9)$ 与 $f(B,5)$ 有邻边。\n\n$f(A,1)$ 与 $f(C,1)$ 有邻边，$f(A,2)$ 与 $f(C,4)$ 有邻边，$f(A,5)$ 与 $f(C,9)$ 有邻边。\n\n以数字 $1$ 为二叉搜索树的根，可以得到节点最多的二叉搜索树为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2y8i07id.png)\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leqslant n\\leqslant 18$，保证四个面所有单位三角形上填入的数互不相同且都取自 $[1,4n^2]$。", "locale": "zh-CN"}}}
{"pid": "P1268", "type": "P", "difficulty": 4, "samples": [["5\n5 9 12 8\n8 11 7\n5 1\n4\n", "15\n\n"], ["4\n15 36 60\n31 55\n36", "71"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["树形数据结构", "枚举", "构造"], "title": "树的重量", "background": "", "description": "树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”。\n\n令 $N=\\{1,2,3,\\cdots ,n\\}$，用一个 $N$ 上的矩阵 $M$ 来定义树 $T$。其中，矩阵 $M$ 满足：对于任意的 $i$，$j$，$k$，有 $M[i,j]+M[j,k] \\ge M[i,k]$。树 $T$ 满足：\n\n1. 叶节点属于集合 $N$；\n2. 边权均为非负整数；\n3. $d_T(i,j)=M[i,j]$，其中 $d_T(i,j)$ 表示树上 $i$ 到 $j$ 的最短路径长度。\n\n如下图，矩阵 $M$ 描述了一棵树。\n\n$$M=\\begin{bmatrix}\n0 & 5 & 9 & 12 & 8 \\\\\n5 & 0 & 8 & 11 & 7 \\\\\n9 & 8 & 0 & 5 & 1 \\\\\n12 & 11 & 5 & 0 & 4 \\\\\n8 & 7 & 1 & 4 & 0 \\\\\n\\end{bmatrix}$$\n\n树的重量是指树上所有边权之和。对于任意给出的合法矩阵 $M$，它所能表示树的重量是惟一确定的，不可能找到两棵不同重量的树，它们都符合矩阵 $M$。你的任务就是，根据给出的矩阵 $M$，计算 $M$ 所表示树的重量。下图是上面给出的矩阵 $M$ 所能表示的一棵树，这棵树的总重量为 $15$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dnk8ys2t.png)\n", "inputFormat": "第一行是一个整数 $n\\ (2<n<30)$。\n\n其后 $n-1$ 行，给出的是矩阵 $M$ 的一个上三角（不包含对角线），矩阵中所有元素是不超过 $100$ 的非负整数。输入数据保证合法。", "outputFormat": "对于每组输入，输出一行，一个整数，表示树的重量。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Weight of a Tree", "background": "", "description": "Trees can be used to represent evolutionary relationships among species. An \"evolutionary tree\" is a tree with edge weights, where each leaf node represents a species, and the distance between two leaves represents the difference between the two species. Now, an important problem is to reconstruct the corresponding \"evolutionary tree\" from the distances between species.\n\nLet $N=\\{1,2,3,\\cdots ,n\\}$, and use a matrix $M$ on $N$ to define a tree $T$. The matrix $M$ satisfies: for any $i$, $j$, $k$, we have $M[i,j]+M[j,k] \\ge M[i,k]$. The tree $T$ satisfies:\n1. The leaves are the elements of $N$.\n2. All edge weights are non-negative integers.\n3. $d_T(i,j)=M[i,j]$, where $d_T(i,j)$ denotes the length of the shortest path between $i$ and $j$ in the tree.\n\nAs shown below, the matrix $M$ describes a tree.\n\n$$M=\\begin{bmatrix}\n0 & 5 & 9 & 12 & 8 \\\\\n5 & 0 & 8 & 11 & 7 \\\\\n9 & 8 & 0 & 5 & 1 \\\\\n12 & 11 & 5 & 0 & 4 \\\\\n8 & 7 & 1 & 4 & 0 \\\\\n\\end{bmatrix}$$\n\nThe weight of a tree is the sum of all edge weights in the tree. For any valid matrix $M$, the total weight of the tree it represents is uniquely determined. It is impossible to find two trees with different total weights that are both consistent with $M$. Your task is to compute the weight of the tree represented by the given matrix $M$. The figure below shows one tree represented by the above matrix $M$, and the total weight of this tree is $15$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dnk8ys2t.png)", "inputFormat": "The first line contains an integer $n$ with $2<n<30$.\n\nThen $n-1$ lines follow, giving the strict upper triangular part of matrix $M$ (excluding the diagonal). All entries in the matrix are non-negative integers not exceeding $100$. The input is guaranteed to be valid. Matrix $M$ is symmetric with zeros on the diagonal. On the $i$-th of the next $n-1$ lines ($1 \\le i \\le n-1$), there are $n-i$ integers: $M[i, i+1], M[i, i+2], \\ldots, M[i, n]$.", "outputFormat": "Output one line containing a single integer, the total weight of the tree.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "树的重量", "background": "", "description": "树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”。\n\n令 $N=\\{1,2,3,\\cdots ,n\\}$，用一个 $N$ 上的矩阵 $M$ 来定义树 $T$。其中，矩阵 $M$ 满足：对于任意的 $i$，$j$，$k$，有 $M[i,j]+M[j,k] \\ge M[i,k]$。树 $T$ 满足：\n\n1. 叶节点属于集合 $N$；\n2. 边权均为非负整数；\n3. $d_T(i,j)=M[i,j]$，其中 $d_T(i,j)$ 表示树上 $i$ 到 $j$ 的最短路径长度。\n\n如下图，矩阵 $M$ 描述了一棵树。\n\n$$M=\\begin{bmatrix}\n0 & 5 & 9 & 12 & 8 \\\\\n5 & 0 & 8 & 11 & 7 \\\\\n9 & 8 & 0 & 5 & 1 \\\\\n12 & 11 & 5 & 0 & 4 \\\\\n8 & 7 & 1 & 4 & 0 \\\\\n\\end{bmatrix}$$\n\n树的重量是指树上所有边权之和。对于任意给出的合法矩阵 $M$，它所能表示树的重量是惟一确定的，不可能找到两棵不同重量的树，它们都符合矩阵 $M$。你的任务就是，根据给出的矩阵 $M$，计算 $M$ 所表示树的重量。下图是上面给出的矩阵 $M$ 所能表示的一棵树，这棵树的总重量为 $15$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dnk8ys2t.png)\n", "inputFormat": "第一行是一个整数 $n\\ (2<n<30)$。\n\n其后 $n-1$ 行，给出的是矩阵 $M$ 的一个上三角（不包含对角线），矩阵中所有元素是不超过 $100$ 的非负整数。输入数据保证合法。", "outputFormat": "对于每组输入，输出一行，一个整数，表示树的重量。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1269", "type": "P", "difficulty": 5, "samples": [["4\n2 2 3 3 1\n2 1 3 4 2\n1 1 1\n1 2 2\n4", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "贪心", "树形数据结构", "树形 DP"], "title": "信号放大器", "background": null, "description": "树型网络是最节省材料的网络。所谓树型网络，是指一个无环的连通网络，网络中任意两个结点间有且仅有一条通信道路。\n\n网络中有一个结点是服务器，负责将信号直接或间接地发送到各终端机。如图上方，server 结点发出一个信号给结点 $a$ 和 $c$，$a$ 再转发给 $b$。如此，整个网络都收到这个信号了。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e4vb2e7t.png)\n\n但是，实际操作中，信号从一个结点发到另一个结点，会出现信号强度的衰减。衰减量一般由线路长度决定。\n\n如图下方，边上所标的数字为边的衰减量。假设从 server 出发一个强度为 $4$ 个单位的信号，发到结点 $a$ 后强度衰减为 $4-3=1$ 个单位。结点 $a$ 再将其转发给结点 $b$。由于信号强度为 $1$，衰减量为 $2$，因此信号无法发送到 $b$。\n\n一个解决这一问题的方法是，安装信号放大器。信号放大器的作用是将强度大于零的信号还原成初始强度（从服务器出发时的强度）。\n\n上图中，若在结点 $a$ 处安装一个信号放大器，则强度为 $4$ 的信号发到 $a$ 处，即被放大至 $4$。这样，信号就可以被发送到网络中的任意一个节点了。为了简化问题，我们假定每个结点只处理一次信号，当它第二次收到某个信号时，就忽略此信号。\n\n你的任务是根据给出的树型网络，计算出最少需要安装的信号放大器数量。", "inputFormat": "第一行一个整数 $n$，表示网络中结点的数量。（$n \\le 20000$）\n\n第 $2 \\sim n+1$ 行，每行描述一个节点的连接关系。其中第 $i+1$ 行，描述的是结点 $i$ 的连接关系：首先一个整数 $k$，表示与结点 $i$ 相连的结点的数量。此后 $2k$ 个数，每两个描述一个与结点 $i$ 相连的结点，分别表示结点的编号（编号在 $1 \\sim n$ 之间）和该结点与结点 $i$ 之间的边的信号衰减量。结点 $1$ 表示服务器。\n\n最后一行，一个整数，表示从服务器上出发信号的强度。", "outputFormat": "一个整数，表示要使信号能够传遍整个网络，需要安装的最少的信号放大器数量。\n\n如果不论如何安装信号放大器，都无法使信号传遍整个网络，则输出 `No solution.`。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Signal Amplifier", "background": "", "description": "A tree network minimizes material use. A tree network is an acyclic connected network in which there is exactly one communication path between any two nodes.\n\nThere is one node in the network that is the server, responsible for sending a signal directly or indirectly to all terminals. As shown in the top figure, the server node sends a signal to nodes $a$ and $c$, and $a$ then forwards it to $b$. In this way, the entire network receives the signal.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e4vb2e7t.png)\n\nHowever, in practice, when a signal is sent from one node to another, its strength attenuates. The attenuation is generally determined by the length of the line.\n\nAs shown in the bottom figure, the numbers on the edges indicate the attenuation on those edges. Suppose a signal of strength $4$ units is emitted from the server; after reaching node $a$, the strength attenuates to $4-3=1$ unit. Node $a$ then forwards it to node $b$. Since the signal strength is $1$ and the attenuation is $2$, the signal cannot be delivered to $b$.\n\nOne way to solve this problem is to install signal amplifiers. A signal amplifier restores any signal with positive strength to the initial strength (the strength at the server when it is emitted).\n\nIn the figure above, if a signal amplifier is installed at node $a$, then when the signal of strength $4$ reaches $a$, it is amplified back to $4$. Thus, the signal can be delivered to any node in the network. To simplify the problem, we assume each node processes a signal at most once; when it receives the same signal a second time, it ignores it.\n\nYour task is to compute, for the given tree network, the minimum number of signal amplifiers that must be installed.", "inputFormat": "The first line contains an integer $n$, the number of nodes in the network ($n \\le 20000$).\n\nLines $2$ to $n+1$ each describe the connections of a node. Specifically, line $i+1$ describes node $i$: it starts with an integer $k$, the number of nodes adjacent to node $i$. Then follow $2k$ numbers, where each pair describes a neighbor of node $i$: the neighbor’s identifier (an integer between $1$ and $n$) and the attenuation on the edge between that neighbor and node $i$. Node $1$ is the server.\n\nThe last line contains one integer, the initial signal strength emitted by the server.", "outputFormat": "Output a single integer, the minimum number of signal amplifiers required to make the signal reach the entire network.\n\nIf it is impossible to make the signal reach the entire network no matter how the amplifiers are installed, output `No solution.`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "信号放大器", "background": null, "description": "树型网络是最节省材料的网络。所谓树型网络，是指一个无环的连通网络，网络中任意两个结点间有且仅有一条通信道路。\n\n网络中有一个结点是服务器，负责将信号直接或间接地发送到各终端机。如图上方，server 结点发出一个信号给结点 $a$ 和 $c$，$a$ 再转发给 $b$。如此，整个网络都收到这个信号了。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e4vb2e7t.png)\n\n但是，实际操作中，信号从一个结点发到另一个结点，会出现信号强度的衰减。衰减量一般由线路长度决定。\n\n如图下方，边上所标的数字为边的衰减量。假设从 server 出发一个强度为 $4$ 个单位的信号，发到结点 $a$ 后强度衰减为 $4-3=1$ 个单位。结点 $a$ 再将其转发给结点 $b$。由于信号强度为 $1$，衰减量为 $2$，因此信号无法发送到 $b$。\n\n一个解决这一问题的方法是，安装信号放大器。信号放大器的作用是将强度大于零的信号还原成初始强度（从服务器出发时的强度）。\n\n上图中，若在结点 $a$ 处安装一个信号放大器，则强度为 $4$ 的信号发到 $a$ 处，即被放大至 $4$。这样，信号就可以被发送到网络中的任意一个节点了。为了简化问题，我们假定每个结点只处理一次信号，当它第二次收到某个信号时，就忽略此信号。\n\n你的任务是根据给出的树型网络，计算出最少需要安装的信号放大器数量。", "inputFormat": "第一行一个整数 $n$，表示网络中结点的数量。（$n \\le 20000$）\n\n第 $2 \\sim n+1$ 行，每行描述一个节点的连接关系。其中第 $i+1$ 行，描述的是结点 $i$ 的连接关系：首先一个整数 $k$，表示与结点 $i$ 相连的结点的数量。此后 $2k$ 个数，每两个描述一个与结点 $i$ 相连的结点，分别表示结点的编号（编号在 $1 \\sim n$ 之间）和该结点与结点 $i$ 之间的边的信号衰减量。结点 $1$ 表示服务器。\n\n最后一行，一个整数，表示从服务器上出发信号的强度。", "outputFormat": "一个整数，表示要使信号能够传遍整个网络，需要安装的最少的信号放大器数量。\n\n如果不论如何安装信号放大器，都无法使信号传遍整个网络，则输出 `No solution.`。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1270", "type": "P", "difficulty": 5, "samples": [["60\n7 0 8 0 3 1 14 2 10 0 12 4 6 2\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "树形数据结构", "树形 DP"], "title": "“访问”美术馆", "background": "", "description": "经过数月的精心准备，Peer Brelstet，一个出了名的盗画者，准备开始他的下一个行动。艺术馆的结构，每条走廊要么分叉为两条走廊，要么通向一个展览室。Peer 知道每个展室里藏画的数量，并且他精确测量了通过每条走廊的时间。由于经验老到，他拿下一幅画需要 $5$ 秒的时间。你的任务是编一个程序，计算在警察赶来之前，他最多能偷到多少幅画。假定他回到起点后还需要留至少 $1$ 秒逃跑。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7kbyjwgy.png)\n", "inputFormat": "第一行是警察赶到的时间，以秒为单位。第 $2$ 行描述了艺术馆的结构，是一串非负整数，成对地出现：每一对的第一个数是走过一条走廊的时间，第 $2$ 个数是它末端的藏画数量；如果第 $2$ 个数是 $0$，那么说明这条走廊分叉为两条另外的走廊。数据按照深度优先的次序给出，请看样例。\n\n一个展室最多有 $20$ 幅画。通过每个走廊的时间不超过 $20$ 秒。艺术馆最多有 $100$ 个展室。警察赶到的时间在 $6000$ 秒以内。", "outputFormat": "输出最多能偷到的画的数量。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "\"Visiting\" the Art Museum", "background": "", "description": "After months of meticulous preparation, Peer Brelstet, a notorious art thief, is ready for his next move. The art museum is structured so that each corridor either splits into two corridors or leads to an exhibition room. Peer knows how many paintings are hidden in each room, and he has measured precisely the time to traverse each corridor. Since he is experienced, taking one painting takes $ 5 $ seconds. Your task is to write a program to compute the maximum number of paintings he can steal before the police arrive. Assume that after returning to the starting point, he still has at least $ 1 $ second left to escape.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7kbyjwgy.png)", "inputFormat": "The first line is the time when the police arrive, in seconds.  \nThe second line describes the structure of the art museum as a sequence of non-negative integers given in pairs: in each pair, the first number is the time to traverse a corridor, and the second number is the number of paintings at its end; if the second number is $ 0 $, it means this corridor branches into two other corridors. The data are given in depth-first order; see the sample.\n\nA room contains at most $ 20 $ paintings.  \nThe time to traverse any corridor does not exceed $ 20 $ seconds.  \nThe art museum has at most $ 100 $ rooms.  \nThe police arrival time is no more than $ 6000 $ seconds.", "outputFormat": "Output the maximum number of paintings he can steal.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "“访问”美术馆", "background": "", "description": "经过数月的精心准备，Peer Brelstet，一个出了名的盗画者，准备开始他的下一个行动。艺术馆的结构，每条走廊要么分叉为两条走廊，要么通向一个展览室。Peer 知道每个展室里藏画的数量，并且他精确测量了通过每条走廊的时间。由于经验老到，他拿下一幅画需要 $5$ 秒的时间。你的任务是编一个程序，计算在警察赶来之前，他最多能偷到多少幅画。假定他回到起点后还需要留至少 $1$ 秒逃跑。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7kbyjwgy.png)\n", "inputFormat": "第一行是警察赶到的时间，以秒为单位。第 $2$ 行描述了艺术馆的结构，是一串非负整数，成对地出现：每一对的第一个数是走过一条走廊的时间，第 $2$ 个数是它末端的藏画数量；如果第 $2$ 个数是 $0$，那么说明这条走廊分叉为两条另外的走廊。数据按照深度优先的次序给出，请看样例。\n\n一个展室最多有 $20$ 幅画。通过每个走廊的时间不超过 $20$ 秒。艺术馆最多有 $100$ 个展室。警察赶到的时间在 $6000$ 秒以内。", "outputFormat": "输出最多能偷到的画的数量。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1271", "type": "P", "difficulty": 2, "samples": [["5 10\n2 5 2 2 5 2 2 2 1 2", "1 2 2 2 2 2 2 2 5 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["排序"], "title": "【深基9.例1】选举学生会", "background": null, "description": "学校正在选举学生会成员，有 $n$（$1 \\le n\\le 999$）名候选人，每名候选人编号分别从 $1$ 到 $n$，现在收集到了 $m$（$1 \\le m \\le 2000000$）张选票，每张选票都写了一个候选人编号。现在想把这些堆积如山的选票按照投票数字从小到大排序。设第 $i$（$1 \\le i \\le m$）张选票上的数字为 $a_i$，则保证有 $1 \\le a_i \\le n$。", "inputFormat": "输入 $n$ 和 $m$ 以及 $m$ 个选票上的数字。", "outputFormat": "求出排序后的选票编号。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[Shenji 9. Example 1] Student Union Election", "background": "", "description": "The school is electing student union members. There are $n$ ($1 \\le n \\le 999$) candidates, and each candidate is numbered from $1$ to $n$. Now $m$ ($1 \\le m \\le 2000000$) ballots have been collected, and each ballot has a candidate number written on it. Now we want to sort this mountain of ballots in ascending order by the vote number. Let the number on the $i$-th ($1 \\le i \\le m$) ballot be $a_i$, and it is guaranteed that $1 \\le a_i \\le n$.", "inputFormat": "Input $n$ and $m$, followed by the numbers on the $m$ ballots.", "outputFormat": "Output the ballot numbers after sorting.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【深基9.例1】选举学生会", "background": null, "description": "学校正在选举学生会成员，有 $n$（$1 \\le n\\le 999$）名候选人，每名候选人编号分别从 $1$ 到 $n$，现在收集到了 $m$（$1 \\le m \\le 2000000$）张选票，每张选票都写了一个候选人编号。现在想把这些堆积如山的选票按照投票数字从小到大排序。设第 $i$（$1 \\le i \\le m$）张选票上的数字为 $a_i$，则保证有 $1 \\le a_i \\le n$。", "inputFormat": "输入 $n$ 和 $m$ 以及 $m$ 个选票上的数字。", "outputFormat": "求出排序后的选票编号。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1272", "type": "P", "difficulty": 5, "samples": [["11 6\n1 2\n1 3\n1 4\n1 5\n2 6\n2 7\n2 8\n4 9\n4 10\n4 11\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "树形 DP"], "title": "重建道路", "background": null, "description": "一场可怕的地震后，人们用 $N$ 个牲口棚（编号 $1\\sim N$）重建了农夫 John 的牧场。由于人们没有时间建设多余的道路，所以现在从一个牲口棚到另一个牲口棚的道路是唯一的。因此，牧场运输系统可以被构建成一棵树。\n\nJohn 想要知道另一次地震会造成多严重的破坏。有些道路一旦被毁坏，就会使一棵含有 $P$ 个牲口棚的子连通块和剩余的牲口棚分离，John 想知道这些道路的最小数目。", "inputFormat": "第一行两个整数，$N$ 和 $P$。\n\n第二行到第 $N$ 行，每行两个整数 $I$ 和 $J$，表示节点 $I$ 是节点 $J$ 的父节点。牧场运输系统可以被构建成一棵以 1 号节点为根的树。", "outputFormat": "单独一行，包含一旦被破坏将分离出恰含 $P$ 个节点的子连通块的道路的最小数目。", "hint": "### 样例解释\n\n如果道路 $1-4$ 和 $1-5$ 被破坏，含有节点（$1,2,3,6,7,8$）的子树将被分离出来。\n\n### 限制与约定\n\n$1\\le N\\le 150$，$1\\le P\\le N$，保证给出的是一棵树。", "locale": "zh-CN", "translations": {"en": {"title": "Rebuilding Roads", "background": "", "description": "After a terrible earthquake, people rebuilt Farmer John's ranch with $N$ barns (numbered $1 \\sim N$). Since there was no time to build extra roads, there is a unique path between any two barns. Therefore, the ranch road network forms a tree.\n\nJohn wants to know how severe the damage would be in another earthquake. Some roads, once destroyed, would separate a subtree containing $P$ barns from the remaining barns. John wants to know the minimum number of such roads.", "inputFormat": "The first line contains two integers, $N$ and $P$.\n\nFrom the second line to the $N$-th line (i.e., $N - 1$ lines), each line contains two integers $I$ and $J$, indicating that node $I$ is the parent of node $J$. The road network can be built as a tree rooted at node $1$.", "outputFormat": "Output a single line containing the minimum number of roads whose destruction would separate a subtree with exactly $P$ nodes.", "hint": "Sample explanation:\nIf roads $1-4$ and $1-5$ are destroyed, the subtree containing nodes ($1, 2, 3, 6, 7, 8$) will be separated.\n\nConstraints:\n$1 \\le N \\le 150$, $1 \\le P \\le N$. It is guaranteed that the input forms a tree.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "重建道路", "background": null, "description": "一场可怕的地震后，人们用 $N$ 个牲口棚（编号 $1\\sim N$）重建了农夫 John 的牧场。由于人们没有时间建设多余的道路，所以现在从一个牲口棚到另一个牲口棚的道路是唯一的。因此，牧场运输系统可以被构建成一棵树。\n\nJohn 想要知道另一次地震会造成多严重的破坏。有些道路一旦被毁坏，就会使一棵含有 $P$ 个牲口棚的子连通块和剩余的牲口棚分离，John 想知道这些道路的最小数目。", "inputFormat": "第一行两个整数，$N$ 和 $P$。\n\n第二行到第 $N$ 行，每行两个整数 $I$ 和 $J$，表示节点 $I$ 是节点 $J$ 的父节点。牧场运输系统可以被构建成一棵以 1 号节点为根的树。", "outputFormat": "单独一行，包含一旦被破坏将分离出恰含 $P$ 个节点的子连通块的道路的最小数目。", "hint": "### 样例解释\n\n如果道路 $1-4$ 和 $1-5$ 被破坏，含有节点（$1,2,3,6,7,8$）的子树将被分离出来。\n\n### 限制与约定\n\n$1\\le N\\le 150$，$1\\le P\\le N$，保证给出的是一棵树。", "locale": "zh-CN"}}}
{"pid": "P1273", "type": "P", "difficulty": 4, "samples": [["5 3\r\n2 2 2 5 3\r\n2 3 2 4 3\r\n3 4 2", "2\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "树形数据结构", "递归", "背包 DP", "树形 DP"], "title": "有线电视网", "background": null, "description": "某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。\n\n从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。\n\n现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。\n\n写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。", "inputFormat": "输入文件的第一行包含两个用空格隔开的整数 $N$ 和 $M$，其中 $2 \\le N \\le 3000$，$1 \\le M \\le N-1$，$N$ 为整个有线电视网的结点总数，$M$ 为用户终端的数量。\n\n第一个转播站即树的根结点编号为 $1$，其他的转播站编号为 $2$ 到 $N-M$，用户终端编号为 $N-M+1$ 到 $N$。\n\n接下来的 $N-M$ 行每行表示—个转播站的数据，第 $i+1$ 行表示第 $i$ 个转播站的数据，其格式如下：\n\n$K \\ \\ A_1 \\ \\ C_1 \\ \\ A_2 \\ \\ C_2 \\ \\ \\ldots \\ \\ A_k \\ \\ C_k$\n\n$K$ 表示该转播站下接 $K$ 个结点（转播站或用户），每个结点对应一对整数 $A$ 与 $C$ ，$A$ 表示结点编号，$C$ 表示从当前转播站传输信号到结点 $A$ 的费用。最后一行依次表示所有用户为观看比赛而准备支付的钱数。单次传输成本和用户愿意交的费用均不超过 $10$。\n\n[](https://paste.ubuntu.com/p/xN9NRmYvpY/)", "outputFormat": "输出文件仅一行，包含一个整数，表示上述问题所要求的最大用户数。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7yj4u55m.png)\n\n如图所示，共有五个结点。结点 ① 为根结点，即现场直播站，② 为一个中转站，③④⑤ 为用户端，共 $M$ 个，编号从 $N-M+1$ 到 $N$，他们为观看比赛分别准备的钱数为 $3$、$4$、$2$。\n\n从结点 ① 可以传送信号到结点 ②，费用为 $2$；\n\n也可以传送信号到结点 ⑤，费用为 $3$（第二行数据所示）；\n\n从结点 ② 可以传输信号到结点 ③，费用为$2$；\n\n也可传输信号到结点 ④，费用为 $3$（第三行数据所示）。\n\n如果要让所有用户（③④⑤）都能看上比赛，则信号传输的总费用为：$2+3+2+3=10$，大于用户愿意支付的总费用 $3+4+2=9$，有线电视网就亏本了，而只让 ③④ 两个用户看比赛就不亏本了。\n\n[](https://paste.ubuntu.com/p/H9BMGJvFHH/)", "locale": "zh-CN", "translations": {"en": {"title": "Cable Television Network", "background": "", "description": "A pay cable television network plans to rebroadcast an important football match. Their rebroadcast network and user terminals form a tree structure. The root of the tree is located at the match venue, the leaves are user terminals, and the other relay stations are internal nodes of the tree.\n\nThe signal transmission costs from relay station to relay station and from relay station to user terminals are known. The total cost of one broadcast equals the sum of all transmission costs used.\n\nEach user has prepared a certain amount of money to watch the match. The cable network has the right to decide which users receive the signal and which do not.\n\nWrite a program to find a plan that allows the cable network to serve as many users as possible without incurring a loss.", "inputFormat": "The first line contains two integers $N$ and $M$ separated by a space, where $2 \\le N \\le 3000$, $1 \\le M \\le N - 1$. Here $N$ is the total number of nodes in the entire cable network, and $M$ is the number of user terminals.\n\nThe first relay station (the root of the tree) is numbered $1$. The other relay stations are numbered from $2$ to $N - M$. The user terminals are numbered from $N - M + 1$ to $N$.\n\nThe next $N - M$ lines each describe one relay station. The $(i + 1)$-th line describes relay station $i$ in the following format:\n\n$K \\ \\ A_1 \\ \\ C_1 \\ \\ A_2 \\ \\ C_2 \\ \\ \\ldots \\ \\ A_k \\ \\ C_k$\n\n$K$ indicates that this relay station has $K$ direct children (relay stations or users). Each child is given by a pair of integers $A$ and $C$, where $A$ is the child node number, and $C$ is the transmission cost from the current relay station to node $A$.\n\nThe last line contains, in order, the amounts of money each user is willing to pay to watch the match. Each single transmission cost and each user's payment do not exceed $10$.", "outputFormat": "Output a single integer on one line: the maximum number of users that can be served without the network incurring a loss.", "hint": "Sample explanation:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7yj4u55m.png)\n\nAs shown in the figure, there are five nodes in total. Node 1 is the root node, i.e., the live broadcast station. Node 2 is a relay station. Nodes 3, 4, 5 are user terminals, $M$ in total, numbered from $N - M + 1$ to $N$. They are willing to pay $3$, $4$, and $2$, respectively.\n\nFrom node 1, the signal can be sent to node 2 at a cost of $2$;\nit can also be sent to node 5 at a cost of $3$ (as shown by the second line of data).\nFrom node 2, the signal can be sent to node 3 at a cost of $2$;\nit can also be sent to node 4 at a cost of $3$ (as shown by the third line of data).\n\nIf all users (3, 4, 5) are to watch the match, the total transmission cost is $2 + 3 + 2 + 3 = 10$, which is greater than the total amount users are willing to pay $3 + 4 + 2 = 9$, so the cable network would incur a loss. If only users 3 and 4 watch the match, then there is no loss.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "有线电视网", "background": null, "description": "某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。\n\n从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。\n\n现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。\n\n写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。", "inputFormat": "输入文件的第一行包含两个用空格隔开的整数 $N$ 和 $M$，其中 $2 \\le N \\le 3000$，$1 \\le M \\le N-1$，$N$ 为整个有线电视网的结点总数，$M$ 为用户终端的数量。\n\n第一个转播站即树的根结点编号为 $1$，其他的转播站编号为 $2$ 到 $N-M$，用户终端编号为 $N-M+1$ 到 $N$。\n\n接下来的 $N-M$ 行每行表示—个转播站的数据，第 $i+1$ 行表示第 $i$ 个转播站的数据，其格式如下：\n\n$K \\ \\ A_1 \\ \\ C_1 \\ \\ A_2 \\ \\ C_2 \\ \\ \\ldots \\ \\ A_k \\ \\ C_k$\n\n$K$ 表示该转播站下接 $K$ 个结点（转播站或用户），每个结点对应一对整数 $A$ 与 $C$ ，$A$ 表示结点编号，$C$ 表示从当前转播站传输信号到结点 $A$ 的费用。最后一行依次表示所有用户为观看比赛而准备支付的钱数。单次传输成本和用户愿意交的费用均不超过 $10$。\n\n[](https://paste.ubuntu.com/p/xN9NRmYvpY/)", "outputFormat": "输出文件仅一行，包含一个整数，表示上述问题所要求的最大用户数。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7yj4u55m.png)\n\n如图所示，共有五个结点。结点 ① 为根结点，即现场直播站，② 为一个中转站，③④⑤ 为用户端，共 $M$ 个，编号从 $N-M+1$ 到 $N$，他们为观看比赛分别准备的钱数为 $3$、$4$、$2$。\n\n从结点 ① 可以传送信号到结点 ②，费用为 $2$；\n\n也可以传送信号到结点 ⑤，费用为 $3$（第二行数据所示）；\n\n从结点 ② 可以传输信号到结点 ③，费用为$2$；\n\n也可传输信号到结点 ④，费用为 $3$（第三行数据所示）。\n\n如果要让所有用户（③④⑤）都能看上比赛，则信号传输的总费用为：$2+3+2+3=10$，大于用户愿意支付的总费用 $3+4+2=9$，有线电视网就亏本了，而只让 ③④ 两个用户看比赛就不亏本了。\n\n[](https://paste.ubuntu.com/p/H9BMGJvFHH/)", "locale": "zh-CN"}}}
{"pid": "P1274", "type": "P", "difficulty": 4, "samples": [["1 1\n", "1 4 13 16 \n14 15 2 3 \n8 5 12 9 \n11 10 7 6 \n\n1 4 13 16 \n14 15 2 3 \n12 9 8 5 \n7 6 11 10 \n\n……剩余214组合法解省略"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "魔术数字游戏", "background": "", "description": "填数字方格的游戏有很多种变化，如下图所示的 $4 \\times 4$ 方格中，我们要选择从数字 $1$ 到 $16$ 来填满这十六个格子($A_{i,j}$ ，其中 $i=1 \\cdots 4$ ，$j=1 \\cdots 4$)。为了让游戏更有挑战性，我们要求下列六项中的每一项所指定的四个格子，其数字累加的和必须为 $34$ ：\n\n| $A_{1,1}$ | $A_{1,2}$ | $A_{1,3}$ |  $A_{1,4}$|\n| :----------- | :----------- | :----------- | :----------- |\n| $A_{2,1}$ | $A_{2,2}$ | $A_{2,3}$ | $A_{2,4}$ |\n| $A_{3,1}$ | $A_{3,2}$ | $A_{3,3}$ | $A_{3,4}$ |\n| $A_{4,1}$ | $A_{4,2}$ | $A_{4,3}$ | $A_{4,4}$ |\n\n- 四个角落上的数字，即 $A_{1,1}+A_{1,4}+A_{4,1}+A_{4,4}=34$ 。\n- 每个角落上的 $2 \\times 2$ 方格中的数字，例如左上角 $A_{1,1}+A_{1,2}+A_{2,1}+A_{2,2}=34$ 。\n- 最中间的 $2 \\times 2$ 方格中的数字，即 $A_{2,2}+A_{2,3}+A_{3,2}+A_{3,3}=34$ 。\n- 每条水平线上四个格子中的数字，即 $A_{i,1}+A_{i,2}+A_{i,3}+A_{i,4}=34$，其中 $i=1 \\cdots 4$ 。\n- 每条垂直线上四个格子中的数字，即 $A_{1,j}+A_{2,j}+A_{3,j}+A_{4,j}=34$，其中 $j=1 \\cdots 4$ 。\n- 两条对角线上四个格子中的数字，例如左上角到右下角 $A_{1,1}+A_{2,2}+A_{3,3}+A_{4,4}=34$ 。\n- 右上角到左下角：$A_{1,4}+A_{2,3}+A_{3,2}+A_{4,1}=34$ 。\n\n特别的，我们会指定把数字 $1$ 先固定在某一格内。", "inputFormat": "输入只有一行包含两个正数据 $i$ 和 $j$ ，表示第 $i$ 行和第 $j$ 列的格子放数字 $1$。剩下的十五个格子，请按照前述六项条件用数字 $2$ 到 $16$ 来填满。", "outputFormat": "输出所有合法解，并且依序排好。相邻两组合法解之间用一个空行隔开。\n\n对于每一组合法解，输出四行，每行四个数，相邻两数之间用一个空格隔开。\n\n合法解排序的方式，是先从第一行的数字开始比较，每一行数字，由最左边的数字开始比，数字较小的解答必须先输出到文件中。", "hint": "\n可以得到，对于样例，合理的填写方法有 $216$ 种，以上仅为其中的两种。\n\n#### 数据规模与约定 \n对于全部的测试点，保证 $1 \\leq i, j \\leq 4$。", "locale": "zh-CN", "translations": {"en": {"title": "Magic Number Game", "background": "", "description": "There are many variations of number-filling grid games. In the $4 \\times 4$ grid below, we are to fill the sixteen cells with the numbers $1$ through $16$ (cells $A_{i,j}$, where $i = 1 \\cdots 4$, $j = 1 \\cdots 4$). To make the game more challenging, we require that the four numbers specified in each of the following items must add up to $34$:\n\n| $A_{1,1}$ | $A_{1,2}$ | $A_{1,3}$ |  $A_{1,4}$|\n| :----------- | :----------- | :----------- | :----------- |\n| $A_{2,1}$ | $A_{2,2}$ | $A_{2,3}$ | $A_{2,4}$ |\n| $A_{3,1}$ | $A_{3,2}$ | $A_{3,3}$ | $A_{3,4}$ |\n| $A_{4,1}$ | $A_{4,2}$ | $A_{4,3}$ | $A_{4,4}$ |\n\n- The four corner cells: $A_{1,1}+A_{1,4}+A_{4,1}+A_{4,4}=34$.\n- Each $2 \\times 2$ block at a corner, for example the top-left: $A_{1,1}+A_{1,2}+A_{2,1}+A_{2,2}=34$.\n- The central $2 \\times 2$ block: $A_{2,2}+A_{2,3}+A_{3,2}+A_{3,3}=34$.\n- Each row: $A_{i,1}+A_{i,2}+A_{i,3}+A_{i,4}=34$, where $i = 1 \\cdots 4$.\n- Each column: $A_{1,j}+A_{2,j}+A_{3,j}+A_{4,j}=34$, where $j = 1 \\cdots 4$.\n- The two diagonals, for example the main diagonal from top-left to bottom-right: $A_{1,1}+A_{2,2}+A_{3,3}+A_{4,4}=34$.\n- From top-right to bottom-left: $A_{1,4}+A_{2,3}+A_{3,2}+A_{4,1}=34$.\n\nIn particular, we will fix the number $1$ in a specified cell.", "inputFormat": "The input contains a single line with two positive integers $i$ and $j$, indicating that the cell in row $i$ and column $j$ contains the number $1$. Fill the remaining fifteen cells with the numbers $2$ through $16$ according to the conditions above.", "outputFormat": "Output all valid solutions in increasing order, separated by a single empty line.\n\nFor each valid solution, output four lines, each containing four numbers separated by a single space.\n\nThe ordering of valid solutions is determined as follows: compare numbers starting from the first row; within each row, compare from the leftmost number. The solution with the smaller number at the first differing position must be printed first.", "hint": "For the sample, there are $216$ valid fillings.\n\nConstraints: For all test points, it is guaranteed that $1 \\leq i, j \\leq 4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "魔术数字游戏", "background": "", "description": "填数字方格的游戏有很多种变化，如下图所示的 $4 \\times 4$ 方格中，我们要选择从数字 $1$ 到 $16$ 来填满这十六个格子($A_{i,j}$ ，其中 $i=1 \\cdots 4$ ，$j=1 \\cdots 4$)。为了让游戏更有挑战性，我们要求下列六项中的每一项所指定的四个格子，其数字累加的和必须为 $34$ ：\n\n| $A_{1,1}$ | $A_{1,2}$ | $A_{1,3}$ |  $A_{1,4}$|\n| :----------- | :----------- | :----------- | :----------- |\n| $A_{2,1}$ | $A_{2,2}$ | $A_{2,3}$ | $A_{2,4}$ |\n| $A_{3,1}$ | $A_{3,2}$ | $A_{3,3}$ | $A_{3,4}$ |\n| $A_{4,1}$ | $A_{4,2}$ | $A_{4,3}$ | $A_{4,4}$ |\n\n- 四个角落上的数字，即 $A_{1,1}+A_{1,4}+A_{4,1}+A_{4,4}=34$ 。\n- 每个角落上的 $2 \\times 2$ 方格中的数字，例如左上角 $A_{1,1}+A_{1,2}+A_{2,1}+A_{2,2}=34$ 。\n- 最中间的 $2 \\times 2$ 方格中的数字，即 $A_{2,2}+A_{2,3}+A_{3,2}+A_{3,3}=34$ 。\n- 每条水平线上四个格子中的数字，即 $A_{i,1}+A_{i,2}+A_{i,3}+A_{i,4}=34$，其中 $i=1 \\cdots 4$ 。\n- 每条垂直线上四个格子中的数字，即 $A_{1,j}+A_{2,j}+A_{3,j}+A_{4,j}=34$，其中 $j=1 \\cdots 4$ 。\n- 两条对角线上四个格子中的数字，例如左上角到右下角 $A_{1,1}+A_{2,2}+A_{3,3}+A_{4,4}=34$ 。\n- 右上角到左下角：$A_{1,4}+A_{2,3}+A_{3,2}+A_{4,1}=34$ 。\n\n特别的，我们会指定把数字 $1$ 先固定在某一格内。", "inputFormat": "输入只有一行包含两个正数据 $i$ 和 $j$ ，表示第 $i$ 行和第 $j$ 列的格子放数字 $1$。剩下的十五个格子，请按照前述六项条件用数字 $2$ 到 $16$ 来填满。", "outputFormat": "输出所有合法解，并且依序排好。相邻两组合法解之间用一个空行隔开。\n\n对于每一组合法解，输出四行，每行四个数，相邻两数之间用一个空格隔开。\n\n合法解排序的方式，是先从第一行的数字开始比较，每一行数字，由最左边的数字开始比，数字较小的解答必须先输出到文件中。", "hint": "\n可以得到，对于样例，合理的填写方法有 $216$ 种，以上仅为其中的两种。\n\n#### 数据规模与约定 \n对于全部的测试点，保证 $1 \\leq i, j \\leq 4$。", "locale": "zh-CN"}}}
{"pid": "P1275", "type": "P", "difficulty": 5, "samples": [["2\r\n3 4\r\n0 1 0 1\r\n1 0 0 1\r\n0 0 0 0\r\n0 1 0 1\r\n1 1 0 0\r\n0 0 0 0\r\n2 2\r\n0 0\r\n0 1\r\n1 1\r\n1 1", "YES\r\nNO\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "魔板", "background": null, "description": "有这样一种魔板：它是一个长方形的面板，被划分成 $n$ 行 $m$ 列的 $n \\times m$ 个方格。每个方格内有一个小灯泡，灯泡的状态有两种（亮或暗）。我们可以通过若干操作使魔板从一个状态改变为另一个状态。操作的方式有两种：\n\n1. 任选一行，改变该行中所有灯泡的状态，即亮的变暗、暗的变亮；\n2. 任选两列，交换其位置。\n\n当然并不是任意的两种状态都可以通过若干操作来实现互相转化的。\n\n你的任务就是根据给定两个魔板状态，判断两个状态能否互相转化。", "inputFormat": "文件中包含多组数据。第一行一个整数 $k$（$0 < k \\leq 5$），表示有 $k$ 组数据。\n\n每组数据的第一行两个整数 $n$ 和 $m$（$0 < n,m \\leq 100$）。\n\n以下的 $n$ 行描述第一个魔板。每行有 $m$ 个数字（$0$ 或 $1$），中间用空格分隔。若第 $x$ 行的第 $y$个数字为 $0$，则表示魔板的第 $x$ 行 $y$ 列的灯泡为“亮”；否则为“暗”。\n\n然后的 $n$ 行描述第二个魔板。数据格式同上。\n\n任意两组数据间没有空行。", "outputFormat": "共 $k$ 行，依次描述每一组数据的结果。\n\n若两个魔板可以相互转化，则输出 $\\texttt{YES}$，否则输出 $\\texttt{NO}$。（注意：请使用大写字母）", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Magic Board", "background": "", "description": "There is a kind of magic board: it is a rectangular panel divided into $n$ rows and $m$ columns, forming $n \\times m$ cells. Each cell contains a small light bulb, and each bulb has two possible states (on or off). We can transform the board from one state to another using several operations. There are two types of operations:\n\n1. Choose any row and toggle the state of all bulbs in that row, i.e., on becomes off and off becomes on.\n2. Choose any two columns and swap their positions.\n\nOf course, not every pair of states can be transformed into each other through these operations.\n\nYour task is to determine whether two given board states can be transformed into each other.", "inputFormat": "The file contains multiple datasets. The first line contains an integer $k$ ($0 < k \\leq 5$), indicating there are $k$ datasets.\n\nFor each dataset, the first line contains two integers $n$ and $m$ ($0 < n, m \\leq 100$).\n\nThe next $n$ lines describe the first magic board. Each line contains $m$ numbers ($0$ or $1$), separated by spaces. If the $y$-th number in the $x$-th row is $0$, then the bulb at row $x$, column $y$ is \"on\"; otherwise it is \"off\".\n\nThe following $n$ lines describe the second magic board in the same format.\n\nThere are no blank lines between any two datasets.", "outputFormat": "Output $k$ lines, each describing the result for one dataset in order.\n\nIf the two boards can be transformed into each other, output $\\texttt{YES}$; otherwise, output $\\texttt{NO}$. (Note: please use uppercase letters.)", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "魔板", "background": null, "description": "有这样一种魔板：它是一个长方形的面板，被划分成 $n$ 行 $m$ 列的 $n \\times m$ 个方格。每个方格内有一个小灯泡，灯泡的状态有两种（亮或暗）。我们可以通过若干操作使魔板从一个状态改变为另一个状态。操作的方式有两种：\n\n1. 任选一行，改变该行中所有灯泡的状态，即亮的变暗、暗的变亮；\n2. 任选两列，交换其位置。\n\n当然并不是任意的两种状态都可以通过若干操作来实现互相转化的。\n\n你的任务就是根据给定两个魔板状态，判断两个状态能否互相转化。", "inputFormat": "文件中包含多组数据。第一行一个整数 $k$（$0 < k \\leq 5$），表示有 $k$ 组数据。\n\n每组数据的第一行两个整数 $n$ 和 $m$（$0 < n,m \\leq 100$）。\n\n以下的 $n$ 行描述第一个魔板。每行有 $m$ 个数字（$0$ 或 $1$），中间用空格分隔。若第 $x$ 行的第 $y$个数字为 $0$，则表示魔板的第 $x$ 行 $y$ 列的灯泡为“亮”；否则为“暗”。\n\n然后的 $n$ 行描述第二个魔板。数据格式同上。\n\n任意两组数据间没有空行。", "outputFormat": "共 $k$ 行，依次描述每一组数据的结果。\n\n若两个魔板可以相互转化，则输出 $\\texttt{YES}$，否则输出 $\\texttt{NO}$。（注意：请使用大写字母）", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1276", "type": "P", "difficulty": 2, "samples": [["10 3\n0 2 6\n1 1 8\n0 5 7\n", "3\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "校门外的树（增强版）", "background": "", "description": "校门外马路上本来从编号 $0$ 到 $L$，每一编号的位置都有一棵树。有砍树者每次从编号 $A$ 到 $B$ 处连续砍掉每一棵树，就连树苗也不放过（记 `0 A B`，含 $A$ 和 $B$）；幸运的是还有植树者每次从编号 $C$ 到 $D$ 中凡是空穴（树被砍且还没种上树苗或树苗又被砍掉）的地方都补种上树苗（记 `1 C D`，含 $C$ 和 $D$）；问最终校门外留下的树苗多少棵？植树者种上又被砍掉的树苗有多少棵？", "inputFormat": "第一行，两个正整数 $L$ 和 $N$，表示校园外原来有 $L + 1$ 棵树，并有 $N$ 次砍树或种树的操作。\n\n以下 $N$ 行，每行三个整数，表示砍树或植树的标记和范围。", "outputFormat": "共两行。第一行校门外留下的树苗数目，第二行种上又被拔掉的树苗数目。", "hint": "对于 $100 \\%$ 的数据，$1 \\le L \\le 10000$，$1 \\le N \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Trees Outside the School Gate (Enhanced Version)", "background": "", "description": "Along the road outside the school gate, positions are numbered from $0$ to $L$, and at every numbered position there is a tree. A lumberjack removes every tree or sapling continuously from position $A$ to $B$ inclusive (denoted as `0 A B`, including $A$ and $B$); fortunately, a planter plants a sapling at every empty hole from position $C$ to $D$ inclusive (denoted as `1 C D`, including $C$ and $D$), where an empty hole means a position where the tree has been cut and there is currently no sapling (or a previously planted sapling there has been cut again). After all operations, how many saplings remain outside the school gate? How many saplings that were planted were later cut down?", "inputFormat": "The first line contains two positive integers $L$ and $N$, meaning there were originally $L + 1$ trees outside the campus, and there are $N$ cutting or planting operations.\n\nEach of the following $N$ lines contains three integers, indicating the operation tag and its range.", "outputFormat": "Output two lines. The first line is the number of saplings remaining outside the school gate. The second line is the number of saplings that were planted and then cut down.", "hint": "For $100\\%$ of the testdata, $1 \\le L \\le 10000$, $1 \\le N \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "校门外的树（增强版）", "background": "", "description": "校门外马路上本来从编号 $0$ 到 $L$，每一编号的位置都有一棵树。有砍树者每次从编号 $A$ 到 $B$ 处连续砍掉每一棵树，就连树苗也不放过（记 `0 A B`，含 $A$ 和 $B$）；幸运的是还有植树者每次从编号 $C$ 到 $D$ 中凡是空穴（树被砍且还没种上树苗或树苗又被砍掉）的地方都补种上树苗（记 `1 C D`，含 $C$ 和 $D$）；问最终校门外留下的树苗多少棵？植树者种上又被砍掉的树苗有多少棵？", "inputFormat": "第一行，两个正整数 $L$ 和 $N$，表示校园外原来有 $L + 1$ 棵树，并有 $N$ 次砍树或种树的操作。\n\n以下 $N$ 行，每行三个整数，表示砍树或植树的标记和范围。", "outputFormat": "共两行。第一行校门外留下的树苗数目，第二行种上又被拔掉的树苗数目。", "hint": "对于 $100 \\%$ 的数据，$1 \\le L \\le 10000$，$1 \\le N \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P1277", "type": "P", "difficulty": 6, "samples": [["130 120 172 140 157 93 144 168 66 195 0 1 15 1 3 49 2 2 16 3 0 33", "22 15 28 65\n49 1 21 49\n53 76 16 27\n33 1 79 27\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "Special Judge"], "title": "拼字游戏", "background": "", "description": "有一个未知的 $4 \\times 4$ 的拼盘 $M$，它的每个元素都是正整数。给出 $4$ 行元素的总和，$4$ 列元素的总和以及两条对角线元素总和。另外还给出了拼盘中任意 $4$ 个位置的元素值，它们的位置在输入文件中给定。\n\n编写一个程序求出拼盘中另外 $12$ 个位置的正整数的值，要求这些元素的行之和，列之和以及对角线之和与输入文件中给定的值相一致。\n", "inputFormat": "输入文件包含用空格隔开的 $22$ 个正整数。\n\n前四个数字分别表示四行中每一行元素的总和，接下来的 $4$ 个数字分别表示 $4$ 列中每列元素的总和。接下来的数字表示主对角线元素的总和，即 $M(0, 0)+M(1,1)+M(2, 2)+M(3, 3)$。然后的数字（第 $10$ 个数字）表示逆对角线上元数之和，即 $M(0, 3)+M(1, 2)+M(2, 1)+M(3, 0)$ 。剩下的部分还包含 $12$ 个数字，被分成三个一组的形式 $i,j,k$。表示 $M(i,j)=k$。\n\n你可以假设任何行对角线或列之和不会超过 $300$。另外还可假设对于给定的输入文件总是存在解决方案。\n", "outputFormat": "输出文件应包含按 $4 \\times 4$ 的形式输出的 $16$ 个数字，同一行的四个数字用一个空个隔开。注意：对于给定的输入文件，可能有一个以上可能的解决方案。任何一个方案都是可接受的。\n", "hint": "- 对于 $10\\%$ 的数据，任何行，列或对角线之和不会超过 $20$；\n- 对于 $30\\%$ 的数据，任何行，列或对角线之和不会超过 $80$；\n- 对于 $60\\%$ 的数据，任何行，列或对角线之和不会超过 $200$；\n- 对于 $100\\%$ 的数据，任何行，列或对角线之和不会超过 $300$。\n\n感谢 @Jomoo 的贡献。", "locale": "zh-CN", "translations": {"en": {"title": "Word Puzzle", "background": "", "description": "There is an unknown $4 \\times 4$ grid $M$, where each entry is a positive integer. You are given the sums of the $4$ rows, the sums of the $4$ columns, and the sums of both diagonals. In addition, the values of any $4$ positions in the grid are given; their positions are specified in the input.\n\nWrite a program to determine the positive integers in the remaining $12$ positions of the grid, such that the row sums, column sums, and diagonal sums match the values provided in the input.\n\nYou may assume that no row, column, or diagonal sum exceeds $300$. You may also assume that a solution always exists for the given input.", "inputFormat": "The input contains $22$ space-separated positive integers.\n\nThe first four numbers are the sums of the four rows, respectively; the next four numbers are the sums of the $4$ columns. The next number is the sum of the main diagonal elements, i.e., $M(0, 0)+M(1,1)+M(2, 2)+M(3, 3)$. The following number (the $10$th number) is the sum of the anti-diagonal elements, i.e., $M(0, 3)+M(1, 2)+M(2, 1)+M(3, 0)$. The remaining part contains $12$ numbers, grouped into triples $i, j, k$, meaning $M(i,j)=k$.", "outputFormat": "Output the $16$ numbers arranged as a $4 \\times 4$ grid; within each row, separate the four numbers by a single space. Note: For a given input, there may be more than one valid solution. Any one of them is acceptable.", "hint": "- For $10\\%$ of the testdata, no row, column, or diagonal sum exceeds $20$.\n- For $30\\%$ of the testdata, no row, column, or diagonal sum exceeds $80$.\n- For $60\\%$ of the testdata, no row, column, or diagonal sum exceeds $200$.\n- For $100\\%$ of the testdata, no row, column, or diagonal sum exceeds $300$.\n\nThanks to @Jomoo for the contribution.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "拼字游戏", "background": "", "description": "有一个未知的 $4 \\times 4$ 的拼盘 $M$，它的每个元素都是正整数。给出 $4$ 行元素的总和，$4$ 列元素的总和以及两条对角线元素总和。另外还给出了拼盘中任意 $4$ 个位置的元素值，它们的位置在输入文件中给定。\n\n编写一个程序求出拼盘中另外 $12$ 个位置的正整数的值，要求这些元素的行之和，列之和以及对角线之和与输入文件中给定的值相一致。\n", "inputFormat": "输入文件包含用空格隔开的 $22$ 个正整数。\n\n前四个数字分别表示四行中每一行元素的总和，接下来的 $4$ 个数字分别表示 $4$ 列中每列元素的总和。接下来的数字表示主对角线元素的总和，即 $M(0, 0)+M(1,1)+M(2, 2)+M(3, 3)$。然后的数字（第 $10$ 个数字）表示逆对角线上元数之和，即 $M(0, 3)+M(1, 2)+M(2, 1)+M(3, 0)$ 。剩下的部分还包含 $12$ 个数字，被分成三个一组的形式 $i,j,k$。表示 $M(i,j)=k$。\n\n你可以假设任何行对角线或列之和不会超过 $300$。另外还可假设对于给定的输入文件总是存在解决方案。\n", "outputFormat": "输出文件应包含按 $4 \\times 4$ 的形式输出的 $16$ 个数字，同一行的四个数字用一个空个隔开。注意：对于给定的输入文件，可能有一个以上可能的解决方案。任何一个方案都是可接受的。\n", "hint": "- 对于 $10\\%$ 的数据，任何行，列或对角线之和不会超过 $20$；\n- 对于 $30\\%$ 的数据，任何行，列或对角线之和不会超过 $80$；\n- 对于 $60\\%$ 的数据，任何行，列或对角线之和不会超过 $200$；\n- 对于 $100\\%$ 的数据，任何行，列或对角线之和不会超过 $300$。\n\n感谢 @Jomoo 的贡献。", "locale": "zh-CN"}}}
{"pid": "P1278", "type": "P", "difficulty": 4, "samples": [["5\r\nIOO\r\nIUUO\r\nAI\r\nOIOOI\r\nAOOI", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["记忆化搜索", "状压 DP"], "title": "单词游戏", "background": "", "description": "Io 和 Ao 在玩一个单词游戏。\n\n他们轮流说出一个仅包含元音字母的单词，并且后一个单词的第一个字母必须与前一个单词的最后一个字母一致。\n\n游戏可以从任何一个单词开始。\n\n任何单词禁止说两遍，游戏中只能使用给定词典中含有的单词。\n\n游戏的复杂度定义为游戏中所使用的单词长度总和。\n\n编写程序，求出使用一本给定的词典来玩这个游戏所能达到的游戏最大可能复杂度。\n", "inputFormat": "输入文件的第一行，表示一个自然数 $N(1 \\le N \\le 16)$，$N$ 表示一本字典中包含的单词数量以下的每一行包含字典中的一个单词，每一个单词是由字母 `A`、`E`、`I`、`O` 和 `U` 组成的一个字符串，每个单词的长度将小于等于 $100$，所有的单词是不一样的。\n", "outputFormat": "输出文件仅有一行，表示该游戏的最大可能复杂度。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Word Game", "background": "", "description": "Io and Ao are playing a word game.\n\nThey take turns saying a word that contains only vowels, and the first letter of each new word must be the same as the last letter of the previous word.\n\nThe game can start from any word.\n\nNo word may be said twice, and only words contained in the given dictionary may be used during the game.\n\nThe complexity of the game is defined as the total sum of the lengths of the words used in the game.\n\nWrite a program to compute the maximum possible complexity achievable when playing this game using a given dictionary.", "inputFormat": "The first line of the input file contains a natural number $N(1 \\le N \\le 16)$, where $N$ is the number of words in the dictionary. Each of the following $N$ lines contains one word from the dictionary. Each word is a string consisting only of the letters 'A', 'E', 'I', 'O', and 'U'. The length of each word is less than or equal to $100$. All words are different.", "outputFormat": "The output file contains a single line, which is the maximum possible complexity of the game.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "单词游戏", "background": "", "description": "Io 和 Ao 在玩一个单词游戏。\n\n他们轮流说出一个仅包含元音字母的单词，并且后一个单词的第一个字母必须与前一个单词的最后一个字母一致。\n\n游戏可以从任何一个单词开始。\n\n任何单词禁止说两遍，游戏中只能使用给定词典中含有的单词。\n\n游戏的复杂度定义为游戏中所使用的单词长度总和。\n\n编写程序，求出使用一本给定的词典来玩这个游戏所能达到的游戏最大可能复杂度。\n", "inputFormat": "输入文件的第一行，表示一个自然数 $N(1 \\le N \\le 16)$，$N$ 表示一本字典中包含的单词数量以下的每一行包含字典中的一个单词，每一个单词是由字母 `A`、`E`、`I`、`O` 和 `U` 组成的一个字符串，每个单词的长度将小于等于 $100$，所有的单词是不一样的。\n", "outputFormat": "输出文件仅有一行，表示该游戏的最大可能复杂度。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1279", "type": "P", "difficulty": 3, "samples": [["cmc\r\nsnmn\r\n2\r\n", "10\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP"], "title": "字串距离", "background": "", "description": "设有字符串 $X$，我们称在 $X$ 的头尾及中间插入任意多个空格后构成的新字符串为 $X$ 的扩展串，如字符串 $X$ 为$\\verb!abcbcd!$，则字符串 $\\verb!abcb␣cd!$，$\\verb!␣a␣bcbcd␣!$ 和 $\\verb!abcb␣cd␣!$ 都是 $X$ 的扩展串，这里 $\\verb!␣!$ 代表空格字符。\n\n如果 $A_1$ 是字符串 $A$ 的扩展串，$B_1$ 是字符串 $B$ 的扩展串，$A_1$ 与 $B_1$ 具有相同的长度，那么我们定义字符串 $A_1$ 与 $B_1$ 的距离为相应位置上的字符的距离总和，而两个非空格字符的距离定义为它们的 ASCII 码的差的绝对值，而空格字符与其他任意字符之间的距离为已知的定值K，空格字符与空格字符的距离为 $0$。在字符串 $A$、$B$ 的所有扩展串中，必定存在两个等长的扩展串 $A_1$，$B_1$，使得 $A_1$ 与 $B_1$ 之间的距离达到最小，我们将这一距离定义为字符串 $A$，$B$ 的距离。\n\n请你写一个程序，求出字符串 $A$，$B$ 的距离。\n", "inputFormat": "输入文件第一行为字符串 $A$ ，第二行为字符串 $B$。$A$，$B$ 均由小写字母组成且长度均不超过 $2000$。第三行为一个整数 $K(1\\leq K\\leq 100)$，表示空格与其他字符的距离。\n", "outputFormat": "输出文件仅一行包含一个整数，表示所求得字符串 $A,B$ 的距离。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "String Distance", "background": "", "description": "Given a string $X$, we call any new string formed by inserting any number of spaces at the beginning, end, or between characters of $X$ an extended string of $X$. For example, if $X$ is $\\verb!abcbcd!$, then $\\verb!abcb␣cd!$, $\\verb!␣a␣bcbcd␣!$, and $\\verb!abcb␣cd␣!$ are all extended strings of $X$, where $\\verb!␣!$ denotes the space character.\n\nIf $A_1$ is an extended string of $A$, $B_1$ is an extended string of $B$, and $A_1$ and $B_1$ have the same length, then we define the distance between $A_1$ and $B_1$ as the sum of the distances at corresponding positions. The distance between two non-space characters is defined as the absolute difference of their ASCII codes. The distance between a space character and any other character is a given constant $K$, and the distance between a space and a space is $0$. Among all extended strings of $A$ and $B$, there must exist two extended strings $A_1$ and $B_1$ of equal length such that the distance between $A_1$ and $B_1$ is minimized. We define this minimal value as the distance between strings $A$ and $B$.\n\nPlease write a program to compute the distance between strings $A$ and $B$.", "inputFormat": "The first line contains string $A$, and the second line contains string $B$. Both $A$ and $B$ consist of lowercase letters, and each has length at most $2000$. The third line contains an integer $K(1\\leq K\\leq 100)$, which is the distance between a space and any other character.", "outputFormat": "Output a single line containing an integer, which is the distance between $A$ and $B$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "字串距离", "background": "", "description": "设有字符串 $X$，我们称在 $X$ 的头尾及中间插入任意多个空格后构成的新字符串为 $X$ 的扩展串，如字符串 $X$ 为$\\verb!abcbcd!$，则字符串 $\\verb!abcb␣cd!$，$\\verb!␣a␣bcbcd␣!$ 和 $\\verb!abcb␣cd␣!$ 都是 $X$ 的扩展串，这里 $\\verb!␣!$ 代表空格字符。\n\n如果 $A_1$ 是字符串 $A$ 的扩展串，$B_1$ 是字符串 $B$ 的扩展串，$A_1$ 与 $B_1$ 具有相同的长度，那么我们定义字符串 $A_1$ 与 $B_1$ 的距离为相应位置上的字符的距离总和，而两个非空格字符的距离定义为它们的 ASCII 码的差的绝对值，而空格字符与其他任意字符之间的距离为已知的定值K，空格字符与空格字符的距离为 $0$。在字符串 $A$、$B$ 的所有扩展串中，必定存在两个等长的扩展串 $A_1$，$B_1$，使得 $A_1$ 与 $B_1$ 之间的距离达到最小，我们将这一距离定义为字符串 $A$，$B$ 的距离。\n\n请你写一个程序，求出字符串 $A$，$B$ 的距离。\n", "inputFormat": "输入文件第一行为字符串 $A$ ，第二行为字符串 $B$。$A$，$B$ 均由小写字母组成且长度均不超过 $2000$。第三行为一个整数 $K(1\\leq K\\leq 100)$，表示空格与其他字符的距离。\n", "outputFormat": "输出文件仅一行包含一个整数，表示所求得字符串 $A,B$ 的距离。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1280", "type": "P", "difficulty": 3, "samples": [["15 6\n1 2\n1 6\n4 11\n8 5\n8 1\n11 5\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "枚举", "排序"], "title": "尼克的任务", "background": "", "description": "尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。\n\n尼克的一个工作日为 $n$ 分钟，从第 $1$ 分钟开始到第 $n$ 分钟结束。当尼克到达单位后他就开始干活，公司一共有 $k$ 个任务需要完成。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 $p$ 分钟开始，持续时间为 $t$ 分钟，则该任务将在第 $(p+t-1)$ 分钟结束。\n\n写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。", "inputFormat": "输入数据第一行含两个用空格隔开的整数 $n$ 和 $k$。\n\n接下来共有 $k$ 行，每一行有两个用空格隔开的整数 $p$ 和 $t$，表示该任务从第 $p$ 分钟开始，持续时间为 $t$ 分钟。", "outputFormat": "输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^4,1 \\leq k \\leq 10^4,1 \\leq p \\leq n,1 \\leq p+t-1 \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "Nick's Task", "background": "", "description": "Before going to work each day, Nick connects to the Internet and receives emails from his supervisor. These emails list all tasks that Nick’s department must complete that day. Each task is defined by a start time and a duration.\n\nNick’s workday lasts $n$ minutes, from minute $1$ to minute $n$. As soon as Nick arrives at work, he starts working. There are $k$ tasks in total. If, at the same moment, multiple tasks need to be done, Nick may choose any one of them to do, and the others will be completed by his colleagues. Conversely, if there is only one task, then that task must be done by Nick. If some tasks start at a time when Nick is already working, those tasks will also be handled by his colleagues. If a task starts at minute $p$ and lasts $t$ minutes, then it ends at minute $(p+t-1)$.\n\nWrite a program to determine how Nick should choose tasks in order to maximize his free time.", "inputFormat": "The first line contains two integers $n$ and $k$ separated by a space.\n\nEach of the next $k$ lines contains two integers $p$ and $t$, indicating a task that starts at minute $p$ and lasts $t$ minutes.", "outputFormat": "Output a single line containing one integer, the maximum free time Nick can obtain.", "hint": "Constraints\n\n- For 100% of the testdata, it is guaranteed that $1 \\leq n \\leq 10^4, 1 \\leq k \\leq 10^4, 1 \\leq p \\leq n, 1 \\leq p+t-1 \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "尼克的任务", "background": "", "description": "尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。\n\n尼克的一个工作日为 $n$ 分钟，从第 $1$ 分钟开始到第 $n$ 分钟结束。当尼克到达单位后他就开始干活，公司一共有 $k$ 个任务需要完成。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 $p$ 分钟开始，持续时间为 $t$ 分钟，则该任务将在第 $(p+t-1)$ 分钟结束。\n\n写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。", "inputFormat": "输入数据第一行含两个用空格隔开的整数 $n$ 和 $k$。\n\n接下来共有 $k$ 行，每一行有两个用空格隔开的整数 $p$ 和 $t$，表示该任务从第 $p$ 分钟开始，持续时间为 $t$ 分钟。", "outputFormat": "输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^4,1 \\leq k \\leq 10^4,1 \\leq p \\leq n,1 \\leq p+t-1 \\leq n$。", "locale": "zh-CN"}}}
